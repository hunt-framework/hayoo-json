[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "Top"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Equality",
          "name": "Equality",
          "package": "Top",
          "source": "src/Top-Constraint-Equality.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Constraint Equality",
          "module": "Top.Constraint.Equality",
          "name": "Equality",
          "package": "Top",
          "partial": "Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Equality",
          "name": "EqualityConstraint",
          "package": "Top",
          "source": "src/Top-Constraint-Equality.html#EqualityConstraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Constraint Equality",
          "module": "Top.Constraint.Equality",
          "name": "EqualityConstraint",
          "package": "Top",
          "partial": "Equality Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#t:EqualityConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe constructor of an equality constraint.\n\u003c/p\u003e",
          "module": "Top.Constraint.Equality",
          "name": "(.==.)",
          "package": "Top",
          "signature": "Tp -\u003e Tp -\u003e info -\u003e EqualityConstraint info",
          "source": "src/Top-Constraint-Equality.html#.%3D%3D.",
          "type": "function"
        },
        "index": {
          "description": "The constructor of an equality constraint",
          "hierarchy": "Top Constraint Equality",
          "module": "Top.Constraint.Equality",
          "name": "(.==.) .==.",
          "normalized": "Tp-\u003eTp-\u003ea-\u003eEqualityConstraint a",
          "package": "Top",
          "signature": "Tp-\u003eTp-\u003einfo-\u003eEqualityConstraint info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#v:.-61--61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Equality",
          "name": "Equality",
          "package": "Top",
          "signature": "Equality Tp Tp info",
          "source": "src/Top-Constraint-Equality.html#EqualityConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint Equality",
          "module": "Top.Constraint.Equality",
          "name": "Equality",
          "package": "Top",
          "partial": "Equality",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Equality.html#v:Equality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "Information",
          "package": "Top",
          "source": "src/Top-Constraint-Information.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "Information",
          "package": "Top",
          "partial": "Information",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "PolyTypeConstraintInfo",
          "package": "Top",
          "source": "src/Top-Constraint-Information.html#PolyTypeConstraintInfo",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "PolyTypeConstraintInfo",
          "package": "Top",
          "partial": "Poly Type Constraint Info",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#t:PolyTypeConstraintInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "TypeConstraintInfo",
          "package": "Top",
          "source": "src/Top-Constraint-Information.html#TypeConstraintInfo",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "TypeConstraintInfo",
          "package": "Top",
          "partial": "Type Constraint Info",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#t:TypeConstraintInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "ambiguousPredicate",
          "package": "Top",
          "signature": "Predicate -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#ambiguousPredicate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "ambiguousPredicate",
          "normalized": "Predicate-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Predicate",
          "signature": "Predicate-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:ambiguousPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "closeDirective",
          "package": "Top",
          "signature": "(String, info) -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#closeDirective",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "closeDirective",
          "normalized": "(String,a)-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Directive",
          "signature": "(String,info)-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:closeDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "disjointDirective",
          "package": "Top",
          "signature": "(String, info) -\u003e (String, info) -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#disjointDirective",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "disjointDirective",
          "normalized": "(String,a)-\u003e(String,a)-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Directive",
          "signature": "(String,info)-\u003e(String,info)-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:disjointDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "equalityTypePair",
          "package": "Top",
          "signature": "(Tp, Tp) -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#equalityTypePair",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "equalityTypePair",
          "normalized": "(Tp,Tp)-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Type Pair",
          "signature": "(Tp,Tp)-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:equalityTypePair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "escapedSkolems",
          "package": "Top",
          "signature": "[Int] -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#escapedSkolems",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "escapedSkolems",
          "normalized": "[Int]-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Skolems",
          "signature": "[Int]-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:escapedSkolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "instantiatedTypeScheme",
          "package": "Top",
          "signature": "Forall (Qualification Predicates Tp) -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#instantiatedTypeScheme",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "instantiatedTypeScheme",
          "normalized": "Forall(Qualification Predicates Tp)-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Type Scheme",
          "signature": "Forall(Qualification Predicates Tp)-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:instantiatedTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "neverDirective",
          "package": "Top",
          "signature": "(Predicate, info) -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#neverDirective",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "neverDirective",
          "normalized": "(Predicate,a)-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Directive",
          "signature": "(Predicate,info)-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:neverDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "parentPredicate",
          "package": "Top",
          "signature": "Predicate -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#parentPredicate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "parentPredicate",
          "normalized": "Predicate-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Predicate",
          "signature": "Predicate-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:parentPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "predicateArisingFrom",
          "package": "Top",
          "signature": "(Predicate, info) -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#predicateArisingFrom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "predicateArisingFrom",
          "normalized": "(Predicate,a)-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Arising From",
          "signature": "(Predicate,info)-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:predicateArisingFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "skolemizedTypeScheme",
          "package": "Top",
          "signature": "(Tps, Forall (Qualification Predicates Tp)) -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#skolemizedTypeScheme",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "skolemizedTypeScheme",
          "normalized": "(Tps,Forall(Qualification Predicates Tp))-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Type Scheme",
          "signature": "(Tps,Forall(Qualification Predicates Tp))-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:skolemizedTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Information",
          "name": "unresolvedPredicate",
          "package": "Top",
          "signature": "Predicate -\u003e info -\u003e info",
          "source": "src/Top-Constraint-Information.html#unresolvedPredicate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint Information",
          "module": "Top.Constraint.Information",
          "name": "unresolvedPredicate",
          "normalized": "Predicate-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Predicate",
          "signature": "Predicate-\u003einfo-\u003einfo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Information.html#v:unresolvedPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Polymorphism",
          "name": "Polymorphism",
          "package": "Top",
          "source": "src/Top-Constraint-Polymorphism.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Constraint Polymorphism",
          "module": "Top.Constraint.Polymorphism",
          "name": "Polymorphism",
          "package": "Top",
          "partial": "Polymorphism",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Polymorphism",
          "name": "PolymorphismConstraint",
          "package": "Top",
          "source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Constraint Polymorphism",
          "module": "Top.Constraint.Polymorphism",
          "name": "PolymorphismConstraint",
          "package": "Top",
          "partial": "Polymorphism Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#t:PolymorphismConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe constructor of an instantiate (explicit instance) constraint.\n\u003c/p\u003e",
          "module": "Top.Constraint.Polymorphism",
          "name": "(.::.)",
          "package": "Top",
          "signature": "Tp -\u003e Scheme Predicates -\u003e info -\u003e PolymorphismConstraint info",
          "source": "src/Top-Constraint-Polymorphism.html#.%3A%3A.",
          "type": "function"
        },
        "index": {
          "description": "The constructor of an instantiate explicit instance constraint",
          "hierarchy": "Top Constraint Polymorphism",
          "module": "Top.Constraint.Polymorphism",
          "name": "(.::.) .::.",
          "normalized": "Tp-\u003eScheme Predicates-\u003ea-\u003ePolymorphismConstraint a",
          "package": "Top",
          "signature": "Tp-\u003eScheme Predicates-\u003einfo-\u003ePolymorphismConstraint info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:.::."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Polymorphism",
          "name": "Generalize",
          "package": "Top",
          "signature": "Generalize Int (Tps, Tp) info",
          "source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint Polymorphism",
          "module": "Top.Constraint.Polymorphism",
          "name": "Generalize",
          "normalized": "Generalize Int(Tps,Tp)a",
          "package": "Top",
          "partial": "Generalize",
          "signature": "Generalize Int(Tps,Tp)info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Generalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Polymorphism",
          "name": "Implicit",
          "package": "Top",
          "signature": "Implicit Tp (Tps, Tp) info",
          "source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint Polymorphism",
          "module": "Top.Constraint.Polymorphism",
          "name": "Implicit",
          "normalized": "Implicit Tp(Tps,Tp)a",
          "package": "Top",
          "partial": "Implicit",
          "signature": "Implicit Tp(Tps,Tp)info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Implicit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Polymorphism",
          "name": "Instantiate",
          "package": "Top",
          "signature": "Instantiate Tp (Sigma Predicates) info",
          "source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint Polymorphism",
          "module": "Top.Constraint.Polymorphism",
          "name": "Instantiate",
          "package": "Top",
          "partial": "Instantiate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Instantiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Polymorphism",
          "name": "Skolemize",
          "package": "Top",
          "signature": "Skolemize Tp (Tps, Sigma Predicates) info",
          "source": "src/Top-Constraint-Polymorphism.html#PolymorphismConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint Polymorphism",
          "module": "Top.Constraint.Polymorphism",
          "name": "Skolemize",
          "normalized": "Skolemize Tp(Tps,Sigma Predicates)a",
          "package": "Top",
          "partial": "Skolemize",
          "signature": "Skolemize Tp(Tps,Sigma Predicates)info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Polymorphism.html#v:Skolemize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstraints for overloading\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Constraint.Qualifier",
          "name": "Qualifier",
          "package": "Top",
          "source": "src/Top-Constraint-Qualifier.html",
          "type": "module"
        },
        "index": {
          "description": "Constraints for overloading",
          "hierarchy": "Top Constraint Qualifier",
          "module": "Top.Constraint.Qualifier",
          "name": "Qualifier",
          "package": "Top",
          "partial": "Qualifier",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Qualifier",
          "name": "ExtraConstraint",
          "package": "Top",
          "source": "src/Top-Constraint-Qualifier.html#ExtraConstraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Constraint Qualifier",
          "module": "Top.Constraint.Qualifier",
          "name": "ExtraConstraint",
          "package": "Top",
          "partial": "Extra Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#t:ExtraConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Qualifier",
          "name": "Assume",
          "package": "Top",
          "signature": "Assume Predicate info",
          "source": "src/Top-Constraint-Qualifier.html#ExtraConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint Qualifier",
          "module": "Top.Constraint.Qualifier",
          "name": "Assume",
          "package": "Top",
          "partial": "Assume",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#v:Assume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint.Qualifier",
          "name": "Prove",
          "package": "Top",
          "signature": "Prove Predicate info",
          "source": "src/Top-Constraint-Qualifier.html#ExtraConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint Qualifier",
          "module": "Top.Constraint.Qualifier",
          "name": "Prove",
          "package": "Top",
          "partial": "Prove",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint-Qualifier.html#v:Prove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA data type to represent constraints in general, and a type class for\n constraints that are solvable.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Constraint",
          "name": "Constraint",
          "package": "Top",
          "source": "src/Top-Constraint.html",
          "type": "module"
        },
        "index": {
          "description": "data type to represent constraints in general and type class for constraints that are solvable",
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "Constraint",
          "package": "Top",
          "partial": "Constraint",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "Constraint",
          "package": "Top",
          "source": "src/Top-Constraint.html#Constraint",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "Constraint",
          "package": "Top",
          "partial": "Constraint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data type ConstraintSum is similar to the (standard) Either data type.    \n However, its Show instance is slightly different as the name of the constructor\n is not shown.\n\u003c/p\u003e",
          "module": "Top.Constraint",
          "name": "ConstraintSum",
          "package": "Top",
          "source": "src/Top-Constraint.html#ConstraintSum",
          "type": "data"
        },
        "index": {
          "description": "The data type ConstraintSum is similar to the standard Either data type However its Show instance is slightly different as the name of the constructor is not shown",
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "ConstraintSum",
          "package": "Top",
          "partial": "Constraint Sum",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:ConstraintSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "Constraints",
          "package": "Top",
          "source": "src/Top-Constraint.html#Constraints",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "Constraints",
          "package": "Top",
          "partial": "Constraints",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Constraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "Operation",
          "package": "Top",
          "source": "src/Top-Constraint.html#Operation",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "Operation",
          "package": "Top",
          "partial": "Operation",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Operation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA constraint is solvable if it knows how it can be solved in a certain\n state (a monadic operation), if it can check afterwards whether the final\n state satisfies it, and when it can be shown.\n\u003c/p\u003e",
          "module": "Top.Constraint",
          "name": "Solvable",
          "package": "Top",
          "source": "src/Top-Constraint.html#Solvable",
          "type": "class"
        },
        "index": {
          "description": "constraint is solvable if it knows how it can be solved in certain state monadic operation if it can check afterwards whether the final state satisfies it and when it can be shown",
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "Solvable",
          "package": "Top",
          "partial": "Solvable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#t:Solvable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "Constraint",
          "package": "Top",
          "signature": "Constraint c (c -\u003e m ()) (c -\u003e m Bool)",
          "source": "src/Top-Constraint.html#Constraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "Constraint",
          "normalized": "Constraint a(a-\u003eb())(a-\u003eb Bool)",
          "package": "Top",
          "partial": "Constraint",
          "signature": "Constraint c(c-\u003em())(c-\u003em Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:Constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "Op_",
          "package": "Top",
          "signature": "Op_ String",
          "source": "src/Top-Constraint.html#Operation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "Op_",
          "package": "Top",
          "partial": "Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:Op_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "SumLeft",
          "package": "Top",
          "signature": "SumLeft (f info)",
          "source": "src/Top-Constraint.html#ConstraintSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "SumLeft",
          "package": "Top",
          "partial": "Sum Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:SumLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "SumRight",
          "package": "Top",
          "signature": "SumRight (g info)",
          "source": "src/Top-Constraint.html#ConstraintSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "SumRight",
          "package": "Top",
          "partial": "Sum Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:SumRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "checkCondition",
          "package": "Top",
          "signature": "c -\u003e m Bool",
          "source": "src/Top-Constraint.html#checkCondition",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "checkCondition",
          "normalized": "a-\u003eb Bool",
          "package": "Top",
          "partial": "Condition",
          "signature": "c-\u003em Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:checkCondition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to the \u003ccode\u003e\u003ca\u003eeither\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Top.Constraint",
          "name": "constraintSum",
          "package": "Top",
          "signature": "(f info -\u003e c) -\u003e (g info -\u003e c) -\u003e ConstraintSum f g info -\u003e c",
          "source": "src/Top-Constraint.html#constraintSum",
          "type": "function"
        },
        "index": {
          "description": "Similar to the either function",
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "constraintSum",
          "normalized": "(a b-\u003ec)-\u003e(d b-\u003ec)-\u003eConstraintSum a d b-\u003ec",
          "package": "Top",
          "partial": "Sum",
          "signature": "(f info-\u003ec)-\u003e(g info-\u003ec)-\u003eConstraintSum f g info-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:constraintSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLifting a constraint to the Constraint data type. Every instance of\n the Solvable type class can be lifted.\n\u003c/p\u003e",
          "module": "Top.Constraint",
          "name": "liftConstraint",
          "package": "Top",
          "signature": "c -\u003e Constraint m",
          "source": "src/Top-Constraint.html#liftConstraint",
          "type": "function"
        },
        "index": {
          "description": "Lifting constraint to the Constraint data type Every instance of the Solvable type class can be lifted",
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "liftConstraint",
          "normalized": "a-\u003eConstraint b",
          "package": "Top",
          "partial": "Constraint",
          "signature": "c-\u003eConstraint m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:liftConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "liftConstraints",
          "package": "Top",
          "signature": "[c] -\u003e Constraints m",
          "source": "src/Top-Constraint.html#liftConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "liftConstraints",
          "normalized": "[a]-\u003eConstraints b",
          "package": "Top",
          "partial": "Constraints",
          "signature": "[c]-\u003eConstraints m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:liftConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "mapConstraint",
          "package": "Top",
          "signature": "(forall a.  m1 a -\u003e m2 a) -\u003e Constraint m1 -\u003e Constraint m2",
          "source": "src/Top-Constraint.html#mapConstraint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "mapConstraint",
          "normalized": "(a b c d-\u003ec d)-\u003eConstraint c-\u003eConstraint c",
          "package": "Top",
          "partial": "Constraint",
          "signature": "(forall a. m a-\u003em a)-\u003eConstraint m-\u003eConstraint m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:mapConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "operation",
          "package": "Top",
          "signature": "String -\u003e m () -\u003e Constraint m",
          "source": "src/Top-Constraint.html#operation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "operation",
          "normalized": "String-\u003ea()-\u003eConstraint a",
          "package": "Top",
          "signature": "String-\u003em()-\u003eConstraint m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:operation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Constraint",
          "name": "solveConstraint",
          "package": "Top",
          "signature": "c -\u003e m ()",
          "source": "src/Top-Constraint.html#solveConstraint",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Constraint",
          "module": "Top.Constraint",
          "name": "solveConstraint",
          "normalized": "a-\u003eb()",
          "package": "Top",
          "partial": "Constraint",
          "signature": "c-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Constraint.html#v:solveConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn interface for a monad that constains the most basic operations to \n solve constraints. Can be reused for all kinds of constraint-based\n analyses.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Implementation.Basic",
          "name": "Basic",
          "package": "Top",
          "source": "src/Top-Implementation-Basic.html",
          "type": "module"
        },
        "index": {
          "description": "An interface for monad that constains the most basic operations to solve constraints Can be reused for all kinds of constraint-based analyses",
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "Basic",
          "package": "Top",
          "partial": "Basic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA BasicState is parameterized over the monad in which the constraints can\n be solved, and over the information that is stored with each constraint.\n\u003c/p\u003e",
          "module": "Top.Implementation.Basic",
          "name": "BasicState",
          "package": "Top",
          "source": "src/Top-Implementation-Basic.html#BasicState",
          "type": "data"
        },
        "index": {
          "description": "BasicState is parameterized over the monad in which the constraints can be solved and over the information that is stored with each constraint",
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "BasicState",
          "package": "Top",
          "partial": "Basic State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#t:BasicState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Basic",
          "name": "BasicState",
          "package": "Top",
          "signature": "BasicState",
          "source": "src/Top-Implementation-Basic.html#BasicState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "BasicState",
          "package": "Top",
          "partial": "Basic State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:BasicState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConditions to check (for the solved constraints)\n\u003c/p\u003e",
          "module": "Top.Implementation.Basic",
          "name": "conditions",
          "package": "Top",
          "signature": "[(m Bool, String)]",
          "source": "src/Top-Implementation-Basic.html#BasicState",
          "type": "function"
        },
        "index": {
          "description": "Conditions to check for the solved constraints",
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "conditions",
          "normalized": "[(a Bool,String)]",
          "package": "Top",
          "signature": "[(m Bool,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:conditions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA stack of constraints that is to be solved\n\u003c/p\u003e",
          "module": "Top.Implementation.Basic",
          "name": "constraints",
          "package": "Top",
          "signature": "Constraints m",
          "source": "src/Top-Implementation-Basic.html#BasicState",
          "type": "function"
        },
        "index": {
          "description": "stack of constraints that is to be solved",
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "constraints",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:constraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe detected errors\n\u003c/p\u003e",
          "module": "Top.Implementation.Basic",
          "name": "errors",
          "package": "Top",
          "signature": "[(info, ErrorLabel)]",
          "source": "src/Top-Implementation-Basic.html#BasicState",
          "type": "function"
        },
        "index": {
          "description": "The detected errors",
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "errors",
          "normalized": "[(a,ErrorLabel)]",
          "package": "Top",
          "signature": "[(info,ErrorLabel)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:errors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Basic",
          "name": "optionCheck",
          "package": "Top",
          "signature": "Option Bool",
          "source": "src/Top-Implementation-Basic.html#BasicState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "optionCheck",
          "package": "Top",
          "partial": "Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:optionCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscard all remaining constraints after the first error\n\u003c/p\u003e",
          "module": "Top.Implementation.Basic",
          "name": "optionStop",
          "package": "Top",
          "signature": "Option Bool",
          "source": "src/Top-Implementation-Basic.html#BasicState",
          "type": "function"
        },
        "index": {
          "description": "Discard all remaining constraints after the first error",
          "hierarchy": "Top Implementation Basic",
          "module": "Top.Implementation.Basic",
          "name": "optionStop",
          "package": "Top",
          "partial": "Stop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Basic.html#v:optionStop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.FastSubstitution",
          "name": "FastSubstitution",
          "package": "Top",
          "source": "src/Top-Implementation-FastSubstitution.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation FastSubstitution",
          "module": "Top.Implementation.FastSubstitution",
          "name": "FastSubstitution",
          "package": "Top",
          "partial": "Fast Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.FastSubstitution",
          "name": "GreedyState",
          "package": "Top",
          "source": "src/Top-Implementation-FastSubstitution.html#GreedyState",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Implementation FastSubstitution",
          "module": "Top.Implementation.FastSubstitution",
          "name": "GreedyState",
          "package": "Top",
          "partial": "Greedy State",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#t:GreedyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.FastSubstitution",
          "name": "GreedyState",
          "package": "Top",
          "signature": "GreedyState",
          "source": "src/Top-Implementation-FastSubstitution.html#GreedyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation FastSubstitution",
          "module": "Top.Implementation.FastSubstitution",
          "name": "GreedyState",
          "package": "Top",
          "partial": "Greedy State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#v:GreedyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.FastSubstitution",
          "name": "unGS",
          "package": "Top",
          "signature": "FixpointSubstitution",
          "source": "src/Top-Implementation-FastSubstitution.html#GreedyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation FastSubstitution",
          "module": "Top.Implementation.FastSubstitution",
          "name": "unGS",
          "package": "Top",
          "partial": "GS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#v:unGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.FastSubstitution",
          "name": "writeExpandedType",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e FixpointSubstitution -\u003e FixpointSubstitution",
          "source": "src/Top-Implementation-FastSubstitution.html#writeExpandedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation FastSubstitution",
          "module": "Top.Implementation.FastSubstitution",
          "name": "writeExpandedType",
          "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eFixpointSubstitution-\u003eFixpointSubstitution",
          "package": "Top",
          "partial": "Expanded Type",
          "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eFixpointSubstitution-\u003eFixpointSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-FastSubstitution.html#v:writeExpandedType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "General",
          "package": "Top",
          "source": "src/Top-Implementation-General.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "General",
          "package": "Top",
          "partial": "General",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "And",
          "package": "Top",
          "source": "src/Top-Implementation-General.html#And",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "And",
          "package": "Top",
          "partial": "And",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "Fix",
          "package": "Top",
          "source": "src/Top-Implementation-General.html#Fix",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "Fix",
          "package": "Top",
          "partial": "Fix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "Simple",
          "package": "Top",
          "source": "src/Top-Implementation-General.html#Simple",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "Simple",
          "package": "Top",
          "partial": "Simple",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:Simple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "SolveState",
          "package": "Top",
          "source": "src/Top-Implementation-General.html#SolveState",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "SolveState",
          "package": "Top",
          "partial": "Solve State",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#t:SolveState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "Compose",
          "package": "Top",
          "signature": "Compose (f (g x m) m)",
          "source": "src/Top-Implementation-General.html#And",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "Compose",
          "package": "Top",
          "partial": "Compose",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:Compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "Fix",
          "package": "Top",
          "signature": "Fix (g m) x",
          "source": "src/Top-Implementation-General.html#Fix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "Fix",
          "package": "Top",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "Simple",
          "package": "Top",
          "signature": "Simple a x",
          "source": "src/Top-Implementation-General.html#Simple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "Simple",
          "package": "Top",
          "partial": "Simple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:Simple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "allOptions",
          "package": "Top",
          "signature": "m [String]",
          "source": "src/Top-Implementation-General.html#allOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "allOptions",
          "normalized": "a[String]",
          "package": "Top",
          "partial": "Options",
          "signature": "m[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:allOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "allStates",
          "package": "Top",
          "signature": "m [(String, String)]",
          "source": "src/Top-Implementation-General.html#allStates",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "allStates",
          "normalized": "a[(String,String)]",
          "package": "Top",
          "partial": "States",
          "signature": "m[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:allStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "collectStates",
          "package": "Top",
          "signature": "s -\u003e [(String, String)]",
          "source": "src/Top-Implementation-General.html#collectStates",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "collectStates",
          "normalized": "a-\u003e[(String,String)]",
          "package": "Top",
          "partial": "States",
          "signature": "s-\u003e[(String,String)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:collectStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "fromFstFixE",
          "package": "Top",
          "signature": "Embedding (g m) c -\u003e Embedding (Fix g x m) c",
          "source": "src/Top-Implementation-General.html#fromFstFixE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "fromFstFixE",
          "normalized": "Embedding(a b)c-\u003eEmbedding(Fix a d b)c",
          "package": "Top",
          "partial": "Fst Fix",
          "signature": "Embedding(g m)c-\u003eEmbedding(Fix g x m)c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:fromFstFixE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "fromFstSimpleE",
          "package": "Top",
          "signature": "Embedding a c -\u003e Embedding (Simple a x m) c",
          "source": "src/Top-Implementation-General.html#fromFstSimpleE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "fromFstSimpleE",
          "normalized": "Embedding a b-\u003eEmbedding(Simple a c d)b",
          "package": "Top",
          "partial": "Fst Simple",
          "signature": "Embedding a c-\u003eEmbedding(Simple a x m)c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:fromFstSimpleE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "fstSimpleE",
          "package": "Top",
          "signature": "Embedding (Simple a x m) a",
          "source": "src/Top-Implementation-General.html#fstSimpleE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "fstSimpleE",
          "package": "Top",
          "partial": "Simple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:fstSimpleE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "showState",
          "package": "Top",
          "signature": "s -\u003e String",
          "source": "src/Top-Implementation-General.html#showState",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "showState",
          "normalized": "a-\u003eString",
          "package": "Top",
          "partial": "State",
          "signature": "s-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:showState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "stateName",
          "package": "Top",
          "signature": "s -\u003e String",
          "source": "src/Top-Implementation-General.html#stateName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "stateName",
          "normalized": "a-\u003eString",
          "package": "Top",
          "partial": "Name",
          "signature": "s-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:stateName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.General",
          "name": "stateOptions",
          "package": "Top",
          "signature": "s -\u003e [String]",
          "source": "src/Top-Implementation-General.html#stateOptions",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation General",
          "module": "Top.Implementation.General",
          "name": "stateOptions",
          "normalized": "a-\u003e[String]",
          "package": "Top",
          "partial": "Options",
          "signature": "s-\u003e[String]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-General.html#v:stateOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "Overloading",
          "package": "Top",
          "source": "src/Top-Implementation-Overloading.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "Overloading",
          "package": "Top",
          "partial": "Overloading",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "OverloadingState",
          "package": "Top",
          "source": "src/Top-Implementation-Overloading.html#OverloadingState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "OverloadingState",
          "package": "Top",
          "partial": "Overloading State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:OverloadingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "PredicateMap",
          "package": "Top",
          "source": "src/Top-Implementation-Overloading.html#PredicateMap",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "PredicateMap",
          "package": "Top",
          "partial": "Predicate Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:PredicateMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "TypeClassDirective",
          "package": "Top",
          "source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "TypeClassDirective",
          "package": "Top",
          "partial": "Type Class Directive",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:TypeClassDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "TypeClassDirectives",
          "package": "Top",
          "source": "src/Top-Implementation-Overloading.html#TypeClassDirectives",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "TypeClassDirectives",
          "package": "Top",
          "partial": "Type Class Directives",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#t:TypeClassDirectives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "CloseDirective",
          "package": "Top",
          "signature": "CloseDirective String info",
          "source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "CloseDirective",
          "package": "Top",
          "partial": "Close Directive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:CloseDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "DefaultDirective",
          "package": "Top",
          "signature": "DefaultDirective String Tps info",
          "source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "DefaultDirective",
          "package": "Top",
          "partial": "Default Directive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:DefaultDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "DisjointDirective",
          "package": "Top",
          "signature": "DisjointDirective [String] info",
          "source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "DisjointDirective",
          "normalized": "DisjointDirective[String]a",
          "package": "Top",
          "partial": "Disjoint Directive",
          "signature": "DisjointDirective[String]info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:DisjointDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "NeverDirective",
          "package": "Top",
          "signature": "NeverDirective Predicate info",
          "source": "src/Top-Implementation-Overloading.html#TypeClassDirective",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "NeverDirective",
          "package": "Top",
          "partial": "Never Directive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:NeverDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "OverloadingState",
          "package": "Top",
          "signature": "OverloadingState",
          "source": "src/Top-Implementation-Overloading.html#OverloadingState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "OverloadingState",
          "package": "Top",
          "partial": "Overloading State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:OverloadingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "PredicateMap",
          "package": "Top",
          "signature": "PredicateMap",
          "source": "src/Top-Implementation-Overloading.html#PredicateMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "PredicateMap",
          "package": "Top",
          "partial": "Predicate Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:PredicateMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "ambiguous",
          "package": "Top",
          "signature": "[(Predicate, info)] -\u003e m ()",
          "source": "src/Top-Implementation-Overloading.html#ambiguous",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "ambiguous",
          "normalized": "[(Predicate,a)]-\u003eb()",
          "package": "Top",
          "signature": "[(Predicate,info)]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:ambiguous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "ambiguousLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Implementation-Overloading.html#ambiguousLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "ambiguousLabel",
          "package": "Top",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:ambiguousLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "assumeQsSubst",
          "package": "Top",
          "signature": "Select (OverloadingState info) m [(Predicate, info)]",
          "source": "src/Top-Implementation-Overloading.html#proveQsSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "assumeQsSubst",
          "normalized": "Select(OverloadingState a)b[(Predicate,a)]",
          "package": "Top",
          "partial": "Qs Subst",
          "signature": "Select(OverloadingState info)m[(Predicate,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:assumeQsSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll known type classes and instances\n\u003c/p\u003e",
          "module": "Top.Implementation.Overloading",
          "name": "classEnvironment",
          "package": "Top",
          "signature": "ClassEnvironment",
          "source": "src/Top-Implementation-Overloading.html#OverloadingState",
          "type": "function"
        },
        "index": {
          "description": "All known type classes and instances",
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "classEnvironment",
          "package": "Top",
          "partial": "Environment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:classEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "disjointLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Implementation-Overloading.html#disjointLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "disjointLabel",
          "package": "Top",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:disjointLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "generalizedQsSubst",
          "package": "Top",
          "signature": "Select (OverloadingState info) m [(Predicate, info)]",
          "source": "src/Top-Implementation-Overloading.html#proveQsSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "generalizedQsSubst",
          "normalized": "Select(OverloadingState a)b[(Predicate,a)]",
          "package": "Top",
          "partial": "Qs Subst",
          "signature": "Select(OverloadingState info)m[(Predicate,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:generalizedQsSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "globalAssumptions",
          "package": "Top",
          "signature": "[(Predicate, info)]",
          "source": "src/Top-Implementation-Overloading.html#PredicateMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "globalAssumptions",
          "normalized": "[(Predicate,a)]",
          "package": "Top",
          "partial": "Assumptions",
          "signature": "[(Predicate,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:globalAssumptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "globalGeneralizedQs",
          "package": "Top",
          "signature": "[(Predicate, info)]",
          "source": "src/Top-Implementation-Overloading.html#PredicateMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "globalGeneralizedQs",
          "normalized": "[(Predicate,a)]",
          "package": "Top",
          "partial": "Generalized Qs",
          "signature": "[(Predicate,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:globalGeneralizedQs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "globalQualifiers",
          "package": "Top",
          "signature": "[(Predicate, info)]",
          "source": "src/Top-Implementation-Overloading.html#PredicateMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "globalQualifiers",
          "normalized": "[(Predicate,a)]",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "[(Predicate,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:globalQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "missingInSignatureLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Implementation-Overloading.html#missingInSignatureLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "missingInSignatureLabel",
          "package": "Top",
          "partial": "In Signature Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:missingInSignatureLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "modifyPredicateMap",
          "package": "Top",
          "signature": "(PredicateMap info -\u003e PredicateMap info) -\u003e m ()",
          "source": "src/Top-Implementation-Overloading.html#modifyPredicateMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "modifyPredicateMap",
          "normalized": "(PredicateMap a-\u003ePredicateMap a)-\u003eb()",
          "package": "Top",
          "partial": "Predicate Map",
          "signature": "(PredicateMap info-\u003ePredicateMap info)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:modifyPredicateMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class assertions\n\u003c/p\u003e",
          "module": "Top.Implementation.Overloading",
          "name": "predicateMap",
          "package": "Top",
          "signature": "PredicateMap info",
          "source": "src/Top-Implementation-Overloading.html#OverloadingState",
          "type": "function"
        },
        "index": {
          "description": "Type class assertions",
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "predicateMap",
          "package": "Top",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:predicateMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "proveQsSubst",
          "package": "Top",
          "signature": "Select (OverloadingState info) m [(Predicate, info)]",
          "source": "src/Top-Implementation-Overloading.html#proveQsSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "proveQsSubst",
          "normalized": "Select(OverloadingState a)b[(Predicate,a)]",
          "package": "Top",
          "partial": "Qs Subst",
          "signature": "Select(OverloadingState info)m[(Predicate,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:proveQsSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "simplify",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e TypeClassDirectives info -\u003e [(Predicate, info)] -\u003e m [(Predicate, info)]",
          "source": "src/Top-Implementation-Overloading.html#simplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "simplify",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTypeClassDirectives a-\u003e[(Predicate,a)]-\u003eb[(Predicate,a)]",
          "package": "Top",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTypeClassDirectives info-\u003e[(Predicate,info)]-\u003em[(Predicate,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "substPredicate",
          "package": "Top",
          "signature": "(Predicate, info) -\u003e m (Predicate, info)",
          "source": "src/Top-Implementation-Overloading.html#substPredicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "substPredicate",
          "normalized": "(Predicate,a)-\u003eb(Predicate,a)",
          "package": "Top",
          "partial": "Predicate",
          "signature": "(Predicate,info)-\u003em(Predicate,info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:substPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirectives for type class assertions\n\u003c/p\u003e",
          "module": "Top.Implementation.Overloading",
          "name": "typeClassDirectives",
          "package": "Top",
          "signature": "TypeClassDirectives info",
          "source": "src/Top-Implementation-Overloading.html#OverloadingState",
          "type": "function"
        },
        "index": {
          "description": "Directives for type class assertions",
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "typeClassDirectives",
          "package": "Top",
          "partial": "Class Directives",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:typeClassDirectives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.Overloading",
          "name": "unresolvedLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Implementation-Overloading.html#unresolvedLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation Overloading",
          "module": "Top.Implementation.Overloading",
          "name": "unresolvedLabel",
          "package": "Top",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-Overloading.html#v:unresolvedLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "SimpleSubstitution",
          "package": "Top",
          "source": "src/Top-Implementation-SimpleSubstitution.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation SimpleSubstitution",
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "SimpleSubstitution",
          "package": "Top",
          "partial": "Simple Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "SimpleState",
          "package": "Top",
          "source": "src/Top-Implementation-SimpleSubstitution.html#SimpleState",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Implementation SimpleSubstitution",
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "SimpleState",
          "package": "Top",
          "partial": "Simple State",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#t:SimpleState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "SimpleState",
          "package": "Top",
          "signature": "SimpleState",
          "source": "src/Top-Implementation-SimpleSubstitution.html#SimpleState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation SimpleSubstitution",
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "SimpleState",
          "package": "Top",
          "partial": "Simple State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#v:SimpleState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "unSS",
          "package": "Top",
          "signature": "MapSubstitution",
          "source": "src/Top-Implementation-SimpleSubstitution.html#SimpleState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation SimpleSubstitution",
          "module": "Top.Implementation.SimpleSubstitution",
          "name": "unSS",
          "package": "Top",
          "partial": "SS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-SimpleSubstitution.html#v:unSS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "ApplyHeuristics",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "ApplyHeuristics",
          "package": "Top",
          "partial": "Apply Heuristics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "applyHeuristics",
          "package": "Top",
          "signature": "(Path (EdgeId, info) -\u003e [Heuristic info]) -\u003e m [ErrorInfo info]",
          "source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html#applyHeuristics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "applyHeuristics",
          "normalized": "(Path(EdgeId,a)-\u003e[Heuristic a])-\u003eb[ErrorInfo a]",
          "package": "Top",
          "partial": "Heuristics",
          "signature": "(Path(EdgeId,info)-\u003e[Heuristic info])-\u003em[ErrorInfo info]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#v:applyHeuristics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "expandPath",
          "package": "Top",
          "signature": "TypeGraphPath info -\u003e m (Path (EdgeId, info))",
          "source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html#expandPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "expandPath",
          "normalized": "TypeGraphPath a-\u003eb(Path(EdgeId,a))",
          "package": "Top",
          "partial": "Path",
          "signature": "TypeGraphPath info-\u003em(Path(EdgeId,info))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#v:expandPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "predicatePath",
          "package": "Top",
          "signature": "m (Path (EdgeId, PathStep info))",
          "source": "src/Top-Implementation-TypeGraph-ApplyHeuristics.html#predicatePath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ApplyHeuristics",
          "module": "Top.Implementation.TypeGraph.ApplyHeuristics",
          "name": "predicatePath",
          "normalized": "a(Path(EdgeId,PathStep b))",
          "package": "Top",
          "partial": "Path",
          "signature": "m(Path(EdgeId,PathStep info))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ApplyHeuristics.html#v:predicatePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Basics",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Basics",
          "package": "Top",
          "partial": "Basics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "ChildSide",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ChildSide",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "ChildSide",
          "package": "Top",
          "partial": "Child Side",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:ChildSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Clique",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#Clique",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Clique",
          "package": "Top",
          "partial": "Clique",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:Clique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "CliqueList",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#CliqueList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "CliqueList",
          "package": "Top",
          "partial": "Clique List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:CliqueList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeId",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeId",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeId",
          "package": "Top",
          "partial": "Edge Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:EdgeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeNr",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeNr",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeNr",
          "package": "Top",
          "partial": "Edge Nr",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:EdgeNr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "ParentChild",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "ParentChild",
          "package": "Top",
          "partial": "Parent Child",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:ParentChild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "PathStep",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "PathStep",
          "package": "Top",
          "partial": "Path Step",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:PathStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "TypeGraphPath",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#TypeGraphPath",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "TypeGraphPath",
          "package": "Top",
          "partial": "Type Graph Path",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:TypeGraphPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexId",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#VertexId",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexId",
          "package": "Top",
          "partial": "Vertex Id",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:VertexId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexInfo",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#VertexInfo",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexInfo",
          "package": "Top",
          "partial": "Vertex Info",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:VertexInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexKind",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexKind",
          "package": "Top",
          "partial": "Vertex Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#t:VertexKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Child",
          "package": "Top",
          "signature": "Child ChildSide",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Child",
          "package": "Top",
          "partial": "Child",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:Child"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "CliqueX",
          "package": "Top",
          "signature": "CliqueX [ParentChild]",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#Clique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "CliqueX",
          "normalized": "CliqueX[ParentChild]",
          "package": "Top",
          "partial": "Clique",
          "signature": "CliqueX[ParentChild]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:CliqueX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeId",
          "package": "Top",
          "signature": "EdgeId VertexId VertexId EdgeNr",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeId",
          "package": "Top",
          "partial": "Edge Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:EdgeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeNrX",
          "package": "Top",
          "signature": "EdgeNrX Int",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#EdgeNr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "EdgeNrX",
          "package": "Top",
          "partial": "Edge Nr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:EdgeNrX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Implied",
          "package": "Top",
          "signature": "Implied ChildSide VertexId VertexId",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Implied",
          "package": "Top",
          "partial": "Implied",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:Implied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Initial",
          "package": "Top",
          "signature": "Initial info",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#PathStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "Initial",
          "package": "Top",
          "partial": "Initial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:Initial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "LeftChild",
          "package": "Top",
          "signature": "LeftChild",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ChildSide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "LeftChild",
          "package": "Top",
          "partial": "Left Child",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:LeftChild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "ParentChild",
          "package": "Top",
          "signature": "ParentChild",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "ParentChild",
          "package": "Top",
          "partial": "Parent Child",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:ParentChild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "RightChild",
          "package": "Top",
          "signature": "RightChild",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ChildSide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "RightChild",
          "package": "Top",
          "partial": "Right Child",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:RightChild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VApp",
          "package": "Top",
          "signature": "VApp VertexId VertexId",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VApp",
          "package": "Top",
          "partial": "VApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VCon",
          "package": "Top",
          "signature": "VCon String",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VCon",
          "package": "Top",
          "partial": "VCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VVar",
          "package": "Top",
          "signature": "VVar",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#VertexKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VVar",
          "package": "Top",
          "partial": "VVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexId",
          "package": "Top",
          "signature": "VertexId Int",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#VertexId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "VertexId",
          "package": "Top",
          "partial": "Vertex Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:VertexId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "child",
          "package": "Top",
          "signature": "VertexId",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "child",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:child"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "childSide",
          "package": "Top",
          "signature": "ChildSide",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "childSide",
          "package": "Top",
          "partial": "Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:childSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "childrenInClique",
          "package": "Top",
          "signature": "Clique -\u003e [VertexId]",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#childrenInClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "childrenInClique",
          "normalized": "Clique-\u003e[VertexId]",
          "package": "Top",
          "partial": "In Clique",
          "signature": "Clique-\u003e[VertexId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:childrenInClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "cliqueRepresentative",
          "package": "Top",
          "signature": "Clique -\u003e VertexId",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#cliqueRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "cliqueRepresentative",
          "normalized": "Clique-\u003eVertexId",
          "package": "Top",
          "partial": "Representative",
          "signature": "Clique-\u003eVertexId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:cliqueRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "combineCliqueList",
          "package": "Top",
          "signature": "CliqueList -\u003e CliqueList -\u003e CliqueList",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#combineCliqueList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "combineCliqueList",
          "normalized": "CliqueList-\u003eCliqueList-\u003eCliqueList",
          "package": "Top",
          "partial": "Clique List",
          "signature": "CliqueList-\u003eCliqueList-\u003eCliqueList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:combineCliqueList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "impliedEdgeNr",
          "package": "Top",
          "signature": "EdgeNr",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#impliedEdgeNr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "impliedEdgeNr",
          "package": "Top",
          "partial": "Edge Nr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:impliedEdgeNr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "isDisjointClique",
          "package": "Top",
          "signature": "Clique -\u003e Clique -\u003e Bool",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#isDisjointClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "isDisjointClique",
          "normalized": "Clique-\u003eClique-\u003eBool",
          "package": "Top",
          "partial": "Disjoint Clique",
          "signature": "Clique-\u003eClique-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:isDisjointClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "isSubsetClique",
          "package": "Top",
          "signature": "Clique -\u003e Clique -\u003e Bool",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#isSubsetClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "isSubsetClique",
          "normalized": "Clique-\u003eClique-\u003eBool",
          "package": "Top",
          "partial": "Subset Clique",
          "signature": "Clique-\u003eClique-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:isSubsetClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "makeClique",
          "package": "Top",
          "signature": "[ParentChild] -\u003e Clique",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#makeClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "makeClique",
          "normalized": "[ParentChild]-\u003eClique",
          "package": "Top",
          "partial": "Clique",
          "signature": "[ParentChild]-\u003eClique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:makeClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "makeEdgeNr",
          "package": "Top",
          "signature": "Int -\u003e EdgeNr",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#makeEdgeNr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "makeEdgeNr",
          "normalized": "Int-\u003eEdgeNr",
          "package": "Top",
          "partial": "Edge Nr",
          "signature": "Int-\u003eEdgeNr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:makeEdgeNr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "mergeCliques",
          "package": "Top",
          "signature": "CliqueList -\u003e Clique",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#mergeCliques",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "mergeCliques",
          "normalized": "CliqueList-\u003eClique",
          "package": "Top",
          "partial": "Cliques",
          "signature": "CliqueList-\u003eClique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:mergeCliques"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "parent",
          "package": "Top",
          "signature": "VertexId",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#ParentChild",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "parent",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:parent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "triplesInClique",
          "package": "Top",
          "signature": "Clique -\u003e [ParentChild]",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#triplesInClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "triplesInClique",
          "normalized": "Clique-\u003e[ParentChild]",
          "package": "Top",
          "partial": "In Clique",
          "signature": "Clique-\u003e[ParentChild]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:triplesInClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "vertexIdToTp",
          "package": "Top",
          "signature": "VertexId -\u003e Tp",
          "source": "src/Top-Implementation-TypeGraph-Basics.html#vertexIdToTp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Basics",
          "module": "Top.Implementation.TypeGraph.Basics",
          "name": "vertexIdToTp",
          "normalized": "VertexId-\u003eTp",
          "package": "Top",
          "partial": "Id To Tp",
          "signature": "VertexId-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Basics.html#v:vertexIdToTp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "Class",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Class.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "Class",
          "package": "Top",
          "partial": "Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "TypeGraph",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Class.html#TypeGraph",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "TypeGraph",
          "package": "Top",
          "partial": "Type Graph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#t:TypeGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addEdge",
          "package": "Top",
          "signature": "EdgeId -\u003e info -\u003e graph -\u003e graph",
          "source": "src/Top-Implementation-TypeGraph-Class.html#addEdge",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addEdge",
          "normalized": "EdgeId-\u003ea-\u003eb-\u003eb",
          "package": "Top",
          "partial": "Edge",
          "signature": "EdgeId-\u003einfo-\u003egraph-\u003egraph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addNewEdge",
          "package": "Top",
          "signature": "(VertexId, VertexId) -\u003e info -\u003e graph -\u003e graph",
          "source": "src/Top-Implementation-TypeGraph-Class.html#addNewEdge",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addNewEdge",
          "normalized": "(VertexId,VertexId)-\u003ea-\u003eb-\u003eb",
          "package": "Top",
          "partial": "New Edge",
          "signature": "(VertexId,VertexId)-\u003einfo-\u003egraph-\u003egraph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addNewEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addTermGraph",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Int -\u003e Tp -\u003e graph -\u003e (Int, VertexId, graph)",
          "source": "src/Top-Implementation-TypeGraph-Class.html#addTermGraph",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addTermGraph",
          "normalized": "OrderedTypeSynonyms-\u003eInt-\u003eTp-\u003ea-\u003e(Int,VertexId,a)",
          "package": "Top",
          "partial": "Term Graph",
          "signature": "OrderedTypeSynonyms-\u003eInt-\u003eTp-\u003egraph-\u003e(Int,VertexId,graph)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addTermGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addVertex",
          "package": "Top",
          "signature": "VertexId -\u003e VertexInfo -\u003e graph -\u003e graph",
          "source": "src/Top-Implementation-TypeGraph-Class.html#addVertex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "addVertex",
          "normalized": "VertexId-\u003eVertexInfo-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Vertex",
          "signature": "VertexId-\u003eVertexInfo-\u003egraph-\u003egraph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:addVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "allPaths",
          "package": "Top",
          "signature": "VertexId -\u003e VertexId -\u003e graph -\u003e TypeGraphPath info",
          "source": "src/Top-Implementation-TypeGraph-Class.html#allPaths",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "allPaths",
          "normalized": "VertexId-\u003eVertexId-\u003ea-\u003eTypeGraphPath b",
          "package": "Top",
          "partial": "Paths",
          "signature": "VertexId-\u003eVertexId-\u003egraph-\u003eTypeGraphPath info",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:allPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "allPathsList",
          "package": "Top",
          "signature": "VertexId -\u003e [VertexId] -\u003e graph -\u003e TypeGraphPath info",
          "source": "src/Top-Implementation-TypeGraph-Class.html#allPathsList",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "allPathsList",
          "normalized": "VertexId-\u003e[VertexId]-\u003ea-\u003eTypeGraphPath b",
          "package": "Top",
          "partial": "Paths List",
          "signature": "VertexId-\u003e[VertexId]-\u003egraph-\u003eTypeGraphPath info",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:allPathsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "allPathsListWithout",
          "package": "Top",
          "signature": "Set VertexId -\u003e VertexId -\u003e [VertexId] -\u003e graph -\u003e TypeGraphPath info",
          "source": "src/Top-Implementation-TypeGraph-Class.html#allPathsListWithout",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "allPathsListWithout",
          "normalized": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003ea-\u003eTypeGraphPath b",
          "package": "Top",
          "partial": "Paths List Without",
          "signature": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003egraph-\u003eTypeGraphPath info",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:allPathsListWithout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "childrenInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e graph -\u003e ([ParentChild], [ParentChild])",
          "source": "src/Top-Implementation-TypeGraph-Class.html#childrenInGroupOf",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "childrenInGroupOf",
          "normalized": "VertexId-\u003ea-\u003e([ParentChild],[ParentChild])",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003egraph-\u003e([ParentChild],[ParentChild])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:childrenInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "constantsInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e graph -\u003e [String]",
          "source": "src/Top-Implementation-TypeGraph-Class.html#constantsInGroupOf",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "constantsInGroupOf",
          "normalized": "VertexId-\u003ea-\u003e[String]",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003egraph-\u003e[String]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:constantsInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "deleteEdge",
          "package": "Top",
          "signature": "EdgeId -\u003e graph -\u003e graph",
          "source": "src/Top-Implementation-TypeGraph-Class.html#deleteEdge",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "deleteEdge",
          "normalized": "EdgeId-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Edge",
          "signature": "EdgeId-\u003egraph-\u003egraph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:deleteEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "edgesFrom",
          "package": "Top",
          "signature": "VertexId -\u003e graph -\u003e [(EdgeId, info)]",
          "source": "src/Top-Implementation-TypeGraph-Class.html#edgesFrom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "edgesFrom",
          "normalized": "VertexId-\u003ea-\u003e[(EdgeId,b)]",
          "package": "Top",
          "partial": "From",
          "signature": "VertexId-\u003egraph-\u003e[(EdgeId,info)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:edgesFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "getMarkedPossibleErrors",
          "package": "Top",
          "signature": "graph -\u003e [VertexId]",
          "source": "src/Top-Implementation-TypeGraph-Class.html#getMarkedPossibleErrors",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "getMarkedPossibleErrors",
          "normalized": "a-\u003e[VertexId]",
          "package": "Top",
          "partial": "Marked Possible Errors",
          "signature": "graph-\u003e[VertexId]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:getMarkedPossibleErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "makeSubstitution",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e graph -\u003e [(VertexId, Tp)]",
          "source": "src/Top-Implementation-TypeGraph-Class.html#makeSubstitution",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "makeSubstitution",
          "normalized": "OrderedTypeSynonyms-\u003ea-\u003e[(VertexId,Tp)]",
          "package": "Top",
          "partial": "Substitution",
          "signature": "OrderedTypeSynonyms-\u003egraph-\u003e[(VertexId,Tp)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:makeSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "markAsPossibleError",
          "package": "Top",
          "signature": "VertexId -\u003e graph -\u003e graph",
          "source": "src/Top-Implementation-TypeGraph-Class.html#markAsPossibleError",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "markAsPossibleError",
          "normalized": "VertexId-\u003ea-\u003ea",
          "package": "Top",
          "partial": "As Possible Error",
          "signature": "VertexId-\u003egraph-\u003egraph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:markAsPossibleError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "representativeInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e graph -\u003e VertexId",
          "source": "src/Top-Implementation-TypeGraph-Class.html#representativeInGroupOf",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "representativeInGroupOf",
          "normalized": "VertexId-\u003ea-\u003eVertexId",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003egraph-\u003eVertexId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:representativeInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "substituteType",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tp -\u003e graph -\u003e Tp",
          "source": "src/Top-Implementation-TypeGraph-Class.html#substituteType",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "substituteType",
          "normalized": "OrderedTypeSynonyms-\u003eTp-\u003ea-\u003eTp",
          "package": "Top",
          "partial": "Type",
          "signature": "OrderedTypeSynonyms-\u003eTp-\u003egraph-\u003eTp",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:substituteType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "substituteTypeSafe",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tp -\u003e graph -\u003e Maybe Tp",
          "source": "src/Top-Implementation-TypeGraph-Class.html#substituteTypeSafe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "substituteTypeSafe",
          "normalized": "OrderedTypeSynonyms-\u003eTp-\u003ea-\u003eMaybe Tp",
          "package": "Top",
          "partial": "Type Safe",
          "signature": "OrderedTypeSynonyms-\u003eTp-\u003egraph-\u003eMaybe Tp",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:substituteTypeSafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "substituteVariable",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Int -\u003e graph -\u003e Tp",
          "source": "src/Top-Implementation-TypeGraph-Class.html#substituteVariable",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "substituteVariable",
          "normalized": "OrderedTypeSynonyms-\u003eInt-\u003ea-\u003eTp",
          "package": "Top",
          "partial": "Variable",
          "signature": "OrderedTypeSynonyms-\u003eInt-\u003egraph-\u003eTp",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:substituteVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "typeFromTermGraph",
          "package": "Top",
          "signature": "VertexId -\u003e graph -\u003e Tp",
          "source": "src/Top-Implementation-TypeGraph-Class.html#typeFromTermGraph",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "typeFromTermGraph",
          "normalized": "VertexId-\u003ea-\u003eTp",
          "package": "Top",
          "partial": "From Term Graph",
          "signature": "VertexId-\u003egraph-\u003eTp",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:typeFromTermGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "unmarkPossibleErrors",
          "package": "Top",
          "signature": "graph -\u003e graph",
          "source": "src/Top-Implementation-TypeGraph-Class.html#unmarkPossibleErrors",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "unmarkPossibleErrors",
          "normalized": "a-\u003ea",
          "package": "Top",
          "partial": "Possible Errors",
          "signature": "graph-\u003egraph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:unmarkPossibleErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "verticesInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e graph -\u003e [(VertexId, VertexInfo)]",
          "source": "src/Top-Implementation-TypeGraph-Class.html#verticesInGroupOf",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Class",
          "module": "Top.Implementation.TypeGraph.Class",
          "name": "verticesInGroupOf",
          "normalized": "VertexId-\u003ea-\u003e[(VertexId,VertexInfo)]",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003egraph-\u003e[(VertexId,VertexInfo)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Class.html#v:verticesInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "ClassMonadic",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "ClassMonadic",
          "package": "Top",
          "partial": "Class Monadic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "HasTG",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#HasTG",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "HasTG",
          "package": "Top",
          "partial": "Has TG",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#t:HasTG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "HasTypeGraph",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#HasTypeGraph",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "HasTypeGraph",
          "package": "Top",
          "partial": "Has Type Graph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#t:HasTypeGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addEdge",
          "package": "Top",
          "signature": "EdgeId -\u003e info -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addEdge",
          "normalized": "EdgeId-\u003ea-\u003eb()",
          "package": "Top",
          "partial": "Edge",
          "signature": "EdgeId-\u003einfo-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addNewEdge",
          "package": "Top",
          "signature": "(VertexId, VertexId) -\u003e info -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addNewEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addNewEdge",
          "normalized": "(VertexId,VertexId)-\u003ea-\u003eb()",
          "package": "Top",
          "partial": "New Edge",
          "signature": "(VertexId,VertexId)-\u003einfo-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addNewEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addTermGraph",
          "package": "Top",
          "signature": "Tp -\u003e m VertexId",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addTermGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addTermGraph",
          "normalized": "Tp-\u003ea VertexId",
          "package": "Top",
          "partial": "Term Graph",
          "signature": "Tp-\u003em VertexId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addTermGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addVertex",
          "package": "Top",
          "signature": "VertexId -\u003e VertexInfo -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#addVertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "addVertex",
          "normalized": "VertexId-\u003eVertexInfo-\u003ea()",
          "package": "Top",
          "partial": "Vertex",
          "signature": "VertexId-\u003eVertexInfo-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:addVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "allPaths",
          "package": "Top",
          "signature": "VertexId -\u003e VertexId -\u003e m (TypeGraphPath info)",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#allPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "allPaths",
          "normalized": "VertexId-\u003eVertexId-\u003ea(TypeGraphPath b)",
          "package": "Top",
          "partial": "Paths",
          "signature": "VertexId-\u003eVertexId-\u003em(TypeGraphPath info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:allPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "allPathsList",
          "package": "Top",
          "signature": "VertexId -\u003e [VertexId] -\u003e m (TypeGraphPath info)",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#allPathsList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "allPathsList",
          "normalized": "VertexId-\u003e[VertexId]-\u003ea(TypeGraphPath b)",
          "package": "Top",
          "partial": "Paths List",
          "signature": "VertexId-\u003e[VertexId]-\u003em(TypeGraphPath info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:allPathsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "allPathsListWithout",
          "package": "Top",
          "signature": "Set VertexId -\u003e VertexId -\u003e [VertexId] -\u003e m (TypeGraphPath info)",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#allPathsListWithout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "allPathsListWithout",
          "normalized": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003ea(TypeGraphPath b)",
          "package": "Top",
          "partial": "Paths List Without",
          "signature": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003em(TypeGraphPath info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:allPathsListWithout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "changeTypeGraph",
          "package": "Top",
          "signature": "graph -\u003e graph) -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#changeTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "changeTypeGraph",
          "normalized": "a-\u003ea)-\u003eb()",
          "package": "Top",
          "partial": "Type Graph",
          "signature": "graph-\u003egraph)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:changeTypeGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "childrenInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e m ([ParentChild], [ParentChild])",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#childrenInGroupOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "childrenInGroupOf",
          "normalized": "VertexId-\u003ea([ParentChild],[ParentChild])",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003em([ParentChild],[ParentChild])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:childrenInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "constantsInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e m [String]",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#constantsInGroupOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "constantsInGroupOf",
          "normalized": "VertexId-\u003ea[String]",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003em[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:constantsInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "deleteEdge",
          "package": "Top",
          "signature": "EdgeId -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#deleteEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "deleteEdge",
          "normalized": "EdgeId-\u003ea()",
          "package": "Top",
          "partial": "Edge",
          "signature": "EdgeId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:deleteEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "edgesFrom",
          "package": "Top",
          "signature": "VertexId -\u003e m [(EdgeId, info)]",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#edgesFrom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "edgesFrom",
          "normalized": "VertexId-\u003ea[(EdgeId,b)]",
          "package": "Top",
          "partial": "From",
          "signature": "VertexId-\u003em[(EdgeId,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:edgesFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "getMarkedPossibleErrors",
          "package": "Top",
          "signature": "m [VertexId]",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#getMarkedPossibleErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "getMarkedPossibleErrors",
          "normalized": "a[VertexId]",
          "package": "Top",
          "partial": "Marked Possible Errors",
          "signature": "m[VertexId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:getMarkedPossibleErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "makeFixpointSubst",
          "package": "Top",
          "signature": "m FixpointSubstitution",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#makeFixpointSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "makeFixpointSubst",
          "package": "Top",
          "partial": "Fixpoint Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:makeFixpointSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "makeSubstitution",
          "package": "Top",
          "signature": "m [(VertexId, Tp)]",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#makeSubstitution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "makeSubstitution",
          "normalized": "a[(VertexId,Tp)]",
          "package": "Top",
          "partial": "Substitution",
          "signature": "m[(VertexId,Tp)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:makeSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "markAsPossibleError",
          "package": "Top",
          "signature": "VertexId -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#markAsPossibleError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "markAsPossibleError",
          "normalized": "VertexId-\u003ea()",
          "package": "Top",
          "partial": "As Possible Error",
          "signature": "VertexId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:markAsPossibleError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "representativeInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e m VertexId",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#representativeInGroupOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "representativeInGroupOf",
          "normalized": "VertexId-\u003ea VertexId",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003em VertexId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:representativeInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "substituteType",
          "package": "Top",
          "signature": "Tp -\u003e m Tp",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#substituteType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "substituteType",
          "normalized": "Tp-\u003ea Tp",
          "package": "Top",
          "partial": "Type",
          "signature": "Tp-\u003em Tp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:substituteType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "substituteTypeSafe",
          "package": "Top",
          "signature": "Tp -\u003e m (Maybe Tp)",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#substituteTypeSafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "substituteTypeSafe",
          "normalized": "Tp-\u003ea(Maybe Tp)",
          "package": "Top",
          "partial": "Type Safe",
          "signature": "Tp-\u003em(Maybe Tp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:substituteTypeSafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "substituteVariable",
          "package": "Top",
          "signature": "Int -\u003e m Tp",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#substituteVariable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "substituteVariable",
          "normalized": "Int-\u003ea Tp",
          "package": "Top",
          "partial": "Variable",
          "signature": "Int-\u003em Tp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:substituteVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "theUnifyTerms",
          "package": "Top",
          "signature": "info -\u003e Tp -\u003e Tp -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#theUnifyTerms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "theUnifyTerms",
          "normalized": "a-\u003eTp-\u003eTp-\u003eb()",
          "package": "Top",
          "partial": "Unify Terms",
          "signature": "info-\u003eTp-\u003eTp-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:theUnifyTerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "typeFromTermGraph",
          "package": "Top",
          "signature": "VertexId -\u003e m Tp",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#typeFromTermGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "typeFromTermGraph",
          "normalized": "VertexId-\u003ea Tp",
          "package": "Top",
          "partial": "From Term Graph",
          "signature": "VertexId-\u003em Tp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:typeFromTermGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "unmarkPossibleErrors",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#unmarkPossibleErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "unmarkPossibleErrors",
          "normalized": "a()",
          "package": "Top",
          "partial": "Possible Errors",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:unmarkPossibleErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "useTypeGraph",
          "package": "Top",
          "signature": "graph -\u003e a) -\u003e m a",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#useTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "useTypeGraph",
          "normalized": "a-\u003eb)-\u003ec b",
          "package": "Top",
          "partial": "Type Graph",
          "signature": "graph-\u003ea)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:useTypeGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "verticesInGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e m [(VertexId, VertexInfo)]",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#verticesInGroupOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "verticesInGroupOf",
          "normalized": "VertexId-\u003ea[(VertexId,VertexInfo)]",
          "package": "Top",
          "partial": "In Group Of",
          "signature": "VertexId-\u003em[(VertexId,VertexInfo)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:verticesInGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "withTypeGraph",
          "package": "Top",
          "signature": "graph -\u003e (a, graph)) -\u003e m a",
          "source": "src/Top-Implementation-TypeGraph-ClassMonadic.html#withTypeGraph",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph ClassMonadic",
          "module": "Top.Implementation.TypeGraph.ClassMonadic",
          "name": "withTypeGraph",
          "normalized": "a-\u003e(b,a))-\u003ec b",
          "package": "Top",
          "partial": "Type Graph",
          "signature": "graph-\u003e(a,graph))-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-ClassMonadic.html#v:withTypeGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "DefaultHeuristics",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "DefaultHeuristics",
          "package": "Top",
          "partial": "Default Heuristics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "defaultHeuristics",
          "package": "Top",
          "signature": "Path (EdgeId, info) -\u003e [Heuristic info]",
          "source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#defaultHeuristics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "defaultHeuristics",
          "normalized": "Path(EdgeId,a)-\u003e[Heuristic a]",
          "package": "Top",
          "partial": "Heuristics",
          "signature": "Path(EdgeId,info)-\u003e[Heuristic info]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:defaultHeuristics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect the \u003ca\u003elatest\u003c/a\u003e constraint\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "firstComeFirstBlamed",
          "package": "Top",
          "signature": "Heuristic info",
          "source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#firstComeFirstBlamed",
          "type": "function"
        },
        "index": {
          "description": "Select the latest constraint",
          "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "firstComeFirstBlamed",
          "package": "Top",
          "partial": "Come First Blamed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:firstComeFirstBlamed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlthough not as precise as the minimal set analysis, this calculates the participation of\n each edge in all error paths. \n Default ratio = 1.0  (100 percent)\n   (the ratio determines which scores compared to the best are accepted)\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "highParticipation",
          "package": "Top",
          "signature": "Double -\u003e Path (EdgeId, info) -\u003e Heuristic info",
          "source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#highParticipation",
          "type": "function"
        },
        "index": {
          "description": "Although not as precise as the minimal set analysis this calculates the participation of each edge in all error paths Default ratio percent the ratio determines which scores compared to the best are accepted",
          "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "highParticipation",
          "normalized": "Double-\u003ePath(EdgeId,a)-\u003eHeuristic a",
          "package": "Top",
          "partial": "Participation",
          "signature": "Double-\u003ePath(EdgeId,info)-\u003eHeuristic info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:highParticipation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the smallest \u003ccode\u003eminimal\u003c/code\u003e sets. This computation is very(!) costly\n   (might take a long time for complex inconsistencies)\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "inMininalSet",
          "package": "Top",
          "signature": "Path (EdgeId, info) -\u003e Heuristic info",
          "source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#inMininalSet",
          "type": "function"
        },
        "index": {
          "description": "Compute the smallest minimal sets This computation is very costly might take long time for complex inconsistencies",
          "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "inMininalSet",
          "normalized": "Path(EdgeId,a)-\u003eHeuristic a",
          "package": "Top",
          "partial": "Mininal Set",
          "signature": "Path(EdgeId,info)-\u003eHeuristic info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:inMininalSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect only the constraints for which there is evidence in the predicates\n of the current state that the constraint at hand is incorrect. \n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "inPredicatePath",
          "package": "Top",
          "signature": "Heuristic info",
          "source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#inPredicatePath",
          "type": "function"
        },
        "index": {
          "description": "Select only the constraints for which there is evidence in the predicates of the current state that the constraint at hand is incorrect",
          "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "inPredicatePath",
          "package": "Top",
          "partial": "Predicate Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:inPredicatePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect only specific constraint numbers\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "selectConstraintNumbers",
          "package": "Top",
          "signature": "[EdgeNr] -\u003e Heuristic info",
          "source": "src/Top-Implementation-TypeGraph-DefaultHeuristics.html#selectConstraintNumbers",
          "type": "function"
        },
        "index": {
          "description": "Select only specific constraint numbers",
          "hierarchy": "Top Implementation TypeGraph DefaultHeuristics",
          "module": "Top.Implementation.TypeGraph.DefaultHeuristics",
          "name": "selectConstraintNumbers",
          "normalized": "[EdgeNr]-\u003eHeuristic a",
          "package": "Top",
          "partial": "Constraint Numbers",
          "signature": "[EdgeNr]-\u003eHeuristic info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-DefaultHeuristics.html#v:selectConstraintNumbers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn equivalence group is a graph-like structure containing type variables and \n type constants that should all be equivalent. The edges explain why they should\n be equal.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "EquivalenceGroup",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html",
          "type": "module"
        },
        "index": {
          "description": "An equivalence group is graph-like structure containing type variables and type constants that should all be equivalent The edges explain why they should be equal",
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "EquivalenceGroup",
          "package": "Top",
          "partial": "Equivalence Group",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "EquivalenceGroup",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#EquivalenceGroup",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "EquivalenceGroup",
          "package": "Top",
          "partial": "Equivalence Group",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#t:EquivalenceGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "checkGroup",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#checkGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "checkGroup",
          "normalized": "EquivalenceGroup a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Group",
          "signature": "EquivalenceGroup info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:checkGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "combineGroups",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#combineGroups",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "combineGroups",
          "normalized": "EquivalenceGroup a-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Groups",
          "signature": "EquivalenceGroup info-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:combineGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "consistent",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e Bool",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#consistent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "consistent",
          "normalized": "EquivalenceGroup a-\u003eBool",
          "package": "Top",
          "signature": "EquivalenceGroup info-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:consistent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "constants",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e [String]",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#constants",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "constants",
          "normalized": "EquivalenceGroup a-\u003e[String]",
          "package": "Top",
          "signature": "EquivalenceGroup info-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:constants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(initial) edges in this equivalence group\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "edges",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e [(EdgeId, info)]",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#edges",
          "type": "function"
        },
        "index": {
          "description": "initial edges in this equivalence group",
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "edges",
          "normalized": "EquivalenceGroup a-\u003e[(EdgeId,a)]",
          "package": "Top",
          "signature": "EquivalenceGroup info-\u003e[(EdgeId,info)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "emptyGroup",
          "package": "Top",
          "signature": "EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#emptyGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "emptyGroup",
          "package": "Top",
          "partial": "Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:emptyGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "equalPaths",
          "package": "Top",
          "signature": "Set VertexId -\u003e VertexId -\u003e [VertexId] -\u003e EquivalenceGroup info -\u003e TypeGraphPath info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#equalPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "equalPaths",
          "normalized": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003eEquivalenceGroup a-\u003eTypeGraphPath a",
          "package": "Top",
          "partial": "Paths",
          "signature": "Set VertexId-\u003eVertexId-\u003e[VertexId]-\u003eEquivalenceGroup info-\u003eTypeGraphPath info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:equalPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "insertClique",
          "package": "Top",
          "signature": "Clique -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#insertClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "insertClique",
          "normalized": "Clique-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Clique",
          "signature": "Clique-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:insertClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "insertEdge",
          "package": "Top",
          "signature": "EdgeId -\u003e info -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#insertEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "insertEdge",
          "normalized": "EdgeId-\u003ea-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Edge",
          "signature": "EdgeId-\u003einfo-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:insertEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "insertVertex",
          "package": "Top",
          "signature": "VertexId -\u003e VertexInfo -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#insertVertex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "insertVertex",
          "normalized": "VertexId-\u003eVertexInfo-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Vertex",
          "signature": "VertexId-\u003eVertexInfo-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:insertVertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "removeClique",
          "package": "Top",
          "signature": "Clique -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#removeClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "removeClique",
          "normalized": "Clique-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Clique",
          "signature": "Clique-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:removeClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "removeEdge",
          "package": "Top",
          "signature": "EdgeId -\u003e EquivalenceGroup info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#removeEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "removeEdge",
          "normalized": "EdgeId-\u003eEquivalenceGroup a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Edge",
          "signature": "EdgeId-\u003eEquivalenceGroup info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:removeEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "splitGroup",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e [EquivalenceGroup info]",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#splitGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "splitGroup",
          "normalized": "EquivalenceGroup a-\u003e[EquivalenceGroup a]",
          "package": "Top",
          "partial": "Group",
          "signature": "EquivalenceGroup info-\u003e[EquivalenceGroup info]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:splitGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "typeOfGroup",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e EquivalenceGroup info -\u003e Maybe Tp",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#typeOfGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "typeOfGroup",
          "normalized": "OrderedTypeSynonyms-\u003eEquivalenceGroup a-\u003eMaybe Tp",
          "package": "Top",
          "partial": "Of Group",
          "signature": "OrderedTypeSynonyms-\u003eEquivalenceGroup info-\u003eMaybe Tp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:typeOfGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evertices in this equivalence group\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "vertices",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e [(VertexId, VertexInfo)]",
          "source": "src/Top-Implementation-TypeGraph-EquivalenceGroup.html#vertices",
          "type": "function"
        },
        "index": {
          "description": "vertices in this equivalence group",
          "hierarchy": "Top Implementation TypeGraph EquivalenceGroup",
          "module": "Top.Implementation.TypeGraph.EquivalenceGroup",
          "name": "vertices",
          "normalized": "EquivalenceGroup a-\u003e[(VertexId,VertexInfo)]",
          "package": "Top",
          "signature": "EquivalenceGroup info-\u003e[(VertexId,VertexInfo)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-EquivalenceGroup.html#v:vertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Heuristic",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Heuristic",
          "package": "Top",
          "partial": "Heuristic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "HComponent",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#HComponent",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "HComponent",
          "package": "Top",
          "partial": "HComponent",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:HComponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "HasTwoTypes",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#HasTwoTypes",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "HasTwoTypes",
          "package": "Top",
          "partial": "Has Two Types",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:HasTwoTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Heuristic",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#Heuristic",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Heuristic",
          "package": "Top",
          "partial": "Heuristic",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:Heuristic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "PathHeuristics",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#PathHeuristics",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "PathHeuristics",
          "package": "Top",
          "partial": "Path Heuristics",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:PathHeuristics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Selector",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#Selector",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Selector",
          "package": "Top",
          "partial": "Selector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#t:Selector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Filter",
          "package": "Top",
          "signature": "Filter String ([(EdgeId, info)] -\u003e m [(EdgeId, info)])",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#HComponent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Filter",
          "normalized": "Filter String([(EdgeId,a)]-\u003eb[(EdgeId,a)])",
          "package": "Top",
          "partial": "Filter",
          "signature": "Filter String([(EdgeId,info)]-\u003em[(EdgeId,info)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Heuristic",
          "package": "Top",
          "signature": "HComponent m info)",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#Heuristic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Heuristic",
          "package": "Top",
          "partial": "Heuristic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Heuristic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Selector",
          "package": "Top",
          "signature": "Selector (String, (EdgeId, info) -\u003e m (Maybe (Int, String, [EdgeId], info)))",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#Selector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Selector",
          "normalized": "Selector(String,(EdgeId,a)-\u003eb(Maybe(Int,String,[EdgeId],a)))",
          "package": "Top",
          "partial": "Selector",
          "signature": "Selector(String,(EdgeId,info)-\u003em(Maybe(Int,String,[EdgeId],info)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Selector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "SelectorList",
          "package": "Top",
          "signature": "SelectorList (String, [(EdgeId, info)] -\u003e m (Maybe (Int, String, [EdgeId], info)))",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#Selector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "SelectorList",
          "normalized": "SelectorList(String,[(EdgeId,a)]-\u003eb(Maybe(Int,String,[EdgeId],a)))",
          "package": "Top",
          "partial": "Selector List",
          "signature": "SelectorList(String,[(EdgeId,info)]-\u003em(Maybe(Int,String,[EdgeId],info)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:SelectorList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Voting",
          "package": "Top",
          "signature": "Voting [Selector m info]",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#HComponent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "Voting",
          "normalized": "Voting[Selector a b]",
          "package": "Top",
          "partial": "Voting",
          "signature": "Voting[Selector m info]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:Voting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "doWithoutEdge",
          "package": "Top",
          "signature": "(EdgeId, info) -\u003e m result -\u003e m result",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#doWithoutEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "doWithoutEdge",
          "normalized": "(EdgeId,a)-\u003eb c-\u003eb c",
          "package": "Top",
          "partial": "Without Edge",
          "signature": "(EdgeId,info)-\u003em result-\u003em result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:doWithoutEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "doWithoutEdges",
          "package": "Top",
          "signature": "[(EdgeId, info)] -\u003e m result -\u003e m result",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#doWithoutEdges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "doWithoutEdges",
          "normalized": "[(EdgeId,a)]-\u003eb c-\u003eb c",
          "package": "Top",
          "partial": "Without Edges",
          "signature": "[(EdgeId,info)]-\u003em result-\u003em result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:doWithoutEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "edgeFilter",
          "package": "Top",
          "signature": "String -\u003e ((EdgeId, info) -\u003e m Bool) -\u003e HComponent m info",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#edgeFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "edgeFilter",
          "normalized": "String-\u003e((EdgeId,a)-\u003eb Bool)-\u003eHComponent b a",
          "package": "Top",
          "partial": "Filter",
          "signature": "String-\u003e((EdgeId,info)-\u003em Bool)-\u003eHComponent m info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:edgeFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "eqInfo2",
          "package": "Top",
          "signature": "(EdgeId, info) -\u003e (EdgeId, info) -\u003e Bool",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#eqInfo2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "eqInfo2",
          "normalized": "(EdgeId,a)-\u003e(EdgeId,a)-\u003eBool",
          "package": "Top",
          "partial": "Info",
          "signature": "(EdgeId,info)-\u003e(EdgeId,info)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:eqInfo2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "getSelectorName",
          "package": "Top",
          "signature": "Selector m info -\u003e String",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#getSelectorName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "getSelectorName",
          "normalized": "Selector a b-\u003eString",
          "package": "Top",
          "partial": "Selector Name",
          "signature": "Selector m info-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:getSelectorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "getSubstitutedTypes",
          "package": "Top",
          "signature": "info -\u003e m (Maybe Tp, Maybe Tp)",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#getSubstitutedTypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "getSubstitutedTypes",
          "normalized": "a-\u003eb(Maybe Tp,Maybe Tp)",
          "package": "Top",
          "partial": "Substituted Types",
          "signature": "info-\u003em(Maybe Tp,Maybe Tp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:getSubstitutedTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "getTwoTypes",
          "package": "Top",
          "signature": "a -\u003e (Tp, Tp)",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#getTwoTypes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "getTwoTypes",
          "normalized": "a-\u003e(Tp,Tp)",
          "package": "Top",
          "partial": "Two Types",
          "signature": "a-\u003e(Tp,Tp)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:getTwoTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "info2ToEdgeNr",
          "package": "Top",
          "signature": "(EdgeId, info) -\u003e EdgeNr",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#info2ToEdgeNr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "info2ToEdgeNr",
          "normalized": "(EdgeId,a)-\u003eEdgeNr",
          "package": "Top",
          "partial": "To Edge Nr",
          "signature": "(EdgeId,info)-\u003eEdgeNr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:info2ToEdgeNr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "maximalEdgeFilter",
          "package": "Top",
          "signature": "String -\u003e ((EdgeId, info) -\u003e m a) -\u003e HComponent m info",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#maximalEdgeFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "maximalEdgeFilter",
          "normalized": "String-\u003e((EdgeId,a)-\u003eb c)-\u003eHComponent b a",
          "package": "Top",
          "partial": "Edge Filter",
          "signature": "String-\u003e((EdgeId,info)-\u003em a)-\u003eHComponent m info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:maximalEdgeFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "minimalEdgeFilter",
          "package": "Top",
          "signature": "String -\u003e ((EdgeId, info) -\u003e m a) -\u003e HComponent m info",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#minimalEdgeFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "minimalEdgeFilter",
          "normalized": "String-\u003e((EdgeId,a)-\u003eb c)-\u003eHComponent b a",
          "package": "Top",
          "partial": "Edge Filter",
          "signature": "String-\u003e((EdgeId,info)-\u003em a)-\u003eHComponent m info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:minimalEdgeFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "resultsEdgeFilter",
          "package": "Top",
          "signature": "([a] -\u003e a) -\u003e String -\u003e ((EdgeId, info) -\u003e m a) -\u003e HComponent m info",
          "source": "src/Top-Implementation-TypeGraph-Heuristic.html#resultsEdgeFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Heuristic",
          "module": "Top.Implementation.TypeGraph.Heuristic",
          "name": "resultsEdgeFilter",
          "normalized": "([a]-\u003ea)-\u003eString-\u003e((EdgeId,b)-\u003ec a)-\u003eHComponent c b",
          "package": "Top",
          "partial": "Edge Filter",
          "signature": "([a]-\u003ea)-\u003eString-\u003e((EdgeId,info)-\u003em a)-\u003eHComponent m info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Heuristic.html#v:resultsEdgeFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Path",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Path.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Path",
          "package": "Top",
          "partial": "Path",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Path",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Path.html#Path",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Path",
          "package": "Top",
          "partial": "Path",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#t:Path"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "(\u003c|\u003e)",
          "package": "Top",
          "signature": "m (Path a) -\u003e m (Path a) -\u003e m (Path a)",
          "source": "src/Top-Implementation-TypeGraph-Path.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "(\u003c|\u003e) \u003c|\u003e",
          "normalized": "a(Path b)-\u003ea(Path b)-\u003ea(Path b)",
          "package": "Top",
          "signature": "m(Path a)-\u003em(Path a)-\u003em(Path a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:-60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "(\u003c++\u003e)",
          "package": "Top",
          "signature": "m [Path a] -\u003e m [Path a] -\u003e m [Path a]",
          "source": "src/Top-Implementation-TypeGraph-Path.html#%3C%2B%2B%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "(\u003c++\u003e) \u003c++\u003e",
          "normalized": "a[Path b]-\u003ea[Path b]-\u003ea[Path b]",
          "package": "Top",
          "signature": "m[Path a]-\u003em[Path a]-\u003em[Path a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:-60--43--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "(\u003c+\u003e)",
          "package": "Top",
          "signature": "m (Path a) -\u003e m (Path a) -\u003e m (Path a)",
          "source": "src/Top-Implementation-TypeGraph-Path.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a(Path b)-\u003ea(Path b)-\u003ea(Path b)",
          "package": "Top",
          "signature": "m(Path a)-\u003em(Path a)-\u003em(Path a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": ":|:",
          "package": "Top",
          "signature": "(Path a) :|: (Path a)",
          "source": "src/Top-Implementation-TypeGraph-Path.html#Path",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": ":|:",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v::-124-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": ":+:",
          "package": "Top",
          "signature": "(Path a) :+: (Path a)",
          "source": "src/Top-Implementation-TypeGraph-Path.html#Path",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": ":+:",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Empty",
          "package": "Top",
          "signature": "Empty",
          "source": "src/Top-Implementation-TypeGraph-Path.html#Path",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Empty",
          "package": "Top",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Fail",
          "package": "Top",
          "signature": "Fail",
          "source": "src/Top-Implementation-TypeGraph-Path.html#Path",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Fail",
          "package": "Top",
          "partial": "Fail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:Fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Step",
          "package": "Top",
          "signature": "Step a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#Path",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "Step",
          "package": "Top",
          "partial": "Step",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:Step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "altList",
          "package": "Top",
          "signature": "[Path a] -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#altList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "altList",
          "normalized": "[Path a]-\u003ePath a",
          "package": "Top",
          "partial": "List",
          "signature": "[Path a]-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:altList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "altList1",
          "package": "Top",
          "signature": "[Path a] -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#altList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "altList1",
          "normalized": "[Path a]-\u003ePath a",
          "package": "Top",
          "partial": "List",
          "signature": "[Path a]-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:altList1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "changeStep",
          "package": "Top",
          "signature": "(a -\u003e Path b) -\u003e Path a -\u003e Path b",
          "source": "src/Top-Implementation-TypeGraph-Path.html#changeStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "changeStep",
          "normalized": "(a-\u003ePath b)-\u003ePath a-\u003ePath b",
          "package": "Top",
          "partial": "Step",
          "signature": "(a-\u003ePath b)-\u003ePath a-\u003ePath b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:changeStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "changeStepM",
          "package": "Top",
          "signature": "(a -\u003e m (Path b)) -\u003e Path a -\u003e m (Path b)",
          "source": "src/Top-Implementation-TypeGraph-Path.html#changeStepM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "changeStepM",
          "normalized": "(a-\u003eb(Path c))-\u003ePath a-\u003eb(Path c)",
          "package": "Top",
          "partial": "Step",
          "signature": "(a-\u003em(Path b))-\u003ePath a-\u003em(Path b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:changeStepM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "flattenPath",
          "package": "Top",
          "signature": "Path a -\u003e [[a]]",
          "source": "src/Top-Implementation-TypeGraph-Path.html#flattenPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "flattenPath",
          "normalized": "Path a-\u003e[[a]]",
          "package": "Top",
          "partial": "Path",
          "signature": "Path a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:flattenPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "limitNumberOfPaths",
          "package": "Top",
          "signature": "Int -\u003e Path a -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#limitNumberOfPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "limitNumberOfPaths",
          "normalized": "Int-\u003ePath a-\u003ePath a",
          "package": "Top",
          "partial": "Number Of Paths",
          "signature": "Int-\u003ePath a-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:limitNumberOfPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two monadic computations\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "mCombine",
          "package": "Top",
          "signature": "(a -\u003e b -\u003e c) -\u003e m a -\u003e m b -\u003e m c",
          "source": "src/Top-Implementation-TypeGraph-Path.html#mCombine",
          "type": "function"
        },
        "index": {
          "description": "Combine two monadic computations",
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "mCombine",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "Top",
          "partial": "Combine",
          "signature": "(a-\u003eb-\u003ec)-\u003em a-\u003em b-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:mCombine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "mapPath",
          "package": "Top",
          "signature": "(a -\u003e b) -\u003e Path a -\u003e Path b",
          "source": "src/Top-Implementation-TypeGraph-Path.html#mapPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "mapPath",
          "normalized": "(a-\u003eb)-\u003ePath a-\u003ePath b",
          "package": "Top",
          "partial": "Path",
          "signature": "(a-\u003eb)-\u003ePath a-\u003ePath b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:mapPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe maximal number of equality paths that is returned by equalPaths \n (although this number can be exceeded...it is more or less used as approximation)\n Nothing indicates that there is no limit\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "maxNumberOfEqualPaths",
          "package": "Top",
          "signature": "Maybe Int",
          "source": "src/Top-Implementation-TypeGraph-Path.html#maxNumberOfEqualPaths",
          "type": "function"
        },
        "index": {
          "description": "The maximal number of equality paths that is returned by equalPaths although this number can be exceeded...it is more or less used as approximation Nothing indicates that there is no limit",
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "maxNumberOfEqualPaths",
          "package": "Top",
          "partial": "Number Of Equal Paths",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:maxNumberOfEqualPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "minCompleteInPath",
          "package": "Top",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e Path a -\u003e Maybe a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#minCompleteInPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "minCompleteInPath",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003eMaybe a",
          "package": "Top",
          "partial": "Complete In Path",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:minCompleteInPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "minimalSets",
          "package": "Top",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Path a -\u003e [[a]]",
          "source": "src/Top-Implementation-TypeGraph-Path.html#minimalSets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "minimalSets",
          "normalized": "(a-\u003ea-\u003eBool)-\u003ePath a-\u003e[[a]]",
          "package": "Top",
          "partial": "Sets",
          "signature": "(a-\u003ea-\u003eBool)-\u003ePath a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:minimalSets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "participationMap",
          "package": "Top",
          "signature": "Path a -\u003e (Integer, Map a Integer)",
          "source": "src/Top-Implementation-TypeGraph-Path.html#participationMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "participationMap",
          "normalized": "Path a-\u003e(Integer,Map a Integer)",
          "package": "Top",
          "partial": "Map",
          "signature": "Path a-\u003e(Integer,Map a Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:participationMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "pathSize",
          "package": "Top",
          "signature": "Path a -\u003e Int",
          "source": "src/Top-Implementation-TypeGraph-Path.html#pathSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "pathSize",
          "normalized": "Path a-\u003eInt",
          "package": "Top",
          "partial": "Size",
          "signature": "Path a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:pathSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "reduceNumberOfPaths",
          "package": "Top",
          "signature": "Path a -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#reduceNumberOfPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "reduceNumberOfPaths",
          "normalized": "Path a-\u003ePath a",
          "package": "Top",
          "partial": "Number Of Paths",
          "signature": "Path a-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:reduceNumberOfPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "removeSomeDuplicates",
          "package": "Top",
          "signature": "(a -\u003e b) -\u003e Path a -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#removeSomeDuplicates",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "removeSomeDuplicates",
          "normalized": "(a-\u003eb)-\u003ePath a-\u003ePath a",
          "package": "Top",
          "partial": "Some Duplicates",
          "signature": "(a-\u003eb)-\u003ePath a-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:removeSomeDuplicates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "seqList",
          "package": "Top",
          "signature": "[Path a] -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#seqList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "seqList",
          "normalized": "[Path a]-\u003ePath a",
          "package": "Top",
          "partial": "List",
          "signature": "[Path a]-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:seqList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "seqList1",
          "package": "Top",
          "signature": "[Path a] -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#seqList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "seqList1",
          "normalized": "[Path a]-\u003ePath a",
          "package": "Top",
          "partial": "List",
          "signature": "[Path a]-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:seqList1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "simplifyPath",
          "package": "Top",
          "signature": "Path a -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#simplifyPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "simplifyPath",
          "normalized": "Path a-\u003ePath a",
          "package": "Top",
          "partial": "Path",
          "signature": "Path a-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:simplifyPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "steps",
          "package": "Top",
          "signature": "Path a -\u003e [a]",
          "source": "src/Top-Implementation-TypeGraph-Path.html#steps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "steps",
          "normalized": "Path a-\u003e[a]",
          "package": "Top",
          "signature": "Path a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:steps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "tailSharingBy",
          "package": "Top",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e Path a -\u003e Path a",
          "source": "src/Top-Implementation-TypeGraph-Path.html#tailSharingBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Path",
          "module": "Top.Implementation.TypeGraph.Path",
          "name": "tailSharingBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003ePath a",
          "package": "Top",
          "partial": "Sharing By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ePath a-\u003ePath a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Path.html#v:tailSharingBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "Standard",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Standard.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "Standard",
          "package": "Top",
          "partial": "Standard",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "StandardTypeGraph",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "StandardTypeGraph",
          "package": "Top",
          "partial": "Standard Type Graph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#t:StandardTypeGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "STG",
          "package": "Top",
          "signature": "STG",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "STG",
          "package": "Top",
          "partial": "STG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:STG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "addClique",
          "package": "Top",
          "signature": "Clique -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#addClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "addClique",
          "normalized": "Clique-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Clique",
          "signature": "Clique-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:addClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "addPossibleInconsistentGroup",
          "package": "Top",
          "signature": "VertexId -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#addPossibleInconsistentGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "addPossibleInconsistentGroup",
          "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Possible Inconsistent Group",
          "signature": "VertexId-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:addPossibleInconsistentGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "combineClasses",
          "package": "Top",
          "signature": "[VertexId] -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#combineClasses",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "combineClasses",
          "normalized": "[VertexId]-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Classes",
          "signature": "[VertexId]-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:combineClasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "constraintNumber",
          "package": "Top",
          "signature": "Int",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "constraintNumber",
          "package": "Top",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:constraintNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "createGroup",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#createGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "createGroup",
          "normalized": "EquivalenceGroup a-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Group",
          "signature": "EquivalenceGroup info-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:createGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "deleteClique",
          "package": "Top",
          "signature": "Clique -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#deleteClique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "deleteClique",
          "normalized": "Clique-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Clique",
          "signature": "Clique-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:deleteClique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "equivalenceGroupCounter",
          "package": "Top",
          "signature": "Int",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "equivalenceGroupCounter",
          "package": "Top",
          "partial": "Group Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:equivalenceGroupCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "equivalenceGroupMap",
          "package": "Top",
          "signature": "Map Int (EquivalenceGroup info)",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "equivalenceGroupMap",
          "package": "Top",
          "partial": "Group Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:equivalenceGroupMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "getAllGroups",
          "package": "Top",
          "signature": "StandardTypeGraph info -\u003e [EquivalenceGroup info]",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#getAllGroups",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "getAllGroups",
          "normalized": "StandardTypeGraph a-\u003e[EquivalenceGroup a]",
          "package": "Top",
          "partial": "All Groups",
          "signature": "StandardTypeGraph info-\u003e[EquivalenceGroup info]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:getAllGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "getGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e StandardTypeGraph info -\u003e EquivalenceGroup info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#getGroupOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "getGroupOf",
          "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eEquivalenceGroup a",
          "package": "Top",
          "partial": "Group Of",
          "signature": "VertexId-\u003eStandardTypeGraph info-\u003eEquivalenceGroup info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:getGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "getPossibleInconsistentGroups",
          "package": "Top",
          "signature": "StandardTypeGraph info -\u003e [VertexId]",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#getPossibleInconsistentGroups",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "getPossibleInconsistentGroups",
          "normalized": "StandardTypeGraph a-\u003e[VertexId]",
          "package": "Top",
          "partial": "Possible Inconsistent Groups",
          "signature": "StandardTypeGraph info-\u003e[VertexId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:getPossibleInconsistentGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "maybeGetGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e StandardTypeGraph info -\u003e Maybe (EquivalenceGroup info)",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#maybeGetGroupOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "maybeGetGroupOf",
          "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eMaybe(EquivalenceGroup a)",
          "package": "Top",
          "partial": "Get Group Of",
          "signature": "VertexId-\u003eStandardTypeGraph info-\u003eMaybe(EquivalenceGroup info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:maybeGetGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "possibleErrors",
          "package": "Top",
          "signature": "[VertexId]",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "possibleErrors",
          "normalized": "[VertexId]",
          "package": "Top",
          "partial": "Errors",
          "signature": "[VertexId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:possibleErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "propagateEquality",
          "package": "Top",
          "signature": "VertexId -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#propagateEquality",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "propagateEquality",
          "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Equality",
          "signature": "VertexId-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:propagateEquality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "propagateRemoval",
          "package": "Top",
          "signature": "VertexId -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#propagateRemoval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "propagateRemoval",
          "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Removal",
          "signature": "VertexId-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:propagateRemoval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "referenceMap",
          "package": "Top",
          "signature": "Map VertexId Int",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#StandardTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "referenceMap",
          "package": "Top",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:referenceMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "removeGroup",
          "package": "Top",
          "signature": "EquivalenceGroup info -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#removeGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "removeGroup",
          "normalized": "EquivalenceGroup a-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Group",
          "signature": "EquivalenceGroup info-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:removeGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "setPossibleInconsistentGroups",
          "package": "Top",
          "signature": "[VertexId] -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#setPossibleInconsistentGroups",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "setPossibleInconsistentGroups",
          "normalized": "[VertexId]-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Possible Inconsistent Groups",
          "signature": "[VertexId]-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:setPossibleInconsistentGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "splitClass",
          "package": "Top",
          "signature": "VertexId -\u003e StandardTypeGraph info -\u003e ([VertexId], StandardTypeGraph info)",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#splitClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "splitClass",
          "normalized": "VertexId-\u003eStandardTypeGraph a-\u003e([VertexId],StandardTypeGraph a)",
          "package": "Top",
          "partial": "Class",
          "signature": "VertexId-\u003eStandardTypeGraph info-\u003e([VertexId],StandardTypeGraph info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:splitClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "updateGroupOf",
          "package": "Top",
          "signature": "VertexId -\u003e (EquivalenceGroup info -\u003e EquivalenceGroup info) -\u003e StandardTypeGraph info -\u003e StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#updateGroupOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "updateGroupOf",
          "normalized": "VertexId-\u003e(EquivalenceGroup a-\u003eEquivalenceGroup a)-\u003eStandardTypeGraph a-\u003eStandardTypeGraph a",
          "package": "Top",
          "partial": "Group Of",
          "signature": "VertexId-\u003e(EquivalenceGroup info-\u003eEquivalenceGroup info)-\u003eStandardTypeGraph info-\u003eStandardTypeGraph info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:updateGroupOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "vertexExists",
          "package": "Top",
          "signature": "VertexId -\u003e StandardTypeGraph info -\u003e Bool",
          "source": "src/Top-Implementation-TypeGraph-Standard.html#vertexExists",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraph Standard",
          "module": "Top.Implementation.TypeGraph.Standard",
          "name": "vertexExists",
          "normalized": "VertexId-\u003eStandardTypeGraph a-\u003eBool",
          "package": "Top",
          "partial": "Exists",
          "signature": "VertexId-\u003eStandardTypeGraph info-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraph-Standard.html#v:vertexExists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "TypeGraphSubstitution",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraphSubstitution.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraphSubstitution",
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "TypeGraphSubstitution",
          "package": "Top",
          "partial": "Type Graph Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "TypeGraphState",
          "package": "Top",
          "source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraphSubstitution",
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "TypeGraphState",
          "package": "Top",
          "partial": "Type Graph State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#t:TypeGraphState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "TypeGraphState",
          "package": "Top",
          "signature": "TypeGraphState",
          "source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraphSubstitution",
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "TypeGraphState",
          "package": "Top",
          "partial": "Type Graph State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:TypeGraphState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "heuristics",
          "package": "Top",
          "signature": "PathHeuristics info",
          "source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraphSubstitution",
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "heuristics",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:heuristics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "removeInconsistencies",
          "package": "Top",
          "signature": "PathHeuristics info -\u003e m ()",
          "source": "src/Top-Implementation-TypeGraphSubstitution.html#removeInconsistencies",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraphSubstitution",
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "removeInconsistencies",
          "normalized": "PathHeuristics a-\u003eb()",
          "package": "Top",
          "partial": "Inconsistencies",
          "signature": "PathHeuristics info-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:removeInconsistencies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "typegraph",
          "package": "Top",
          "signature": "StandardTypeGraph info",
          "source": "src/Top-Implementation-TypeGraphSubstitution.html#TypeGraphState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeGraphSubstitution",
          "module": "Top.Implementation.TypeGraphSubstitution",
          "name": "typegraph",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeGraphSubstitution.html#v:typegraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAdditional state information that should be stored in order to perform\n type inference.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Implementation.TypeInference",
          "name": "TypeInference",
          "package": "Top",
          "source": "src/Top-Implementation-TypeInference.html",
          "type": "module"
        },
        "index": {
          "description": "Additional state information that should be stored in order to perform type inference",
          "hierarchy": "Top Implementation TypeInference",
          "module": "Top.Implementation.TypeInference",
          "name": "TypeInference",
          "package": "Top",
          "partial": "Type Inference",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeInference",
          "name": "TIState",
          "package": "Top",
          "source": "src/Top-Implementation-TypeInference.html#TIState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Implementation TypeInference",
          "module": "Top.Implementation.TypeInference",
          "name": "TIState",
          "package": "Top",
          "partial": "TIState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#t:TIState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Implementation.TypeInference",
          "name": "TIState",
          "package": "Top",
          "signature": "TIState",
          "source": "src/Top-Implementation-TypeInference.html#TIState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Implementation TypeInference",
          "module": "Top.Implementation.TypeInference",
          "name": "TIState",
          "package": "Top",
          "partial": "TIState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:TIState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA counter for fresh type variables\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeInference",
          "name": "counter",
          "package": "Top",
          "signature": "Int",
          "source": "src/Top-Implementation-TypeInference.html#TIState",
          "type": "function"
        },
        "index": {
          "description": "counter for fresh type variables",
          "hierarchy": "Top Implementation TypeInference",
          "module": "Top.Implementation.TypeInference",
          "name": "counter",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:counter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType scheme map\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeInference",
          "name": "schemeMap",
          "package": "Top",
          "signature": "Map Int (Scheme Predicates)",
          "source": "src/Top-Implementation-TypeInference.html#TIState",
          "type": "function"
        },
        "index": {
          "description": "Type scheme map",
          "hierarchy": "Top Implementation TypeInference",
          "module": "Top.Implementation.TypeInference",
          "name": "schemeMap",
          "package": "Top",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:schemeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of skolem constants\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeInference",
          "name": "skolems",
          "package": "Top",
          "signature": "[([Int], info, Tps)]",
          "source": "src/Top-Implementation-TypeInference.html#TIState",
          "type": "function"
        },
        "index": {
          "description": "List of skolem constants",
          "hierarchy": "Top Implementation TypeInference",
          "module": "Top.Implementation.TypeInference",
          "name": "skolems",
          "normalized": "[([Int],a,Tps)]",
          "package": "Top",
          "signature": "[([Int],info,Tps)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:skolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll known type synonyms\n\u003c/p\u003e",
          "module": "Top.Implementation.TypeInference",
          "name": "synonyms",
          "package": "Top",
          "signature": "OrderedTypeSynonyms",
          "source": "src/Top-Implementation-TypeInference.html#TIState",
          "type": "function"
        },
        "index": {
          "description": "All known type synonyms",
          "hierarchy": "Top Implementation TypeInference",
          "module": "Top.Implementation.TypeInference",
          "name": "synonyms",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Implementation-TypeInference.html#v:synonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "Basic",
          "package": "Top",
          "source": "src/Top-Interface-Basic.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "Basic",
          "package": "Top",
          "partial": "Basic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "ClassBasic",
          "package": "Top",
          "source": "src/Top-Interface-Basic.html#ClassBasic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "ClassBasic",
          "package": "Top",
          "partial": "Class Basic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#t:ClassBasic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA datatype to label the errors that are detected.\n\u003c/p\u003e",
          "module": "Top.Interface.Basic",
          "name": "ErrorLabel",
          "package": "Top",
          "source": "src/Top-Interface-Basic.html#ErrorLabel",
          "type": "data"
        },
        "index": {
          "description": "datatype to label the errors that are detected",
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "ErrorLabel",
          "package": "Top",
          "partial": "Error Label",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#t:ErrorLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "HasBasic",
          "package": "Top",
          "source": "src/Top-Interface-Basic.html#HasBasic",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "HasBasic",
          "package": "Top",
          "partial": "Has Basic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#t:HasBasic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "ClassBasic",
          "package": "Top",
          "signature": "ClassBasic",
          "source": "src/Top-Interface-Basic.html#ClassBasic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "ClassBasic",
          "package": "Top",
          "partial": "Class Basic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:ClassBasic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "ErrorLabel",
          "package": "Top",
          "signature": "ErrorLabel String",
          "source": "src/Top-Interface-Basic.html#ErrorLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "ErrorLabel",
          "package": "Top",
          "partial": "Error Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:ErrorLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "NoErrorLabel",
          "package": "Top",
          "signature": "NoErrorLabel",
          "source": "src/Top-Interface-Basic.html#ErrorLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "NoErrorLabel",
          "package": "Top",
          "partial": "No Error Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:NoErrorLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "addCheck",
          "package": "Top",
          "signature": "String -\u003e m Bool -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#addCheck",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "addCheck",
          "normalized": "String-\u003ea Bool-\u003ea()",
          "package": "Top",
          "partial": "Check",
          "signature": "String-\u003em Bool-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:addCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "addError",
          "package": "Top",
          "signature": "info -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#addError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "addError",
          "normalized": "a-\u003eb()",
          "package": "Top",
          "partial": "Error",
          "signature": "info-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:addError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "addLabeledError",
          "package": "Top",
          "signature": "ErrorLabel -\u003e info -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#addLabeledError",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "addLabeledError",
          "normalized": "ErrorLabel-\u003ea-\u003eb()",
          "package": "Top",
          "partial": "Labeled Error",
          "signature": "ErrorLabel-\u003einfo-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:addLabeledError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "checkConditions",
          "package": "Top",
          "signature": "OptionAccess m Bool",
          "source": "src/Top-Interface-Basic.html#checkConditions",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "checkConditions",
          "package": "Top",
          "partial": "Conditions",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:checkConditions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "checkOption",
          "package": "Top",
          "signature": "Option Bool",
          "source": "src/Top-Interface-Basic.html#stopOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "checkOption",
          "package": "Top",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:checkOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "deBasic",
          "package": "Top",
          "signature": "SelectFix t (StateFixT s m) a -\u003e StateFixT s m a",
          "source": "src/Top-Interface-Basic.html#deBasic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "deBasic",
          "normalized": "SelectFix a(StateFixT b c)d-\u003eStateFixT b c d",
          "package": "Top",
          "partial": "Basic",
          "signature": "SelectFix t(StateFixT s m)a-\u003eStateFixT s m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:deBasic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "discardConstraints",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Basic.html#discardConstraints",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "discardConstraints",
          "normalized": "a()",
          "package": "Top",
          "partial": "Constraints",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:discardConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "doChecks",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Basic.html#doChecks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "doChecks",
          "normalized": "a()",
          "package": "Top",
          "partial": "Checks",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:doChecks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "getChecks",
          "package": "Top",
          "signature": "m [(m Bool, String)]",
          "source": "src/Top-Interface-Basic.html#getChecks",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "getChecks",
          "normalized": "a[(a Bool,String)]",
          "package": "Top",
          "partial": "Checks",
          "signature": "m[(m Bool,String)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:getChecks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "getErrors",
          "package": "Top",
          "signature": "m [info]",
          "source": "src/Top-Interface-Basic.html#getErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "getErrors",
          "normalized": "a[b]",
          "package": "Top",
          "partial": "Errors",
          "signature": "m[info]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:getErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "getLabeledErrors",
          "package": "Top",
          "signature": "m [(info, ErrorLabel)]",
          "source": "src/Top-Interface-Basic.html#getLabeledErrors",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "getLabeledErrors",
          "normalized": "a[(b,ErrorLabel)]",
          "package": "Top",
          "partial": "Labeled Errors",
          "signature": "m[(info,ErrorLabel)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:getLabeledErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "popConstraint",
          "package": "Top",
          "signature": "m (Maybe (Constraint m))",
          "source": "src/Top-Interface-Basic.html#popConstraint",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "popConstraint",
          "package": "Top",
          "partial": "Constraint",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:popConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "pushConstraint",
          "package": "Top",
          "signature": "Constraint m -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#pushConstraint",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "pushConstraint",
          "normalized": "Constraint a-\u003ea()",
          "package": "Top",
          "partial": "Constraint",
          "signature": "Constraint m-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "pushConstraints",
          "package": "Top",
          "signature": "Constraints m -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#pushConstraints",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "pushConstraints",
          "normalized": "Constraints a-\u003ea()",
          "package": "Top",
          "partial": "Constraints",
          "signature": "Constraints m-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "pushNamedOperation",
          "package": "Top",
          "signature": "String -\u003e m () -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#pushNamedOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "pushNamedOperation",
          "normalized": "String-\u003ea()-\u003ea()",
          "package": "Top",
          "partial": "Named Operation",
          "signature": "String-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushNamedOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "pushOperation",
          "package": "Top",
          "signature": "m () -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#pushOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "pushOperation",
          "normalized": "a()-\u003ea()",
          "package": "Top",
          "partial": "Operation",
          "signature": "m()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:pushOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "startSolving",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Basic.html#startSolving",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "startSolving",
          "normalized": "a()",
          "package": "Top",
          "partial": "Solving",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:startSolving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "stopAfterFirstError",
          "package": "Top",
          "signature": "OptionAccess m Bool",
          "source": "src/Top-Interface-Basic.html#stopAfterFirstError",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "stopAfterFirstError",
          "package": "Top",
          "partial": "After First Error",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:stopAfterFirstError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "stopOption",
          "package": "Top",
          "signature": "Option Bool",
          "source": "src/Top-Interface-Basic.html#stopOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "stopOption",
          "package": "Top",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:stopOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Basic",
          "name": "updateErrorInfo",
          "package": "Top",
          "signature": "(info -\u003e m info) -\u003e m ()",
          "source": "src/Top-Interface-Basic.html#updateErrorInfo",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Basic",
          "module": "Top.Interface.Basic",
          "name": "updateErrorInfo",
          "normalized": "(a-\u003eb a)-\u003eb()",
          "package": "Top",
          "partial": "Error Info",
          "signature": "(info-\u003em info)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Basic.html#v:updateErrorInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "Qualification",
          "package": "Top",
          "source": "src/Top-Interface-Qualification.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "Qualification",
          "package": "Top",
          "partial": "Qualification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "ClassQual",
          "package": "Top",
          "source": "src/Top-Interface-Qualification.html#ClassQual",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "ClassQual",
          "package": "Top",
          "partial": "Class Qual",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#t:ClassQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "HasQual",
          "package": "Top",
          "source": "src/Top-Interface-Qualification.html#HasQual",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "HasQual",
          "package": "Top",
          "partial": "Has Qual",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#t:HasQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "ClassQual",
          "package": "Top",
          "signature": "ClassQual",
          "source": "src/Top-Interface-Qualification.html#ClassQual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "ClassQual",
          "package": "Top",
          "partial": "Class Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:ClassQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "allQualifiers",
          "package": "Top",
          "signature": "m [Predicate]",
          "source": "src/Top-Interface-Qualification.html#allQualifiers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "allQualifiers",
          "normalized": "a[Predicate]",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "m[Predicate]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:allQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "ambiguities",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Qualification.html#ambiguities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "ambiguities",
          "normalized": "a()",
          "package": "Top",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:ambiguities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "ambiguousQualifiers",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Qualification.html#ambiguousQualifiers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "ambiguousQualifiers",
          "normalized": "a()",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:ambiguousQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "assumeQualifier",
          "package": "Top",
          "signature": "info -\u003e Predicate -\u003e m ()",
          "source": "src/Top-Interface-Qualification.html#assumeQualifier",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "assumeQualifier",
          "normalized": "a-\u003ePredicate-\u003eb()",
          "package": "Top",
          "partial": "Qualifier",
          "signature": "info-\u003ePredicate-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:assumeQualifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "assumeQualifiers",
          "package": "Top",
          "signature": "info -\u003e Predicates -\u003e m ()",
          "source": "src/Top-Interface-Qualification.html#assumeQualifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "assumeQualifiers",
          "normalized": "a-\u003ePredicates-\u003eb()",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "info-\u003ePredicates-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:assumeQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "changeQualifiers",
          "package": "Top",
          "signature": "(Predicate -\u003e m Predicate) -\u003e m ()",
          "source": "src/Top-Interface-Qualification.html#changeQualifiers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "changeQualifiers",
          "normalized": "(Predicate-\u003ea Predicate)-\u003ea()",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "(Predicate-\u003em Predicate)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:changeQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "contextReduction",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Qualification.html#contextReduction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "contextReduction",
          "normalized": "a()",
          "package": "Top",
          "partial": "Reduction",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:contextReduction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "deQual",
          "package": "Top",
          "signature": "Select t (StateFixT s m) a -\u003e StateFixT s m a",
          "source": "src/Top-Interface-Qualification.html#deQual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "deQual",
          "normalized": "Select a(StateFixT b c)d-\u003eStateFixT b c d",
          "package": "Top",
          "partial": "Qual",
          "signature": "Select t(StateFixT s m)a-\u003eStateFixT s m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:deQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "generalizeWithQualifiers",
          "package": "Top",
          "signature": "Tps -\u003e Tp -\u003e m (Scheme [Predicate])",
          "source": "src/Top-Interface-Qualification.html#generalizeWithQualifiers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "generalizeWithQualifiers",
          "normalized": "Tps-\u003eTp-\u003ea(Scheme[Predicate])",
          "package": "Top",
          "partial": "With Qualifiers",
          "signature": "Tps-\u003eTp-\u003em(Scheme[Predicate])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:generalizeWithQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "getClassEnvironment",
          "package": "Top",
          "signature": "m ClassEnvironment",
          "source": "src/Top-Interface-Qualification.html#getClassEnvironment",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "getClassEnvironment",
          "package": "Top",
          "partial": "Class Environment",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:getClassEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiers",
          "package": "Top",
          "signature": "Bool -\u003e m [(info, Tp, Tp)]",
          "source": "src/Top-Interface-Qualification.html#improveQualifiers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiers",
          "normalized": "Bool-\u003ea[(b,Tp,Tp)]",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "Bool-\u003em[(info,Tp,Tp)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiersFinal",
          "package": "Top",
          "signature": "m [(info, Tp, Tp)]",
          "source": "src/Top-Interface-Qualification.html#improveQualifiersFinal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiersFinal",
          "normalized": "a[(b,Tp,Tp)]",
          "package": "Top",
          "partial": "Qualifiers Final",
          "signature": "m[(info,Tp,Tp)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiersFinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiersFix",
          "package": "Top",
          "signature": "Bool -\u003e m ()",
          "source": "src/Top-Interface-Qualification.html#improveQualifiersFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiersFix",
          "normalized": "Bool-\u003ea()",
          "package": "Top",
          "partial": "Qualifiers Fix",
          "signature": "Bool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiersFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiersNormal",
          "package": "Top",
          "signature": "m [(info, Tp, Tp)]",
          "source": "src/Top-Interface-Qualification.html#improveQualifiersNormal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "improveQualifiersNormal",
          "normalized": "a[(b,Tp,Tp)]",
          "package": "Top",
          "partial": "Qualifiers Normal",
          "signature": "m[(info,Tp,Tp)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:improveQualifiersNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "proveQualifier",
          "package": "Top",
          "signature": "info -\u003e Predicate -\u003e m ()",
          "source": "src/Top-Interface-Qualification.html#proveQualifier",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "proveQualifier",
          "normalized": "a-\u003ePredicate-\u003eb()",
          "package": "Top",
          "partial": "Qualifier",
          "signature": "info-\u003ePredicate-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:proveQualifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "proveQualifiers",
          "package": "Top",
          "signature": "info -\u003e Predicates -\u003e m ()",
          "source": "src/Top-Interface-Qualification.html#proveQualifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "proveQualifiers",
          "normalized": "a-\u003ePredicates-\u003eb()",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "info-\u003ePredicates-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:proveQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "setClassEnvironment",
          "package": "Top",
          "signature": "ClassEnvironment -\u003e m ()",
          "source": "src/Top-Interface-Qualification.html#setClassEnvironment",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "setClassEnvironment",
          "normalized": "ClassEnvironment-\u003ea()",
          "package": "Top",
          "partial": "Class Environment",
          "signature": "ClassEnvironment-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:setClassEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Qualification",
          "name": "simplifyQualifiers",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Qualification.html#simplifyQualifiers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface Qualification",
          "module": "Top.Interface.Qualification",
          "name": "simplifyQualifiers",
          "normalized": "a()",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Qualification.html#v:simplifyQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Substitution",
          "name": "Substitution",
          "package": "Top",
          "source": "src/Top-Interface-Substitution.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "Substitution",
          "package": "Top",
          "partial": "Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Substitution",
          "name": "ClassSubst",
          "package": "Top",
          "source": "src/Top-Interface-Substitution.html#ClassSubst",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "ClassSubst",
          "package": "Top",
          "partial": "Class Subst",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#t:ClassSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Substitution",
          "name": "HasSubst",
          "package": "Top",
          "source": "src/Top-Interface-Substitution.html#HasSubst",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "HasSubst",
          "package": "Top",
          "partial": "Has Subst",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#t:HasSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Substitution",
          "name": "ClassSubst",
          "package": "Top",
          "signature": "ClassSubst",
          "source": "src/Top-Interface-Substitution.html#ClassSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "ClassSubst",
          "package": "Top",
          "partial": "Class Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:ClassSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the substitution to a value that contains type variables (a \n member of the Substitutable type class). \n\u003c/p\u003e",
          "module": "Top.Interface.Substitution",
          "name": "applySubst",
          "package": "Top",
          "signature": "a -\u003e m a",
          "source": "src/Top-Interface-Substitution.html#applySubst",
          "type": "function"
        },
        "index": {
          "description": "Apply the substitution to value that contains type variables member of the Substitutable type class",
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "applySubst",
          "normalized": "a-\u003eb a",
          "package": "Top",
          "partial": "Subst",
          "signature": "a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:applySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Substitution",
          "name": "deSubst",
          "package": "Top",
          "signature": "Select t (StateFixT s m) a -\u003e StateFixT s m a",
          "source": "src/Top-Interface-Substitution.html#deSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "deSubst",
          "normalized": "Select a(StateFixT b c)d-\u003eStateFixT b c d",
          "package": "Top",
          "partial": "Subst",
          "signature": "Select t(StateFixT s m)a-\u003eStateFixT s m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:deSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup the value of a type variable in the substitution\n\u003c/p\u003e",
          "module": "Top.Interface.Substitution",
          "name": "findSubstForVar",
          "package": "Top",
          "signature": "Int -\u003e m Tp",
          "source": "src/Top-Interface-Substitution.html#findSubstForVar",
          "type": "method"
        },
        "index": {
          "description": "Lookup the value of type variable in the substitution",
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "findSubstForVar",
          "normalized": "Int-\u003ea Tp",
          "package": "Top",
          "partial": "Subst For Var",
          "signature": "Int-\u003em Tp",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:findSubstForVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a fixpoint substitution.\n\u003c/p\u003e",
          "module": "Top.Interface.Substitution",
          "name": "fixpointSubst",
          "package": "Top",
          "signature": "m FixpointSubstitution",
          "source": "src/Top-Interface-Substitution.html#fixpointSubst",
          "type": "method"
        },
        "index": {
          "description": "Return fixpoint substitution",
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "fixpointSubst",
          "package": "Top",
          "partial": "Subst",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:fixpointSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake the state consistent. Only relevant for substitution states that \n can be inconsistent (for instance, the type graph substitution state).\n\u003c/p\u003e",
          "module": "Top.Interface.Substitution",
          "name": "makeSubstConsistent",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-Substitution.html#makeSubstConsistent",
          "type": "method"
        },
        "index": {
          "description": "Make the state consistent Only relevant for substitution states that can be inconsistent for instance the type graph substitution state",
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "makeSubstConsistent",
          "normalized": "a()",
          "package": "Top",
          "partial": "Subst Consistent",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:makeSubstConsistent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.Substitution",
          "name": "unificationErrorLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Interface-Substitution.html#unificationErrorLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "unificationErrorLabel",
          "package": "Top",
          "partial": "Error Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:unificationErrorLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnify two terms. Supply additional information for this unification.\n\u003c/p\u003e",
          "module": "Top.Interface.Substitution",
          "name": "unifyTerms",
          "package": "Top",
          "signature": "info -\u003e Tp -\u003e Tp -\u003e m ()",
          "source": "src/Top-Interface-Substitution.html#unifyTerms",
          "type": "method"
        },
        "index": {
          "description": "Unify two terms Supply additional information for this unification",
          "hierarchy": "Top Interface Substitution",
          "module": "Top.Interface.Substitution",
          "name": "unifyTerms",
          "normalized": "a-\u003eTp-\u003eTp-\u003eb()",
          "package": "Top",
          "partial": "Terms",
          "signature": "info-\u003eTp-\u003eTp-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-Substitution.html#v:unifyTerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "TypeInference",
          "package": "Top",
          "source": "src/Top-Interface-TypeInference.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "TypeInference",
          "package": "Top",
          "partial": "Type Inference",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "ClassTI",
          "package": "Top",
          "source": "src/Top-Interface-TypeInference.html#ClassTI",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "ClassTI",
          "package": "Top",
          "partial": "Class TI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#t:ClassTI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "HasTI",
          "package": "Top",
          "source": "src/Top-Interface-TypeInference.html#HasTI",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "HasTI",
          "package": "Top",
          "partial": "Has TI",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#t:HasTI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "ClassTI",
          "package": "Top",
          "signature": "ClassTI",
          "source": "src/Top-Interface-TypeInference.html#ClassTI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "ClassTI",
          "package": "Top",
          "partial": "Class TI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:ClassTI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "addSkolem",
          "package": "Top",
          "signature": "([Int], info, Tps) -\u003e m ()",
          "source": "src/Top-Interface-TypeInference.html#addSkolem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "addSkolem",
          "normalized": "([Int],a,Tps)-\u003eb()",
          "package": "Top",
          "partial": "Skolem",
          "signature": "([Int],info,Tps)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:addSkolem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "allTypeSchemes",
          "package": "Top",
          "signature": "m (Map Int (Scheme Predicates))",
          "source": "src/Top-Interface-TypeInference.html#allTypeSchemes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "allTypeSchemes",
          "package": "Top",
          "partial": "Type Schemes",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:allTypeSchemes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "checkSkolems",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-TypeInference.html#checkSkolems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "checkSkolems",
          "normalized": "a()",
          "package": "Top",
          "partial": "Skolems",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:checkSkolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "deTI",
          "package": "Top",
          "signature": "Select t (StateFixT s m) a -\u003e StateFixT s m a",
          "source": "src/Top-Interface-TypeInference.html#deTI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "deTI",
          "normalized": "Select a(StateFixT b c)d-\u003eStateFixT b c d",
          "package": "Top",
          "partial": "TI",
          "signature": "Select t(StateFixT s m)a-\u003eStateFixT s m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:deTI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "escapingSkolemLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Interface-TypeInference.html#escapingSkolemLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "escapingSkolemLabel",
          "package": "Top",
          "partial": "Skolem Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:escapingSkolemLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "findScheme",
          "package": "Top",
          "signature": "Sigma Predicates -\u003e m (Scheme Predicates)",
          "source": "src/Top-Interface-TypeInference.html#findScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "findScheme",
          "normalized": "Sigma Predicates-\u003ea(Scheme Predicates)",
          "package": "Top",
          "partial": "Scheme",
          "signature": "Sigma Predicates-\u003em(Scheme Predicates)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:findScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "getSkolemSubstitution",
          "package": "Top",
          "signature": "m MapSubstitution",
          "source": "src/Top-Interface-TypeInference.html#getSkolemSubstitution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "getSkolemSubstitution",
          "package": "Top",
          "partial": "Skolem Substitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getSkolemSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "getSkolems",
          "package": "Top",
          "signature": "m [([Int], info, Tps)]",
          "source": "src/Top-Interface-TypeInference.html#getSkolems",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "getSkolems",
          "normalized": "a[([Int],b,Tps)]",
          "package": "Top",
          "partial": "Skolems",
          "signature": "m[([Int],info,Tps)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getSkolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "getTypeScheme",
          "package": "Top",
          "signature": "Int -\u003e m (Scheme Predicates)",
          "source": "src/Top-Interface-TypeInference.html#getTypeScheme",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "getTypeScheme",
          "normalized": "Int-\u003ea(Scheme Predicates)",
          "package": "Top",
          "partial": "Type Scheme",
          "signature": "Int-\u003em(Scheme Predicates)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "getTypeSynonyms",
          "package": "Top",
          "signature": "m OrderedTypeSynonyms",
          "source": "src/Top-Interface-TypeInference.html#getTypeSynonyms",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "getTypeSynonyms",
          "package": "Top",
          "partial": "Type Synonyms",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "getUnique",
          "package": "Top",
          "signature": "m Int",
          "source": "src/Top-Interface-TypeInference.html#getUnique",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "getUnique",
          "package": "Top",
          "partial": "Unique",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:getUnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "instantiateM",
          "package": "Top",
          "signature": "Forall a -\u003e m a",
          "source": "src/Top-Interface-TypeInference.html#instantiateM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "instantiateM",
          "normalized": "Forall a-\u003eb a",
          "package": "Top",
          "signature": "Forall a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:instantiateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst, make the substitution consistent. Then check the skolem constants(?)\n\u003c/p\u003e",
          "module": "Top.Interface.TypeInference",
          "name": "makeConsistent",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Interface-TypeInference.html#makeConsistent",
          "type": "function"
        },
        "index": {
          "description": "First make the substitution consistent Then check the skolem constants",
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "makeConsistent",
          "normalized": "a()",
          "package": "Top",
          "partial": "Consistent",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:makeConsistent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "nextUnique",
          "package": "Top",
          "signature": "m Int",
          "source": "src/Top-Interface-TypeInference.html#nextUnique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "nextUnique",
          "package": "Top",
          "partial": "Unique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:nextUnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "replaceSchemeVar",
          "package": "Top",
          "signature": "Sigma Predicates -\u003e m (Scheme Predicates)",
          "source": "src/Top-Interface-TypeInference.html#replaceSchemeVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "replaceSchemeVar",
          "normalized": "Sigma Predicates-\u003ea(Scheme Predicates)",
          "package": "Top",
          "partial": "Scheme Var",
          "signature": "Sigma Predicates-\u003em(Scheme Predicates)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:replaceSchemeVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "setSkolems",
          "package": "Top",
          "signature": "[([Int], info, Tps)] -\u003e m ()",
          "source": "src/Top-Interface-TypeInference.html#setSkolems",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "setSkolems",
          "normalized": "[([Int],a,Tps)]-\u003eb()",
          "package": "Top",
          "partial": "Skolems",
          "signature": "[([Int],info,Tps)]-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:setSkolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "setTypeSynonyms",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e m ()",
          "source": "src/Top-Interface-TypeInference.html#setTypeSynonyms",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "setTypeSynonyms",
          "normalized": "OrderedTypeSynonyms-\u003ea()",
          "package": "Top",
          "partial": "Type Synonyms",
          "signature": "OrderedTypeSynonyms-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:setTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "setUnique",
          "package": "Top",
          "signature": "Int -\u003e m ()",
          "source": "src/Top-Interface-TypeInference.html#setUnique",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "setUnique",
          "normalized": "Int-\u003ea()",
          "package": "Top",
          "partial": "Unique",
          "signature": "Int-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:setUnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "skolemVersusConstantLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Interface-TypeInference.html#skolemVersusConstantLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "skolemVersusConstantLabel",
          "package": "Top",
          "partial": "Versus Constant Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemVersusConstantLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "skolemVersusSkolemLabel",
          "package": "Top",
          "signature": "ErrorLabel",
          "source": "src/Top-Interface-TypeInference.html#skolemVersusSkolemLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "skolemVersusSkolemLabel",
          "package": "Top",
          "partial": "Versus Skolem Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemVersusSkolemLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "skolemizeFaked",
          "package": "Top",
          "signature": "info -\u003e Tps -\u003e Forall a -\u003e m a",
          "source": "src/Top-Interface-TypeInference.html#skolemizeFaked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "skolemizeFaked",
          "normalized": "a-\u003eTps-\u003eForall b-\u003ec b",
          "package": "Top",
          "partial": "Faked",
          "signature": "info-\u003eTps-\u003eForall a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemizeFaked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "skolemizeTruly",
          "package": "Top",
          "signature": "Forall a -\u003e m a",
          "source": "src/Top-Interface-TypeInference.html#skolemizeTruly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "skolemizeTruly",
          "normalized": "Forall a-\u003eb a",
          "package": "Top",
          "partial": "Truly",
          "signature": "Forall a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:skolemizeTruly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "storeTypeScheme",
          "package": "Top",
          "signature": "Int -\u003e Scheme Predicates -\u003e m ()",
          "source": "src/Top-Interface-TypeInference.html#storeTypeScheme",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "storeTypeScheme",
          "normalized": "Int-\u003eScheme Predicates-\u003ea()",
          "package": "Top",
          "partial": "Type Scheme",
          "signature": "Int-\u003eScheme Predicates-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:storeTypeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Interface.TypeInference",
          "name": "zipWithUniques",
          "package": "Top",
          "signature": "(Int -\u003e a -\u003e b) -\u003e [a] -\u003e m [b]",
          "source": "src/Top-Interface-TypeInference.html#zipWithUniques",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Interface TypeInference",
          "module": "Top.Interface.TypeInference",
          "name": "zipWithUniques",
          "normalized": "(Int-\u003ea-\u003eb)-\u003e[a]-\u003ec[b]",
          "package": "Top",
          "partial": "With Uniques",
          "signature": "(Int-\u003ea-\u003eb)-\u003e[a]-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Interface-TypeInference.html#v:zipWithUniques"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "Select",
          "package": "Top",
          "source": "src/Top-Monad-Select.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "Select",
          "package": "Top",
          "partial": "Select",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "Embedded",
          "package": "Top",
          "source": "src/Top-Monad-Select.html#Embedded",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "Embedded",
          "package": "Top",
          "partial": "Embedded",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#t:Embedded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "Select",
          "package": "Top",
          "source": "src/Top-Monad-Select.html#Select",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "Select",
          "package": "Top",
          "partial": "Select",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#t:Select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "SelectFix",
          "package": "Top",
          "source": "src/Top-Monad-Select.html#SelectFix",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "SelectFix",
          "package": "Top",
          "partial": "Select Fix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#t:SelectFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "Select",
          "package": "Top",
          "signature": "Select (m a)",
          "source": "src/Top-Monad-Select.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "Select",
          "package": "Top",
          "partial": "Select",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:Select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "SelectFix",
          "package": "Top",
          "signature": "SelectFix (m a)",
          "source": "src/Top-Monad-Select.html#SelectFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "SelectFix",
          "package": "Top",
          "partial": "Select Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:SelectFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "deselect",
          "package": "Top",
          "signature": "Select t m a -\u003e m a",
          "source": "src/Top-Monad-Select.html#deselect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "deselect",
          "normalized": "Select a b c-\u003eb c",
          "package": "Top",
          "signature": "Select t m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "deselectFix",
          "package": "Top",
          "signature": "SelectFix t m a -\u003e m a",
          "source": "src/Top-Monad-Select.html#deselectFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "deselectFix",
          "normalized": "SelectFix a b c-\u003eb c",
          "package": "Top",
          "partial": "Fix",
          "signature": "SelectFix t m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselectFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "deselectFixFor",
          "package": "Top",
          "signature": "label -\u003e SelectFix t m a -\u003e m a",
          "source": "src/Top-Monad-Select.html#deselectFixFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "deselectFixFor",
          "normalized": "a-\u003eSelectFix b c d-\u003ec d",
          "package": "Top",
          "partial": "Fix For",
          "signature": "label-\u003eSelectFix t m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselectFixFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "deselectFor",
          "package": "Top",
          "signature": "label -\u003e Select t m a -\u003e m a",
          "source": "src/Top-Monad-Select.html#deselectFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "deselectFor",
          "normalized": "a-\u003eSelect b c d-\u003ec d",
          "package": "Top",
          "partial": "For",
          "signature": "label-\u003eSelect t m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:deselectFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "embedding",
          "package": "Top",
          "signature": "Embedding s t",
          "source": "src/Top-Monad-Select.html#embedding",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "embedding",
          "package": "Top",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:embedding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "select",
          "package": "Top",
          "signature": "m a -\u003e Select t m a",
          "source": "src/Top-Monad-Select.html#select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "select",
          "normalized": "a b-\u003eSelect c a b",
          "package": "Top",
          "signature": "m a-\u003eSelect t m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.Select",
          "name": "selectFix",
          "package": "Top",
          "signature": "m a -\u003e SelectFix t m a",
          "source": "src/Top-Monad-Select.html#selectFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad Select",
          "module": "Top.Monad.Select",
          "name": "selectFix",
          "normalized": "a b-\u003eSelectFix c a b",
          "package": "Top",
          "partial": "Fix",
          "signature": "m a-\u003eSelectFix t m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-Select.html#v:selectFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "StateFix",
          "package": "Top",
          "source": "src/Top-Monad-StateFix.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "StateFix",
          "package": "Top",
          "partial": "State Fix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "StateFix",
          "package": "Top",
          "source": "src/Top-Monad-StateFix.html#StateFix",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "StateFix",
          "package": "Top",
          "partial": "State Fix",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#t:StateFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "StateFixT",
          "package": "Top",
          "source": "src/Top-Monad-StateFix.html#StateFixT",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "StateFixT",
          "package": "Top",
          "partial": "State Fix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#t:StateFixT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "Fix",
          "package": "Top",
          "signature": "Fix",
          "source": "src/Top-Monad-StateFix.html#StateFixT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "Fix",
          "package": "Top",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:Fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "evalStateFix",
          "package": "Top",
          "signature": "StateFix s a -\u003e s (StateFix s) -\u003e a",
          "source": "src/Top-Monad-StateFix.html#evalStateFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "evalStateFix",
          "normalized": "StateFix a b-\u003ea(StateFix a)-\u003eb",
          "package": "Top",
          "partial": "State Fix",
          "signature": "StateFix s a-\u003es(StateFix s)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:evalStateFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "evalStateFixT",
          "package": "Top",
          "signature": "StateFixT s m a -\u003e s (StateFixT s m) -\u003e m a",
          "source": "src/Top-Monad-StateFix.html#evalStateFixT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "evalStateFixT",
          "normalized": "StateFixT a b c-\u003ea(StateFixT a b)-\u003eb c",
          "package": "Top",
          "partial": "State Fix",
          "signature": "StateFixT s m a-\u003es(StateFixT s m)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:evalStateFixT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "execStateFix",
          "package": "Top",
          "signature": "StateFix s a -\u003e s (StateFix s) -\u003e s (StateFix s)",
          "source": "src/Top-Monad-StateFix.html#execStateFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "execStateFix",
          "normalized": "StateFix a b-\u003ea(StateFix a)-\u003ea(StateFix a)",
          "package": "Top",
          "partial": "State Fix",
          "signature": "StateFix s a-\u003es(StateFix s)-\u003es(StateFix s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:execStateFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "execStateFixT",
          "package": "Top",
          "signature": "StateFixT s m a -\u003e s (StateFixT s m) -\u003e m (s (StateFixT s m))",
          "source": "src/Top-Monad-StateFix.html#execStateFixT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "execStateFixT",
          "normalized": "StateFixT a b c-\u003ea(StateFixT a b)-\u003eb(a(StateFixT a b))",
          "package": "Top",
          "partial": "State Fix",
          "signature": "StateFixT s m a-\u003es(StateFixT s m)-\u003em(s(StateFixT s m))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:execStateFixT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "runStateFix",
          "package": "Top",
          "signature": "StateFix s a -\u003e s (StateFix s) -\u003e (a, s (StateFix s))",
          "source": "src/Top-Monad-StateFix.html#runStateFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "runStateFix",
          "normalized": "StateFix a b-\u003ea(StateFix a)-\u003e(b,a(StateFix a))",
          "package": "Top",
          "partial": "State Fix",
          "signature": "StateFix s a-\u003es(StateFix s)-\u003e(a,s(StateFix s))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:runStateFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "runStateFixT",
          "package": "Top",
          "signature": "StateFixT s m a -\u003e s (StateFixT s m) -\u003e m (a, s (StateFixT s m))",
          "source": "src/Top-Monad-StateFix.html#runStateFixT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "runStateFixT",
          "normalized": "StateFixT a b c-\u003ea(StateFixT a b)-\u003eb(c,a(StateFixT a b))",
          "package": "Top",
          "partial": "State Fix",
          "signature": "StateFixT s m a-\u003es(StateFixT s m)-\u003em(a,s(StateFixT s m))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:runStateFixT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Monad.StateFix",
          "name": "unFix",
          "package": "Top",
          "signature": "StateT (s (StateFixT s m)) m a",
          "source": "src/Top-Monad-StateFix.html#StateFixT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Monad StateFix",
          "module": "Top.Monad.StateFix",
          "name": "unFix",
          "package": "Top",
          "partial": "Fix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Monad-StateFix.html#v:unFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Tree",
          "package": "Top",
          "source": "src/Top-Ordering-Tree.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Tree",
          "package": "Top",
          "partial": "Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Direction",
          "package": "Top",
          "source": "src/Top-Ordering-Tree.html#Direction",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Direction",
          "package": "Top",
          "partial": "Direction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Direction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Phased",
          "package": "Top",
          "source": "src/Top-Ordering-Tree.html#Phased",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Phased",
          "package": "Top",
          "partial": "Phased",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Phased"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Spreaded",
          "package": "Top",
          "source": "src/Top-Ordering-Tree.html#Spreaded",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Spreaded",
          "package": "Top",
          "partial": "Spreaded",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Spreaded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Tree",
          "package": "Top",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Tree",
          "package": "Top",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Trees",
          "package": "Top",
          "source": "src/Top-Ordering-Tree.html#Trees",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Trees",
          "package": "Top",
          "partial": "Trees",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#t:Trees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "(.\u003c\u003c.)",
          "package": "Top",
          "signature": "[a] -\u003e Tree a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#.%3E.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "(.\u003c\u003c.) .\u003c\u003c.",
          "normalized": "[a]-\u003eTree a-\u003eTree a",
          "package": "Top",
          "signature": "[a]-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-60--60-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "(.\u003c.)",
          "package": "Top",
          "signature": "[a] -\u003e Tree a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#.%3E.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "(.\u003c.) .\u003c.",
          "normalized": "[a]-\u003eTree a-\u003eTree a",
          "package": "Top",
          "signature": "[a]-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-60-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "(.\u003e\u003e.)",
          "package": "Top",
          "signature": "[a] -\u003e Tree a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#.%3E.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "(.\u003e\u003e.) .\u003e\u003e.",
          "normalized": "[a]-\u003eTree a-\u003eTree a",
          "package": "Top",
          "signature": "[a]-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-62--62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "(.\u003e.)",
          "package": "Top",
          "signature": "[a] -\u003e Tree a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#.%3E.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "(.\u003e.) .\u003e.",
          "normalized": "[a]-\u003eTree a-\u003eTree a",
          "package": "Top",
          "signature": "[a]-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:.-62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "AddList",
          "package": "Top",
          "signature": "AddList Direction [a] (Tree a)",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "AddList",
          "normalized": "AddList Direction[a](Tree a)",
          "package": "Top",
          "partial": "Add List",
          "signature": "AddList Direction[a](Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:AddList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Chunk",
          "package": "Top",
          "signature": "Chunk Int (Tree a)",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Chunk",
          "package": "Top",
          "partial": "Chunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Chunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Down",
          "package": "Top",
          "signature": "Down",
          "source": "src/Top-Ordering-Tree.html#Direction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Down",
          "package": "Top",
          "partial": "Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Node",
          "package": "Top",
          "signature": "Node (Trees a)",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Node",
          "package": "Top",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Phase",
          "package": "Top",
          "signature": "Phase Int [a]",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Phase",
          "normalized": "Phase Int[a]",
          "package": "Top",
          "partial": "Phase",
          "signature": "Phase Int[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Phase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Receive",
          "package": "Top",
          "signature": "Receive Int",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Receive",
          "package": "Top",
          "partial": "Receive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Receive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Spread",
          "package": "Top",
          "signature": "Spread Direction [a] (Tree a)",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Spread",
          "normalized": "Spread Direction[a](Tree a)",
          "package": "Top",
          "partial": "Spread",
          "signature": "Spread Direction[a](Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Spread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "StrictOrder",
          "package": "Top",
          "signature": "StrictOrder (Tree a) (Tree a)",
          "source": "src/Top-Ordering-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "StrictOrder",
          "package": "Top",
          "partial": "Strict Order",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:StrictOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "Up",
          "package": "Top",
          "signature": "Up",
          "source": "src/Top-Ordering-Tree.html#Direction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "Up",
          "package": "Top",
          "partial": "Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:Up"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "binTree",
          "package": "Top",
          "signature": "Tree a -\u003e Tree a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#binTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "binTree",
          "normalized": "Tree a-\u003eTree a-\u003eTree a",
          "package": "Top",
          "partial": "Tree",
          "signature": "Tree a-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:binTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "chunkTree",
          "package": "Top",
          "signature": "Tree a -\u003e [(Int, Tree a)]",
          "source": "src/Top-Ordering-Tree.html#chunkTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "chunkTree",
          "normalized": "Tree a-\u003e[(Int,Tree a)]",
          "package": "Top",
          "partial": "Tree",
          "signature": "Tree a-\u003e[(Int,Tree a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:chunkTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "emptyTree",
          "package": "Top",
          "signature": "Tree a",
          "source": "src/Top-Ordering-Tree.html#emptyTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "emptyTree",
          "package": "Top",
          "partial": "Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:emptyTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "flattenTree",
          "package": "Top",
          "signature": "TreeWalk -\u003e Tree a -\u003e [a]",
          "source": "src/Top-Ordering-Tree.html#flattenTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "flattenTree",
          "normalized": "TreeWalk-\u003eTree a-\u003e[a]",
          "package": "Top",
          "partial": "Tree",
          "signature": "TreeWalk-\u003eTree a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:flattenTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "listTree",
          "package": "Top",
          "signature": "[a] -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#listTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "listTree",
          "normalized": "[a]-\u003eTree a",
          "package": "Top",
          "partial": "Tree",
          "signature": "[a]-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:listTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "makeTreeHelper",
          "package": "Top",
          "signature": "(t -\u003e [a] -\u003e t1 -\u003e t1) -\u003e t -\u003e [a] -\u003e t1 -\u003e t1",
          "source": "src/Top-Ordering-Tree.html#makeTreeHelper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "makeTreeHelper",
          "normalized": "(a-\u003e[b]-\u003ea-\u003ea)-\u003ea-\u003e[b]-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Tree Helper",
          "signature": "(t-\u003e[a]-\u003et-\u003et)-\u003et-\u003e[a]-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:makeTreeHelper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "phaseTree",
          "package": "Top",
          "signature": "a -\u003e Tree a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#phaseTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "phaseTree",
          "normalized": "a-\u003eTree a-\u003eTree a",
          "package": "Top",
          "partial": "Tree",
          "signature": "a-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:phaseTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "spreadTree",
          "package": "Top",
          "signature": "(a -\u003e Maybe Int) -\u003e Tree a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#spreadTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "spreadTree",
          "normalized": "(a-\u003eMaybe Int)-\u003eTree a-\u003eTree a",
          "package": "Top",
          "partial": "Tree",
          "signature": "(a-\u003eMaybe Int)-\u003eTree a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:spreadTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.Tree",
          "name": "unitTree",
          "package": "Top",
          "signature": "a -\u003e Tree a",
          "source": "src/Top-Ordering-Tree.html#unitTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering Tree",
          "module": "Top.Ordering.Tree",
          "name": "unitTree",
          "normalized": "a-\u003eTree a",
          "package": "Top",
          "partial": "Tree",
          "signature": "a-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-Tree.html#v:unitTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "TreeWalk",
          "package": "Top",
          "source": "src/Top-Ordering-TreeWalk.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "TreeWalk",
          "package": "Top",
          "partial": "Tree Walk",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "List",
          "package": "Top",
          "source": "src/Top-Ordering-TreeWalk.html#List",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "List",
          "package": "Top",
          "partial": "List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#t:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "TreeWalk",
          "package": "Top",
          "source": "src/Top-Ordering-TreeWalk.html#TreeWalk",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "TreeWalk",
          "package": "Top",
          "partial": "Tree Walk",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#t:TreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "TreeWalk",
          "package": "Top",
          "signature": "TreeWalk (forall a.  List a -\u003e [(List a, List a)] -\u003e List a)",
          "source": "src/Top-Ordering-TreeWalk.html#TreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "TreeWalk",
          "normalized": "TreeWalk(a b List c-\u003e[(List c,List c)]-\u003eList c)",
          "package": "Top",
          "partial": "Tree Walk",
          "signature": "TreeWalk(forall a. List a-\u003e[(List a,List a)]-\u003eList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:TreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "bottomUpTreeWalk",
          "package": "Top",
          "signature": "TreeWalk",
          "source": "src/Top-Ordering-TreeWalk.html#bottomUpTreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "bottomUpTreeWalk",
          "package": "Top",
          "partial": "Up Tree Walk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:bottomUpTreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "concatList",
          "package": "Top",
          "signature": "[List a] -\u003e List a",
          "source": "src/Top-Ordering-TreeWalk.html#concatList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "concatList",
          "normalized": "[List a]-\u003eList a",
          "package": "Top",
          "partial": "List",
          "signature": "[List a]-\u003eList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:concatList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopFirstPostTreeWalk",
          "package": "Top",
          "signature": "TreeWalk",
          "source": "src/Top-Ordering-TreeWalk.html#inorderTopFirstPostTreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopFirstPostTreeWalk",
          "package": "Top",
          "partial": "Top First Post Tree Walk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopFirstPostTreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopFirstPreTreeWalk",
          "package": "Top",
          "signature": "TreeWalk",
          "source": "src/Top-Ordering-TreeWalk.html#inorderTopFirstPreTreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopFirstPreTreeWalk",
          "package": "Top",
          "partial": "Top First Pre Tree Walk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopFirstPreTreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopLastPostTreeWalk",
          "package": "Top",
          "signature": "TreeWalk",
          "source": "src/Top-Ordering-TreeWalk.html#inorderTopLastPostTreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopLastPostTreeWalk",
          "package": "Top",
          "partial": "Top Last Post Tree Walk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopLastPostTreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopLastPreTreeWalk",
          "package": "Top",
          "signature": "TreeWalk",
          "source": "src/Top-Ordering-TreeWalk.html#inorderTopLastPreTreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "inorderTopLastPreTreeWalk",
          "package": "Top",
          "partial": "Top Last Pre Tree Walk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:inorderTopLastPreTreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "reverseTreeWalk",
          "package": "Top",
          "signature": "TreeWalk -\u003e TreeWalk",
          "source": "src/Top-Ordering-TreeWalk.html#reverseTreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "reverseTreeWalk",
          "normalized": "TreeWalk-\u003eTreeWalk",
          "package": "Top",
          "partial": "Tree Walk",
          "signature": "TreeWalk-\u003eTreeWalk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:reverseTreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Ordering.TreeWalk",
          "name": "topDownTreeWalk",
          "package": "Top",
          "signature": "TreeWalk",
          "source": "src/Top-Ordering-TreeWalk.html#topDownTreeWalk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Ordering TreeWalk",
          "module": "Top.Ordering.TreeWalk",
          "name": "topDownTreeWalk",
          "package": "Top",
          "partial": "Down Tree Walk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Ordering-TreeWalk.html#v:topDownTreeWalk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "Greedy",
          "package": "Top",
          "source": "src/Top-Solver-Greedy.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "Greedy",
          "package": "Top",
          "partial": "Greedy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "Greedy",
          "package": "Top",
          "source": "src/Top-Solver-Greedy.html#Greedy",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "Greedy",
          "package": "Top",
          "partial": "Greedy",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:Greedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "GreedyS",
          "package": "Top",
          "source": "src/Top-Solver-Greedy.html#GreedyS",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "GreedyS",
          "package": "Top",
          "partial": "Greedy",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:GreedyS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "GreedySimple",
          "package": "Top",
          "source": "src/Top-Solver-Greedy.html#GreedySimple",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "GreedySimple",
          "package": "Top",
          "partial": "Greedy Simple",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:GreedySimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "GreedySimpleS",
          "package": "Top",
          "source": "src/Top-Solver-Greedy.html#GreedySimpleS",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "GreedySimpleS",
          "package": "Top",
          "partial": "Greedy Simple",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#t:GreedySimpleS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "greedyConstraintSolver",
          "package": "Top",
          "signature": "ConstraintSolver constraint info",
          "source": "src/Top-Solver-Greedy.html#greedyConstraintSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "greedyConstraintSolver",
          "package": "Top",
          "partial": "Constraint Solver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:greedyConstraintSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "greedySimpleConstraintSolver",
          "package": "Top",
          "signature": "ConstraintSolver constraint info",
          "source": "src/Top-Solver-Greedy.html#greedySimpleConstraintSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "greedySimpleConstraintSolver",
          "package": "Top",
          "partial": "Simple Constraint Solver",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:greedySimpleConstraintSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "solveGreedy",
          "package": "Top",
          "signature": "SolveOptions -\u003e [constraint] -\u003e Greedy info (SolveResult info)",
          "source": "src/Top-Solver-Greedy.html#solveGreedy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "solveGreedy",
          "normalized": "SolveOptions-\u003e[a]-\u003eGreedy b(SolveResult b)",
          "package": "Top",
          "partial": "Greedy",
          "signature": "SolveOptions-\u003e[constraint]-\u003eGreedy info(SolveResult info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:solveGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.Greedy",
          "name": "solveSimple",
          "package": "Top",
          "signature": "SolveOptions -\u003e [constraint] -\u003e GreedySimple info (SolveResult info)",
          "source": "src/Top-Solver-Greedy.html#solveSimple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver Greedy",
          "module": "Top.Solver.Greedy",
          "name": "solveSimple",
          "normalized": "SolveOptions-\u003e[a]-\u003eGreedySimple b(SolveResult b)",
          "package": "Top",
          "partial": "Simple",
          "signature": "SolveOptions-\u003e[constraint]-\u003eGreedySimple info(SolveResult info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-Greedy.html#v:solveSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.PartitionCombinator",
          "name": "PartitionCombinator",
          "package": "Top",
          "source": "src/Top-Solver-PartitionCombinator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Solver PartitionCombinator",
          "module": "Top.Solver.PartitionCombinator",
          "name": "PartitionCombinator",
          "package": "Top",
          "partial": "Partition Combinator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.PartitionCombinator",
          "name": "Chunk",
          "package": "Top",
          "source": "src/Top-Solver-PartitionCombinator.html#Chunk",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver PartitionCombinator",
          "module": "Top.Solver.PartitionCombinator",
          "name": "Chunk",
          "package": "Top",
          "partial": "Chunk",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#t:Chunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.PartitionCombinator",
          "name": "ChunkID",
          "package": "Top",
          "source": "src/Top-Solver-PartitionCombinator.html#ChunkID",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver PartitionCombinator",
          "module": "Top.Solver.PartitionCombinator",
          "name": "ChunkID",
          "package": "Top",
          "partial": "Chunk ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#t:ChunkID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.PartitionCombinator",
          "name": "Chunks",
          "package": "Top",
          "source": "src/Top-Solver-PartitionCombinator.html#Chunks",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver PartitionCombinator",
          "module": "Top.Solver.PartitionCombinator",
          "name": "Chunks",
          "package": "Top",
          "partial": "Chunks",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#t:Chunks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.PartitionCombinator",
          "name": "solveChunkConstraints",
          "package": "Top",
          "signature": "(Map Int (Scheme Predicates) -\u003e constraint -\u003e constraint) -\u003e ConstraintSolver constraint info -\u003e (Tree constraint -\u003e [constraint]) -\u003e Chunks constraint -\u003e ConstraintSolver constraint info",
          "source": "src/Top-Solver-PartitionCombinator.html#solveChunkConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver PartitionCombinator",
          "module": "Top.Solver.PartitionCombinator",
          "name": "solveChunkConstraints",
          "normalized": "(Map Int(Scheme Predicates)-\u003ea-\u003ea)-\u003eConstraintSolver a b-\u003e(Tree a-\u003e[a])-\u003eChunks a-\u003eConstraintSolver a b",
          "package": "Top",
          "partial": "Chunk Constraints",
          "signature": "(Map Int(Scheme Predicates)-\u003econstraint-\u003econstraint)-\u003eConstraintSolver constraint info-\u003e(Tree constraint-\u003e[constraint])-\u003eChunks constraint-\u003eConstraintSolver constraint info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-PartitionCombinator.html#v:solveChunkConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.SwitchCombinator",
          "name": "SwitchCombinator",
          "package": "Top",
          "source": "src/Top-Solver-SwitchCombinator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Solver SwitchCombinator",
          "module": "Top.Solver.SwitchCombinator",
          "name": "SwitchCombinator",
          "package": "Top",
          "partial": "Switch Combinator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-SwitchCombinator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first solver is used to solve the constraint set. If this fails (at least one \n error is returned), then the second solver takes over.     \n\u003c/p\u003e",
          "module": "Top.Solver.SwitchCombinator",
          "name": "(|\u003e\u003e|)",
          "package": "Top",
          "signature": "ConstraintSolver constraint info -\u003e ConstraintSolver constraint info -\u003e ConstraintSolver constraint info",
          "source": "src/Top-Solver-SwitchCombinator.html#%7C%3E%3E%7C",
          "type": "function"
        },
        "index": {
          "description": "The first solver is used to solve the constraint set If this fails at least one error is returned then the second solver takes over",
          "hierarchy": "Top Solver SwitchCombinator",
          "module": "Top.Solver.SwitchCombinator",
          "name": "(|\u003e\u003e|) |\u003e\u003e|",
          "normalized": "ConstraintSolver a b-\u003eConstraintSolver a b-\u003eConstraintSolver a b",
          "package": "Top",
          "signature": "ConstraintSolver constraint info-\u003eConstraintSolver constraint info-\u003eConstraintSolver constraint info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-SwitchCombinator.html#v:-124--62--62--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.TypeGraph",
          "name": "TypeGraph",
          "package": "Top",
          "source": "src/Top-Solver-TypeGraph.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Solver TypeGraph",
          "module": "Top.Solver.TypeGraph",
          "name": "TypeGraph",
          "package": "Top",
          "partial": "Type Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.TypeGraph",
          "name": "TG",
          "package": "Top",
          "source": "src/Top-Solver-TypeGraph.html#TG",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver TypeGraph",
          "module": "Top.Solver.TypeGraph",
          "name": "TG",
          "package": "Top",
          "partial": "TG",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#t:TG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.TypeGraph",
          "name": "TGS",
          "package": "Top",
          "source": "src/Top-Solver-TypeGraph.html#TGS",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver TypeGraph",
          "module": "Top.Solver.TypeGraph",
          "name": "TGS",
          "package": "Top",
          "partial": "TGS",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#t:TGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.TypeGraph",
          "name": "solveTypeGraph",
          "package": "Top",
          "signature": "TG info () -\u003e SolveOptions -\u003e [constraint] -\u003e TG info (SolveResult info)",
          "source": "src/Top-Solver-TypeGraph.html#solveTypeGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver TypeGraph",
          "module": "Top.Solver.TypeGraph",
          "name": "solveTypeGraph",
          "normalized": "TG a()-\u003eSolveOptions-\u003e[b]-\u003eTG a(SolveResult a)",
          "package": "Top",
          "partial": "Type Graph",
          "signature": "TG info()-\u003eSolveOptions-\u003e[constraint]-\u003eTG info(SolveResult info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#v:solveTypeGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.TypeGraph",
          "name": "typegraphConstraintSolver",
          "package": "Top",
          "signature": "PathHeuristics info -\u003e ConstraintSolver constraint info",
          "source": "src/Top-Solver-TypeGraph.html#typegraphConstraintSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver TypeGraph",
          "module": "Top.Solver.TypeGraph",
          "name": "typegraphConstraintSolver",
          "normalized": "PathHeuristics a-\u003eConstraintSolver b a",
          "package": "Top",
          "partial": "Constraint Solver",
          "signature": "PathHeuristics info-\u003eConstraintSolver constraint info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#v:typegraphConstraintSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver.TypeGraph",
          "name": "typegraphConstraintSolverDefault",
          "package": "Top",
          "signature": "ConstraintSolver constraint info",
          "source": "src/Top-Solver-TypeGraph.html#typegraphConstraintSolverDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver TypeGraph",
          "module": "Top.Solver.TypeGraph",
          "name": "typegraphConstraintSolverDefault",
          "package": "Top",
          "partial": "Constraint Solver Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver-TypeGraph.html#v:typegraphConstraintSolverDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "Solver",
          "package": "Top",
          "source": "src/Top-Solver.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "Solver",
          "package": "Top",
          "partial": "Solver",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "BasicMonad",
          "package": "Top",
          "source": "src/Top-Solver.html#BasicMonad",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "BasicMonad",
          "package": "Top",
          "partial": "Basic Monad",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:BasicMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "ConstraintSolver",
          "package": "Top",
          "source": "src/Top-Solver.html#ConstraintSolver",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "ConstraintSolver",
          "package": "Top",
          "partial": "Constraint Solver",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:ConstraintSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "LogEntries",
          "package": "Top",
          "source": "src/Top-Solver.html#LogEntries",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "LogEntries",
          "package": "Top",
          "partial": "Log Entries",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:LogEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "LogEntry",
          "package": "Top",
          "source": "src/Top-Solver.html#LogEntry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "LogEntry",
          "package": "Top",
          "partial": "Log Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:LogEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "SolveOptions",
          "package": "Top",
          "source": "src/Top-Solver.html#SolveOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "SolveOptions",
          "package": "Top",
          "partial": "Solve Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:SolveOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "SolveResult",
          "package": "Top",
          "source": "src/Top-Solver.html#SolveResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "SolveResult",
          "package": "Top",
          "partial": "Solve Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#t:SolveResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "ConstraintSolver",
          "package": "Top",
          "signature": "ConstraintSolver (SolveOptions -\u003e [constraint] -\u003e (SolveResult info, LogEntries))",
          "source": "src/Top-Solver.html#ConstraintSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "ConstraintSolver",
          "normalized": "ConstraintSolver(SolveOptions-\u003e[a]-\u003e(SolveResult b,LogEntries))",
          "package": "Top",
          "partial": "Constraint Solver",
          "signature": "ConstraintSolver(SolveOptions-\u003e[constraint]-\u003e(SolveResult info,LogEntries))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:ConstraintSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "LogEntries",
          "package": "Top",
          "signature": "LogEntries ([LogEntry] -\u003e [LogEntry])",
          "source": "src/Top-Solver.html#LogEntries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "LogEntries",
          "normalized": "LogEntries([LogEntry]-\u003e[LogEntry])",
          "package": "Top",
          "partial": "Log Entries",
          "signature": "LogEntries([LogEntry]-\u003e[LogEntry])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:LogEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "LogEntry",
          "package": "Top",
          "signature": "LogEntry",
          "source": "src/Top-Solver.html#LogEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "LogEntry",
          "package": "Top",
          "partial": "Log Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:LogEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "SolveOptions_",
          "package": "Top",
          "signature": "SolveOptions_",
          "source": "src/Top-Solver.html#SolveOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "SolveOptions_",
          "package": "Top",
          "partial": "Solve Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:SolveOptions_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "SolveResult",
          "package": "Top",
          "signature": "SolveResult",
          "source": "src/Top-Solver.html#SolveResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "SolveResult",
          "package": "Top",
          "partial": "Solve Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:SolveResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "classEnvironment",
          "package": "Top",
          "signature": "ClassEnvironment",
          "source": "src/Top-Solver.html#SolveOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "classEnvironment",
          "package": "Top",
          "partial": "Environment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:classEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "combineResults",
          "package": "Top",
          "signature": "SolveResult info -\u003e SolveResult info -\u003e SolveResult info",
          "source": "src/Top-Solver.html#combineResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "combineResults",
          "normalized": "SolveResult a-\u003eSolveResult a-\u003eSolveResult a",
          "package": "Top",
          "partial": "Results",
          "signature": "SolveResult info-\u003eSolveResult info-\u003eSolveResult info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:combineResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "emptyResult",
          "package": "Top",
          "signature": "Int -\u003e SolveResult info",
          "source": "src/Top-Solver.html#emptyResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "emptyResult",
          "normalized": "Int-\u003eSolveResult a",
          "package": "Top",
          "partial": "Result",
          "signature": "Int-\u003eSolveResult info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:emptyResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "errorsFromResult",
          "package": "Top",
          "signature": "[(info, ErrorLabel)]",
          "source": "src/Top-Solver.html#SolveResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "errorsFromResult",
          "normalized": "[(a,ErrorLabel)]",
          "package": "Top",
          "partial": "From Result",
          "signature": "[(info,ErrorLabel)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:errorsFromResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "evalBasicMonad",
          "package": "Top",
          "signature": "BasicMonad f a -\u003e (a, LogEntries)",
          "source": "src/Top-Solver.html#evalBasicMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "evalBasicMonad",
          "normalized": "BasicMonad a b-\u003e(b,LogEntries)",
          "package": "Top",
          "partial": "Basic Monad",
          "signature": "BasicMonad f a-\u003e(a,LogEntries)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:evalBasicMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "initialize",
          "package": "Top",
          "signature": "a -\u003e SolveOptions -\u003e m ()",
          "source": "src/Top-Solver.html#initialize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "initialize",
          "normalized": "a-\u003eSolveOptions-\u003eb()",
          "package": "Top",
          "signature": "a-\u003eSolveOptions-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:initialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "logMsg",
          "package": "Top",
          "signature": "String -\u003e m ()",
          "source": "src/Top-Solver.html#logMsg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "logMsg",
          "normalized": "String-\u003ea()",
          "package": "Top",
          "partial": "Msg",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:logMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "logMsgPrio",
          "package": "Top",
          "signature": "Int -\u003e String -\u003e m ()",
          "source": "src/Top-Solver.html#logMsgPrio",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "logMsgPrio",
          "normalized": "Int-\u003eString-\u003ea()",
          "package": "Top",
          "partial": "Msg Prio",
          "signature": "Int-\u003eString-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:logMsgPrio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint the current state and add this as a debug message. \n\u003c/p\u003e",
          "module": "Top.Solver",
          "name": "logState",
          "package": "Top",
          "signature": "m ()",
          "source": "src/Top-Solver.html#logState",
          "type": "function"
        },
        "index": {
          "description": "Print the current state and add this as debug message",
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "logState",
          "normalized": "a()",
          "package": "Top",
          "partial": "State",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:logState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "makeConstraintSolver",
          "package": "Top",
          "signature": "(SolveOptions -\u003e [constraint] -\u003e BasicMonad f (SolveResult info)) -\u003e ConstraintSolver constraint info",
          "source": "src/Top-Solver.html#makeConstraintSolver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "makeConstraintSolver",
          "normalized": "(SolveOptions-\u003e[a]-\u003eBasicMonad b(SolveResult c))-\u003eConstraintSolver a c",
          "package": "Top",
          "partial": "Constraint Solver",
          "signature": "(SolveOptions-\u003e[constraint]-\u003eBasicMonad f(SolveResult info))-\u003eConstraintSolver constraint info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:makeConstraintSolver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "msg",
          "package": "Top",
          "signature": "String",
          "source": "src/Top-Solver.html#LogEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "msg",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:msg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "noLogEntries",
          "package": "Top",
          "signature": "LogEntries",
          "source": "src/Top-Solver.html#noLogEntries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "noLogEntries",
          "package": "Top",
          "partial": "Log Entries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:noLogEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "onlySolveConstraints",
          "package": "Top",
          "signature": "[constraint] -\u003e m ()",
          "source": "src/Top-Solver.html#onlySolveConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "onlySolveConstraints",
          "normalized": "[a]-\u003eb()",
          "package": "Top",
          "partial": "Solve Constraints",
          "signature": "[constraint]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:onlySolveConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "priority",
          "package": "Top",
          "signature": "Int",
          "source": "src/Top-Solver.html#LogEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "priority",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:priority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "qualifiersFromResult",
          "package": "Top",
          "signature": "Predicates",
          "source": "src/Top-Solver.html#SolveResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "qualifiersFromResult",
          "package": "Top",
          "partial": "From Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:qualifiersFromResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "setCheckConditions",
          "package": "Top",
          "signature": "Bool",
          "source": "src/Top-Solver.html#SolveOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "setCheckConditions",
          "package": "Top",
          "partial": "Check Conditions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:setCheckConditions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "setStopAfterFirstError",
          "package": "Top",
          "signature": "Bool",
          "source": "src/Top-Solver.html#SolveOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "setStopAfterFirstError",
          "package": "Top",
          "partial": "Stop After First Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:setStopAfterFirstError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "singleEntry",
          "package": "Top",
          "signature": "Int -\u003e String -\u003e LogEntries",
          "source": "src/Top-Solver.html#singleEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "singleEntry",
          "normalized": "Int-\u003eString-\u003eLogEntries",
          "package": "Top",
          "partial": "Entry",
          "signature": "Int-\u003eString-\u003eLogEntries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:singleEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "solve",
          "package": "Top",
          "signature": "SolveOptions -\u003e [constraint] -\u003e ConstraintSolver constraint info -\u003e (SolveResult info, LogEntries)",
          "source": "src/Top-Solver.html#solve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "solve",
          "normalized": "SolveOptions-\u003e[a]-\u003eConstraintSolver a b-\u003e(SolveResult b,LogEntries)",
          "package": "Top",
          "signature": "SolveOptions-\u003e[constraint]-\u003eConstraintSolver constraint info-\u003e(SolveResult info,LogEntries)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "solveConstraints",
          "package": "Top",
          "signature": "SolveOptions -\u003e [constraint] -\u003e m (SolveResult info)",
          "source": "src/Top-Solver.html#solveConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "solveConstraints",
          "normalized": "SolveOptions-\u003e[a]-\u003eb(SolveResult c)",
          "package": "Top",
          "partial": "Constraints",
          "signature": "SolveOptions-\u003e[constraint]-\u003em(SolveResult info)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solveConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "solveOptions",
          "package": "Top",
          "signature": "SolveOptions",
          "source": "src/Top-Solver.html#solveOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "solveOptions",
          "package": "Top",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solveOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "solveResult",
          "package": "Top",
          "signature": "m (SolveResult info)",
          "source": "src/Top-Solver.html#solveResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "solveResult",
          "package": "Top",
          "partial": "Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:solveResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "substitutionFromResult",
          "package": "Top",
          "signature": "FixpointSubstitution",
          "source": "src/Top-Solver.html#SolveResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "substitutionFromResult",
          "package": "Top",
          "partial": "From Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:substitutionFromResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "typeSynonyms",
          "package": "Top",
          "signature": "OrderedTypeSynonyms",
          "source": "src/Top-Solver.html#SolveOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "typeSynonyms",
          "package": "Top",
          "partial": "Synonyms",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:typeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "typeschemesFromResult",
          "package": "Top",
          "signature": "Map Int (Scheme Predicates)",
          "source": "src/Top-Solver.html#SolveResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "typeschemesFromResult",
          "package": "Top",
          "partial": "From Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:typeschemesFromResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "uniqueCounter",
          "package": "Top",
          "signature": "Int",
          "source": "src/Top-Solver.html#SolveOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "uniqueCounter",
          "package": "Top",
          "partial": "Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:uniqueCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Solver",
          "name": "uniqueFromResult",
          "package": "Top",
          "signature": "Int",
          "source": "src/Top-Solver.html#SolveResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Solver",
          "module": "Top.Solver",
          "name": "uniqueFromResult",
          "package": "Top",
          "partial": "From Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Solver.html#v:uniqueFromResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes and the standard reduction instances. A part of the code\n was taken from the paper \u003ca\u003eTyping Haskell in Haskell\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Classes",
          "name": "Classes",
          "package": "Top",
          "source": "src/Top-Types-Classes.html",
          "type": "module"
        },
        "index": {
          "description": "Type classes and the standard reduction instances part of the code was taken from the paper Typing Haskell in Haskell",
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "Classes",
          "package": "Top",
          "partial": "Classes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "Class",
          "package": "Top",
          "source": "src/Top-Types-Classes.html#Class",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "Class",
          "package": "Top",
          "partial": "Class",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Class"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "ClassEnvironment",
          "package": "Top",
          "source": "src/Top-Types-Classes.html#ClassEnvironment",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "ClassEnvironment",
          "package": "Top",
          "partial": "Class Environment",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:ClassEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "Instance",
          "package": "Top",
          "source": "src/Top-Types-Classes.html#Instance",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "Instance",
          "package": "Top",
          "partial": "Instance",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Instance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "Instances",
          "package": "Top",
          "source": "src/Top-Types-Classes.html#Instances",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "Instances",
          "package": "Top",
          "partial": "Instances",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Instances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "Predicate",
          "package": "Top",
          "source": "src/Top-Types-Classes.html#Predicate",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "Predicate",
          "package": "Top",
          "partial": "Predicate",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Predicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "Predicates",
          "package": "Top",
          "source": "src/Top-Types-Classes.html#Predicates",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "Predicates",
          "package": "Top",
          "partial": "Predicates",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:Predicates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "ReductionError",
          "package": "Top",
          "source": "src/Top-Types-Classes.html#ReductionError",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "ReductionError",
          "package": "Top",
          "partial": "Reduction Error",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#t:ReductionError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "Predicate",
          "package": "Top",
          "signature": "Predicate String Tp",
          "source": "src/Top-Types-Classes.html#Predicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "Predicate",
          "package": "Top",
          "partial": "Predicate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:Predicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "ReductionError",
          "package": "Top",
          "signature": "ReductionError a",
          "source": "src/Top-Types-Classes.html#ReductionError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "ReductionError",
          "package": "Top",
          "partial": "Reduction Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:ReductionError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "associatedContextReduction",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e [(Predicate, a)] -\u003e ([(Predicate, a)], [ReductionError (Predicate, a)])",
          "source": "src/Top-Types-Classes.html#associatedContextReduction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "associatedContextReduction",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003e[(Predicate,a)]-\u003e([(Predicate,a)],[ReductionError(Predicate,a)])",
          "package": "Top",
          "partial": "Context Reduction",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003e[(Predicate,a)]-\u003e([(Predicate,a)],[ReductionError(Predicate,a)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:associatedContextReduction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "byInstance",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicate -\u003e Maybe Predicates",
          "source": "src/Top-Types-Classes.html#byInstance",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "byInstance",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates",
          "package": "Top",
          "partial": "Instance",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:byInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "bySuperclass",
          "package": "Top",
          "signature": "ClassEnvironment -\u003e Predicate -\u003e Predicates",
          "source": "src/Top-Types-Classes.html#bySuperclass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "bySuperclass",
          "normalized": "ClassEnvironment-\u003ePredicate-\u003ePredicates",
          "package": "Top",
          "partial": "Superclass",
          "signature": "ClassEnvironment-\u003ePredicate-\u003ePredicates",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:bySuperclass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "contextReduction",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e (Predicates, [ReductionError Predicate])",
          "source": "src/Top-Types-Classes.html#contextReduction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "contextReduction",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003e(Predicates,[ReductionError Predicate])",
          "package": "Top",
          "partial": "Reduction",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003e(Predicates,[ReductionError Predicate])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:contextReduction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty class environment\n\u003c/p\u003e",
          "module": "Top.Types.Classes",
          "name": "emptyClassEnvironment",
          "package": "Top",
          "signature": "ClassEnvironment",
          "source": "src/Top-Types-Classes.html#emptyClassEnvironment",
          "type": "function"
        },
        "index": {
          "description": "The empty class environment",
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "emptyClassEnvironment",
          "package": "Top",
          "partial": "Class Environment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:emptyClassEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "entail",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e Predicate -\u003e Bool",
          "source": "src/Top-Types-Classes.html#entail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "entail",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool",
          "package": "Top",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:entail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "entailList",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e Predicates -\u003e Bool",
          "source": "src/Top-Types-Classes.html#entailList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "entailList",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicates-\u003eBool",
          "package": "Top",
          "partial": "List",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003ePredicates-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:entailList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "inClassEnvironment",
          "package": "Top",
          "signature": "String -\u003e ClassEnvironment -\u003e Bool",
          "source": "src/Top-Types-Classes.html#inClassEnvironment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "inClassEnvironment",
          "normalized": "String-\u003eClassEnvironment-\u003eBool",
          "package": "Top",
          "partial": "Class Environment",
          "signature": "String-\u003eClassEnvironment-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:inClassEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "inHeadNormalForm",
          "package": "Top",
          "signature": "Predicate -\u003e Bool",
          "source": "src/Top-Types-Classes.html#inHeadNormalForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "inHeadNormalForm",
          "normalized": "Predicate-\u003eBool",
          "package": "Top",
          "partial": "Head Normal Form",
          "signature": "Predicate-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:inHeadNormalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "insertInstance",
          "package": "Top",
          "signature": "String -\u003e Instance -\u003e ClassEnvironment -\u003e ClassEnvironment",
          "source": "src/Top-Types-Classes.html#insertInstance",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "insertInstance",
          "normalized": "String-\u003eInstance-\u003eClassEnvironment-\u003eClassEnvironment",
          "package": "Top",
          "partial": "Instance",
          "signature": "String-\u003eInstance-\u003eClassEnvironment-\u003eClassEnvironment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:insertInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "instances",
          "package": "Top",
          "signature": "String -\u003e ClassEnvironment -\u003e Instances",
          "source": "src/Top-Types-Classes.html#instances",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "instances",
          "normalized": "String-\u003eClassEnvironment-\u003eInstances",
          "package": "Top",
          "signature": "String-\u003eClassEnvironment-\u003eInstances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:instances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "listToHeadNormalForm",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicates -\u003e Maybe Predicates",
          "source": "src/Top-Types-Classes.html#listToHeadNormalForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "listToHeadNormalForm",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003eMaybe Predicates",
          "package": "Top",
          "partial": "To Head Normal Form",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicates-\u003eMaybe Predicates",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:listToHeadNormalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "matchPredicates",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Predicate -\u003e Predicate -\u003e Maybe MapSubstitution",
          "source": "src/Top-Types-Classes.html#matchPredicates",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "matchPredicates",
          "normalized": "OrderedTypeSynonyms-\u003ePredicate-\u003ePredicate-\u003eMaybe MapSubstitution",
          "package": "Top",
          "partial": "Predicates",
          "signature": "OrderedTypeSynonyms-\u003ePredicate-\u003ePredicate-\u003eMaybe MapSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:matchPredicates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "scEntail",
          "package": "Top",
          "signature": "ClassEnvironment -\u003e Predicates -\u003e Predicate -\u003e Bool",
          "source": "src/Top-Types-Classes.html#scEntail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "scEntail",
          "normalized": "ClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool",
          "package": "Top",
          "partial": "Entail",
          "signature": "ClassEnvironment-\u003ePredicates-\u003ePredicate-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:scEntail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "standardClasses",
          "package": "Top",
          "signature": "ClassEnvironment",
          "source": "src/Top-Types-Classes.html#standardClasses",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "standardClasses",
          "package": "Top",
          "partial": "Classes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:standardClasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "superclassPaths",
          "package": "Top",
          "signature": "String -\u003e String -\u003e ClassEnvironment -\u003e [[String]]",
          "source": "src/Top-Types-Classes.html#superclassPaths",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "superclassPaths",
          "normalized": "String-\u003eString-\u003eClassEnvironment-\u003e[[String]]",
          "package": "Top",
          "partial": "Paths",
          "signature": "String-\u003eString-\u003eClassEnvironment-\u003e[[String]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:superclassPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor example, Eq is a superclass of Ord\n\u003c/p\u003e",
          "module": "Top.Types.Classes",
          "name": "superclasses",
          "package": "Top",
          "signature": "String -\u003e ClassEnvironment -\u003e [String]",
          "source": "src/Top-Types-Classes.html#superclasses",
          "type": "function"
        },
        "index": {
          "description": "For example Eq is superclass of Ord",
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "superclasses",
          "normalized": "String-\u003eClassEnvironment-\u003e[String]",
          "package": "Top",
          "signature": "String-\u003eClassEnvironment-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:superclasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Classes",
          "name": "toHeadNormalForm",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e Predicate -\u003e Maybe Predicates",
          "source": "src/Top-Types-Classes.html#toHeadNormalForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Classes",
          "module": "Top.Types.Classes",
          "name": "toHeadNormalForm",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates",
          "package": "Top",
          "partial": "Head Normal Form",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003ePredicate-\u003eMaybe Predicates",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Classes.html#v:toHeadNormalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eKinds can be represented by a type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Kinds",
          "name": "Kinds",
          "package": "Top",
          "source": "src/Top-Types-Kinds.html",
          "type": "module"
        },
        "index": {
          "description": "Kinds can be represented by type",
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "Kinds",
          "package": "Top",
          "partial": "Kinds",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Kinds",
          "name": "Kind",
          "package": "Top",
          "source": "src/Top-Types-Kinds.html#Kind",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "Kind",
          "package": "Top",
          "partial": "Kind",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#t:Kind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Kinds",
          "name": "KindScheme",
          "package": "Top",
          "source": "src/Top-Types-Kinds.html#KindScheme",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "KindScheme",
          "package": "Top",
          "partial": "Kind Scheme",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#t:KindScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Kinds",
          "name": "Kinds",
          "package": "Top",
          "source": "src/Top-Types-Kinds.html#Kinds",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "Kinds",
          "package": "Top",
          "partial": "Kinds",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#t:Kinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn traditional kind inference systems, a kind cannot contain variables.\n At some point in the inference process the kind variables are defaulted\n to star.\n\u003c/p\u003e",
          "module": "Top.Types.Kinds",
          "name": "defaultToStar",
          "package": "Top",
          "signature": "Kind -\u003e Kind",
          "source": "src/Top-Types-Kinds.html#defaultToStar",
          "type": "function"
        },
        "index": {
          "description": "In traditional kind inference systems kind cannot contain variables At some point in the inference process the kind variables are defaulted to star",
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "defaultToStar",
          "normalized": "Kind-\u003eKind",
          "package": "Top",
          "partial": "To Star",
          "signature": "Kind-\u003eKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:defaultToStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function to show kinds.\n\u003c/p\u003e",
          "module": "Top.Types.Kinds",
          "name": "showKind",
          "package": "Top",
          "signature": "Kind -\u003e String",
          "source": "src/Top-Types-Kinds.html#showKind",
          "type": "function"
        },
        "index": {
          "description": "function to show kinds",
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "showKind",
          "normalized": "Kind-\u003eString",
          "package": "Top",
          "partial": "Kind",
          "signature": "Kind-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:showKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Kinds",
          "name": "showKindScheme",
          "package": "Top",
          "signature": "KindScheme -\u003e String",
          "source": "src/Top-Types-Kinds.html#showKindScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "showKindScheme",
          "normalized": "KindScheme-\u003eString",
          "package": "Top",
          "partial": "Kind Scheme",
          "signature": "KindScheme-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:showKindScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStar is the kind of all values.\n\u003c/p\u003e",
          "module": "Top.Types.Kinds",
          "name": "star",
          "package": "Top",
          "signature": "Kind",
          "source": "src/Top-Types-Kinds.html#star",
          "type": "function"
        },
        "index": {
          "description": "Star is the kind of all values",
          "hierarchy": "Top Types Kinds",
          "module": "Top.Types.Kinds",
          "name": "star",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Kinds.html#v:star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a data type to represent (plain) types, some basic \n functionality for types, and an instance for Show.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Primitive",
          "name": "Primitive",
          "package": "Top",
          "source": "src/Top-Types-Primitive.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains data type to represent plain types some basic functionality for types and an instance for Show",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "Primitive",
          "package": "Top",
          "partial": "Primitive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "HasTypes",
          "package": "Top",
          "source": "src/Top-Types-Primitive.html#HasTypes",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "HasTypes",
          "package": "Top",
          "partial": "Has Types",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#t:HasTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data type to represent monotypes. Note that \u003ccode\u003eType\u003c/code\u003e is already in use\n in the Unified Haskell Architecture (UHA) which is used in the Helium compiler\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "Tp",
          "package": "Top",
          "source": "src/Top-Types-Primitive.html#Tp",
          "type": "data"
        },
        "index": {
          "description": "data type to represent monotypes Note that Type is already in use in the Unified Haskell Architecture UHA which is used in the Helium compiler",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "Tp",
          "package": "Top",
          "partial": "Tp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#t:Tp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "Tps",
          "package": "Top",
          "source": "src/Top-Types-Primitive.html#Tps",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "Tps",
          "package": "Top",
          "partial": "Tps",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#t:Tps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a function type from one type to another. This operator is\n left associative.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "(.-\u003e.)",
          "package": "Top",
          "signature": "Tp -\u003e Tp -\u003e Tp",
          "source": "src/Top-Types-Primitive.html#.-%3E.",
          "type": "function"
        },
        "index": {
          "description": "Constructs function type from one type to another This operator is left associative",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "(.-\u003e.) .-\u003e.",
          "normalized": "Tp-\u003eTp-\u003eTp",
          "package": "Top",
          "signature": "Tp-\u003eTp-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:.-45--62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe application of two Top.Types. Not all types that can be\n constructed are well-formed.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "TApp",
          "package": "Top",
          "signature": "TApp Tp Tp",
          "source": "src/Top-Types-Primitive.html#Tp",
          "type": "function"
        },
        "index": {
          "description": "The application of two Top.Types Not all types that can be constructed are well-formed",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "TApp",
          "package": "Top",
          "partial": "TApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:TApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type constant is represented by a string.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "TCon",
          "package": "Top",
          "signature": "TCon String",
          "source": "src/Top-Types-Primitive.html#Tp",
          "type": "function"
        },
        "index": {
          "description": "type constant is represented by string",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "TCon",
          "package": "Top",
          "partial": "TCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:TCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type variables are numbered.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "TVar",
          "package": "Top",
          "signature": "TVar Int",
          "source": "src/Top-Types-Primitive.html#Tp",
          "type": "function"
        },
        "index": {
          "description": "The type variables are numbered",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "TVar",
          "package": "Top",
          "partial": "TVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:TVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the arity of a type, that is, the number of expected arguments.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "arityOfTp",
          "package": "Top",
          "signature": "Tp -\u003e Int",
          "source": "src/Top-Types-Primitive.html#arityOfTp",
          "type": "function"
        },
        "index": {
          "description": "Returns the arity of type that is the number of expected arguments",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "arityOfTp",
          "normalized": "Tp-\u003eInt",
          "package": "Top",
          "partial": "Of Tp",
          "signature": "Tp-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:arityOfTp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "boolType",
          "package": "Top",
          "signature": "Tp",
          "source": "src/Top-Types-Primitive.html#intType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "boolType",
          "package": "Top",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:boolType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "changeTypes",
          "package": "Top",
          "signature": "(Tp -\u003e Tp) -\u003e a -\u003e a",
          "source": "src/Top-Types-Primitive.html#changeTypes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "changeTypes",
          "normalized": "(Tp-\u003eTp)-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Types",
          "signature": "(Tp-\u003eTp)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:changeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "charType",
          "package": "Top",
          "signature": "Tp",
          "source": "src/Top-Types-Primitive.html#intType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "charType",
          "package": "Top",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:charType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the list of type constants of a type. (no duplicates)\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "constantsInType",
          "package": "Top",
          "signature": "Tp -\u003e [String]",
          "source": "src/Top-Types-Primitive.html#constantsInType",
          "type": "function"
        },
        "index": {
          "description": "Returns the list of type constants of type no duplicates",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "constantsInType",
          "normalized": "Tp-\u003e[String]",
          "package": "Top",
          "partial": "In Type",
          "signature": "Tp-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:constantsInType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "floatType",
          "package": "Top",
          "signature": "Tp",
          "source": "src/Top-Types-Primitive.html#intType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "floatType",
          "package": "Top",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:floatType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll the type variables in a type are frozen by turning them into a type\n constant. The integer numeral is prefixed with an underscore ('_').\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "freezeVariablesInType",
          "package": "Top",
          "signature": "Tp -\u003e Tp",
          "source": "src/Top-Types-Primitive.html#freezeVariablesInType",
          "type": "function"
        },
        "index": {
          "description": "All the type variables in type are frozen by turning them into type constant The integer numeral is prefixed with an underscore",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "freezeVariablesInType",
          "normalized": "Tp-\u003eTp",
          "package": "Top",
          "partial": "Variables In Type",
          "signature": "Tp-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:freezeVariablesInType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the right spine of a function type. For instance,\n if type \u003ccode\u003et\u003c/code\u003e is \u003ccode\u003eInt -\u003e (Bool -\u003e String)\u003c/code\u003e, then \u003ccode\u003efunctionSpine t\u003c/code\u003e\n is \u003ccode\u003e([Int,Bool],String)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "functionSpine",
          "package": "Top",
          "signature": "Tp -\u003e (Tps, Tp)",
          "source": "src/Top-Types-Primitive.html#functionSpine",
          "type": "function"
        },
        "index": {
          "description": "Returns the right spine of function type For instance if type is Int Bool String then functionSpine is Int Bool String",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "functionSpine",
          "normalized": "Tp-\u003e(Tps,Tp)",
          "package": "Top",
          "partial": "Spine",
          "signature": "Tp-\u003e(Tps,Tp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:functionSpine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the right spine of a function type of a maximal length.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "functionSpineOfLength",
          "package": "Top",
          "signature": "Int -\u003e Tp -\u003e (Tps, Tp)",
          "source": "src/Top-Types-Primitive.html#functionSpineOfLength",
          "type": "function"
        },
        "index": {
          "description": "Returns the right spine of function type of maximal length",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "functionSpineOfLength",
          "normalized": "Int-\u003eTp-\u003e(Tps,Tp)",
          "package": "Top",
          "partial": "Spine Of Length",
          "signature": "Int-\u003eTp-\u003e(Tps,Tp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:functionSpineOfLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "getTypes",
          "package": "Top",
          "signature": "a -\u003e Tps",
          "source": "src/Top-Types-Primitive.html#getTypes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "getTypes",
          "normalized": "a-\u003eTps",
          "package": "Top",
          "partial": "Types",
          "signature": "a-\u003eTps",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:getTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "intType",
          "package": "Top",
          "signature": "Tp",
          "source": "src/Top-Types-Primitive.html#intType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "intType",
          "package": "Top",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:intType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor instance, \u003ccode\u003e(ioType boolType)\u003c/code\u003e represents \u003ccode\u003e(IO Bool)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "ioType",
          "package": "Top",
          "signature": "Tp -\u003e Tp",
          "source": "src/Top-Types-Primitive.html#ioType",
          "type": "function"
        },
        "index": {
          "description": "For instance ioType boolType represents IO Bool",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "ioType",
          "normalized": "Tp-\u003eTp",
          "package": "Top",
          "partial": "Type",
          "signature": "Tp-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:ioType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "isFunctionType",
          "package": "Top",
          "signature": "Tp -\u003e Bool",
          "source": "src/Top-Types-Primitive.html#isFunctionType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "isFunctionType",
          "normalized": "Tp-\u003eBool",
          "package": "Top",
          "partial": "Function Type",
          "signature": "Tp-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isFunctionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "isIOType",
          "package": "Top",
          "signature": "Tp -\u003e Bool",
          "source": "src/Top-Types-Primitive.html#isIOType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "isIOType",
          "normalized": "Tp-\u003eBool",
          "package": "Top",
          "partial": "IOType",
          "signature": "Tp-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isIOType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "isTApp",
          "package": "Top",
          "signature": "Tp -\u003e Bool",
          "source": "src/Top-Types-Primitive.html#isTApp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "isTApp",
          "normalized": "Tp-\u003eBool",
          "package": "Top",
          "partial": "TApp",
          "signature": "Tp-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "isTCon",
          "package": "Top",
          "signature": "Tp -\u003e Bool",
          "source": "src/Top-Types-Primitive.html#isTCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "isTCon",
          "normalized": "Tp-\u003eBool",
          "package": "Top",
          "partial": "TCon",
          "signature": "Tp-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "isTVar",
          "package": "Top",
          "signature": "Tp -\u003e Bool",
          "source": "src/Top-Types-Primitive.html#isTVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "isTVar",
          "normalized": "Tp-\u003eBool",
          "package": "Top",
          "partial": "TVar",
          "signature": "Tp-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "isTupleConstructor",
          "package": "Top",
          "signature": "String -\u003e Bool",
          "source": "src/Top-Types-Primitive.html#isTupleConstructor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "isTupleConstructor",
          "normalized": "String-\u003eBool",
          "package": "Top",
          "partial": "Tuple Constructor",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:isTupleConstructor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the left spine of a type. For instance, if type \u003ccode\u003et\u003c/code\u003e\n is \u003ccode\u003eEither Bool [Int]\u003c/code\u003e, then \u003ccode\u003eleftSpine t\u003c/code\u003e is \u003ccode\u003e(Either,[Bool,[Int]])\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "leftSpine",
          "package": "Top",
          "signature": "Tp -\u003e (Tp, Tps)",
          "source": "src/Top-Types-Primitive.html#leftSpine",
          "type": "function"
        },
        "index": {
          "description": "Returns the left spine of type For instance if type is Either Bool Int then leftSpine is Either Bool Int",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "leftSpine",
          "normalized": "Tp-\u003e(Tp,Tps)",
          "package": "Top",
          "partial": "Spine",
          "signature": "Tp-\u003e(Tp,Tps)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:leftSpine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor instance, \u003ccode\u003e(listType intType)\u003c/code\u003e represents \u003ccode\u003e[Int]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "listType",
          "package": "Top",
          "signature": "Tp -\u003e Tp",
          "source": "src/Top-Types-Primitive.html#listType",
          "type": "function"
        },
        "index": {
          "description": "For instance listType intType represents Int",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "listType",
          "normalized": "Tp-\u003eTp",
          "package": "Top",
          "partial": "Type",
          "signature": "Tp-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:listType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe priority of a type, primarily used for the insertion of parentheses \n in pretty printing.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "priorityOfType",
          "package": "Top",
          "signature": "Tp -\u003e Int",
          "source": "src/Top-Types-Primitive.html#priorityOfType",
          "type": "function"
        },
        "index": {
          "description": "The priority of type primarily used for the insertion of parentheses in pretty printing",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "priorityOfType",
          "normalized": "Tp-\u003eInt",
          "package": "Top",
          "partial": "Of Type",
          "signature": "Tp-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:priorityOfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "stringType",
          "package": "Top",
          "signature": "Tp",
          "source": "src/Top-Types-Primitive.html#intType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "stringType",
          "package": "Top",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:stringType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Primitive",
          "name": "tpParser",
          "package": "Top",
          "signature": "String -\u003e [(Tp, String)]",
          "source": "src/Top-Types-Primitive.html#tpParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "tpParser",
          "normalized": "String-\u003e[(Tp,String)]",
          "package": "Top",
          "partial": "Parser",
          "signature": "String-\u003e[(Tp,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:tpParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA cathesian product of zero or more Top.Types. For instance,\n \u003ccode\u003e(tupleType [])\u003c/code\u003e represents \u003ccode\u003e()\u003c/code\u003e, and \u003ccode\u003e(tupleType [charType, stringType])\u003c/code\u003e\n represents \u003ccode\u003e(Char,String)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "tupleType",
          "package": "Top",
          "signature": "Tps -\u003e Tp",
          "source": "src/Top-Types-Primitive.html#tupleType",
          "type": "function"
        },
        "index": {
          "description": "cathesian product of zero or more Top.Types For instance tupleType represents and tupleType charType stringType represents Char String",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "tupleType",
          "normalized": "Tps-\u003eTp",
          "package": "Top",
          "partial": "Type",
          "signature": "Tps-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:tupleType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecover the type variables that are frozen in a type.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "unfreezeVariablesInType",
          "package": "Top",
          "signature": "Tp -\u003e Tp",
          "source": "src/Top-Types-Primitive.html#unfreezeVariablesInType",
          "type": "function"
        },
        "index": {
          "description": "Recover the type variables that are frozen in type",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "unfreezeVariablesInType",
          "normalized": "Tp-\u003eTp",
          "package": "Top",
          "partial": "Variables In Type",
          "signature": "Tp-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:unfreezeVariablesInType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the list of type variables of a type. (no duplicates)\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "variablesInType",
          "package": "Top",
          "signature": "Tp -\u003e [Int]",
          "source": "src/Top-Types-Primitive.html#variablesInType",
          "type": "function"
        },
        "index": {
          "description": "Returns the list of type variables of type no duplicates",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "variablesInType",
          "normalized": "Tp-\u003e[Int]",
          "package": "Top",
          "partial": "In Type",
          "signature": "Tp-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:variablesInType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit type. A special instance of of tuple type.\n\u003c/p\u003e",
          "module": "Top.Types.Primitive",
          "name": "voidType",
          "package": "Top",
          "signature": "Tp",
          "source": "src/Top-Types-Primitive.html#voidType",
          "type": "function"
        },
        "index": {
          "description": "The unit type special instance of of tuple type",
          "hierarchy": "Top Types Primitive",
          "module": "Top.Types.Primitive",
          "name": "voidType",
          "package": "Top",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Primitive.html#v:voidType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eQualification of types (for instance, predicates to deal with type classes).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Qualification",
          "name": "Qualification",
          "package": "Top",
          "source": "src/Top-Types-Qualification.html",
          "type": "module"
        },
        "index": {
          "description": "Qualification of types for instance predicates to deal with type classes",
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "Qualification",
          "package": "Top",
          "partial": "Qualification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "Qualification",
          "package": "Top",
          "source": "src/Top-Types-Qualification.html#Qualification",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "Qualification",
          "package": "Top",
          "partial": "Qualification",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#t:Qualification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "ShowQualifiers",
          "package": "Top",
          "source": "src/Top-Types-Qualification.html#ShowQualifiers",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "ShowQualifiers",
          "package": "Top",
          "partial": "Show Qualifiers",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#t:ShowQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "(.=\u003e.)",
          "package": "Top",
          "signature": "q -\u003e a -\u003e Qualification q a",
          "source": "src/Top-Types-Qualification.html#.%3D%3E.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "(.=\u003e.) .=\u003e.",
          "normalized": "a-\u003eb-\u003eQualification a b",
          "package": "Top",
          "signature": "q-\u003ea-\u003eQualification q a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:.-61--62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "Qualification",
          "package": "Top",
          "signature": "Qualification (q, a)",
          "source": "src/Top-Types-Qualification.html#Qualification",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "Qualification",
          "normalized": "Qualification(a,b)",
          "package": "Top",
          "partial": "Qualification",
          "signature": "Qualification(q,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:Qualification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "qualifiers",
          "package": "Top",
          "signature": "Qualification q a -\u003e q",
          "source": "src/Top-Types-Qualification.html#qualifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "qualifiers",
          "normalized": "Qualification a b-\u003ea",
          "package": "Top",
          "signature": "Qualification q a-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:qualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "qualify",
          "package": "Top",
          "signature": "context -\u003e [q] -\u003e a -\u003e Qualification [q] a",
          "source": "src/Top-Types-Qualification.html#qualify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "qualify",
          "normalized": "a-\u003e[b]-\u003ec-\u003eQualification[b]c",
          "package": "Top",
          "signature": "context-\u003e[q]-\u003ea-\u003eQualification[q]a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:qualify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "showContext",
          "package": "Top",
          "signature": "a -\u003e String",
          "source": "src/Top-Types-Qualification.html#showContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "showContext",
          "normalized": "a-\u003eString",
          "package": "Top",
          "partial": "Context",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:showContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "showContextSimple",
          "package": "Top",
          "signature": "[String] -\u003e String",
          "source": "src/Top-Types-Qualification.html#showContextSimple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "showContextSimple",
          "normalized": "[String]-\u003eString",
          "package": "Top",
          "partial": "Context Simple",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:showContextSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "showQualifiers",
          "package": "Top",
          "signature": "a -\u003e [String]",
          "source": "src/Top-Types-Qualification.html#showQualifiers",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "showQualifiers",
          "normalized": "a-\u003e[String]",
          "package": "Top",
          "partial": "Qualifiers",
          "signature": "a-\u003e[String]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:showQualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "split",
          "package": "Top",
          "signature": "Qualification q a -\u003e (q, a)",
          "source": "src/Top-Types-Qualification.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "split",
          "normalized": "Qualification a b-\u003e(a,b)",
          "package": "Top",
          "signature": "Qualification q a-\u003e(q,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Qualification",
          "name": "unqualify",
          "package": "Top",
          "signature": "Qualification q a -\u003e a",
          "source": "src/Top-Types-Qualification.html#unqualify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Qualification",
          "module": "Top.Types.Qualification",
          "name": "unqualify",
          "normalized": "Qualification a b-\u003eb",
          "package": "Top",
          "signature": "Qualification q a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Qualification.html#v:unqualify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUniversal and existential quantification of types\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Quantification",
          "name": "Quantification",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html",
          "type": "module"
        },
        "index": {
          "description": "Universal and existential quantification of types",
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "Quantification",
          "package": "Top",
          "partial": "Quantification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "Existential",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#Existential",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "Existential",
          "package": "Top",
          "partial": "Existential",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Existential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "Exists",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#Exists",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "Exists",
          "package": "Top",
          "partial": "Exists",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "Forall",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#Forall",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "Forall",
          "package": "Top",
          "partial": "Forall",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "HasSkolems",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#HasSkolems",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "HasSkolems",
          "package": "Top",
          "partial": "Has Skolems",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:HasSkolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "Quantification",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#Quantification",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "Quantification",
          "package": "Top",
          "partial": "Quantification",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Quantification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "QuantorMap",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#QuantorMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "QuantorMap",
          "package": "Top",
          "partial": "Quantor Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:QuantorMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "ShowQuantorOptions",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "ShowQuantorOptions",
          "package": "Top",
          "partial": "Show Quantor Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:ShowQuantorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class can deal with the pretty printing of (possibly nested) quantifiers.\n\u003c/p\u003e",
          "module": "Top.Types.Quantification",
          "name": "ShowQuantors",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#ShowQuantors",
          "type": "class"
        },
        "index": {
          "description": "This class can deal with the pretty printing of possibly nested quantifiers",
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "ShowQuantors",
          "package": "Top",
          "partial": "Show Quantors",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:ShowQuantors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "Universal",
          "package": "Top",
          "source": "src/Top-Types-Quantification.html#Universal",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "Universal",
          "package": "Top",
          "partial": "Universal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#t:Universal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "Quantification",
          "package": "Top",
          "signature": "Quantification ([Int], QuantorMap, a)",
          "source": "src/Top-Types-Quantification.html#Quantification",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "Quantification",
          "normalized": "Quantification([Int],QuantorMap,a)",
          "package": "Top",
          "partial": "Quantification",
          "signature": "Quantification([Int],QuantorMap,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:Quantification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "ShowQuantorOptions",
          "package": "Top",
          "signature": "ShowQuantorOptions",
          "source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "ShowQuantorOptions",
          "package": "Top",
          "partial": "Show Quantor Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:ShowQuantorOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "allSkolems",
          "package": "Top",
          "signature": "a -\u003e [Int]",
          "source": "src/Top-Types-Quantification.html#allSkolems",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "allSkolems",
          "normalized": "a-\u003e[Int]",
          "package": "Top",
          "partial": "Skolems",
          "signature": "a-\u003e[Int]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:allSkolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "bindSkolemConstants",
          "package": "Top",
          "signature": "[Int] -\u003e a -\u003e Quantification q a",
          "source": "src/Top-Types-Quantification.html#bindSkolemConstants",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "bindSkolemConstants",
          "normalized": "[Int]-\u003ea-\u003eQuantification b a",
          "package": "Top",
          "partial": "Skolem Constants",
          "signature": "[Int]-\u003ea-\u003eQuantification q a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:bindSkolemConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "bindTypeVariables",
          "package": "Top",
          "signature": "[Int] -\u003e a -\u003e Quantification q a",
          "source": "src/Top-Types-Quantification.html#bindTypeVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "bindTypeVariables",
          "normalized": "[Int]-\u003ea-\u003eQuantification b a",
          "package": "Top",
          "partial": "Type Variables",
          "signature": "[Int]-\u003ea-\u003eQuantification q a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:bindTypeVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "changeSkolems",
          "package": "Top",
          "signature": "[(Int, Tp)] -\u003e a -\u003e a",
          "source": "src/Top-Types-Quantification.html#changeSkolems",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "changeSkolems",
          "normalized": "[(Int,Tp)]-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Skolems",
          "signature": "[(Int,Tp)]-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:changeSkolems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "close",
          "package": "Top",
          "signature": "[Int] -\u003e a -\u003e Exists a",
          "source": "src/Top-Types-Quantification.html#close",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "close",
          "normalized": "[Int]-\u003ea-\u003eExists a",
          "package": "Top",
          "signature": "[Int]-\u003ea-\u003eExists a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:close"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "defaultOptions",
          "package": "Top",
          "signature": "ShowQuantorOptions",
          "source": "src/Top-Types-Quantification.html#defaultOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "defaultOptions",
          "package": "Top",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:defaultOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "dontUseIdentifiers",
          "package": "Top",
          "signature": "[String]",
          "source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "dontUseIdentifiers",
          "normalized": "[String]",
          "package": "Top",
          "partial": "Use Identifiers",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:dontUseIdentifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "fromSkolemString",
          "package": "Top",
          "signature": "String -\u003e Maybe Int",
          "source": "src/Top-Types-Quantification.html#fromSkolemString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "fromSkolemString",
          "normalized": "String-\u003eMaybe Int",
          "package": "Top",
          "partial": "Skolem String",
          "signature": "String-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:fromSkolemString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "generalize",
          "package": "Top",
          "signature": "context -\u003e a -\u003e Forall a",
          "source": "src/Top-Types-Quantification.html#generalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "generalize",
          "normalized": "a-\u003eb-\u003eForall b",
          "package": "Top",
          "signature": "context-\u003ea-\u003eForall a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:generalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "generalizeAll",
          "package": "Top",
          "signature": "a -\u003e Forall a",
          "source": "src/Top-Types-Quantification.html#generalizeAll",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "generalizeAll",
          "normalized": "a-\u003eForall a",
          "package": "Top",
          "partial": "All",
          "signature": "a-\u003eForall a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:generalizeAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "getQuantorMap",
          "package": "Top",
          "signature": "Quantification q a -\u003e QuantorMap",
          "source": "src/Top-Types-Quantification.html#getQuantorMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "getQuantorMap",
          "normalized": "Quantification a b-\u003eQuantorMap",
          "package": "Top",
          "partial": "Quantor Map",
          "signature": "Quantification q a-\u003eQuantorMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:getQuantorMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "instantiate",
          "package": "Top",
          "signature": "Int -\u003e Forall a -\u003e (Int, a)",
          "source": "src/Top-Types-Quantification.html#instantiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "instantiate",
          "normalized": "Int-\u003eForall a-\u003e(Int,a)",
          "package": "Top",
          "signature": "Int-\u003eForall a-\u003e(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:instantiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "introduceSkolemConstants",
          "package": "Top",
          "signature": "Int -\u003e Quantification q a -\u003e (Int, a)",
          "source": "src/Top-Types-Quantification.html#introduceSkolemConstants",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "introduceSkolemConstants",
          "normalized": "Int-\u003eQuantification a b-\u003e(Int,b)",
          "package": "Top",
          "partial": "Skolem Constants",
          "signature": "Int-\u003eQuantification q a-\u003e(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:introduceSkolemConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "introduceTypeVariables",
          "package": "Top",
          "signature": "Int -\u003e Quantification q a -\u003e (Int, a)",
          "source": "src/Top-Types-Quantification.html#introduceTypeVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "introduceTypeVariables",
          "normalized": "Int-\u003eQuantification a b-\u003e(Int,b)",
          "package": "Top",
          "partial": "Type Variables",
          "signature": "Int-\u003eQuantification q a-\u003e(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:introduceTypeVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "makeSkolemConstant",
          "package": "Top",
          "signature": "Int -\u003e Tp",
          "source": "src/Top-Types-Quantification.html#makeSkolemConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "makeSkolemConstant",
          "normalized": "Int-\u003eTp",
          "package": "Top",
          "partial": "Skolem Constant",
          "signature": "Int-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:makeSkolemConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "noQuantifiers",
          "package": "Top",
          "signature": "a -\u003e Quantification q a",
          "source": "src/Top-Types-Quantification.html#noQuantifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "noQuantifiers",
          "normalized": "a-\u003eQuantification b a",
          "package": "Top",
          "partial": "Quantifiers",
          "signature": "a-\u003eQuantification q a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:noQuantifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "open",
          "package": "Top",
          "signature": "Int -\u003e Exists a -\u003e (Int, a)",
          "source": "src/Top-Types-Quantification.html#open",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "open",
          "normalized": "Int-\u003eExists a-\u003e(Int,a)",
          "package": "Top",
          "signature": "Int-\u003eExists a-\u003e(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:open"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "quantifiers",
          "package": "Top",
          "signature": "Quantification q a -\u003e [Int]",
          "source": "src/Top-Types-Quantification.html#quantifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "quantifiers",
          "normalized": "Quantification a b-\u003e[Int]",
          "package": "Top",
          "signature": "Quantification q a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:quantifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "quantify",
          "package": "Top",
          "signature": "[Int] -\u003e a -\u003e Forall a",
          "source": "src/Top-Types-Quantification.html#quantify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "quantify",
          "normalized": "[Int]-\u003ea-\u003eForall a",
          "package": "Top",
          "signature": "[Int]-\u003ea-\u003eForall a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:quantify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "reveal",
          "package": "Top",
          "signature": "Int -\u003e Exists a -\u003e (Int, a)",
          "source": "src/Top-Types-Quantification.html#open",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "reveal",
          "normalized": "Int-\u003eExists a-\u003e(Int,a)",
          "package": "Top",
          "signature": "Int-\u003eExists a-\u003e(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:reveal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "showAllTheSame",
          "package": "Top",
          "signature": "Bool",
          "source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "showAllTheSame",
          "package": "Top",
          "partial": "All The Same",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showAllTheSame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "showQuantor",
          "package": "Top",
          "signature": "Quantification q a -\u003e String",
          "source": "src/Top-Types-Quantification.html#showQuantor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "showQuantor",
          "normalized": "Quantification a b-\u003eString",
          "package": "Top",
          "partial": "Quantor",
          "signature": "Quantification q a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showQuantor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "showQuantors",
          "package": "Top",
          "signature": "a -\u003e String",
          "source": "src/Top-Types-Quantification.html#showQuantors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "showQuantors",
          "normalized": "a-\u003eString",
          "package": "Top",
          "partial": "Quantors",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showQuantors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "showQuantorsWithout",
          "package": "Top",
          "signature": "ShowQuantorOptions -\u003e a -\u003e String",
          "source": "src/Top-Types-Quantification.html#showQuantorsWithout",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "showQuantorsWithout",
          "normalized": "ShowQuantorOptions-\u003ea-\u003eString",
          "package": "Top",
          "partial": "Quantors Without",
          "signature": "ShowQuantorOptions-\u003ea-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showQuantorsWithout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "showTopLevelQuantors",
          "package": "Top",
          "signature": "Bool",
          "source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "showTopLevelQuantors",
          "package": "Top",
          "partial": "Top Level Quantors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:showTopLevelQuantors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "skolemPrefix",
          "package": "Top",
          "signature": "String",
          "source": "src/Top-Types-Quantification.html#skolemPrefix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "skolemPrefix",
          "package": "Top",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:skolemPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "skolemize",
          "package": "Top",
          "signature": "Int -\u003e Forall a -\u003e (Int, a)",
          "source": "src/Top-Types-Quantification.html#instantiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "skolemize",
          "normalized": "Int-\u003eForall a-\u003e(Int,a)",
          "package": "Top",
          "signature": "Int-\u003eForall a-\u003e(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:skolemize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "skolemizeFTV",
          "package": "Top",
          "signature": "a -\u003e a",
          "source": "src/Top-Types-Quantification.html#skolemizeFTV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "skolemizeFTV",
          "normalized": "a-\u003ea",
          "package": "Top",
          "partial": "FTV",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:skolemizeFTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "unquantify",
          "package": "Top",
          "signature": "Quantification q a -\u003e a",
          "source": "src/Top-Types-Quantification.html#unquantify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "unquantify",
          "normalized": "Quantification a b-\u003eb",
          "package": "Top",
          "signature": "Quantification q a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:unquantify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "unreveal",
          "package": "Top",
          "signature": "[Int] -\u003e a -\u003e Exists a",
          "source": "src/Top-Types-Quantification.html#unreveal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "unreveal",
          "normalized": "[Int]-\u003ea-\u003eExists a",
          "package": "Top",
          "signature": "[Int]-\u003ea-\u003eExists a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:unreveal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "unskolemize",
          "package": "Top",
          "signature": "[Int] -\u003e a -\u003e Forall a",
          "source": "src/Top-Types-Quantification.html#unskolemize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "unskolemize",
          "normalized": "[Int]-\u003ea-\u003eForall a",
          "package": "Top",
          "signature": "[Int]-\u003ea-\u003eForall a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:unskolemize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "useTheNameMap",
          "package": "Top",
          "signature": "Bool",
          "source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "useTheNameMap",
          "package": "Top",
          "partial": "The Name Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:useTheNameMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of unique identifiers.(a, b, .., z, a1, b1 .., z1, a2, ..)\n\u003c/p\u003e",
          "module": "Top.Types.Quantification",
          "name": "variableList",
          "package": "Top",
          "signature": "[String]",
          "source": "src/Top-Types-Quantification.html#variableList",
          "type": "function"
        },
        "index": {
          "description": "List of unique identifiers a1 b1 z1 a2",
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "variableList",
          "normalized": "[String]",
          "package": "Top",
          "partial": "List",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:variableList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "variablePrefix",
          "package": "Top",
          "signature": "String",
          "source": "src/Top-Types-Quantification.html#ShowQuantorOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "variablePrefix",
          "package": "Top",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:variablePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Quantification",
          "name": "withoutQuantors",
          "package": "Top",
          "signature": "Quantification q a -\u003e Bool",
          "source": "src/Top-Types-Quantification.html#withoutQuantors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Quantification",
          "module": "Top.Types.Quantification",
          "name": "withoutQuantors",
          "normalized": "Quantification a b-\u003eBool",
          "package": "Top",
          "partial": "Quantors",
          "signature": "Quantification q a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Quantification.html#v:withoutQuantors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA representation of type schemes. A type scheme is a (qualified) type\n with a number of quantifiers (foralls) in front of it. A partial mapping \n from type variable (Int) to their name (String) is preserved.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Schemes",
          "name": "Schemes",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html",
          "type": "module"
        },
        "index": {
          "description": "representation of type schemes type scheme is qualified type with number of quantifiers foralls in front of it partial mapping from type variable Int to their name String is preserved",
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "Schemes",
          "package": "Top",
          "partial": "Schemes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "IsSigmaPreds",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#IsSigmaPreds",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "IsSigmaPreds",
          "package": "Top",
          "partial": "Is Sigma Preds",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:IsSigmaPreds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class to convert something into a type scheme\n\u003c/p\u003e",
          "module": "Top.Types.Schemes",
          "name": "IsTpScheme",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#IsTpScheme",
          "type": "class"
        },
        "index": {
          "description": "type class to convert something into type scheme",
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "IsTpScheme",
          "package": "Top",
          "partial": "Is Tp Scheme",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:IsTpScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "QType",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#QType",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "QType",
          "package": "Top",
          "partial": "QType",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:QType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sigma is a type scheme or a type scheme variable\n\u003c/p\u003e",
          "module": "Top.Types.Schemes",
          "name": "Scheme",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#Scheme",
          "type": "type"
        },
        "index": {
          "description": "sigma is type scheme or type scheme variable",
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "Scheme",
          "package": "Top",
          "partial": "Scheme",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:Scheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "Sigma",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#Sigma",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "Sigma",
          "package": "Top",
          "partial": "Sigma",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:Sigma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "SigmaPreds",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#SigmaPreds",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "SigmaPreds",
          "package": "Top",
          "partial": "Sigma Preds",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:SigmaPreds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "SigmaVar",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#SigmaVar",
          "type": "type"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "SigmaVar",
          "package": "Top",
          "partial": "Sigma Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:SigmaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type scheme consists of a list of quantified type variables, a finite map \n that partially maps these type variables to their original identifier, and a\n qualified type.\n\u003c/p\u003e",
          "module": "Top.Types.Schemes",
          "name": "TpScheme",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#TpScheme",
          "type": "type"
        },
        "index": {
          "description": "type scheme consists of list of quantified type variables finite map that partially maps these type variables to their original identifier and qualified type",
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "TpScheme",
          "package": "Top",
          "partial": "Tp Scheme",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:TpScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA substitution for type scheme variables\n\u003c/p\u003e",
          "module": "Top.Types.Schemes",
          "name": "TpSchemeMap",
          "package": "Top",
          "source": "src/Top-Types-Schemes.html#TpSchemeMap",
          "type": "type"
        },
        "index": {
          "description": "substitution for type scheme variables",
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "TpSchemeMap",
          "package": "Top",
          "partial": "Tp Scheme Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#t:TpSchemeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "SigmaScheme",
          "package": "Top",
          "signature": "SigmaScheme (Scheme qs)",
          "source": "src/Top-Types-Schemes.html#Sigma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "SigmaScheme",
          "package": "Top",
          "partial": "Sigma Scheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:SigmaScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "SigmaVar",
          "package": "Top",
          "signature": "SigmaVar SigmaVar",
          "source": "src/Top-Types-Schemes.html#Sigma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "SigmaVar",
          "package": "Top",
          "partial": "Sigma Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:SigmaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine the arity of a type scheme.    \n\u003c/p\u003e",
          "module": "Top.Types.Schemes",
          "name": "arityOfTpScheme",
          "package": "Top",
          "signature": "TpScheme -\u003e Int",
          "source": "src/Top-Types-Schemes.html#arityOfTpScheme",
          "type": "function"
        },
        "index": {
          "description": "Determine the arity of type scheme",
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "arityOfTpScheme",
          "normalized": "TpScheme-\u003eInt",
          "package": "Top",
          "partial": "Of Tp Scheme",
          "signature": "TpScheme-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:arityOfTpScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "genericInstanceOf",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e ClassEnvironment -\u003e TpScheme -\u003e TpScheme -\u003e Bool",
          "source": "src/Top-Types-Schemes.html#genericInstanceOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "genericInstanceOf",
          "normalized": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTpScheme-\u003eTpScheme-\u003eBool",
          "package": "Top",
          "partial": "Instance Of",
          "signature": "OrderedTypeSynonyms-\u003eClassEnvironment-\u003eTpScheme-\u003eTpScheme-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:genericInstanceOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "instantiateWithNameMap",
          "package": "Top",
          "signature": "Int -\u003e TpScheme -\u003e (Int, Predicates, Tp)",
          "source": "src/Top-Types-Schemes.html#instantiateWithNameMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "instantiateWithNameMap",
          "normalized": "Int-\u003eTpScheme-\u003e(Int,Predicates,Tp)",
          "package": "Top",
          "partial": "With Name Map",
          "signature": "Int-\u003eTpScheme-\u003e(Int,Predicates,Tp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:instantiateWithNameMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the type scheme overloaded (does it contain predicates)?\n\u003c/p\u003e",
          "module": "Top.Types.Schemes",
          "name": "isOverloaded",
          "package": "Top",
          "signature": "TpScheme -\u003e Bool",
          "source": "src/Top-Types-Schemes.html#isOverloaded",
          "type": "function"
        },
        "index": {
          "description": "Is the type scheme overloaded does it contain predicates",
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "isOverloaded",
          "normalized": "TpScheme-\u003eBool",
          "package": "Top",
          "partial": "Overloaded",
          "signature": "TpScheme-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:isOverloaded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "makeScheme",
          "package": "Top",
          "signature": "[Int] -\u003e Predicates -\u003e Tp -\u003e TpScheme",
          "source": "src/Top-Types-Schemes.html#makeScheme",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "makeScheme",
          "normalized": "[Int]-\u003ePredicates-\u003eTp-\u003eTpScheme",
          "package": "Top",
          "partial": "Scheme",
          "signature": "[Int]-\u003ePredicates-\u003eTp-\u003eTpScheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:makeScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "toSigmaPreds",
          "package": "Top",
          "signature": "a -\u003e SigmaPreds",
          "source": "src/Top-Types-Schemes.html#toSigmaPreds",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "toSigmaPreds",
          "normalized": "a-\u003eSigmaPreds",
          "package": "Top",
          "partial": "Sigma Preds",
          "signature": "a-\u003eSigmaPreds",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:toSigmaPreds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Schemes",
          "name": "toTpScheme",
          "package": "Top",
          "signature": "a -\u003e TpScheme",
          "source": "src/Top-Types-Schemes.html#toTpScheme",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Schemes",
          "module": "Top.Types.Schemes",
          "name": "toTpScheme",
          "normalized": "a-\u003eTpScheme",
          "package": "Top",
          "partial": "Tp Scheme",
          "signature": "a-\u003eTpScheme",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Schemes.html#v:toTpScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a data type to represent (plain) types, some basic \n functionality for types, and an instance for Show.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Substitution",
          "name": "Substitution",
          "package": "Top",
          "source": "src/Top-Types-Substitution.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains data type to represent plain types some basic functionality for types and an instance for Show",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "Substitution",
          "package": "Top",
          "partial": "Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fixpoint is computed when looking up the target of a type variable in this substitution. \n Combining two substitutions is cheap, whereas a lookup is more expensive than the \n normal finite map substitution.\n\u003c/p\u003e",
          "module": "Top.Types.Substitution",
          "name": "FixpointSubstitution",
          "package": "Top",
          "source": "src/Top-Types-Substitution.html#FixpointSubstitution",
          "type": "newtype"
        },
        "index": {
          "description": "fixpoint is computed when looking up the target of type variable in this substitution Combining two substitutions is cheap whereas lookup is more expensive than the normal finite map substitution",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "FixpointSubstitution",
          "package": "Top",
          "partial": "Fixpoint Substitution",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:FixpointSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA substitution represented by a finite map.\n\u003c/p\u003e",
          "module": "Top.Types.Substitution",
          "name": "MapSubstitution",
          "package": "Top",
          "source": "src/Top-Types-Substitution.html#MapSubstitution",
          "type": "type"
        },
        "index": {
          "description": "substitution represented by finite map",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "MapSubstitution",
          "package": "Top",
          "partial": "Map Substitution",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:MapSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "Substitutable",
          "package": "Top",
          "source": "src/Top-Types-Substitution.html#Substitutable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "Substitutable",
          "package": "Top",
          "partial": "Substitutable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:Substitutable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "Substitution",
          "package": "Top",
          "source": "src/Top-Types-Substitution.html#Substitution",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "Substitution",
          "package": "Top",
          "partial": "Substitution",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:Substitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "WrappedSubstitution",
          "package": "Top",
          "source": "src/Top-Types-Substitution.html#WrappedSubstitution",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "WrappedSubstitution",
          "package": "Top",
          "partial": "Wrapped Substitution",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#t:WrappedSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "(|-\u003e)",
          "package": "Top",
          "signature": "s -\u003e a -\u003e a",
          "source": "src/Top-Types-Substitution.html#%7C-%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "(|-\u003e) |-\u003e",
          "normalized": "a-\u003eb-\u003eb",
          "package": "Top",
          "signature": "s-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:-124--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two finite map substitutions: safe.\n Note for \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e: bindings in right argument shadow those in the left\n\u003c/p\u003e",
          "module": "Top.Types.Substitution",
          "name": "(@@)",
          "package": "Top",
          "signature": "MapSubstitution -\u003e MapSubstitution -\u003e MapSubstitution",
          "source": "src/Top-Types-Substitution.html#%40%40",
          "type": "function"
        },
        "index": {
          "description": "Compose two finite map substitutions safe Note for union bindings in right argument shadow those in the left",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "(@@) @@",
          "normalized": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution",
          "package": "Top",
          "signature": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:-64--64-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two finite map substitutions: quick and dirty!\n\u003c/p\u003e",
          "module": "Top.Types.Substitution",
          "name": "(@@@)",
          "package": "Top",
          "signature": "MapSubstitution -\u003e MapSubstitution -\u003e MapSubstitution",
          "source": "src/Top-Types-Substitution.html#%40%40%40",
          "type": "function"
        },
        "index": {
          "description": "Compose two finite map substitutions quick and dirty",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "(@@@) @@@",
          "normalized": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution",
          "package": "Top",
          "signature": "MapSubstitution-\u003eMapSubstitution-\u003eMapSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:-64--64--64-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "FixpointSubstitution",
          "package": "Top",
          "signature": "FixpointSubstitution (Map Int Tp)",
          "source": "src/Top-Types-Substitution.html#FixpointSubstitution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "FixpointSubstitution",
          "package": "Top",
          "partial": "Fixpoint Substitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:FixpointSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "WrappedSubstitution",
          "package": "Top",
          "signature": "WrappedSubstitution a (Int -\u003e a -\u003e Tp, [Int] -\u003e a -\u003e a, [Int] -\u003e a -\u003e a, a -\u003e [Int], a -\u003e Tps)",
          "source": "src/Top-Types-Substitution.html#WrappedSubstitution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "WrappedSubstitution",
          "normalized": "WrappedSubstitution a(Int-\u003ea-\u003eTp,[Int]-\u003ea-\u003ea,[Int]-\u003ea-\u003ea,a-\u003e[Int],a-\u003eTps)",
          "package": "Top",
          "partial": "Wrapped Substitution",
          "signature": "WrappedSubstitution a(Int-\u003ea-\u003eTp,[Int]-\u003ea-\u003ea,[Int]-\u003ea-\u003ea,a-\u003e[Int],a-\u003eTps)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:WrappedSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "allTypeConstants",
          "package": "Top",
          "signature": "a -\u003e [String]",
          "source": "src/Top-Types-Substitution.html#allTypeConstants",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "allTypeConstants",
          "normalized": "a-\u003e[String]",
          "package": "Top",
          "partial": "Type Constants",
          "signature": "a-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:allTypeConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "allTypeVariables",
          "package": "Top",
          "signature": "a -\u003e [Int]",
          "source": "src/Top-Types-Substitution.html#allTypeVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "allTypeVariables",
          "normalized": "a-\u003e[Int]",
          "package": "Top",
          "partial": "Type Variables",
          "signature": "a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:allTypeVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "cod",
          "package": "Top",
          "signature": "s -\u003e Tps",
          "source": "src/Top-Types-Substitution.html#cod",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "cod",
          "normalized": "a-\u003eTps",
          "package": "Top",
          "signature": "s-\u003eTps",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:cod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two fixpoint substitutions that are disjoint\n\u003c/p\u003e",
          "module": "Top.Types.Substitution",
          "name": "disjointFPS",
          "package": "Top",
          "signature": "FixpointSubstitution -\u003e FixpointSubstitution -\u003e FixpointSubstitution",
          "source": "src/Top-Types-Substitution.html#disjointFPS",
          "type": "function"
        },
        "index": {
          "description": "Combine two fixpoint substitutions that are disjoint",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "disjointFPS",
          "normalized": "FixpointSubstitution-\u003eFixpointSubstitution-\u003eFixpointSubstitution",
          "package": "Top",
          "partial": "FPS",
          "signature": "FixpointSubstitution-\u003eFixpointSubstitution-\u003eFixpointSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:disjointFPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "dom",
          "package": "Top",
          "signature": "s -\u003e [Int]",
          "source": "src/Top-Types-Substitution.html#dom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "dom",
          "normalized": "a-\u003e[Int]",
          "package": "Top",
          "signature": "s-\u003e[Int]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:dom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty fixpoint substitution \n\u003c/p\u003e",
          "module": "Top.Types.Substitution",
          "name": "emptyFPS",
          "package": "Top",
          "signature": "FixpointSubstitution",
          "source": "src/Top-Types-Substitution.html#emptyFPS",
          "type": "function"
        },
        "index": {
          "description": "The empty fixpoint substitution",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "emptyFPS",
          "package": "Top",
          "partial": "FPS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:emptyFPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "emptySubst",
          "package": "Top",
          "signature": "MapSubstitution",
          "source": "src/Top-Types-Substitution.html#emptySubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "emptySubst",
          "package": "Top",
          "partial": "Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:emptySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "freezeFTV",
          "package": "Top",
          "signature": "a -\u003e a",
          "source": "src/Top-Types-Substitution.html#freezeFTV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "freezeFTV",
          "normalized": "a-\u003ea",
          "package": "Top",
          "partial": "FTV",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:freezeFTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "ftv",
          "package": "Top",
          "signature": "a -\u003e [Int]",
          "source": "src/Top-Types-Substitution.html#ftv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "ftv",
          "normalized": "a-\u003e[Int]",
          "package": "Top",
          "signature": "a-\u003e[Int]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:ftv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "listToSubstitution",
          "package": "Top",
          "signature": "[(Int, Tp)] -\u003e MapSubstitution",
          "source": "src/Top-Types-Substitution.html#listToSubstitution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "listToSubstitution",
          "normalized": "[(Int,Tp)]-\u003eMapSubstitution",
          "package": "Top",
          "partial": "To Substitution",
          "signature": "[(Int,Tp)]-\u003eMapSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:listToSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "lookupInt",
          "package": "Top",
          "signature": "Int -\u003e s -\u003e Tp",
          "source": "src/Top-Types-Substitution.html#lookupInt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "lookupInt",
          "normalized": "Int-\u003ea-\u003eTp",
          "package": "Top",
          "partial": "Int",
          "signature": "Int-\u003es-\u003eTp",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:lookupInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe next type variable that is not free (default is zero)\n\u003c/p\u003e",
          "module": "Top.Types.Substitution",
          "name": "nextFTV",
          "package": "Top",
          "signature": "a -\u003e Int",
          "source": "src/Top-Types-Substitution.html#nextFTV",
          "type": "function"
        },
        "index": {
          "description": "The next type variable that is not free default is zero",
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "nextFTV",
          "normalized": "a-\u003eInt",
          "package": "Top",
          "partial": "FTV",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:nextFTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "removeDom",
          "package": "Top",
          "signature": "[Int] -\u003e s -\u003e s",
          "source": "src/Top-Types-Substitution.html#removeDom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "removeDom",
          "normalized": "[Int]-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Dom",
          "signature": "[Int]-\u003es-\u003es",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:removeDom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "restrictDom",
          "package": "Top",
          "signature": "[Int] -\u003e s -\u003e s",
          "source": "src/Top-Types-Substitution.html#restrictDom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "restrictDom",
          "normalized": "[Int]-\u003ea-\u003ea",
          "package": "Top",
          "partial": "Dom",
          "signature": "[Int]-\u003es-\u003es",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:restrictDom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "singleSubstitution",
          "package": "Top",
          "signature": "Int -\u003e Tp -\u003e MapSubstitution",
          "source": "src/Top-Types-Substitution.html#singleSubstitution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "singleSubstitution",
          "normalized": "Int-\u003eTp-\u003eMapSubstitution",
          "package": "Top",
          "partial": "Substitution",
          "signature": "Int-\u003eTp-\u003eMapSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:singleSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Substitution",
          "name": "wrapSubstitution",
          "package": "Top",
          "signature": "substitution -\u003e WrappedSubstitution",
          "source": "src/Top-Types-Substitution.html#wrapSubstitution",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Substitution",
          "module": "Top.Types.Substitution",
          "name": "wrapSubstitution",
          "normalized": "a-\u003eWrappedSubstitution",
          "package": "Top",
          "partial": "Substitution",
          "signature": "substitution-\u003eWrappedSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Substitution.html#v:wrapSubstitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains type synonyms to represent type synonyms. A collection\n of type synonyms can always be ordered, since (mutually) recursive type\n synonyms are not permitted. The ordering of type synonyms must be determined\n to find a minimal number of unfold steps to make two types syntactically \n equivalent.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Synonym",
          "name": "Synonym",
          "package": "Top",
          "source": "src/Top-Types-Synonym.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains type synonyms to represent type synonyms collection of type synonyms can always be ordered since mutually recursive type synonyms are not permitted The ordering of type synonyms must be determined to find minimal number of unfold steps to make two types syntactically equivalent",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "Synonym",
          "package": "Top",
          "partial": "Synonym",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn (unordered) collection of type synonyms, together with an ordering.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "OrderedTypeSynonyms",
          "package": "Top",
          "source": "src/Top-Types-Synonym.html#OrderedTypeSynonyms",
          "type": "type"
        },
        "index": {
          "description": "An unordered collection of type synonyms together with an ordering",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "OrderedTypeSynonyms",
          "package": "Top",
          "partial": "Ordered Type Synonyms",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#t:OrderedTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn ordering of type synonyms maps a name of a type synonym to \n a position in the ordering.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "TypeSynonymOrdering",
          "package": "Top",
          "source": "src/Top-Types-Synonym.html#TypeSynonymOrdering",
          "type": "type"
        },
        "index": {
          "description": "An ordering of type synonyms maps name of type synonym to position in the ordering",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "TypeSynonymOrdering",
          "package": "Top",
          "partial": "Type Synonym Ordering",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#t:TypeSynonymOrdering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA (unordered) collection of type synonyms is represented by a finite map of\n strings (the name of the type synonym) to pairs that have an int\n (the number of arguments of the type synonym) and a function.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "TypeSynonyms",
          "package": "Top",
          "source": "src/Top-Types-Synonym.html#TypeSynonyms",
          "type": "type"
        },
        "index": {
          "description": "unordered collection of type synonyms is represented by finite map of strings the name of the type synonym to pairs that have an int the number of arguments of the type synonym and function",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "TypeSynonyms",
          "package": "Top",
          "partial": "Type Synonyms",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#t:TypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to expand the top-level type constructor of one of the two paired Top.Types. If both\n top-level type constructors can be expanded, then the type synonym thast appears first\n in the ordering is expanded.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "expandOneStepOrdered",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e (Tp, Tp) -\u003e Maybe (Tp, Tp)",
          "source": "src/Top-Types-Synonym.html#expandOneStepOrdered",
          "type": "function"
        },
        "index": {
          "description": "Try to expand the top-level type constructor of one of the two paired Top.Types If both top-level type constructors can be expanded then the type synonym thast appears first in the ordering is expanded",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "expandOneStepOrdered",
          "normalized": "OrderedTypeSynonyms-\u003e(Tp,Tp)-\u003eMaybe(Tp,Tp)",
          "package": "Top",
          "partial": "One Step Ordered",
          "signature": "OrderedTypeSynonyms-\u003e(Tp,Tp)-\u003eMaybe(Tp,Tp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandOneStepOrdered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFully expand the top-level type constructor.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "expandToplevelTC",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Maybe Tp",
          "source": "src/Top-Types-Synonym.html#expandToplevelTC",
          "type": "function"
        },
        "index": {
          "description": "Fully expand the top-level type constructor",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "expandToplevelTC",
          "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eMaybe Tp",
          "package": "Top",
          "partial": "Toplevel TC",
          "signature": "OrderedTypeSynonyms-\u003eTp-\u003eMaybe Tp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandToplevelTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFully expand a type in a recursive way.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "expandType",
          "package": "Top",
          "signature": "TypeSynonyms -\u003e Tp -\u003e Tp",
          "source": "src/Top-Types-Synonym.html#expandType",
          "type": "function"
        },
        "index": {
          "description": "Fully expand type in recursive way",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "expandType",
          "normalized": "TypeSynonyms-\u003eTp-\u003eTp",
          "package": "Top",
          "partial": "Type",
          "signature": "TypeSynonyms-\u003eTp-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFully expand the top-level type constructor.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "expandTypeConstructor",
          "package": "Top",
          "signature": "TypeSynonyms -\u003e Tp -\u003e Tp",
          "source": "src/Top-Types-Synonym.html#expandTypeConstructor",
          "type": "function"
        },
        "index": {
          "description": "Fully expand the top-level type constructor",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "expandTypeConstructor",
          "normalized": "TypeSynonyms-\u003eTp-\u003eTp",
          "package": "Top",
          "partial": "Type Constructor",
          "signature": "TypeSynonyms-\u003eTp-\u003eTp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandTypeConstructor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to expand the top-level type constructor one step.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "expandTypeConstructorOneStep",
          "package": "Top",
          "signature": "TypeSynonyms -\u003e Tp -\u003e Maybe Tp",
          "source": "src/Top-Types-Synonym.html#expandTypeConstructorOneStep",
          "type": "function"
        },
        "index": {
          "description": "Try to expand the top-level type constructor one step",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "expandTypeConstructorOneStep",
          "normalized": "TypeSynonyms-\u003eTp-\u003eMaybe Tp",
          "package": "Top",
          "partial": "Type Constructor One Step",
          "signature": "TypeSynonyms-\u003eTp-\u003eMaybe Tp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:expandTypeConstructorOneStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrder a collection of type synonyms, and return this ordering paired with\n sets of mutually recursive type synonyms that are detected.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "getTypeSynonymOrdering",
          "package": "Top",
          "signature": "TypeSynonyms -\u003e (TypeSynonymOrdering, [[String]])",
          "source": "src/Top-Types-Synonym.html#getTypeSynonymOrdering",
          "type": "function"
        },
        "index": {
          "description": "Order collection of type synonyms and return this ordering paired with sets of mutually recursive type synonyms that are detected",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "getTypeSynonymOrdering",
          "normalized": "TypeSynonyms-\u003e(TypeSynonymOrdering,[[String]])",
          "package": "Top",
          "partial": "Type Synonym Ordering",
          "signature": "TypeSynonyms-\u003e(TypeSynonymOrdering,[[String]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:getTypeSynonymOrdering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Synonym",
          "name": "isPhantomTypeSynonym",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e String -\u003e Bool",
          "source": "src/Top-Types-Synonym.html#isPhantomTypeSynonym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "isPhantomTypeSynonym",
          "normalized": "OrderedTypeSynonyms-\u003eString-\u003eBool",
          "package": "Top",
          "partial": "Phantom Type Synonym",
          "signature": "OrderedTypeSynonyms-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:isPhantomTypeSynonym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty collection of ordered type synonyms.\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "noOrderedTypeSynonyms",
          "package": "Top",
          "signature": "OrderedTypeSynonyms",
          "source": "src/Top-Types-Synonym.html#noOrderedTypeSynonyms",
          "type": "function"
        },
        "index": {
          "description": "An empty collection of ordered type synonyms",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "noOrderedTypeSynonyms",
          "package": "Top",
          "partial": "Ordered Type Synonyms",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:noOrderedTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA string is a list of characters\n\u003c/p\u003e",
          "module": "Top.Types.Synonym",
          "name": "stringAsTypeSynonym",
          "package": "Top",
          "signature": "OrderedTypeSynonyms",
          "source": "src/Top-Types-Synonym.html#stringAsTypeSynonym",
          "type": "function"
        },
        "index": {
          "description": "string is list of characters",
          "hierarchy": "Top Types Synonym",
          "module": "Top.Types.Synonym",
          "name": "stringAsTypeSynonym",
          "package": "Top",
          "partial": "As Type Synonym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Synonym.html#v:stringAsTypeSynonym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA unification algorithm for types, which can take a list of (ordered) \n type synonyms into account.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types.Unification",
          "name": "Unification",
          "package": "Top",
          "source": "src/Top-Types-Unification.html",
          "type": "module"
        },
        "index": {
          "description": "unification algorithm for types which can take list of ordered type synonyms into account",
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "Unification",
          "package": "Top",
          "partial": "Unification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are two reasons why two types cannot be unified: either two (different) type constants clash (they\n should be the same), or a type variable should be unified with a composed type that contains this same\n type variable.\n\u003c/p\u003e",
          "module": "Top.Types.Unification",
          "name": "UnificationError",
          "package": "Top",
          "source": "src/Top-Types-Unification.html#UnificationError",
          "type": "data"
        },
        "index": {
          "description": "There are two reasons why two types cannot be unified either two different type constants clash they should be the same or type variable should be unified with composed type that contains this same type variable",
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "UnificationError",
          "package": "Top",
          "partial": "Unification Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#t:UnificationError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Unification",
          "name": "ConstantClash",
          "package": "Top",
          "signature": "ConstantClash String String",
          "source": "src/Top-Types-Unification.html#UnificationError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "ConstantClash",
          "package": "Top",
          "partial": "Constant Clash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:ConstantClash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Unification",
          "name": "InfiniteType",
          "package": "Top",
          "signature": "InfiniteType Int",
          "source": "src/Top-Types-Unification.html#UnificationError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "InfiniteType",
          "package": "Top",
          "partial": "Infinite Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:InfiniteType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the most general type for two types that are equal under type synonyms\n (i.e., the least number of expansions)\n\u003c/p\u003e",
          "module": "Top.Types.Unification",
          "name": "equalUnderTypeSynonyms",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e Maybe Tp",
          "source": "src/Top-Types-Unification.html#equalUnderTypeSynonyms",
          "type": "function"
        },
        "index": {
          "description": "Find the most general type for two types that are equal under type synonyms i.e the least number of expansions",
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "equalUnderTypeSynonyms",
          "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eMaybe Tp",
          "package": "Top",
          "partial": "Under Type Synonyms",
          "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eMaybe Tp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:equalUnderTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe most general unification (substitution) of two types.\n\u003c/p\u003e",
          "module": "Top.Types.Unification",
          "name": "mgu",
          "package": "Top",
          "signature": "Tp -\u003e Tp -\u003e Either UnificationError MapSubstitution",
          "source": "src/Top-Types-Unification.html#mgu",
          "type": "function"
        },
        "index": {
          "description": "The most general unification substitution of two types",
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "mgu",
          "normalized": "Tp-\u003eTp-\u003eEither UnificationError MapSubstitution",
          "package": "Top",
          "signature": "Tp-\u003eTp-\u003eEither UnificationError MapSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:mgu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Types.Unification",
          "name": "mguWithTypeSynonyms",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e Either UnificationError (Bool, MapSubstitution)",
          "source": "src/Top-Types-Unification.html#mguWithTypeSynonyms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "mguWithTypeSynonyms",
          "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eEither UnificationError(Bool,MapSubstitution)",
          "package": "Top",
          "partial": "With Type Synonyms",
          "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eEither UnificationError(Bool,MapSubstitution)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:mguWithTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a set of (ordered) type synonyms, can two types be unified?                              \n\u003c/p\u003e",
          "module": "Top.Types.Unification",
          "name": "unifiable",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tp -\u003e Tp -\u003e Bool",
          "source": "src/Top-Types-Unification.html#unifiable",
          "type": "function"
        },
        "index": {
          "description": "Given set of ordered type synonyms can two types be unified",
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "unifiable",
          "normalized": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eBool",
          "package": "Top",
          "signature": "OrderedTypeSynonyms-\u003eTp-\u003eTp-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:unifiable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as unifiable, but takes as input a list of types\n\u003c/p\u003e",
          "module": "Top.Types.Unification",
          "name": "unifiableList",
          "package": "Top",
          "signature": "OrderedTypeSynonyms -\u003e Tps -\u003e Bool",
          "source": "src/Top-Types-Unification.html#unifiableList",
          "type": "function"
        },
        "index": {
          "description": "Same as unifiable but takes as input list of types",
          "hierarchy": "Top Types Unification",
          "module": "Top.Types.Unification",
          "name": "unifiableList",
          "normalized": "OrderedTypeSynonyms-\u003eTps-\u003eBool",
          "package": "Top",
          "partial": "List",
          "signature": "OrderedTypeSynonyms-\u003eTps-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types-Unification.html#v:unifiableList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA collection of type utilities.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Top.Types",
          "name": "Types",
          "package": "Top",
          "source": "src/Top-Types.html",
          "type": "module"
        },
        "index": {
          "description": "collection of type utilities",
          "hierarchy": "Top Types",
          "module": "Top.Types",
          "name": "Types",
          "package": "Top",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "Embedding",
          "package": "Top",
          "source": "src/Top-Util-Embedding.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "Embedding",
          "package": "Top",
          "partial": "Embedding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "Embedding",
          "package": "Top",
          "source": "src/Top-Util-Embedding.html#Embedding",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "Embedding",
          "package": "Top",
          "partial": "Embedding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#t:Embedding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "Embedding",
          "package": "Top",
          "signature": "Embedding",
          "source": "src/Top-Util-Embedding.html#Embedding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "Embedding",
          "package": "Top",
          "partial": "Embedding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:Embedding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "changeE",
          "package": "Top",
          "signature": "(b -\u003e b) -\u003e a -\u003e a",
          "source": "src/Top-Util-Embedding.html#Embedding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "changeE",
          "normalized": "(a-\u003ea)-\u003eb-\u003eb",
          "package": "Top",
          "signature": "(b-\u003eb)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:changeE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "composeE",
          "package": "Top",
          "signature": "Embedding a b -\u003e Embedding b c -\u003e Embedding a c",
          "source": "src/Top-Util-Embedding.html#composeE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "composeE",
          "normalized": "Embedding a b-\u003eEmbedding b c-\u003eEmbedding a c",
          "package": "Top",
          "signature": "Embedding a b-\u003eEmbedding b c-\u003eEmbedding a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:composeE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "fromFstE",
          "package": "Top",
          "signature": "Embedding a c -\u003e Embedding (a, b) c",
          "source": "src/Top-Util-Embedding.html#fromFstE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "fromFstE",
          "normalized": "Embedding a b-\u003eEmbedding(a,c)b",
          "package": "Top",
          "partial": "Fst",
          "signature": "Embedding a c-\u003eEmbedding(a,b)c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:fromFstE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "fromSndE",
          "package": "Top",
          "signature": "Embedding b c -\u003e Embedding (a, b) c",
          "source": "src/Top-Util-Embedding.html#fromSndE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "fromSndE",
          "normalized": "Embedding a b-\u003eEmbedding(c,a)b",
          "package": "Top",
          "partial": "Snd",
          "signature": "Embedding b c-\u003eEmbedding(a,b)c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:fromSndE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "fstE",
          "package": "Top",
          "signature": "Embedding (a, b) a",
          "source": "src/Top-Util-Embedding.html#fstE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "fstE",
          "normalized": "Embedding(a,b)a",
          "package": "Top",
          "signature": "Embedding(a,b)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:fstE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "getE",
          "package": "Top",
          "signature": "a -\u003e b",
          "source": "src/Top-Util-Embedding.html#Embedding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "getE",
          "normalized": "a-\u003eb",
          "package": "Top",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:getE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "idE",
          "package": "Top",
          "signature": "Embedding a a",
          "source": "src/Top-Util-Embedding.html#idE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "idE",
          "package": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:idE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "setE",
          "package": "Top",
          "signature": "Embedding a b -\u003e b -\u003e a -\u003e a",
          "source": "src/Top-Util-Embedding.html#setE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "setE",
          "normalized": "Embedding a b-\u003eb-\u003ea-\u003ea",
          "package": "Top",
          "signature": "Embedding a b-\u003eb-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:setE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "sndE",
          "package": "Top",
          "signature": "Embedding (a, b) b",
          "source": "src/Top-Util-Embedding.html#sndE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "sndE",
          "normalized": "Embedding(a,b)b",
          "package": "Top",
          "signature": "Embedding(a,b)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:sndE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Embedding",
          "name": "withE",
          "package": "Top",
          "signature": "Embedding a b -\u003e (b -\u003e c) -\u003e a -\u003e c",
          "source": "src/Top-Util-Embedding.html#withE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Embedding",
          "module": "Top.Util.Embedding",
          "name": "withE",
          "normalized": "Embedding a b-\u003e(b-\u003ec)-\u003ea-\u003ec",
          "package": "Top",
          "signature": "Embedding a b-\u003e(b-\u003ec)-\u003ea-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Embedding.html#v:withE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Empty",
          "name": "Empty",
          "package": "Top",
          "source": "src/Top-Util-Empty.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Util Empty",
          "module": "Top.Util.Empty",
          "name": "Empty",
          "package": "Top",
          "partial": "Empty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Empty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Empty",
          "name": "Empty",
          "package": "Top",
          "source": "src/Top-Util-Empty.html#Empty",
          "type": "class"
        },
        "index": {
          "hierarchy": "Top Util Empty",
          "module": "Top.Util.Empty",
          "name": "Empty",
          "package": "Top",
          "partial": "Empty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Empty.html#t:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Empty",
          "name": "empty",
          "package": "Top",
          "signature": "a",
          "source": "src/Top-Util-Empty.html#empty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Top Util Empty",
          "module": "Top.Util.Empty",
          "name": "empty",
          "package": "Top",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Empty.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "Option",
          "package": "Top",
          "source": "src/Top-Util-Option.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "Option",
          "package": "Top",
          "partial": "Option",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "Option",
          "package": "Top",
          "source": "src/Top-Util-Option.html#Option",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "Option",
          "package": "Top",
          "partial": "Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#t:Option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "OptionAccess",
          "package": "Top",
          "source": "src/Top-Util-Option.html#OptionAccess",
          "type": "data"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "OptionAccess",
          "package": "Top",
          "partial": "Option Access",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#t:OptionAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "Access",
          "package": "Top",
          "signature": "Access",
          "source": "src/Top-Util-Option.html#OptionAccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "Access",
          "package": "Top",
          "partial": "Access",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:Access"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "Option",
          "package": "Top",
          "signature": "Option",
          "source": "src/Top-Util-Option.html#Option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "Option",
          "package": "Top",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:Option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "currentValue",
          "package": "Top",
          "signature": "a",
          "source": "src/Top-Util-Option.html#Option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "currentValue",
          "package": "Top",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:currentValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "defaultValue",
          "package": "Top",
          "signature": "a",
          "source": "src/Top-Util-Option.html#Option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "defaultValue",
          "package": "Top",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:defaultValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "getOption",
          "package": "Top",
          "signature": "m a",
          "source": "src/Top-Util-Option.html#OptionAccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "getOption",
          "package": "Top",
          "partial": "Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:getOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "ignoreOption",
          "package": "Top",
          "signature": "Option a -\u003e OptionAccess m a",
          "source": "src/Top-Util-Option.html#ignoreOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "ignoreOption",
          "normalized": "Option a-\u003eOptionAccess b a",
          "package": "Top",
          "partial": "Option",
          "signature": "Option a-\u003eOptionAccess m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:ignoreOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "option",
          "package": "Top",
          "signature": "a -\u003e String -\u003e Option a",
          "source": "src/Top-Util-Option.html#option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "option",
          "normalized": "a-\u003eString-\u003eOption a",
          "package": "Top",
          "signature": "a-\u003eString-\u003eOption a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "optionAccessTrans",
          "package": "Top",
          "signature": "(forall a.  m1 a -\u003e m2 a) -\u003e OptionAccess m1 b -\u003e OptionAccess m2 b",
          "source": "src/Top-Util-Option.html#optionAccessTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "optionAccessTrans",
          "normalized": "(a b c d-\u003ec d)-\u003eOptionAccess c e-\u003eOptionAccess c e",
          "package": "Top",
          "partial": "Access Trans",
          "signature": "(forall a. m a-\u003em a)-\u003eOptionAccess m b-\u003eOptionAccess m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:optionAccessTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "optionDescription",
          "package": "Top",
          "signature": "String",
          "source": "src/Top-Util-Option.html#Option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "optionDescription",
          "package": "Top",
          "partial": "Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:optionDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "setOption",
          "package": "Top",
          "signature": "a -\u003e m ()",
          "source": "src/Top-Util-Option.html#OptionAccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "setOption",
          "normalized": "a-\u003eb()",
          "package": "Top",
          "partial": "Option",
          "signature": "a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:setOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Top.Util.Option",
          "name": "useOption",
          "package": "Top",
          "signature": "(s -\u003e Option a) -\u003e (Option a -\u003e s -\u003e s) -\u003e OptionAccess m a",
          "source": "src/Top-Util-Option.html#useOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Top Util Option",
          "module": "Top.Util.Option",
          "name": "useOption",
          "normalized": "(a-\u003eOption b)-\u003e(Option b-\u003ea-\u003ea)-\u003eOptionAccess c b",
          "package": "Top",
          "partial": "Option",
          "signature": "(s-\u003eOption a)-\u003e(Option a-\u003es-\u003es)-\u003eOptionAccess m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Top/docs/Top-Util-Option.html#v:useOption"
      }
    }
  ]
]