[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "semaphore-plus"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.LightSwitch",
          "name": "LightSwitch",
          "package": "semaphore-plus",
          "source": "src/Control-Concurrent-LightSwitch.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Concurrent LightSwitch",
          "module": "Control.Concurrent.LightSwitch",
          "name": "LightSwitch",
          "package": "semaphore-plus",
          "partial": "Light Switch",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-LightSwitch.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.LightSwitch",
          "name": "LightSwitch",
          "package": "semaphore-plus",
          "source": "src/Control-Concurrent-LightSwitch.html#LightSwitch",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Concurrent LightSwitch",
          "module": "Control.Concurrent.LightSwitch",
          "name": "LightSwitch",
          "package": "semaphore-plus",
          "partial": "Light Switch",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-LightSwitch.html#t:LightSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.LightSwitch",
          "name": "lockLightSwitch",
          "package": "semaphore-plus",
          "signature": "LightSwitch -\u003e IO ()",
          "source": "src/Control-Concurrent-LightSwitch.html#lockLightSwitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent LightSwitch",
          "module": "Control.Concurrent.LightSwitch",
          "name": "lockLightSwitch",
          "normalized": "LightSwitch-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Light Switch",
          "signature": "LightSwitch-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-LightSwitch.html#v:lockLightSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.LightSwitch",
          "name": "newLightSwitch",
          "package": "semaphore-plus",
          "signature": "QSem -\u003e IO LightSwitch",
          "source": "src/Control-Concurrent-LightSwitch.html#newLightSwitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent LightSwitch",
          "module": "Control.Concurrent.LightSwitch",
          "name": "newLightSwitch",
          "normalized": "QSem-\u003eIO LightSwitch",
          "package": "semaphore-plus",
          "partial": "Light Switch",
          "signature": "QSem-\u003eIO LightSwitch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-LightSwitch.html#v:newLightSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.LightSwitch",
          "name": "unlockLightSwitch",
          "package": "semaphore-plus",
          "signature": "LightSwitch -\u003e IO ()",
          "source": "src/Control-Concurrent-LightSwitch.html#unlockLightSwitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent LightSwitch",
          "module": "Control.Concurrent.LightSwitch",
          "name": "unlockLightSwitch",
          "normalized": "LightSwitch-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Light Switch",
          "signature": "LightSwitch-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-LightSwitch.html#v:unlockLightSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.LightSwitch",
          "name": "withLightSwitch",
          "package": "semaphore-plus",
          "signature": "LightSwitch -\u003e IO () -\u003e IO ()",
          "source": "src/Control-Concurrent-LightSwitch.html#withLightSwitch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent LightSwitch",
          "module": "Control.Concurrent.LightSwitch",
          "name": "withLightSwitch",
          "normalized": "LightSwitch-\u003eIO()-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Light Switch",
          "signature": "LightSwitch-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-LightSwitch.html#v:withLightSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "ReadWriteLock",
          "package": "semaphore-plus",
          "source": "src/Control-Concurrent-ReadWriteLock.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "ReadWriteLock",
          "package": "semaphore-plus",
          "partial": "Read Write Lock",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "ReadWriteLock",
          "package": "semaphore-plus",
          "source": "src/Control-Concurrent-ReadWriteLock.html#ReadWriteLock",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "ReadWriteLock",
          "package": "semaphore-plus",
          "partial": "Read Write Lock",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#t:ReadWriteLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "newReadWriteLock",
          "package": "semaphore-plus",
          "signature": "IO ReadWriteLock",
          "source": "src/Control-Concurrent-ReadWriteLock.html#newReadWriteLock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "newReadWriteLock",
          "package": "semaphore-plus",
          "partial": "Read Write Lock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#v:newReadWriteLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "readLock",
          "package": "semaphore-plus",
          "signature": "ReadWriteLock -\u003e IO ()",
          "source": "src/Control-Concurrent-ReadWriteLock.html#readLock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "readLock",
          "normalized": "ReadWriteLock-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Lock",
          "signature": "ReadWriteLock-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#v:readLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "readUnlock",
          "package": "semaphore-plus",
          "signature": "ReadWriteLock -\u003e IO ()",
          "source": "src/Control-Concurrent-ReadWriteLock.html#readUnlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "readUnlock",
          "normalized": "ReadWriteLock-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Unlock",
          "signature": "ReadWriteLock-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#v:readUnlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "withReadLock",
          "package": "semaphore-plus",
          "signature": "ReadWriteLock -\u003e IO () -\u003e IO ()",
          "source": "src/Control-Concurrent-ReadWriteLock.html#withReadLock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "withReadLock",
          "normalized": "ReadWriteLock-\u003eIO()-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Read Lock",
          "signature": "ReadWriteLock-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#v:withReadLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "withWriteLock",
          "package": "semaphore-plus",
          "signature": "ReadWriteLock -\u003e IO () -\u003e IO ()",
          "source": "src/Control-Concurrent-ReadWriteLock.html#withWriteLock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "withWriteLock",
          "normalized": "ReadWriteLock-\u003eIO()-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Write Lock",
          "signature": "ReadWriteLock-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#v:withWriteLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "writeLock",
          "package": "semaphore-plus",
          "signature": "ReadWriteLock -\u003e IO ()",
          "source": "src/Control-Concurrent-ReadWriteLock.html#writeLock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "writeLock",
          "normalized": "ReadWriteLock-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Lock",
          "signature": "ReadWriteLock-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#v:writeLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "writeUnlock",
          "package": "semaphore-plus",
          "signature": "ReadWriteLock -\u003e IO ()",
          "source": "src/Control-Concurrent-ReadWriteLock.html#writeUnlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ReadWriteLock",
          "module": "Control.Concurrent.ReadWriteLock",
          "name": "writeUnlock",
          "normalized": "ReadWriteLock-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "Unlock",
          "signature": "ReadWriteLock-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-ReadWriteLock.html#v:writeUnlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.Util",
          "name": "Util",
          "package": "semaphore-plus",
          "source": "src/Control-Concurrent-Util.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Concurrent Util",
          "module": "Control.Concurrent.Util",
          "name": "Util",
          "package": "semaphore-plus",
          "partial": "Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-Util.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.Util",
          "name": "withQSem",
          "package": "semaphore-plus",
          "signature": "QSem -\u003e IO () -\u003e IO ()",
          "source": "src/Control-Concurrent-Util.html#withQSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent Util",
          "module": "Control.Concurrent.Util",
          "name": "withQSem",
          "normalized": "QSem-\u003eIO()-\u003eIO()",
          "package": "semaphore-plus",
          "partial": "QSem",
          "signature": "QSem-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/semaphore-plus/docs/Control-Concurrent-Util.html#v:withQSem"
      }
    }
  ]
]