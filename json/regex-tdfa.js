[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "regex-tdfa"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "CharMap2",
          "package": "regex-tdfa",
          "source": "src/Data-IntMap-CharMap2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "CharMap2",
          "package": "regex-tdfa",
          "partial": "Char Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "CharMap",
          "package": "regex-tdfa",
          "source": "src/Data-IntMap-CharMap2.html#CharMap",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "CharMap",
          "package": "regex-tdfa",
          "partial": "Char Map",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#t:CharMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "Key",
          "package": "regex-tdfa",
          "source": "src/Data-IntMap-CharMap2.html#Key",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "Key",
          "package": "regex-tdfa",
          "partial": "Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "(!)",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e Key -\u003e a",
          "source": "src/Data-IntMap-CharMap2.html#%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "(!) !",
          "normalized": "CharMap a-\u003eKey-\u003ea",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003eKey-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "(\\\\)",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e CharMap b -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "(\\\\) \\\\",
          "normalized": "CharMap a-\u003eCharMap b-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003eCharMap b-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "CharMap",
          "package": "regex-tdfa",
          "signature": "CharMap",
          "source": "src/Data-IntMap-CharMap2.html#CharMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "CharMap",
          "package": "regex-tdfa",
          "partial": "Char Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:CharMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "adjust",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a) -\u003e Key -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#adjust",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "adjust",
          "normalized": "(a-\u003ea)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "(a-\u003ea)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "adjustWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e a) -\u003e Key -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#adjustWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "adjustWithKey",
          "normalized": "(Key-\u003ea-\u003ea)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:adjustWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "assocs",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e [(Key, a)]",
          "source": "src/Data-IntMap-CharMap2.html#assocs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "assocs",
          "normalized": "CharMap a-\u003e[(Key,a)]",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003e[(Key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:assocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "delete",
          "package": "regex-tdfa",
          "signature": "Key -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#delete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "delete",
          "normalized": "Key-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "Key-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "difference",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e CharMap b -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#difference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "difference",
          "normalized": "CharMap a-\u003eCharMap b-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003eCharMap b-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "differenceWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e Maybe a) -\u003e CharMap a -\u003e CharMap b -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#differenceWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "differenceWith",
          "normalized": "(a-\u003eb-\u003eMaybe a)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003eb-\u003eMaybe a)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:differenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "differenceWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e b -\u003e Maybe a) -\u003e CharMap a -\u003e CharMap b -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#differenceWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "differenceWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eMaybe a)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eMaybe a)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:differenceWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "elems",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e [a]",
          "source": "src/Data-IntMap-CharMap2.html#elems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "elems",
          "normalized": "CharMap a-\u003e[a]",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "empty",
          "package": "regex-tdfa",
          "signature": "CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "empty",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "filter",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Bool) -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#filter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "(a-\u003eBool)-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "filterWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e Bool) -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#filterWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "filterWithKey",
          "normalized": "(Key-\u003ea-\u003eBool)-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eBool)-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:filterWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "findWithDefault",
          "package": "regex-tdfa",
          "signature": "a -\u003e Key -\u003e CharMap a -\u003e a",
          "source": "src/Data-IntMap-CharMap2.html#findWithDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "findWithDefault",
          "normalized": "a-\u003eKey-\u003eCharMap a-\u003ea",
          "package": "regex-tdfa",
          "partial": "With Default",
          "signature": "a-\u003eKey-\u003eCharMap a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:findWithDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fold",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e CharMap a -\u003e b",
          "source": "src/Data-IntMap-CharMap2.html#fold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fold",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eCharMap a-\u003eb",
          "package": "regex-tdfa",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eCharMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "foldWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e CharMap a -\u003e b",
          "source": "src/Data-IntMap-CharMap2.html#foldWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "foldWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eCharMap a-\u003eb",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eCharMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:foldWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fromAscList",
          "package": "regex-tdfa",
          "signature": "[(Key, a)] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#fromAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fromAscList",
          "normalized": "[(Key,a)]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "Asc List",
          "signature": "[(Key,a)]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fromAscListWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#fromAscListWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fromAscListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "Asc List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fromAscListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fromAscListWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#fromAscListWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fromAscListWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "Asc List With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fromAscListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fromDistinctAscList",
          "package": "regex-tdfa",
          "signature": "[(Key, a)] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fromDistinctAscList",
          "normalized": "[(Key,a)]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "Distinct Asc List",
          "signature": "[(Key,a)]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fromList",
          "package": "regex-tdfa",
          "signature": "[(Key, a)] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fromList",
          "normalized": "[(Key,a)]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "List",
          "signature": "[(Key,a)]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fromListWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#fromListWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fromListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fromListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "fromListWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#fromListWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "fromListWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "List With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:fromListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "insert",
          "package": "regex-tdfa",
          "signature": "Key -\u003e a -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#insert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "insert",
          "normalized": "Key-\u003ea-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "Key-\u003ea-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "insertLookupWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e CharMap a -\u003e (Maybe a, CharMap a)",
          "source": "src/Data-IntMap-CharMap2.html#insertLookupWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "insertLookupWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eCharMap a-\u003e(Maybe a,CharMap a)",
          "package": "regex-tdfa",
          "partial": "Lookup With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eCharMap a-\u003e(Maybe a,CharMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:insertLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "insertWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#insertWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "insertWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:insertWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "insertWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#insertWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "insertWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:insertWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "intersection",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e CharMap b -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#intersection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "intersection",
          "normalized": "CharMap a-\u003eCharMap b-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003eCharMap b-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "intersectionWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e a) -\u003e CharMap a -\u003e CharMap b -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#intersectionWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "intersectionWith",
          "normalized": "(a-\u003eb-\u003ea)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ea)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:intersectionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "intersectionWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e b -\u003e a) -\u003e CharMap a -\u003e CharMap b -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#intersectionWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "intersectionWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003ea)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003ea)-\u003eCharMap a-\u003eCharMap b-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:intersectionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "isProperSubmapOf",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e CharMap a -\u003e Bool",
          "source": "src/Data-IntMap-CharMap2.html#isProperSubmapOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "isProperSubmapOf",
          "normalized": "CharMap a-\u003eCharMap a-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Proper Submap Of",
          "signature": "CharMap a-\u003eCharMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:isProperSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "isProperSubmapOfBy",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e CharMap a -\u003e CharMap b -\u003e Bool",
          "source": "src/Data-IntMap-CharMap2.html#isProperSubmapOfBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "isProperSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eCharMap a-\u003eCharMap b-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Proper Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eCharMap a-\u003eCharMap b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:isProperSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "isSubmapOf",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e CharMap a -\u003e Bool",
          "source": "src/Data-IntMap-CharMap2.html#isSubmapOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "isSubmapOf",
          "normalized": "CharMap a-\u003eCharMap a-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Submap Of",
          "signature": "CharMap a-\u003eCharMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:isSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "isSubmapOfBy",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e CharMap a -\u003e CharMap b -\u003e Bool",
          "source": "src/Data-IntMap-CharMap2.html#isSubmapOfBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "isSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eCharMap a-\u003eCharMap b-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eCharMap a-\u003eCharMap b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:isSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "keys",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e [Key]",
          "source": "src/Data-IntMap-CharMap2.html#keys",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "keys",
          "normalized": "CharMap a-\u003e[Key]",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003e[Key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "keysSet",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e IntSet",
          "source": "src/Data-IntMap-CharMap2.html#keysSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "keysSet",
          "normalized": "CharMap a-\u003eIntSet",
          "package": "regex-tdfa",
          "partial": "Set",
          "signature": "CharMap a-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:keysSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "lookup",
          "package": "regex-tdfa",
          "signature": "Key -\u003e CharMap a -\u003e Maybe a",
          "source": "src/Data-IntMap-CharMap2.html#lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "lookup",
          "normalized": "Key-\u003eCharMap a-\u003eMaybe a",
          "package": "regex-tdfa",
          "signature": "Key-\u003eCharMap a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "map",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b) -\u003e CharMap a -\u003e CharMap b",
          "source": "src/Data-IntMap-CharMap2.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eCharMap a-\u003eCharMap b",
          "package": "regex-tdfa",
          "signature": "(a-\u003eb)-\u003eCharMap a-\u003eCharMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "mapAccum",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e CharMap b -\u003e (a, CharMap c)",
          "source": "src/Data-IntMap-CharMap2.html#mapAccum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "mapAccum",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eCharMap b-\u003e(a,CharMap c)",
          "package": "regex-tdfa",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eCharMap b-\u003e(a,CharMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:mapAccum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "mapAccumWithKey",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Key -\u003e b -\u003e (a, c)) -\u003e a -\u003e CharMap b -\u003e (a, CharMap c)",
          "source": "src/Data-IntMap-CharMap2.html#mapAccumWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "mapAccumWithKey",
          "normalized": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eCharMap b-\u003e(a,CharMap c)",
          "package": "regex-tdfa",
          "partial": "Accum With Key",
          "signature": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eCharMap b-\u003e(a,CharMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:mapAccumWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "mapEither",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Either b c) -\u003e CharMap a -\u003e (CharMap b, CharMap c)",
          "source": "src/Data-IntMap-CharMap2.html#mapEither",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "mapEither",
          "normalized": "(a-\u003eEither b c)-\u003eCharMap a-\u003e(CharMap b,CharMap c)",
          "package": "regex-tdfa",
          "partial": "Either",
          "signature": "(a-\u003eEither b c)-\u003eCharMap a-\u003e(CharMap b,CharMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:mapEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "mapEitherWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e Either b c) -\u003e CharMap a -\u003e (CharMap b, CharMap c)",
          "source": "src/Data-IntMap-CharMap2.html#mapEitherWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "mapEitherWithKey",
          "normalized": "(Key-\u003ea-\u003eEither b c)-\u003eCharMap a-\u003e(CharMap b,CharMap c)",
          "package": "regex-tdfa",
          "partial": "Either With Key",
          "signature": "(Key-\u003ea-\u003eEither b c)-\u003eCharMap a-\u003e(CharMap b,CharMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:mapEitherWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "mapMaybe",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Maybe b) -\u003e CharMap a -\u003e CharMap b",
          "source": "src/Data-IntMap-CharMap2.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eCharMap a-\u003eCharMap b",
          "package": "regex-tdfa",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eCharMap a-\u003eCharMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "mapMaybeWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e Maybe b) -\u003e CharMap a -\u003e CharMap b",
          "source": "src/Data-IntMap-CharMap2.html#mapMaybeWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "mapMaybeWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe b)-\u003eCharMap a-\u003eCharMap b",
          "package": "regex-tdfa",
          "partial": "Maybe With Key",
          "signature": "(Key-\u003ea-\u003eMaybe b)-\u003eCharMap a-\u003eCharMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:mapMaybeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "mapWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e b) -\u003e CharMap a -\u003e CharMap b",
          "source": "src/Data-IntMap-CharMap2.html#mapWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "mapWithKey",
          "normalized": "(Key-\u003ea-\u003eb)-\u003eCharMap a-\u003eCharMap b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb)-\u003eCharMap a-\u003eCharMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:mapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "member",
          "package": "regex-tdfa",
          "signature": "Key -\u003e CharMap a -\u003e Bool",
          "source": "src/Data-IntMap-CharMap2.html#member",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "member",
          "normalized": "Key-\u003eCharMap a-\u003eBool",
          "package": "regex-tdfa",
          "signature": "Key-\u003eCharMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "notMember",
          "package": "regex-tdfa",
          "signature": "Key -\u003e CharMap a -\u003e Bool",
          "source": "src/Data-IntMap-CharMap2.html#notMember",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "notMember",
          "normalized": "Key-\u003eCharMap a-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Member",
          "signature": "Key-\u003eCharMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:notMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "null",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e Bool",
          "source": "src/Data-IntMap-CharMap2.html#null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "null",
          "normalized": "CharMap a-\u003eBool",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "partition",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Bool) -\u003e CharMap a -\u003e (CharMap a, CharMap a)",
          "source": "src/Data-IntMap-CharMap2.html#partition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eCharMap a-\u003e(CharMap a,CharMap a)",
          "package": "regex-tdfa",
          "signature": "(a-\u003eBool)-\u003eCharMap a-\u003e(CharMap a,CharMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "partitionWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e Bool) -\u003e CharMap a -\u003e (CharMap a, CharMap a)",
          "source": "src/Data-IntMap-CharMap2.html#partitionWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "partitionWithKey",
          "normalized": "(Key-\u003ea-\u003eBool)-\u003eCharMap a-\u003e(CharMap a,CharMap a)",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eBool)-\u003eCharMap a-\u003e(CharMap a,CharMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:partitionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "showTree",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e String",
          "source": "src/Data-IntMap-CharMap2.html#showTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "showTree",
          "normalized": "CharMap a-\u003eString",
          "package": "regex-tdfa",
          "partial": "Tree",
          "signature": "CharMap a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "showTreeWith",
          "package": "regex-tdfa",
          "signature": "Bool -\u003e Bool -\u003e CharMap a -\u003e String",
          "source": "src/Data-IntMap-CharMap2.html#showTreeWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "showTreeWith",
          "normalized": "Bool-\u003eBool-\u003eCharMap a-\u003eString",
          "package": "regex-tdfa",
          "partial": "Tree With",
          "signature": "Bool-\u003eBool-\u003eCharMap a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:showTreeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "singleton",
          "package": "regex-tdfa",
          "signature": "Key -\u003e a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "singleton",
          "normalized": "Key-\u003ea-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "Key-\u003ea-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "size",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e Int",
          "source": "src/Data-IntMap-CharMap2.html#size",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "size",
          "normalized": "CharMap a-\u003eInt",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "split",
          "package": "regex-tdfa",
          "signature": "Key -\u003e CharMap a -\u003e (CharMap a, CharMap a)",
          "source": "src/Data-IntMap-CharMap2.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "split",
          "normalized": "Key-\u003eCharMap a-\u003e(CharMap a,CharMap a)",
          "package": "regex-tdfa",
          "signature": "Key-\u003eCharMap a-\u003e(CharMap a,CharMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "splitLookup",
          "package": "regex-tdfa",
          "signature": "Key -\u003e CharMap a -\u003e (CharMap a, Maybe a, CharMap a)",
          "source": "src/Data-IntMap-CharMap2.html#splitLookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "splitLookup",
          "normalized": "Key-\u003eCharMap a-\u003e(CharMap a,Maybe a,CharMap a)",
          "package": "regex-tdfa",
          "partial": "Lookup",
          "signature": "Key-\u003eCharMap a-\u003e(CharMap a,Maybe a,CharMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:splitLookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "toAscList",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e [(Key, a)]",
          "source": "src/Data-IntMap-CharMap2.html#toAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "toAscList",
          "normalized": "CharMap a-\u003e[(Key,a)]",
          "package": "regex-tdfa",
          "partial": "Asc List",
          "signature": "CharMap a-\u003e[(Key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:toAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "toList",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e [(Key, a)]",
          "source": "src/Data-IntMap-CharMap2.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "toList",
          "normalized": "CharMap a-\u003e[(Key,a)]",
          "package": "regex-tdfa",
          "partial": "List",
          "signature": "CharMap a-\u003e[(Key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "unCharMap",
          "package": "regex-tdfa",
          "signature": "IntMap a",
          "source": "src/Data-IntMap-CharMap2.html#CharMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "unCharMap",
          "package": "regex-tdfa",
          "partial": "Char Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:unCharMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "union",
          "package": "regex-tdfa",
          "signature": "CharMap a -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#union",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "union",
          "normalized": "CharMap a-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "CharMap a-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "unionWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e CharMap a -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#unionWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "unionWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eCharMap a-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eCharMap a-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:unionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "unionWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e CharMap a -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#unionWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "unionWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eCharMap a-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eCharMap a-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:unionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "unions",
          "package": "regex-tdfa",
          "signature": "[CharMap a] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#unions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "unions",
          "normalized": "[CharMap a]-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "[CharMap a]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "unionsWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e [CharMap a] -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#unionsWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "unionsWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[CharMap a]-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[CharMap a]-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:unionsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "update",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Maybe a) -\u003e Key -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "update",
          "normalized": "(a-\u003eMaybe a)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "signature": "(a-\u003eMaybe a)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "updateLookupWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e Key -\u003e CharMap a -\u003e (Maybe a, CharMap a)",
          "source": "src/Data-IntMap-CharMap2.html#updateLookupWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "updateLookupWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eCharMap a-\u003e(Maybe a,CharMap a)",
          "package": "regex-tdfa",
          "partial": "Lookup With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eCharMap a-\u003e(Maybe a,CharMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:updateLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.CharMap2",
          "name": "updateWithKey",
          "package": "regex-tdfa",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e Key -\u003e CharMap a -\u003e CharMap a",
          "source": "src/Data-IntMap-CharMap2.html#updateWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap CharMap2",
          "module": "Data.IntMap.CharMap2",
          "name": "updateWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eCharMap a-\u003eCharMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-CharMap2.html#v:updateWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "EnumMap2",
          "package": "regex-tdfa",
          "source": "src/Data-IntMap-EnumMap2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "EnumMap2",
          "package": "regex-tdfa",
          "partial": "Enum Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "EnumMap",
          "package": "regex-tdfa",
          "source": "src/Data-IntMap-EnumMap2.html#EnumMap",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "EnumMap",
          "package": "regex-tdfa",
          "partial": "Enum Map",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#t:EnumMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "(!)",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e key -\u003e a",
          "source": "src/Data-IntMap-EnumMap2.html#%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "(!) !",
          "normalized": "EnumMap a b-\u003ea-\u003eb",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003ekey-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "(\\\\)",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e EnumMap key b -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "(\\\\) \\\\",
          "normalized": "EnumMap a b-\u003eEnumMap a c-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003eEnumMap key b-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "EnumMap",
          "package": "regex-tdfa",
          "signature": "EnumMap",
          "source": "src/Data-IntMap-EnumMap2.html#EnumMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "EnumMap",
          "package": "regex-tdfa",
          "partial": "Enum Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:EnumMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "adjust",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a) -\u003e key -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#adjust",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "adjust",
          "normalized": "(a-\u003ea)-\u003eb-\u003eEnumMap b a-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "signature": "(a-\u003ea)-\u003ekey-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "adjustWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e a) -\u003e key -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#adjustWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "adjustWithKey",
          "normalized": "(a-\u003eb-\u003eb)-\u003ea-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003ea)-\u003ekey-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:adjustWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "assocs",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e [(key, a)]",
          "source": "src/Data-IntMap-EnumMap2.html#assocs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "assocs",
          "normalized": "EnumMap a b-\u003e[(a,b)]",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003e[(key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:assocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "delete",
          "package": "regex-tdfa",
          "signature": "key -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#delete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "delete",
          "normalized": "a-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "key-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "difference",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e EnumMap key b -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#difference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "difference",
          "normalized": "EnumMap a b-\u003eEnumMap a c-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003eEnumMap key b-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "differenceWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e Maybe a) -\u003e EnumMap key a -\u003e EnumMap key b -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#differenceWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "differenceWith",
          "normalized": "(a-\u003eb-\u003eMaybe a)-\u003eEnumMap c a-\u003eEnumMap c b-\u003eEnumMap c a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003eb-\u003eMaybe a)-\u003eEnumMap key a-\u003eEnumMap key b-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:differenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "differenceWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e b -\u003e Maybe a) -\u003e EnumMap key a -\u003e EnumMap key b -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#differenceWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "differenceWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003eMaybe b)-\u003eEnumMap a b-\u003eEnumMap a c-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003eb-\u003eMaybe a)-\u003eEnumMap key a-\u003eEnumMap key b-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:differenceWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "elems",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e [a]",
          "source": "src/Data-IntMap-EnumMap2.html#elems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "elems",
          "normalized": "EnumMap a b-\u003e[b]",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "empty",
          "package": "regex-tdfa",
          "signature": "EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "empty",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "filter",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Bool) -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#filter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eEnumMap b a-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "signature": "(a-\u003eBool)-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "filterWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e Bool) -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#filterWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "filterWithKey",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003eBool)-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:filterWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "findWithDefault",
          "package": "regex-tdfa",
          "signature": "a -\u003e key -\u003e EnumMap key a -\u003e a",
          "source": "src/Data-IntMap-EnumMap2.html#findWithDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "findWithDefault",
          "normalized": "a-\u003eb-\u003eEnumMap b a-\u003ea",
          "package": "regex-tdfa",
          "partial": "With Default",
          "signature": "a-\u003ekey-\u003eEnumMap key a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:findWithDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fold",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e EnumMap key a -\u003e b",
          "source": "src/Data-IntMap-EnumMap2.html#fold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fold",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eEnumMap c a-\u003eb",
          "package": "regex-tdfa",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eEnumMap key a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "foldWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e EnumMap key a -\u003e b",
          "source": "src/Data-IntMap-EnumMap2.html#foldWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "foldWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003ec)-\u003ec-\u003eEnumMap a b-\u003ec",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eEnumMap key a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:foldWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fromAscList",
          "package": "regex-tdfa",
          "signature": "[(key, a)] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#fromAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fromAscList",
          "normalized": "[(a,b)]-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "Asc List",
          "signature": "[(key,a)]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fromAscListWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(key, a)] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#fromAscListWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fromAscListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(b,a)]-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "partial": "Asc List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(key,a)]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fromAscListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fromAscListWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e a -\u003e a) -\u003e [(key, a)] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#fromAscListWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fromAscListWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003e[(a,b)]-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "Asc List With Key",
          "signature": "(key-\u003ea-\u003ea-\u003ea)-\u003e[(key,a)]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fromAscListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fromDistinctAscList",
          "package": "regex-tdfa",
          "signature": "[(key, a)] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fromDistinctAscList",
          "normalized": "[(a,b)]-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "Distinct Asc List",
          "signature": "[(key,a)]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fromList",
          "package": "regex-tdfa",
          "signature": "[(key, a)] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fromList",
          "normalized": "[(a,b)]-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "List",
          "signature": "[(key,a)]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fromListWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(key, a)] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#fromListWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fromListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(b,a)]-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "partial": "List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(key,a)]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fromListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "fromListWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e a -\u003e a) -\u003e [(key, a)] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#fromListWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "fromListWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003e[(a,b)]-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "List With Key",
          "signature": "(key-\u003ea-\u003ea-\u003ea)-\u003e[(key,a)]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:fromListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "insert",
          "package": "regex-tdfa",
          "signature": "key -\u003e a -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#insert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "insert",
          "normalized": "a-\u003eb-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "key-\u003ea-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "insertLookupWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e a -\u003e a) -\u003e key -\u003e a -\u003e EnumMap key a -\u003e (Maybe a, EnumMap key a)",
          "source": "src/Data-IntMap-EnumMap2.html#insertLookupWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "insertLookupWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eEnumMap a b-\u003e(Maybe b,EnumMap a b)",
          "package": "regex-tdfa",
          "partial": "Lookup With Key",
          "signature": "(key-\u003ea-\u003ea-\u003ea)-\u003ekey-\u003ea-\u003eEnumMap key a-\u003e(Maybe a,EnumMap key a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:insertLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "insertWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e key -\u003e a -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#insertWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "insertWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb-\u003ea-\u003eEnumMap b a-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003ekey-\u003ea-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:insertWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "insertWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e a -\u003e a) -\u003e key -\u003e a -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#insertWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "insertWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003ea-\u003ea)-\u003ekey-\u003ea-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:insertWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "intersection",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e EnumMap key b -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#intersection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "intersection",
          "normalized": "EnumMap a b-\u003eEnumMap a c-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003eEnumMap key b-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "intersectionWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e a) -\u003e EnumMap key a -\u003e EnumMap key b -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#intersectionWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "intersectionWith",
          "normalized": "(a-\u003eb-\u003ea)-\u003eEnumMap c a-\u003eEnumMap c b-\u003eEnumMap c a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ea)-\u003eEnumMap key a-\u003eEnumMap key b-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:intersectionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "intersectionWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e b -\u003e a) -\u003e EnumMap key a -\u003e EnumMap key b -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#intersectionWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "intersectionWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003eb)-\u003eEnumMap a b-\u003eEnumMap a c-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003eb-\u003ea)-\u003eEnumMap key a-\u003eEnumMap key b-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:intersectionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "isProperSubmapOf",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e EnumMap key a -\u003e Bool",
          "source": "src/Data-IntMap-EnumMap2.html#isProperSubmapOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "isProperSubmapOf",
          "normalized": "EnumMap a b-\u003eEnumMap a b-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Proper Submap Of",
          "signature": "EnumMap key a-\u003eEnumMap key a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:isProperSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "isProperSubmapOfBy",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e EnumMap key a -\u003e EnumMap key b -\u003e Bool",
          "source": "src/Data-IntMap-EnumMap2.html#isProperSubmapOfBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "isProperSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eEnumMap c a-\u003eEnumMap c b-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Proper Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eEnumMap key a-\u003eEnumMap key b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:isProperSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "isSubmapOf",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e EnumMap key a -\u003e Bool",
          "source": "src/Data-IntMap-EnumMap2.html#isSubmapOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "isSubmapOf",
          "normalized": "EnumMap a b-\u003eEnumMap a b-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Submap Of",
          "signature": "EnumMap key a-\u003eEnumMap key a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:isSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "isSubmapOfBy",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e EnumMap key a -\u003e EnumMap key b -\u003e Bool",
          "source": "src/Data-IntMap-EnumMap2.html#isSubmapOfBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "isSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eEnumMap c a-\u003eEnumMap c b-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eEnumMap key a-\u003eEnumMap key b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:isSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "keys",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e [key]",
          "source": "src/Data-IntMap-EnumMap2.html#keys",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "keys",
          "normalized": "EnumMap a b-\u003e[a]",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003e[key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "keysSet",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e EnumSet key",
          "source": "src/Data-IntMap-EnumMap2.html#keysSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "keysSet",
          "normalized": "EnumMap a b-\u003eEnumSet a",
          "package": "regex-tdfa",
          "partial": "Set",
          "signature": "EnumMap key a-\u003eEnumSet key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:keysSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "lookup",
          "package": "regex-tdfa",
          "signature": "key -\u003e EnumMap key a -\u003e Maybe a",
          "source": "src/Data-IntMap-EnumMap2.html#lookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "lookup",
          "normalized": "a-\u003eEnumMap a b-\u003eMaybe b",
          "package": "regex-tdfa",
          "signature": "key-\u003eEnumMap key a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "map",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b) -\u003e EnumMap key a -\u003e EnumMap key b",
          "source": "src/Data-IntMap-EnumMap2.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eEnumMap c a-\u003eEnumMap c b",
          "package": "regex-tdfa",
          "signature": "(a-\u003eb)-\u003eEnumMap key a-\u003eEnumMap key b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "mapAccum",
          "package": "regex-tdfa",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e EnumMap key b -\u003e (a, EnumMap key c)",
          "source": "src/Data-IntMap-EnumMap2.html#mapAccum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "mapAccum",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eEnumMap d b-\u003e(a,EnumMap d c)",
          "package": "regex-tdfa",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eEnumMap key b-\u003e(a,EnumMap key c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:mapAccum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "mapAccumWithKey",
          "package": "regex-tdfa",
          "signature": "(a -\u003e key -\u003e b -\u003e (a, c)) -\u003e a -\u003e EnumMap key b -\u003e (a, EnumMap key c)",
          "source": "src/Data-IntMap-EnumMap2.html#mapAccumWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "mapAccumWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003e(a,d))-\u003ea-\u003eEnumMap b c-\u003e(a,EnumMap b d)",
          "package": "regex-tdfa",
          "partial": "Accum With Key",
          "signature": "(a-\u003ekey-\u003eb-\u003e(a,c))-\u003ea-\u003eEnumMap key b-\u003e(a,EnumMap key c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:mapAccumWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "mapEither",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Either b c) -\u003e EnumMap key a -\u003e (EnumMap key b, EnumMap key c)",
          "source": "src/Data-IntMap-EnumMap2.html#mapEither",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "mapEither",
          "normalized": "(a-\u003eEither b c)-\u003eEnumMap d a-\u003e(EnumMap d b,EnumMap d c)",
          "package": "regex-tdfa",
          "partial": "Either",
          "signature": "(a-\u003eEither b c)-\u003eEnumMap key a-\u003e(EnumMap key b,EnumMap key c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:mapEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "mapEitherWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e Either b c) -\u003e EnumMap key a -\u003e (EnumMap key b, EnumMap key c)",
          "source": "src/Data-IntMap-EnumMap2.html#mapEitherWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "mapEitherWithKey",
          "normalized": "(a-\u003eb-\u003eEither c d)-\u003eEnumMap a b-\u003e(EnumMap a c,EnumMap a d)",
          "package": "regex-tdfa",
          "partial": "Either With Key",
          "signature": "(key-\u003ea-\u003eEither b c)-\u003eEnumMap key a-\u003e(EnumMap key b,EnumMap key c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:mapEitherWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "mapMaybe",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Maybe b) -\u003e EnumMap key a -\u003e EnumMap key b",
          "source": "src/Data-IntMap-EnumMap2.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eEnumMap c a-\u003eEnumMap c b",
          "package": "regex-tdfa",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eEnumMap key a-\u003eEnumMap key b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "mapMaybeWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e Maybe b) -\u003e EnumMap key a -\u003e EnumMap key b",
          "source": "src/Data-IntMap-EnumMap2.html#mapMaybeWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "mapMaybeWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe c)-\u003eEnumMap a b-\u003eEnumMap a c",
          "package": "regex-tdfa",
          "partial": "Maybe With Key",
          "signature": "(key-\u003ea-\u003eMaybe b)-\u003eEnumMap key a-\u003eEnumMap key b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:mapMaybeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "mapWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e b) -\u003e EnumMap key a -\u003e EnumMap key b",
          "source": "src/Data-IntMap-EnumMap2.html#mapWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "mapWithKey",
          "normalized": "(a-\u003eb-\u003ec)-\u003eEnumMap a b-\u003eEnumMap a c",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003eb)-\u003eEnumMap key a-\u003eEnumMap key b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:mapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "member",
          "package": "regex-tdfa",
          "signature": "key -\u003e EnumMap key a -\u003e Bool",
          "source": "src/Data-IntMap-EnumMap2.html#member",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "member",
          "normalized": "a-\u003eEnumMap a b-\u003eBool",
          "package": "regex-tdfa",
          "signature": "key-\u003eEnumMap key a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "notMember",
          "package": "regex-tdfa",
          "signature": "key -\u003e EnumMap key a -\u003e Bool",
          "source": "src/Data-IntMap-EnumMap2.html#notMember",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "notMember",
          "normalized": "a-\u003eEnumMap a b-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Member",
          "signature": "key-\u003eEnumMap key a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:notMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "null",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e Bool",
          "source": "src/Data-IntMap-EnumMap2.html#null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "null",
          "normalized": "EnumMap a b-\u003eBool",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "partition",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Bool) -\u003e EnumMap key a -\u003e (EnumMap key a, EnumMap key a)",
          "source": "src/Data-IntMap-EnumMap2.html#partition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eEnumMap b a-\u003e(EnumMap b a,EnumMap b a)",
          "package": "regex-tdfa",
          "signature": "(a-\u003eBool)-\u003eEnumMap key a-\u003e(EnumMap key a,EnumMap key a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "partitionWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e Bool) -\u003e EnumMap key a -\u003e (EnumMap key a, EnumMap key a)",
          "source": "src/Data-IntMap-EnumMap2.html#partitionWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "partitionWithKey",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eEnumMap a b-\u003e(EnumMap a b,EnumMap a b)",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003eBool)-\u003eEnumMap key a-\u003e(EnumMap key a,EnumMap key a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:partitionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "showTree",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e String",
          "source": "src/Data-IntMap-EnumMap2.html#showTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "showTree",
          "normalized": "EnumMap a b-\u003eString",
          "package": "regex-tdfa",
          "partial": "Tree",
          "signature": "EnumMap key a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "showTreeWith",
          "package": "regex-tdfa",
          "signature": "Bool -\u003e Bool -\u003e EnumMap key a -\u003e String",
          "source": "src/Data-IntMap-EnumMap2.html#showTreeWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "showTreeWith",
          "normalized": "Bool-\u003eBool-\u003eEnumMap a b-\u003eString",
          "package": "regex-tdfa",
          "partial": "Tree With",
          "signature": "Bool-\u003eBool-\u003eEnumMap key a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:showTreeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "singleton",
          "package": "regex-tdfa",
          "signature": "key -\u003e a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "singleton",
          "normalized": "a-\u003eb-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "key-\u003ea-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "size",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e Int",
          "source": "src/Data-IntMap-EnumMap2.html#size",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "size",
          "normalized": "EnumMap a b-\u003eInt",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "split",
          "package": "regex-tdfa",
          "signature": "key -\u003e EnumMap key a -\u003e (EnumMap key a, EnumMap key a)",
          "source": "src/Data-IntMap-EnumMap2.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "split",
          "normalized": "a-\u003eEnumMap a b-\u003e(EnumMap a b,EnumMap a b)",
          "package": "regex-tdfa",
          "signature": "key-\u003eEnumMap key a-\u003e(EnumMap key a,EnumMap key a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "splitLookup",
          "package": "regex-tdfa",
          "signature": "key -\u003e EnumMap key a -\u003e (EnumMap key a, Maybe a, EnumMap key a)",
          "source": "src/Data-IntMap-EnumMap2.html#splitLookup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "splitLookup",
          "normalized": "a-\u003eEnumMap a b-\u003e(EnumMap a b,Maybe b,EnumMap a b)",
          "package": "regex-tdfa",
          "partial": "Lookup",
          "signature": "key-\u003eEnumMap key a-\u003e(EnumMap key a,Maybe a,EnumMap key a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:splitLookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "toAscList",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e [(key, a)]",
          "source": "src/Data-IntMap-EnumMap2.html#toAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "toAscList",
          "normalized": "EnumMap a b-\u003e[(a,b)]",
          "package": "regex-tdfa",
          "partial": "Asc List",
          "signature": "EnumMap key a-\u003e[(key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:toAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "toList",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e [(key, a)]",
          "source": "src/Data-IntMap-EnumMap2.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "toList",
          "normalized": "EnumMap a b-\u003e[(a,b)]",
          "package": "regex-tdfa",
          "partial": "List",
          "signature": "EnumMap key a-\u003e[(key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "unEnumMap",
          "package": "regex-tdfa",
          "signature": "IntMap a",
          "source": "src/Data-IntMap-EnumMap2.html#EnumMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "unEnumMap",
          "package": "regex-tdfa",
          "partial": "Enum Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:unEnumMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "union",
          "package": "regex-tdfa",
          "signature": "EnumMap key a -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#union",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "union",
          "normalized": "EnumMap a b-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "EnumMap key a-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "unionWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e EnumMap key a -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#unionWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "unionWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eEnumMap b a-\u003eEnumMap b a-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eEnumMap key a-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:unionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "unionWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e a -\u003e a) -\u003e EnumMap key a -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#unionWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "unionWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003eEnumMap a b-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003ea-\u003ea)-\u003eEnumMap key a-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:unionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "unions",
          "package": "regex-tdfa",
          "signature": "[EnumMap key a] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#unions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "unions",
          "normalized": "[EnumMap a b]-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "signature": "[EnumMap key a]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "unionsWith",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e a) -\u003e [EnumMap key a] -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#unionsWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "unionsWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[EnumMap b a]-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[EnumMap key a]-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:unionsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "update",
          "package": "regex-tdfa",
          "signature": "(a -\u003e Maybe a) -\u003e key -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "update",
          "normalized": "(a-\u003eMaybe a)-\u003eb-\u003eEnumMap b a-\u003eEnumMap b a",
          "package": "regex-tdfa",
          "signature": "(a-\u003eMaybe a)-\u003ekey-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "updateLookupWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e Maybe a) -\u003e key -\u003e EnumMap key a -\u003e (Maybe a, EnumMap key a)",
          "source": "src/Data-IntMap-EnumMap2.html#updateLookupWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "updateLookupWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003ea-\u003eEnumMap a b-\u003e(Maybe b,EnumMap a b)",
          "package": "regex-tdfa",
          "partial": "Lookup With Key",
          "signature": "(key-\u003ea-\u003eMaybe a)-\u003ekey-\u003eEnumMap key a-\u003e(Maybe a,EnumMap key a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:updateLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.EnumMap2",
          "name": "updateWithKey",
          "package": "regex-tdfa",
          "signature": "(key -\u003e a -\u003e Maybe a) -\u003e key -\u003e EnumMap key a -\u003e EnumMap key a",
          "source": "src/Data-IntMap-EnumMap2.html#updateWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntMap EnumMap2",
          "module": "Data.IntMap.EnumMap2",
          "name": "updateWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003ea-\u003eEnumMap a b-\u003eEnumMap a b",
          "package": "regex-tdfa",
          "partial": "With Key",
          "signature": "(key-\u003ea-\u003eMaybe a)-\u003ekey-\u003eEnumMap key a-\u003eEnumMap key a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntMap-EnumMap2.html#v:updateWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "EnumSet2",
          "package": "regex-tdfa",
          "source": "src/Data-IntSet-EnumSet2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "EnumSet2",
          "package": "regex-tdfa",
          "partial": "Enum Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "EnumSet",
          "package": "regex-tdfa",
          "source": "src/Data-IntSet-EnumSet2.html#EnumSet",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "EnumSet",
          "package": "regex-tdfa",
          "partial": "Enum Set",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#t:EnumSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "(\\\\)",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "(\\\\) \\\\",
          "normalized": "EnumSet a-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "EnumSet e-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "EnumSet",
          "package": "regex-tdfa",
          "signature": "EnumSet",
          "source": "src/Data-IntSet-EnumSet2.html#EnumSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "EnumSet",
          "package": "regex-tdfa",
          "partial": "Enum Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:EnumSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "delete",
          "package": "regex-tdfa",
          "signature": "e -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#delete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "delete",
          "normalized": "a-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "e-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "difference",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#difference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "difference",
          "normalized": "EnumSet a-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "EnumSet e-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "elems",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e [e]",
          "source": "src/Data-IntSet-EnumSet2.html#elems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "elems",
          "normalized": "EnumSet a-\u003e[a]",
          "package": "regex-tdfa",
          "signature": "EnumSet e-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "empty",
          "package": "regex-tdfa",
          "signature": "EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "empty",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "filter",
          "package": "regex-tdfa",
          "signature": "(e -\u003e Bool) -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#filter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "(e-\u003eBool)-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "fold",
          "package": "regex-tdfa",
          "signature": "(e -\u003e b -\u003e b) -\u003e b -\u003e EnumSet e -\u003e b",
          "source": "src/Data-IntSet-EnumSet2.html#fold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "fold",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eEnumSet a-\u003eb",
          "package": "regex-tdfa",
          "signature": "(e-\u003eb-\u003eb)-\u003eb-\u003eEnumSet e-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "fromAscList",
          "package": "regex-tdfa",
          "signature": "[e] -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#fromAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "fromAscList",
          "normalized": "[a]-\u003eEnumSet a",
          "package": "regex-tdfa",
          "partial": "Asc List",
          "signature": "[e]-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "fromDistinctAscList",
          "package": "regex-tdfa",
          "signature": "[e] -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "fromDistinctAscList",
          "normalized": "[a]-\u003eEnumSet a",
          "package": "regex-tdfa",
          "partial": "Distinct Asc List",
          "signature": "[e]-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "fromList",
          "package": "regex-tdfa",
          "signature": "[e] -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "fromList",
          "normalized": "[a]-\u003eEnumSet a",
          "package": "regex-tdfa",
          "partial": "List",
          "signature": "[e]-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "insert",
          "package": "regex-tdfa",
          "signature": "e -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#insert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "insert",
          "normalized": "a-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "e-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "intersection",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#intersection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "intersection",
          "normalized": "EnumSet a-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "EnumSet e-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "isProperSubsetOf",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e EnumSet e -\u003e Bool",
          "source": "src/Data-IntSet-EnumSet2.html#isProperSubsetOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "isProperSubsetOf",
          "normalized": "EnumSet a-\u003eEnumSet a-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Proper Subset Of",
          "signature": "EnumSet e-\u003eEnumSet e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:isProperSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "isSubsetOf",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e EnumSet e -\u003e Bool",
          "source": "src/Data-IntSet-EnumSet2.html#isSubsetOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "isSubsetOf",
          "normalized": "EnumSet a-\u003eEnumSet a-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Subset Of",
          "signature": "EnumSet e-\u003eEnumSet e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:isSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "map",
          "package": "regex-tdfa",
          "signature": "(e -\u003e e) -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "map",
          "normalized": "(a-\u003ea)-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "(e-\u003ee)-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "member",
          "package": "regex-tdfa",
          "signature": "e -\u003e EnumSet e -\u003e Bool",
          "source": "src/Data-IntSet-EnumSet2.html#member",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "member",
          "normalized": "a-\u003eEnumSet a-\u003eBool",
          "package": "regex-tdfa",
          "signature": "e-\u003eEnumSet e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "notMember",
          "package": "regex-tdfa",
          "signature": "Int -\u003e EnumSet e -\u003e Bool",
          "source": "src/Data-IntSet-EnumSet2.html#notMember",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "notMember",
          "normalized": "Int-\u003eEnumSet a-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Member",
          "signature": "Int-\u003eEnumSet e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:notMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "null",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e Bool",
          "source": "src/Data-IntSet-EnumSet2.html#null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "null",
          "normalized": "EnumSet a-\u003eBool",
          "package": "regex-tdfa",
          "signature": "EnumSet e-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "partition",
          "package": "regex-tdfa",
          "signature": "(e -\u003e Bool) -\u003e EnumSet e -\u003e (EnumSet e, EnumSet e)",
          "source": "src/Data-IntSet-EnumSet2.html#partition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eEnumSet a-\u003e(EnumSet a,EnumSet a)",
          "package": "regex-tdfa",
          "signature": "(e-\u003eBool)-\u003eEnumSet e-\u003e(EnumSet e,EnumSet e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "showTree",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e String",
          "source": "src/Data-IntSet-EnumSet2.html#showTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "showTree",
          "normalized": "EnumSet a-\u003eString",
          "package": "regex-tdfa",
          "partial": "Tree",
          "signature": "EnumSet e-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "showTreeWith",
          "package": "regex-tdfa",
          "signature": "Bool -\u003e Bool -\u003e EnumSet e -\u003e String",
          "source": "src/Data-IntSet-EnumSet2.html#showTreeWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "showTreeWith",
          "normalized": "Bool-\u003eBool-\u003eEnumSet a-\u003eString",
          "package": "regex-tdfa",
          "partial": "Tree With",
          "signature": "Bool-\u003eBool-\u003eEnumSet e-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:showTreeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "singleton",
          "package": "regex-tdfa",
          "signature": "e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "singleton",
          "normalized": "a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "size",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e Int",
          "source": "src/Data-IntSet-EnumSet2.html#size",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "size",
          "normalized": "EnumSet a-\u003eInt",
          "package": "regex-tdfa",
          "signature": "EnumSet e-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "split",
          "package": "regex-tdfa",
          "signature": "e -\u003e EnumSet e -\u003e (EnumSet e, EnumSet e)",
          "source": "src/Data-IntSet-EnumSet2.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "split",
          "normalized": "a-\u003eEnumSet a-\u003e(EnumSet a,EnumSet a)",
          "package": "regex-tdfa",
          "signature": "e-\u003eEnumSet e-\u003e(EnumSet e,EnumSet e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "splitMember",
          "package": "regex-tdfa",
          "signature": "e -\u003e EnumSet e -\u003e (EnumSet e, Bool, EnumSet e)",
          "source": "src/Data-IntSet-EnumSet2.html#splitMember",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "splitMember",
          "normalized": "a-\u003eEnumSet a-\u003e(EnumSet a,Bool,EnumSet a)",
          "package": "regex-tdfa",
          "partial": "Member",
          "signature": "e-\u003eEnumSet e-\u003e(EnumSet e,Bool,EnumSet e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:splitMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "toAscList",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e [e]",
          "source": "src/Data-IntSet-EnumSet2.html#toAscList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "toAscList",
          "normalized": "EnumSet a-\u003e[a]",
          "package": "regex-tdfa",
          "partial": "Asc List",
          "signature": "EnumSet e-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:toAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "toList",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e [e]",
          "source": "src/Data-IntSet-EnumSet2.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "toList",
          "normalized": "EnumSet a-\u003e[a]",
          "package": "regex-tdfa",
          "partial": "List",
          "signature": "EnumSet e-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "unEnumSet",
          "package": "regex-tdfa",
          "signature": "IntSet",
          "source": "src/Data-IntSet-EnumSet2.html#EnumSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "unEnumSet",
          "package": "regex-tdfa",
          "partial": "Enum Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:unEnumSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "union",
          "package": "regex-tdfa",
          "signature": "EnumSet e -\u003e EnumSet e -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#union",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "union",
          "normalized": "EnumSet a-\u003eEnumSet a-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "EnumSet e-\u003eEnumSet e-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.EnumSet2",
          "name": "unions",
          "package": "regex-tdfa",
          "signature": "[EnumSet e] -\u003e EnumSet e",
          "source": "src/Data-IntSet-EnumSet2.html#unions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IntSet EnumSet2",
          "module": "Data.IntSet.EnumSet2",
          "name": "unions",
          "normalized": "[EnumSet a]-\u003eEnumSet a",
          "package": "regex-tdfa",
          "signature": "[EnumSet e]-\u003eEnumSet e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Data-IntSet-EnumSet2.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules provides \u003ccode\u003e\u003ca\u003eRegexMaker\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRegexLike\u003c/a\u003e\u003c/code\u003e instances for using\n\u003ccode\u003eByteString\u003c/code\u003e with the DFA backend (\u003ca\u003eText.Regex.Lib.WrapDFAEngine\u003c/a\u003e and\n\u003ca\u003eText.Regex.Lazy.DFAEngineFPS\u003c/a\u003e).  This module is usually used via\nimport \u003ca\u003eText.Regex.TDFA\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "Lazy",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-ByteString-Lazy.html",
          "type": "module"
        },
        "index": {
          "description": "This modules provides RegexMaker and RegexLike instances for using ByteString with the DFA backend Text.Regex.Lib.WrapDFAEngine and Text.Regex.Lazy.DFAEngineFPS This module is usually used via import Text.Regex.TDFA This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex TDFA ByteString Lazy",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "Lazy",
          "package": "regex-tdfa",
          "partial": "Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "CompOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex TDFA ByteString Lazy",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "CompOption",
          "package": "regex-tdfa",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA ByteString Lazy",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe TDFA backend specific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type, used by this module's RegexOptions and RegexMaker\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "Regex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The TDFA backend specific Regex type used by this module RegexOptions and RegexMaker",
          "hierarchy": "Text Regex TDFA ByteString Lazy",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "Regex",
          "package": "regex-tdfa",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.ByteString.Lazy\",\"Text.Regex.TDFA.ByteString\"]",
          "name": "compile",
          "package": "regex-tdfa",
          "signature": "CompOption-\u003e ExecOption-\u003e ByteString-\u003e Either String Regex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#v:compile\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString.html#v:compile\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA ByteString Lazy",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eByteString-\u003eEither String Regex",
          "package": "regex-tdfa",
          "signature": "CompOption-\u003eExecOption-\u003eByteString-\u003eEither String Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.ByteString.Lazy\",\"Text.Regex.TDFA.ByteString\"]",
          "name": "execute",
          "package": "regex-tdfa",
          "signature": "Regex-\u003e ByteString-\u003e Either String (Maybe MatchArray)",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#v:execute\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString.html#v:execute\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA ByteString Lazy",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "execute",
          "normalized": "Regex-\u003eByteString-\u003eEither String(Maybe MatchArray)",
          "package": "regex-tdfa",
          "signature": "Regex-\u003eByteString-\u003eEither String(Maybe MatchArray)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.ByteString.Lazy\",\"Text.Regex.TDFA.ByteString\"]",
          "name": "regexec",
          "package": "regex-tdfa",
          "signature": "Regex-\u003e ByteString-\u003e Either String (Maybe (ByteString, ByteString, ByteString, [ByteString]))",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#v:regexec\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString.html#v:regexec\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA ByteString Lazy",
          "module": "Text.Regex.TDFA.ByteString.Lazy",
          "name": "regexec",
          "normalized": "Regex-\u003eByteString-\u003eEither String(Maybe(ByteString,ByteString,ByteString,[ByteString]))",
          "package": "regex-tdfa",
          "signature": "Regex-\u003eByteString-\u003eEither String(Maybe(ByteString,ByteString,ByteString,[ByteString]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString-Lazy.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules provides \u003ccode\u003e\u003ca\u003eRegexMaker\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRegexLike\u003c/a\u003e\u003c/code\u003e instances for using\n\u003ccode\u003eByteString\u003c/code\u003e with the DFA backend (\u003ca\u003eText.Regex.Lib.WrapDFAEngine\u003c/a\u003e and\n\u003ca\u003eText.Regex.Lazy.DFAEngineFPS\u003c/a\u003e).  This module is usually used via\nimport \u003ca\u003eText.Regex.TDFA\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.ByteString",
          "name": "ByteString",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-ByteString.html",
          "type": "module"
        },
        "index": {
          "description": "This modules provides RegexMaker and RegexLike instances for using ByteString with the DFA backend Text.Regex.Lib.WrapDFAEngine and Text.Regex.Lazy.DFAEngineFPS This module is usually used via import Text.Regex.TDFA This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex TDFA ByteString",
          "module": "Text.Regex.TDFA.ByteString",
          "name": "ByteString",
          "package": "regex-tdfa",
          "partial": "Byte String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.ByteString",
          "name": "CompOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex TDFA ByteString",
          "module": "Text.Regex.TDFA.ByteString",
          "name": "CompOption",
          "package": "regex-tdfa",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.ByteString",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA ByteString",
          "module": "Text.Regex.TDFA.ByteString",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe TDFA backend specific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type, used by this module's RegexOptions and RegexMaker\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.ByteString",
          "name": "Regex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The TDFA backend specific Regex type used by this module RegexOptions and RegexMaker",
          "hierarchy": "Text Regex TDFA ByteString",
          "module": "Text.Regex.TDFA.ByteString",
          "name": "Regex",
          "package": "regex-tdfa",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ByteString.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon provides simple functions to the backend.  It defines most\n of the data types.  All modules should call error via the\n common_error function below.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "Common",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html",
          "type": "module"
        },
        "index": {
          "description": "Common provides simple functions to the backend It defines most of the data types All modules should call error via the common error function below",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Common",
          "package": "regex-tdfa",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "Action",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Action",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Action",
          "package": "regex-tdfa",
          "partial": "Action",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "CompOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "CompOption",
          "package": "regex-tdfa",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal DFA node, identified by the Set of indices of the QNFA\n nodes it represents.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "DFA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DFA",
          "type": "data"
        },
        "index": {
          "description": "Internal DFA node identified by the Set of indices of the QNFA nodes it represents",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "DFA",
          "package": "regex-tdfa",
          "partial": "DFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:DFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal to the DFA node\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "DT",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "data"
        },
        "index": {
          "description": "Internal to the DFA node",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "DT",
          "package": "regex-tdfa",
          "partial": "DT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:DT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal type to repesent the commands for the tagged transition.\n The outer IntMap is for the destination Index and the inner IntMap\n is for the Source Index.  This is convenient since all runtime data\n going to the same destination must be compared to find the best.\n\u003c/p\u003e\u003cp\u003eA Destination IntMap entry may have an empty Source IntMap if and\n only if the destination is the starting index and the NFA/DFA.\n This instructs the matching engine to spawn a new entry starting at\n the post-update position.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "DTrans",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DTrans",
          "type": "type"
        },
        "index": {
          "description": "Internal type to repesent the commands for the tagged transition The outer IntMap is for the destination Index and the inner IntMap is for the Source Index This is convenient since all runtime data going to the same destination must be compared to find the best Destination IntMap entry may have an empty Source IntMap if and only if the destination is the starting index and the NFA DFA This instructs the matching engine to spawn new entry starting at the post-update position",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "DTrans",
          "package": "regex-tdfa",
          "partial": "DTrans",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:DTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal convenience type for the text display code\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "DTrans'",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DTrans%27",
          "type": "type"
        },
        "index": {
          "description": "Internal convenience type for the text display code",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "DTrans'",
          "package": "regex-tdfa",
          "partial": "DTrans'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:DTrans-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to track elements of the pattern that accept characters or \n are anchors\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "DoPa",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DoPa",
          "type": "newtype"
        },
        "index": {
          "description": "Used to track elements of the pattern that accept characters or are anchors",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "DoPa",
          "package": "regex-tdfa",
          "partial": "Do Pa",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:DoPa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroupIndex is for indexing submatches from capturing\n parenthesized groups (PGroup/Group)\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "GroupIndex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#GroupIndex",
          "type": "type"
        },
        "index": {
          "description": "GroupIndex is for indexing submatches from capturing parenthesized groups PGroup Group",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "GroupIndex",
          "package": "regex-tdfa",
          "partial": "Group Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:GroupIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroupInfo collects the parent and tag information for an instance \n of a group\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "GroupInfo",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#GroupInfo",
          "type": "data"
        },
        "index": {
          "description": "GroupInfo collects the parent and tag information for an instance of group",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "GroupInfo",
          "package": "regex-tdfa",
          "partial": "Group Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:GroupInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal NFA node identity number\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "Index",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Index",
          "type": "type"
        },
        "index": {
          "description": "Internal NFA node identity number",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Index",
          "package": "regex-tdfa",
          "partial": "Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003enewPos\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003enewFlags\u003c/code\u003e lists in Instructions are sorted by, and unique in, the Tag values\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "Instructions",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Instructions",
          "type": "data"
        },
        "index": {
          "description": "The newPos and newFlags lists in Instructions are sorted by and unique in the Tag values",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Instructions",
          "package": "regex-tdfa",
          "partial": "Instructions",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Instructions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal use to indicate type of tag and preference for larger or smaller Positions\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "OP",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#OP",
          "type": "data"
        },
        "index": {
          "description": "Internal use to indicate type of tag and preference for larger or smaller Positions",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "OP",
          "package": "regex-tdfa",
          "partial": "OP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:OP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "OrbitLog",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#OrbitLog",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "OrbitLog",
          "package": "regex-tdfa",
          "partial": "Orbit Log",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:OrbitLog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "OrbitTransformer",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#OrbitTransformer",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "OrbitTransformer",
          "package": "regex-tdfa",
          "partial": "Orbit Transformer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:OrbitTransformer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePositions for which a * was re-started while looping.  Need to\n append locations at back but compare starting with front, so use\n Seq as a Queue.  The initial position is saved in basePos (and a\n Maximize Tag), the middle positions in the Seq, and the final\n position is NOT saved in the Orbits (only in a Maximize Tag).\n\u003c/p\u003e\u003cp\u003eThe orderinal code is being written XXX TODO document it.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "Orbits",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Orbits",
          "type": "data"
        },
        "index": {
          "description": "Positions for which was re-started while looping Need to append locations at back but compare starting with front so use Seq as Queue The initial position is saved in basePos and Maximize Tag the middle positions in the Seq and the final position is NOT saved in the Orbits only in Maximize Tag The orderinal code is being written XXX TODO document it",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Orbits",
          "package": "regex-tdfa",
          "partial": "Orbits",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Orbits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndex into the text being searched\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "Position",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Position",
          "type": "type"
        },
        "index": {
          "description": "Index into the text being searched",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Position",
          "package": "regex-tdfa",
          "partial": "Position",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Position"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal NFA node type\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "QNFA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#QNFA",
          "type": "data"
        },
        "index": {
          "description": "Internal NFA node type",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "QNFA",
          "package": "regex-tdfa",
          "partial": "QNFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:QNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal to QNFA type.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "QT",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "data"
        },
        "index": {
          "description": "Internal to QNFA type",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "QT",
          "package": "regex-tdfa",
          "partial": "QT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:QT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal type to represent the tagged transition from one QNFA to\n another (or itself).  The key is the Index of the destination QNFA.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "QTrans",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#QTrans",
          "type": "type"
        },
        "index": {
          "description": "Internal type to represent the tagged transition from one QNFA to another or itself The key is the Index of the destination QNFA",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "QTrans",
          "package": "regex-tdfa",
          "partial": "QTrans",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:QTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe TDFA backend specific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type, used by this module's RegexOptions and RegexMaker\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "Regex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The TDFA backend specific Regex type used by this module RegexOptions and RegexMaker",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Regex",
          "package": "regex-tdfa",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal DFA identity is this Set of NFA Index\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "SetIndex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#SetIndex",
          "type": "type"
        },
        "index": {
          "description": "Internal DFA identity is this Set of NFA Index",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "SetIndex",
          "package": "regex-tdfa",
          "partial": "Set Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:SetIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by implementation to name certain Postions during\n matching. Identity of Position tag to set during a transition\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "Tag",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Tag",
          "type": "type"
        },
        "index": {
          "description": "Used by implementation to name certain Postions during matching Identity of Position tag to set during transition",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Tag",
          "package": "regex-tdfa",
          "partial": "Tag",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Tag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA TagList and the location of the item in the original pattern\n that is being accepted.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagCommand",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#TagCommand",
          "type": "type"
        },
        "index": {
          "description": "TagList and the location of the item in the original pattern that is being accepted",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagCommand",
          "package": "regex-tdfa",
          "partial": "Tag Command",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:TagCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered list of tags and their associated update operation.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagList",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#TagList",
          "type": "type"
        },
        "index": {
          "description": "Ordered list of tags and their associated update operation",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagList",
          "package": "regex-tdfa",
          "partial": "Tag List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:TagList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe things that can be done with a Tag.  TagTask and\n ResetGroupStopTask are for tags with Maximize or Minimize OP\n values.  ResetOrbitTask and EnterOrbitTask and LeaveOrbitTask are\n for tags with Orbit OP value.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagTask",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#TagTask",
          "type": "data"
        },
        "index": {
          "description": "The things that can be done with Tag TagTask and ResetGroupStopTask are for tags with Maximize or Minimize OP values ResetOrbitTask and EnterOrbitTask and LeaveOrbitTask are for tags with Orbit OP value",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagTask",
          "package": "regex-tdfa",
          "partial": "Tag Task",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:TagTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered list of tags and their associated Task\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagTasks",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#TagTasks",
          "type": "type"
        },
        "index": {
          "description": "Ordered list of tags and their associated Task",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagTasks",
          "package": "regex-tdfa",
          "partial": "Tag Tasks",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:TagTasks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen attached to a QTrans the TagTask can be done before or after\n accepting the character.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagUpdate",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#TagUpdate",
          "type": "data"
        },
        "index": {
          "description": "When attached to QTrans the TagTask can be done before or after accepting the character",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagUpdate",
          "package": "regex-tdfa",
          "partial": "Tag Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:TagUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "Transition",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Transition",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Transition",
          "package": "regex-tdfa",
          "partial": "Transition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:Transition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKnown predicates, just Beginning of Line (^) and End of Line ($).\n Also support for GNU extensions is being added: ` beginning of\n buffer, ' end of buffer, \u003c and \u003e for begin and end of words, b\n and B for word boundary and not word boundary.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "WhichTest",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "data"
        },
        "index": {
          "description": "Known predicates just Beginning of Line and End of Line Also support for GNU extensions is being added beginning of buffer end of buffer and for begin and end of words and for word boundary and not word boundary",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "WhichTest",
          "package": "regex-tdfa",
          "partial": "Which Test",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:WhichTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "WinEmpty",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#WinEmpty",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "WinEmpty",
          "package": "regex-tdfa",
          "partial": "Win Empty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:WinEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered list of tags and their associated update operation to\n perform on an empty transition to the virtual winning state.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "WinTags",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#WinTags",
          "type": "type"
        },
        "index": {
          "description": "Ordered list of tags and their associated update operation to perform on an empty transition to the virtual winning state",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "WinTags",
          "package": "regex-tdfa",
          "partial": "Win Tags",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#t:WinTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "CompOption",
          "package": "regex-tdfa",
          "signature": "CompOption",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "CompOption",
          "package": "regex-tdfa",
          "partial": "Comp Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "DFA",
          "package": "regex-tdfa",
          "signature": "DFA",
          "source": "src/Text-Regex-TDFA-Common.html#DFA",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:DFA\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:DFA\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "DFA",
          "package": "regex-tdfa",
          "partial": "DFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:DFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.Pattern\"]",
          "name": "DoPa",
          "package": "regex-tdfa",
          "signature": "DoPa",
          "source": "src/Text-Regex-TDFA-Common.html#DoPa",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:DoPa\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:DoPa\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "DoPa",
          "package": "regex-tdfa",
          "partial": "Do Pa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:DoPa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "EnterOrbitTask",
          "package": "regex-tdfa",
          "signature": "EnterOrbitTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagTask",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "EnterOrbitTask",
          "package": "regex-tdfa",
          "partial": "Enter Orbit Task",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:EnterOrbitTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "signature": "ExecOption",
          "source": "src/Text-Regex-TDFA-Common.html#ExecOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "partial": "Exec Option",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "GroupInfo",
          "package": "regex-tdfa",
          "signature": "GroupInfo",
          "source": "src/Text-Regex-TDFA-Common.html#GroupInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "GroupInfo",
          "package": "regex-tdfa",
          "partial": "Group Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:GroupInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Ignore",
          "package": "regex-tdfa",
          "signature": "Ignore",
          "source": "src/Text-Regex-TDFA-Common.html#OP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Ignore\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Ignore\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Ignore",
          "package": "regex-tdfa",
          "partial": "Ignore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Ignore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "Instructions",
          "package": "regex-tdfa",
          "signature": "Instructions",
          "source": "src/Text-Regex-TDFA-Common.html#Instructions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Instructions",
          "package": "regex-tdfa",
          "partial": "Instructions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Instructions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "LeaveOrbitTask",
          "package": "regex-tdfa",
          "signature": "LeaveOrbitTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagTask",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "LeaveOrbitTask",
          "package": "regex-tdfa",
          "partial": "Leave Orbit Task",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:LeaveOrbitTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Maximize",
          "package": "regex-tdfa",
          "signature": "Maximize",
          "source": "src/Text-Regex-TDFA-Common.html#OP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Maximize\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Maximize\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Maximize",
          "package": "regex-tdfa",
          "partial": "Maximize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Maximize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Minimize",
          "package": "regex-tdfa",
          "signature": "Minimize",
          "source": "src/Text-Regex-TDFA-Common.html#OP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Minimize\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Minimize\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Minimize",
          "package": "regex-tdfa",
          "partial": "Minimize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Minimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Orbit",
          "package": "regex-tdfa",
          "signature": "Orbit",
          "source": "src/Text-Regex-TDFA-Common.html#OP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Orbit\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Orbit\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Orbit",
          "package": "regex-tdfa",
          "partial": "Orbit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Orbit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "Orbits",
          "package": "regex-tdfa",
          "signature": "Orbits",
          "source": "src/Text-Regex-TDFA-Common.html#Orbits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Orbits",
          "package": "regex-tdfa",
          "partial": "Orbits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Orbits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "PostUpdate",
          "package": "regex-tdfa",
          "signature": "PostUpdate TagTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagUpdate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:PostUpdate\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:PostUpdate\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "PostUpdate",
          "package": "regex-tdfa",
          "partial": "Post Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:PostUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "PreUpdate",
          "package": "regex-tdfa",
          "signature": "PreUpdate TagTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagUpdate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:PreUpdate\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:PreUpdate\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "PreUpdate",
          "package": "regex-tdfa",
          "partial": "Pre Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:PreUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "QNFA",
          "package": "regex-tdfa",
          "signature": "QNFA",
          "source": "src/Text-Regex-TDFA-Common.html#QNFA",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:QNFA\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:QNFA\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "QNFA",
          "package": "regex-tdfa",
          "partial": "QNFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:QNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "Regex",
          "package": "regex-tdfa",
          "signature": "Regex",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Regex",
          "package": "regex-tdfa",
          "partial": "Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "ResetGroupStopTask",
          "package": "regex-tdfa",
          "signature": "ResetGroupStopTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagTask",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "ResetGroupStopTask",
          "package": "regex-tdfa",
          "partial": "Reset Group Stop Task",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:ResetGroupStopTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "ResetOrbitTask",
          "package": "regex-tdfa",
          "signature": "ResetOrbitTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagTask",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "ResetOrbitTask",
          "package": "regex-tdfa",
          "partial": "Reset Orbit Task",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:ResetOrbitTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "SetGroupStopTask",
          "package": "regex-tdfa",
          "signature": "SetGroupStopTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagTask",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "SetGroupStopTask",
          "package": "regex-tdfa",
          "partial": "Set Group Stop Task",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:SetGroupStopTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "SetPost",
          "package": "regex-tdfa",
          "signature": "SetPost",
          "source": "src/Text-Regex-TDFA-Common.html#Action",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "SetPost",
          "package": "regex-tdfa",
          "partial": "Set Post",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:SetPost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "SetPre",
          "package": "regex-tdfa",
          "signature": "SetPre",
          "source": "src/Text-Regex-TDFA-Common.html#Action",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "SetPre",
          "package": "regex-tdfa",
          "partial": "Set Pre",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:SetPre"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "SetVal",
          "package": "regex-tdfa",
          "signature": "SetVal Int",
          "source": "src/Text-Regex-TDFA-Common.html#Action",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "SetVal",
          "package": "regex-tdfa",
          "partial": "Set Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:SetVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "Simple",
          "package": "regex-tdfa",
          "signature": "Simple",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Simple\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:Simple\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Simple",
          "package": "regex-tdfa",
          "partial": "Simple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Simple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "Simple'",
          "package": "regex-tdfa",
          "signature": "Simple'",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Simple-39-\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:Simple-39-\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Simple'",
          "package": "regex-tdfa",
          "partial": "Simple'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Simple-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "TagTask",
          "package": "regex-tdfa",
          "signature": "TagTask",
          "source": "src/Text-Regex-TDFA-Common.html#TagTask",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "TagTask",
          "package": "regex-tdfa",
          "partial": "Tag Task",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:TagTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_BOB",
          "package": "regex-tdfa",
          "signature": "Test_BOB",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_BOB\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_BOB\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_BOB",
          "package": "regex-tdfa",
          "partial": "Test BOB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_BOB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_BOL",
          "package": "regex-tdfa",
          "signature": "Test_BOL",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_BOL\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_BOL\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_BOL",
          "package": "regex-tdfa",
          "partial": "Test BOL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_BOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_BOW",
          "package": "regex-tdfa",
          "signature": "Test_BOW",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_BOW\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_BOW\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_BOW",
          "package": "regex-tdfa",
          "partial": "Test BOW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_BOW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_EOB",
          "package": "regex-tdfa",
          "signature": "Test_EOB",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EOB\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_EOB\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_EOB",
          "package": "regex-tdfa",
          "partial": "Test EOB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EOB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_EOL",
          "package": "regex-tdfa",
          "signature": "Test_EOL",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EOL\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_EOL\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_EOL",
          "package": "regex-tdfa",
          "partial": "Test EOL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_EOW",
          "package": "regex-tdfa",
          "signature": "Test_EOW",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EOW\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_EOW\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_EOW",
          "package": "regex-tdfa",
          "partial": "Test EOW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EOW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_EdgeWord",
          "package": "regex-tdfa",
          "signature": "Test_EdgeWord",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EdgeWord\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_EdgeWord\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_EdgeWord",
          "package": "regex-tdfa",
          "partial": "Test Edge Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_EdgeWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.CorePattern\"]",
          "name": "Test_NotEdgeWord",
          "package": "regex-tdfa",
          "signature": "Test_NotEdgeWord",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_NotEdgeWord\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test_NotEdgeWord\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Test_NotEdgeWord",
          "package": "regex-tdfa",
          "partial": "Test Not Edge Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Test_NotEdgeWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "Testing",
          "package": "regex-tdfa",
          "signature": "Testing",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Testing\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:Testing\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Testing",
          "package": "regex-tdfa",
          "partial": "Testing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Testing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "Testing'",
          "package": "regex-tdfa",
          "signature": "Testing'",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Testing-39-\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:Testing-39-\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Testing'",
          "package": "regex-tdfa",
          "partial": "Testing'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Testing-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "Transition",
          "package": "regex-tdfa",
          "signature": "Transition",
          "source": "src/Text-Regex-TDFA-Common.html#Transition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "Transition",
          "package": "regex-tdfa",
          "partial": "Transition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:Transition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "WinEmpty",
          "package": "regex-tdfa",
          "signature": "WinEmpty Instructions",
          "source": "src/Text-Regex-TDFA-Common.html#WinEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "WinEmpty",
          "package": "regex-tdfa",
          "partial": "Win Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:WinEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "WinTest",
          "package": "regex-tdfa",
          "signature": "WinTest WhichTest (Maybe WinEmpty) (Maybe WinEmpty)",
          "source": "src/Text-Regex-TDFA-Common.html#WinEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "WinTest",
          "package": "regex-tdfa",
          "partial": "Win Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:WinTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "basePos",
          "package": "regex-tdfa",
          "signature": "Position",
          "source": "src/Text-Regex-TDFA-Common.html#Orbits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "basePos",
          "package": "regex-tdfa",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:basePos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue by default.  Set to False to improve speed (and space).\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "captureGroups",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#ExecOption",
          "type": "function"
        },
        "index": {
          "description": "True by default Set to False to improve speed and space",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "captureGroups",
          "package": "regex-tdfa",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:captureGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "caseSensitive",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "caseSensitive",
          "package": "regex-tdfa",
          "partial": "Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:caseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "common_error",
          "package": "regex-tdfa",
          "signature": "String -\u003e String -\u003e a",
          "source": "src/Text-Regex-TDFA-Common.html#common_error",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "common_error",
          "normalized": "String-\u003eString-\u003ea",
          "package": "regex-tdfa",
          "signature": "String-\u003eString-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:common_error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "d_dt",
          "package": "regex-tdfa",
          "signature": "DT",
          "source": "src/Text-Regex-TDFA-Common.html#DFA",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:d_dt\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:d_dt\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "d_dt",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:d_dt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "d_id",
          "package": "regex-tdfa",
          "signature": "SetIndex",
          "source": "src/Text-Regex-TDFA-Common.html#DFA",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:d_id\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:d_id\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "d_id",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:d_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.Pattern\"]",
          "name": "dopaIndex",
          "package": "regex-tdfa",
          "signature": "Int",
          "source": "src/Text-Regex-TDFA-Common.html#DoPa",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dopaIndex\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:dopaIndex\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dopaIndex",
          "package": "regex-tdfa",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dopaIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse dt_a if test is True else use dt_b\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "dt_a",
          "package": "regex-tdfa",
          "signature": "DT",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_a\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dt_a\"]"
        },
        "index": {
          "description": "use dt if test is True else use dt",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dt_a",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse dt_a if test is True else use dt_b\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "dt_b",
          "package": "regex-tdfa",
          "signature": "DT",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_b\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dt_b\"]"
        },
        "index": {
          "description": "use dt if test is True else use dt",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dt_b",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocation(s) of the anchor(s) in the original regexp\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "dt_dopas",
          "package": "regex-tdfa",
          "signature": "EnumSet DoPa",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_dopas\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dt_dopas\"]"
        },
        "index": {
          "description": "location of the anchor in the original regexp",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dt_dopas",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_dopas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault accepting transition\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "dt_other",
          "package": "regex-tdfa",
          "signature": "Transition",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_other\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dt_other\"]"
        },
        "index": {
          "description": "default accepting transition",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dt_other",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_other"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe test to perform\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "dt_test",
          "package": "regex-tdfa",
          "signature": "WhichTest",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_test\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dt_test\"]"
        },
        "index": {
          "description": "The test to perform",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dt_test",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_test"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransition to accept Char\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "dt_trans",
          "package": "regex-tdfa",
          "signature": "CharMap Transition",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_trans\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dt_trans\"]"
        },
        "index": {
          "description": "Transition to accept Char",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dt_trans",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_trans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActions to perform to win\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TDFA\"]",
          "name": "dt_win",
          "package": "regex-tdfa",
          "signature": "IntMap Instructions",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_win\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dt_win\"]"
        },
        "index": {
          "description": "Actions to perform to win",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "dt_win",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:dt_win"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "flagTag",
          "package": "regex-tdfa",
          "signature": "Tag",
          "source": "src/Text-Regex-TDFA-Common.html#GroupInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "flagTag",
          "package": "regex-tdfa",
          "partial": "Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:flagTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "flipOrder",
          "package": "regex-tdfa",
          "signature": "Ordering -\u003e Ordering",
          "source": "src/Text-Regex-TDFA-Common.html#flipOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "flipOrder",
          "normalized": "Ordering-\u003eOrdering",
          "package": "regex-tdfa",
          "partial": "Order",
          "signature": "Ordering-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:flipOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "fst3",
          "package": "regex-tdfa",
          "signature": "(a, b, c) -\u003e a",
          "source": "src/Text-Regex-TDFA-Common.html#fst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "fst3",
          "normalized": "(a,b,c)-\u003ea",
          "package": "regex-tdfa",
          "signature": "(a,b,c)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:fst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "getOrbits",
          "package": "regex-tdfa",
          "signature": "(Seq Position)",
          "source": "src/Text-Regex-TDFA-Common.html#Orbits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "getOrbits",
          "package": "regex-tdfa",
          "partial": "Orbits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:getOrbits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "inOrbit",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#Orbits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "inOrbit",
          "package": "regex-tdfa",
          "partial": "Orbit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:inOrbit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "indent",
          "package": "regex-tdfa",
          "signature": "[String] -\u003e String",
          "source": "src/Text-Regex-TDFA-Common.html#indent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "indent",
          "normalized": "[String]-\u003eString",
          "package": "regex-tdfa",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:indent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse by default.  This is POSIX correct but it takes space and is slower.\n Setting this to true will improve performance, and should be done\n if you plan to set the captureGroups execoption to False.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "lastStarGreedy",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False by default This is POSIX correct but it takes space and is slower Setting this to true will improve performance and should be done if you plan to set the captureGroups execoption to False",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "lastStarGreedy",
          "package": "regex-tdfa",
          "partial": "Star Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:lastStarGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "look",
          "package": "regex-tdfa",
          "signature": "Int -\u003e IntMap a -\u003e a",
          "source": "src/Text-Regex-TDFA-Common.html#look",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "look",
          "normalized": "Int-\u003eIntMap a-\u003ea",
          "package": "regex-tdfa",
          "signature": "Int-\u003eIntMap a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:look"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "mapFst",
          "package": "regex-tdfa",
          "signature": "(t -\u003e t2) -\u003e f (t, t1) -\u003e f (t2, t1)",
          "source": "src/Text-Regex-TDFA-Common.html#mapFst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "mapFst",
          "normalized": "(a-\u003ea)-\u003eb(a,a)-\u003eb(a,a)",
          "package": "regex-tdfa",
          "partial": "Fst",
          "signature": "(t-\u003et)-\u003ef(t,t)-\u003ef(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:mapFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "mapSnd",
          "package": "regex-tdfa",
          "signature": "(t1 -\u003e t2) -\u003e f (t, t1) -\u003e f (t, t2)",
          "source": "src/Text-Regex-TDFA-Common.html#mapSnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "mapSnd",
          "normalized": "(a-\u003ea)-\u003eb(a,a)-\u003eb(a,a)",
          "package": "regex-tdfa",
          "partial": "Snd",
          "signature": "(t-\u003et)-\u003ef(t,t)-\u003ef(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:mapSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Compile for\n                      newline-sensitive matching.  \u003ca\u003eBy default, newline is a completely ordinary\n                      character with no special meaning in either REs or strings.  With this flag,\n                      inverted bracket expressions and . never match newline, a ^ anchor matches the\n                      null string after any newline in the string in addition to its normal\n                      function, and the $ anchor matches the null string before any newline in the\n                      string in addition to its normal function.\u003c/a\u003e \n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "multiline",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Compile for newline-sensitive matching By default newline is completely ordinary character with no special meaning in either REs or strings With this flag inverted bracket expressions and never match newline anchor matches the null string after any newline in the string in addition to its normal function and the anchor matches the null string before any newline in the string in addition to its normal function",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "multiline",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "newOrbits",
          "package": "regex-tdfa",
          "signature": "(Maybe (Position -\u003e OrbitTransformer))",
          "source": "src/Text-Regex-TDFA-Common.html#Instructions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "newOrbits",
          "normalized": "(Maybe(Position-\u003eOrbitTransformer))",
          "package": "regex-tdfa",
          "partial": "Orbits",
          "signature": "(Maybe(Position-\u003eOrbitTransformer))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:newOrbits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "newPos",
          "package": "regex-tdfa",
          "signature": "[(Tag, Action)]",
          "source": "src/Text-Regex-TDFA-Common.html#Instructions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "newPos",
          "normalized": "[(Tag,Action)]",
          "package": "regex-tdfa",
          "partial": "Pos",
          "signature": "[(Tag,Action)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:newPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFalse in blankCompOpt, True in defaultCompOpt. Add the extended non-POSIX syntax described in \u003ca\u003eText.Regex.TDFA\u003c/a\u003e haddock documentation.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "newSyntax",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "False in blankCompOpt True in defaultCompOpt Add the extended non-POSIX syntax described in Text.Regex.TDFA haddock documentation",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "newSyntax",
          "package": "regex-tdfa",
          "partial": "Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:newSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "noWin",
          "package": "regex-tdfa",
          "signature": "WinTags -\u003e Bool",
          "source": "src/Text-Regex-TDFA-Common.html#noWin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "noWin",
          "normalized": "WinTags-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Win",
          "signature": "WinTags-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:noWin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eafter sort or sortBy the use of nub\u003cem\u003enubBy can be replaced by norep\u003c/em\u003enorepBy\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "norep",
          "package": "regex-tdfa",
          "signature": "[a] -\u003e [a]",
          "source": "src/Text-Regex-TDFA-Common.html#norep",
          "type": "function"
        },
        "index": {
          "description": "after sort or sortBy the use of nub nubBy can be replaced by norep norepBy",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "norep",
          "normalized": "[a]-\u003e[a]",
          "package": "regex-tdfa",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:norep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eafter sort or sortBy the use of nub\u003cem\u003enubBy can be replaced by norep\u003c/em\u003enorepBy\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "norepBy",
          "package": "regex-tdfa",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Text-Regex-TDFA-Common.html#norepBy",
          "type": "function"
        },
        "index": {
          "description": "after sort or sortBy the use of nub nubBy can be replaced by norep norepBy",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "norepBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "regex-tdfa",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:norepBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "on",
          "package": "regex-tdfa",
          "signature": "(t1 -\u003e t1 -\u003e t2) -\u003e (t -\u003e t1) -\u003e t -\u003e t -\u003e t2",
          "source": "src/Text-Regex-TDFA-Common.html#on",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "on",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(a-\u003ea)-\u003ea-\u003ea-\u003ea",
          "package": "regex-tdfa",
          "signature": "(t-\u003et-\u003et)-\u003e(t-\u003et)-\u003et-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:on"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "ordinal",
          "package": "regex-tdfa",
          "signature": "Maybe Int",
          "source": "src/Text-Regex-TDFA-Common.html#Orbits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "ordinal",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:ordinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "parentIndex",
          "package": "regex-tdfa",
          "signature": "GroupIndex",
          "source": "src/Text-Regex-TDFA-Common.html#GroupInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "parentIndex",
          "package": "regex-tdfa",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:parentIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "q_id",
          "package": "regex-tdfa",
          "signature": "Index",
          "source": "src/Text-Regex-TDFA-Common.html#QNFA",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:q_id\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:q_id\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "q_id",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:q_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "q_qt",
          "package": "regex-tdfa",
          "signature": "QT",
          "source": "src/Text-Regex-TDFA-Common.html#QNFA",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:q_qt\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:q_qt\"]"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "q_qt",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:q_qt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse qt_a if test is True, else use qt_b\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "qt_a",
          "package": "regex-tdfa",
          "signature": "QT",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_a\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:qt_a\"]"
        },
        "index": {
          "description": "use qt if test is True else use qt",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "qt_a",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse qt_a if test is True, else use qt_b\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "qt_b",
          "package": "regex-tdfa",
          "signature": "QT",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_b\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:qt_b\"]"
        },
        "index": {
          "description": "use qt if test is True else use qt",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "qt_b",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_b"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocation(s) of the anchor(s) in the original regexp\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "qt_dopas",
          "package": "regex-tdfa",
          "signature": "EnumSet DoPa",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_dopas\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:qt_dopas\"]"
        },
        "index": {
          "description": "location of the anchor in the original regexp",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "qt_dopas",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_dopas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault ways to leave this QNFA to other or the same QNFA\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "qt_other",
          "package": "regex-tdfa",
          "signature": "QTrans",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_other\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:qt_other\"]"
        },
        "index": {
          "description": "default ways to leave this QNFA to other or the same QNFA",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "qt_other",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_other"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe test to perform\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "qt_test",
          "package": "regex-tdfa",
          "signature": "WhichTest",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_test\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:qt_test\"]"
        },
        "index": {
          "description": "The test to perform",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "qt_test",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_test"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eall ways to leave this QNFA to other or the same QNFA\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "qt_trans",
          "package": "regex-tdfa",
          "signature": "CharMap QTrans",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_trans\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:qt_trans\"]"
        },
        "index": {
          "description": "all ways to leave this QNFA to other or the same QNFA",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "qt_trans",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_trans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty transitions to the virtual winning state\n\u003c/p\u003e",
          "module": "[\"Text.Regex.TDFA.Common\",\"Text.Regex.TDFA.TNFA\"]",
          "name": "qt_win",
          "package": "regex-tdfa",
          "signature": "WinTags",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_win\",\"http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:qt_win\"]"
        },
        "index": {
          "description": "empty transitions to the virtual winning state",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "qt_win",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:qt_win"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindexes of smallest and largest states\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_b_index",
          "package": "regex-tdfa",
          "signature": "(Index, Index)",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "indexes of smallest and largest states",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_b_index",
          "normalized": "(Index,Index)",
          "package": "regex-tdfa",
          "signature": "(Index,Index)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_b_index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindexes of smallest and largest tags\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_b_tags",
          "package": "regex-tdfa",
          "signature": "(Tag, Tag)",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "indexes of smallest and largest tags",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_b_tags",
          "normalized": "(Tag,Tag)",
          "package": "regex-tdfa",
          "signature": "(Tag,Tag)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_b_tags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_compOptions",
          "package": "regex-tdfa",
          "signature": "CompOption",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_compOptions",
          "package": "regex-tdfa",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_compOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estarting DFA state\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_dfa",
          "package": "regex-tdfa",
          "signature": "DFA",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "starting DFA state",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_dfa",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_dfa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_execOptions",
          "package": "regex-tdfa",
          "signature": "ExecOption",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_execOptions",
          "package": "regex-tdfa",
          "partial": "Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_execOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einformation about each group\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_groups",
          "package": "regex-tdfa",
          "signature": "Array GroupIndex [GroupInfo]",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "information about each group",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_groups",
          "normalized": "Array GroupIndex[GroupInfo]",
          "package": "regex-tdfa",
          "signature": "Array GroupIndex[GroupInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_groups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindex of starting state\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_init",
          "package": "regex-tdfa",
          "signature": "Index",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "index of starting state",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_init",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eused for optimizing execution\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_isFrontAnchored",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "used for optimizing execution",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_isFrontAnchored",
          "package": "regex-tdfa",
          "partial": "Front Anchored",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_isFrontAnchored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einformation about each tag\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_tags",
          "package": "regex-tdfa",
          "signature": "Array Tag OP",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "information about each tag",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_tags",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_tags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll DFA states\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_trie",
          "package": "regex-tdfa",
          "signature": "TrieSet DFA",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "function"
        },
        "index": {
          "description": "All DFA states",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "regex_trie",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:regex_trie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue (and therefore Right associative) in blankCompOpt and defaultCompOpt\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "rightAssoc",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "function"
        },
        "index": {
          "description": "True and therefore Right associative in blankCompOpt and defaultCompOpt",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "rightAssoc",
          "package": "regex-tdfa",
          "partial": "Assoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:rightAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "seeDTrans",
          "package": "regex-tdfa",
          "signature": "DTrans -\u003e String",
          "source": "src/Text-Regex-TDFA-Common.html#seeDTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "seeDTrans",
          "normalized": "DTrans-\u003eString",
          "package": "regex-tdfa",
          "partial": "DTrans",
          "signature": "DTrans-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:seeDTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "showDT",
          "package": "regex-tdfa",
          "signature": "DT -\u003e String",
          "source": "src/Text-Regex-TDFA-Common.html#showDT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "showDT",
          "normalized": "DT-\u003eString",
          "package": "regex-tdfa",
          "partial": "DT",
          "signature": "DT-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:showDT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "showQT",
          "package": "regex-tdfa",
          "signature": "QT -\u003e String",
          "source": "src/Text-Regex-TDFA-Common.html#showQT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "showQT",
          "normalized": "QT-\u003eString",
          "package": "regex-tdfa",
          "partial": "QT",
          "signature": "QT-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:showQT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "snd3",
          "package": "regex-tdfa",
          "signature": "(a, b, c) -\u003e b",
          "source": "src/Text-Regex-TDFA-Common.html#snd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "snd3",
          "normalized": "(a,b,c)-\u003eb",
          "package": "regex-tdfa",
          "signature": "(a,b,c)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:snd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "startTag",
          "package": "regex-tdfa",
          "signature": "Tag",
          "source": "src/Text-Regex-TDFA-Common.html#GroupInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "startTag",
          "package": "regex-tdfa",
          "partial": "Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:startTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "stopTag",
          "package": "regex-tdfa",
          "signature": "Tag",
          "source": "src/Text-Regex-TDFA-Common.html#GroupInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "stopTag",
          "package": "regex-tdfa",
          "partial": "Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:stopTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "thd3",
          "package": "regex-tdfa",
          "signature": "(a, b, c) -\u003e c",
          "source": "src/Text-Regex-TDFA-Common.html#thd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "thd3",
          "normalized": "(a,b,c)-\u003ec",
          "package": "regex-tdfa",
          "signature": "(a,b,c)-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:thd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Common",
          "name": "thisIndex",
          "package": "regex-tdfa",
          "signature": "GroupIndex",
          "source": "src/Text-Regex-TDFA-Common.html#GroupInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "thisIndex",
          "package": "regex-tdfa",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:thisIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehow to go, including respawning\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "trans_how",
          "package": "regex-tdfa",
          "signature": "DTrans",
          "source": "src/Text-Regex-TDFA-Common.html#Transition",
          "type": "function"
        },
        "index": {
          "description": "how to go including respawning",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "trans_how",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:trans_how"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhere to go (maximal), including respawning\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "trans_many",
          "package": "regex-tdfa",
          "signature": "DFA",
          "source": "src/Text-Regex-TDFA-Common.html#Transition",
          "type": "function"
        },
        "index": {
          "description": "where to go maximal including respawning",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "trans_many",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:trans_many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhere to go, not including respawning\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Common",
          "name": "trans_single",
          "package": "regex-tdfa",
          "signature": "DFA",
          "source": "src/Text-Regex-TDFA-Common.html#Transition",
          "type": "function"
        },
        "index": {
          "description": "where to go not including respawning",
          "hierarchy": "Text Regex TDFA Common",
          "module": "Text.Regex.TDFA.Common",
          "name": "trans_single",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Common.html#v:trans_single"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe CorePattern module deconstructs the Pattern tree created by\n ReadRegex.parseRegex and returns a simpler Q/P tree with\n annotations at each Q node.  This will be converted by the TNFA\n module into a QNFA finite automata.\n\u003c/p\u003e\u003cp\u003eOf particular note, this Pattern to Q/P conversion creates and\n assigns all the internal Tags that will be used during the matching\n process, and associates the captures groups with the tags that\n represent their starting and ending locations and with their\n immediate parent group.\n\u003c/p\u003e\u003cp\u003eEach Maximize and Minimize tag is held as either a preTag or a\n postTag by one and only one location in the Q/P tree.  The Orbit\n tags are each held by one and only one Star node.  Tags that stop a\n Group are also held in perhaps numerous preReset lists.\n\u003c/p\u003e\u003cp\u003eThe additional nullQ::nullView field of Q records the potentially\n complex information about what tests and tags must be used if the\n pattern unQ::P matches 0 zero characters.  There can be redundancy\n in nullView, which is eliminated by cleanNullView.\n\u003c/p\u003e\u003cp\u003eUses recursive do notation.\n\u003c/p\u003e\u003cp\u003e2009 XXX TODO: we can avoid needing tags in the part of the pattern\n after the last capturing group (when right-associative).  This is\n flipped for left-associative where the front of the pattern before\n the first capturing group needs no tags.  The edge of these regions\n is subtle: both case needs a Maximize tag.  One ought to be able to\n check the Pattern: if the root is PConcat then a scan from the end\n (start) looking for the first with an embedded PGroup can be found\n and the PGroup free elements can be wrapped in some new PNOTAG\n semantic indicator.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "CorePattern",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-CorePattern.html",
          "type": "module"
        },
        "index": {
          "description": "The CorePattern module deconstructs the Pattern tree created by ReadRegex.parseRegex and returns simpler tree with annotations at each node This will be converted by the TNFA module into QNFA finite automata Of particular note this Pattern to conversion creates and assigns all the internal Tags that will be used during the matching process and associates the captures groups with the tags that represent their starting and ending locations and with their immediate parent group Each Maximize and Minimize tag is held as either preTag or postTag by one and only one location in the tree The Orbit tags are each held by one and only one Star node Tags that stop Group are also held in perhaps numerous preReset lists The additional nullQ nullView field of records the potentially complex information about what tests and tags must be used if the pattern unQ matches zero characters There can be redundancy in nullView which is eliminated by cleanNullView Uses recursive do notation XXX TODO we can avoid needing tags in the part of the pattern after the last capturing group when right-associative This is flipped for left-associative where the front of the pattern before the first capturing group needs no tags The edge of these regions is subtle both case needs Maximize tag One ought to be able to check the Pattern if the root is PConcat then scan from the end start looking for the first with an embedded PGroup can be found and the PGroup free elements can be wrapped in some new PNOTAG semantic indicator",
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "CorePattern",
          "package": "regex-tdfa",
          "partial": "Core Pattern",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "NullView",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-CorePattern.html#NullView",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "NullView",
          "package": "regex-tdfa",
          "partial": "Null View",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:NullView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal use to indicate type of tag and preference for larger or smaller Positions\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "OP",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#OP",
          "type": "data"
        },
        "index": {
          "description": "Internal use to indicate type of tag and preference for larger or smaller Positions",
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "OP",
          "package": "regex-tdfa",
          "partial": "OP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:OP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "P",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "P",
          "package": "regex-tdfa",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Q",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Q",
          "package": "regex-tdfa",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "SetTestInfo",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-CorePattern.html#SetTestInfo",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "SetTestInfo",
          "package": "regex-tdfa",
          "partial": "Set Test Info",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:SetTestInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "TestInfo",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-CorePattern.html#TestInfo",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "TestInfo",
          "package": "regex-tdfa",
          "partial": "Test Info",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:TestInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Wanted",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Wanted",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Wanted",
          "package": "regex-tdfa",
          "partial": "Wanted",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:Wanted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKnown predicates, just Beginning of Line (^) and End of Line ($).\n Also support for GNU extensions is being added: ` beginning of\n buffer, ' end of buffer, \u003c and \u003e for begin and end of words, b\n and B for word boundary and not word boundary.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WhichTest",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#WhichTest",
          "type": "data"
        },
        "index": {
          "description": "Known predicates just Beginning of Line and End of Line Also support for GNU extensions is being added beginning of buffer end of buffer and for begin and end of words and for word boundary and not word boundary",
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WhichTest",
          "package": "regex-tdfa",
          "partial": "Which Test",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#t:WhichTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Empty",
          "package": "regex-tdfa",
          "signature": "Empty",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Empty",
          "package": "regex-tdfa",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "NonEmpty",
          "package": "regex-tdfa",
          "signature": "NonEmpty Q",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "NonEmpty",
          "package": "regex-tdfa",
          "partial": "Non Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:NonEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "OneChar",
          "package": "regex-tdfa",
          "signature": "OneChar Pattern",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "OneChar",
          "package": "regex-tdfa",
          "partial": "One Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:OneChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Or",
          "package": "regex-tdfa",
          "signature": "Or [Q]",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Or",
          "normalized": "Or[Q]",
          "package": "regex-tdfa",
          "partial": "Or",
          "signature": "Or[Q]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Q",
          "package": "regex-tdfa",
          "signature": "Q",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Q",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Seq",
          "package": "regex-tdfa",
          "signature": "Seq Q Q",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Seq",
          "package": "regex-tdfa",
          "partial": "Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "SetTestInfo",
          "package": "regex-tdfa",
          "signature": "SetTestInfo",
          "source": "src/Text-Regex-TDFA-CorePattern.html#SetTestInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "SetTestInfo",
          "package": "regex-tdfa",
          "partial": "Set Test Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:SetTestInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Star",
          "package": "regex-tdfa",
          "signature": "Star",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Star",
          "package": "regex-tdfa",
          "partial": "Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Test",
          "package": "regex-tdfa",
          "signature": "Test TestInfo",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "Test",
          "package": "regex-tdfa",
          "partial": "Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:Test"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsBoth",
          "package": "regex-tdfa",
          "signature": "WantsBoth",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Wanted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsBoth",
          "package": "regex-tdfa",
          "partial": "Wants Both",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:WantsBoth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsEither",
          "package": "regex-tdfa",
          "signature": "WantsEither",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Wanted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsEither",
          "package": "regex-tdfa",
          "partial": "Wants Either",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:WantsEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsQNFA",
          "package": "regex-tdfa",
          "signature": "WantsQNFA",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Wanted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsQNFA",
          "package": "regex-tdfa",
          "partial": "Wants QNFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:WantsQNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsQT",
          "package": "regex-tdfa",
          "signature": "WantsQT",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Wanted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "WantsQT",
          "package": "regex-tdfa",
          "partial": "Wants QT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:WantsQT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "cannotAccept",
          "package": "regex-tdfa",
          "signature": "Q -\u003e Bool",
          "source": "src/Text-Regex-TDFA-CorePattern.html#cannotAccept",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "cannotAccept",
          "normalized": "Q-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Accept",
          "signature": "Q-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:cannotAccept"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "childGroups",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "childGroups",
          "package": "regex-tdfa",
          "partial": "Groups",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:childGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "cleanNullView",
          "package": "regex-tdfa",
          "signature": "NullView -\u003e NullView",
          "source": "src/Text-Regex-TDFA-CorePattern.html#cleanNullView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "cleanNullView",
          "normalized": "NullView-\u003eNullView",
          "package": "regex-tdfa",
          "partial": "Null View",
          "signature": "NullView-\u003eNullView",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:cleanNullView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "firstNull",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "firstNull",
          "package": "regex-tdfa",
          "partial": "Null",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:firstNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "getOrbit",
          "package": "regex-tdfa",
          "signature": "Maybe Tag",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "getOrbit",
          "package": "regex-tdfa",
          "partial": "Orbit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:getOrbit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "getTests",
          "package": "regex-tdfa",
          "signature": "EnumMap WhichTest (EnumSet DoPa)",
          "source": "src/Text-Regex-TDFA-CorePattern.html#SetTestInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "getTests",
          "package": "regex-tdfa",
          "partial": "Tests",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:getTests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "mustAccept",
          "package": "regex-tdfa",
          "signature": "Q -\u003e Bool",
          "source": "src/Text-Regex-TDFA-CorePattern.html#mustAccept",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "mustAccept",
          "normalized": "Q-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Accept",
          "signature": "Q-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:mustAccept"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "nullQ",
          "package": "regex-tdfa",
          "signature": "NullView",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "nullQ",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:nullQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "patternToQ",
          "package": "regex-tdfa",
          "signature": "CompOption -\u003e (Pattern, (GroupIndex, DoPa)) -\u003e (Q, Array Tag OP, Array GroupIndex [GroupInfo])",
          "source": "src/Text-Regex-TDFA-CorePattern.html#patternToQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "patternToQ",
          "normalized": "CompOption-\u003e(Pattern,(GroupIndex,DoPa))-\u003e(Q,Array Tag OP,Array GroupIndex[GroupInfo])",
          "package": "regex-tdfa",
          "partial": "To",
          "signature": "CompOption-\u003e(Pattern,(GroupIndex,DoPa))-\u003e(Q,Array Tag OP,Array GroupIndex[GroupInfo])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:patternToQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "postSet",
          "package": "regex-tdfa",
          "signature": "[Tag]",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "postSet",
          "normalized": "[Tag]",
          "package": "regex-tdfa",
          "partial": "Set",
          "signature": "[Tag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:postSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "postTag",
          "package": "regex-tdfa",
          "signature": "Maybe Tag",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "postTag",
          "package": "regex-tdfa",
          "partial": "Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:postTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "preReset",
          "package": "regex-tdfa",
          "signature": "[Tag]",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "preReset",
          "normalized": "[Tag]",
          "package": "regex-tdfa",
          "partial": "Reset",
          "signature": "[Tag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:preReset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "preTag",
          "package": "regex-tdfa",
          "signature": "Maybe Tag",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "preTag",
          "package": "regex-tdfa",
          "partial": "Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:preTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "resetOrbits",
          "package": "regex-tdfa",
          "signature": "[Tag]",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "resetOrbits",
          "normalized": "[Tag]",
          "package": "regex-tdfa",
          "partial": "Orbits",
          "signature": "[Tag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:resetOrbits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "tagged",
          "package": "regex-tdfa",
          "signature": "Bool",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "tagged",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:tagged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "takes",
          "package": "regex-tdfa",
          "signature": "(Position, Maybe Position)",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "takes",
          "normalized": "(Position,Maybe Position)",
          "package": "regex-tdfa",
          "signature": "(Position,Maybe Position)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:takes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "unQ",
          "package": "regex-tdfa",
          "signature": "P",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "unQ",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:unQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "unStar",
          "package": "regex-tdfa",
          "signature": "Q",
          "source": "src/Text-Regex-TDFA-CorePattern.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "unStar",
          "package": "regex-tdfa",
          "partial": "Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:unStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "wants",
          "package": "regex-tdfa",
          "signature": "Wanted",
          "source": "src/Text-Regex-TDFA-CorePattern.html#Q",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA CorePattern",
          "module": "Text.Regex.TDFA.CorePattern",
          "name": "wants",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-CorePattern.html#v:wants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis creates a lazy Trie based on a finite range of Ints and is used to\nmemorize a function over the subsets of this range.\n\u003c/p\u003e\u003cp\u003eTo create a Trie you need two supply 2 things\n  * Range of keys to bound\n  * A function or functions used to construct the value for a subset of keys\n\u003c/p\u003e\u003cp\u003eThe Trie uses the Array type internally.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "IntArrTrieSet",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-IntArrTrieSet.html",
          "type": "module"
        },
        "index": {
          "description": "This creates lazy Trie based on finite range of Ints and is used to memorize function over the subsets of this range To create Trie you need two supply things Range of keys to bound function or functions used to construct the value for subset of keys The Trie uses the Array type internally",
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "IntArrTrieSet",
          "package": "regex-tdfa",
          "partial": "Int Arr Trie Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "TrieSet",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-IntArrTrieSet.html#TrieSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "TrieSet",
          "package": "regex-tdfa",
          "partial": "Trie Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#t:TrieSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "TrieSet",
          "package": "regex-tdfa",
          "signature": "TrieSet",
          "source": "src/Text-Regex-TDFA-IntArrTrieSet.html#TrieSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "TrieSet",
          "package": "regex-tdfa",
          "partial": "Trie Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#v:TrieSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a Trie constructor for a complete range of keys.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "fromBounds",
          "package": "regex-tdfa",
          "signature": "(Int, Int)-\u003e ([Int] -\u003e v)-\u003e TrieSet v",
          "type": "function"
        },
        "index": {
          "description": "This is Trie constructor for complete range of keys",
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "fromBounds",
          "normalized": "(Int,Int)-\u003e([Int]-\u003ea)-\u003eTrieSet a",
          "package": "regex-tdfa",
          "partial": "Bounds",
          "signature": "(Int,Int)-\u003e([Int]-\u003ev)-\u003eTrieSet v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#v:fromBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a Trie constructor for a complete range of keys that uses\n a function from single values and a merge operation on values to\n fill the Trie.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "fromSinglesMerge",
          "package": "regex-tdfa",
          "signature": "v-\u003e (v -\u003e v -\u003e v)-\u003e (Int, Int)-\u003e (Int -\u003e v)-\u003e TrieSet v",
          "type": "function"
        },
        "index": {
          "description": "This is Trie constructor for complete range of keys that uses function from single values and merge operation on values to fill the Trie",
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "fromSinglesMerge",
          "normalized": "a-\u003e(a-\u003ea-\u003ea)-\u003e(Int,Int)-\u003e(Int-\u003ea)-\u003eTrieSet a",
          "package": "regex-tdfa",
          "partial": "Singles Merge",
          "signature": "v-\u003e(v-\u003ev-\u003ev)-\u003e(Int,Int)-\u003e(Int-\u003ev)-\u003eTrieSet v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#v:fromSinglesMerge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a Trie constructor for a complete range of keys that uses\n a function from single values and a sum operation of values to fill\n the Trie.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "fromSinglesSum",
          "package": "regex-tdfa",
          "signature": "([v] -\u003e v)-\u003e (Int, Int)-\u003e (Int -\u003e v)-\u003e TrieSet v",
          "type": "function"
        },
        "index": {
          "description": "This is Trie constructor for complete range of keys that uses function from single values and sum operation of values to fill the Trie",
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "fromSinglesSum",
          "normalized": "([a]-\u003ea)-\u003e(Int,Int)-\u003e(Int-\u003ea)-\u003eTrieSet a",
          "package": "regex-tdfa",
          "partial": "Singles Sum",
          "signature": "([v]-\u003ev)-\u003e(Int,Int)-\u003e(Int-\u003ev)-\u003eTrieSet v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#v:fromSinglesSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the accessor for the Trie. The list of keys should be\n sorted.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "lookupAsc",
          "package": "regex-tdfa",
          "signature": "TrieSet v -\u003e [Int] -\u003e v",
          "source": "src/Text-Regex-TDFA-IntArrTrieSet.html#lookupAsc",
          "type": "function"
        },
        "index": {
          "description": "This is the accessor for the Trie The list of keys should be sorted",
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "lookupAsc",
          "normalized": "TrieSet a-\u003e[Int]-\u003ea",
          "package": "regex-tdfa",
          "partial": "Asc",
          "signature": "TrieSet v-\u003e[Int]-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#v:lookupAsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "next",
          "package": "regex-tdfa",
          "signature": "Array Int (TrieSet v)",
          "source": "src/Text-Regex-TDFA-IntArrTrieSet.html#TrieSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "next",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#v:next"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "value",
          "package": "regex-tdfa",
          "signature": "v",
          "source": "src/Text-Regex-TDFA-IntArrTrieSet.html#TrieSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA IntArrTrieSet",
          "module": "Text.Regex.TDFA.IntArrTrieSet",
          "name": "value",
          "package": "regex-tdfa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-IntArrTrieSet.html#v:value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the code for the main engine.  This captures the posix subexpressions. This \u003ccode\u003e\u003ca\u003eexecMatch\u003c/a\u003e\u003c/code\u003e\n also dispatches to \u003ca\u003eEngine_NC\u003c/a\u003e, \u003ca\u003eEngine_FA\u003c/a\u003e, and \u003ca\u003eEngine_FC_NA\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eIt is polymorphic over the internal Uncons type class, and specialized to produce the needed\n variants.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.NewDFA.Engine",
          "name": "Engine",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine.html",
          "type": "module"
        },
        "index": {
          "description": "This is the code for the main engine This captures the posix subexpressions This execMatch also dispatches to Engine NC Engine FA and Engine FC NA It is polymorphic over the internal Uncons type class and specialized to produce the needed variants",
          "hierarchy": "Text Regex TDFA NewDFA Engine",
          "module": "Text.Regex.TDFA.NewDFA.Engine",
          "name": "Engine",
          "package": "regex-tdfa",
          "partial": "Engine",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Engine",
          "name": "execMatch",
          "package": "regex-tdfa",
          "signature": "Regex -\u003e Position -\u003e Char -\u003e text -\u003e [MatchArray]",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine.html#execMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Engine",
          "module": "Text.Regex.TDFA.NewDFA.Engine",
          "name": "execMatch",
          "normalized": "Regex-\u003ePosition-\u003eChar-\u003ea-\u003e[MatchArray]",
          "package": "regex-tdfa",
          "partial": "Match",
          "signature": "Regex-\u003ePosition-\u003eChar-\u003etext-\u003e[MatchArray]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine.html#v:execMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the code for the main engine.  This captures the posix\n subexpressions.  There is also a non-capturing engine, and a\n testing engine.\n\u003c/p\u003e\u003cp\u003eIt is polymorphic over the internal Uncons type class, and\n specialized to produce the needed variants.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.NewDFA.Engine_FA",
          "name": "Engine_FA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine_FA.html",
          "type": "module"
        },
        "index": {
          "description": "This is the code for the main engine This captures the posix subexpressions There is also non-capturing engine and testing engine It is polymorphic over the internal Uncons type class and specialized to produce the needed variants",
          "hierarchy": "Text Regex TDFA NewDFA Engine_FA",
          "module": "Text.Regex.TDFA.NewDFA.Engine_FA",
          "name": "Engine_FA",
          "package": "regex-tdfa",
          "partial": "Engine FA",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine_FA.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Engine_FA",
          "name": "execMatch",
          "package": "regex-tdfa",
          "signature": "Regex -\u003e Position -\u003e Char -\u003e text -\u003e [MatchArray]",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine_FA.html#execMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Engine_FA",
          "module": "Text.Regex.TDFA.NewDFA.Engine_FA",
          "name": "execMatch",
          "normalized": "Regex-\u003ePosition-\u003eChar-\u003ea-\u003e[MatchArray]",
          "package": "regex-tdfa",
          "partial": "Match",
          "signature": "Regex-\u003ePosition-\u003eChar-\u003etext-\u003e[MatchArray]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine_FA.html#v:execMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the non-capturing form of Text.Regex.TDFA.NewDFA.String\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC",
          "name": "Engine_NC",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine_NC.html",
          "type": "module"
        },
        "index": {
          "description": "This is the non-capturing form of Text.Regex.TDFA.NewDFA.String",
          "hierarchy": "Text Regex TDFA NewDFA Engine_NC",
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC",
          "name": "Engine_NC",
          "package": "regex-tdfa",
          "partial": "Engine NC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine_NC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC",
          "name": "execMatch",
          "package": "regex-tdfa",
          "signature": "Regex -\u003e Position -\u003e Char -\u003e text -\u003e [MatchArray]",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine_NC.html#execMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Engine_NC",
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC",
          "name": "execMatch",
          "normalized": "Regex-\u003ePosition-\u003eChar-\u003ea-\u003e[MatchArray]",
          "package": "regex-tdfa",
          "partial": "Match",
          "signature": "Regex-\u003ePosition-\u003eChar-\u003etext-\u003e[MatchArray]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine_NC.html#v:execMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the non-capturing form of Text.Regex.TDFA.NewDFA.String\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC_FA",
          "name": "Engine_NC_FA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine_NC_FA.html",
          "type": "module"
        },
        "index": {
          "description": "This is the non-capturing form of Text.Regex.TDFA.NewDFA.String",
          "hierarchy": "Text Regex TDFA NewDFA Engine_NC_FA",
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC_FA",
          "name": "Engine_NC_FA",
          "package": "regex-tdfa",
          "partial": "Engine NC FA",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine_NC_FA.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC_FA",
          "name": "execMatch",
          "package": "regex-tdfa",
          "signature": "Regex -\u003e Position -\u003e Char -\u003e text -\u003e [MatchArray]",
          "source": "src/Text-Regex-TDFA-NewDFA-Engine_NC_FA.html#execMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Engine_NC_FA",
          "module": "Text.Regex.TDFA.NewDFA.Engine_NC_FA",
          "name": "execMatch",
          "normalized": "Regex-\u003ePosition-\u003eChar-\u003ea-\u003e[MatchArray]",
          "package": "regex-tdfa",
          "partial": "Match",
          "signature": "Regex-\u003ePosition-\u003eChar-\u003etext-\u003e[MatchArray]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Engine_NC_FA.html#v:execMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.MakeTest",
          "name": "MakeTest",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-MakeTest.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA MakeTest",
          "module": "Text.Regex.TDFA.NewDFA.MakeTest",
          "name": "MakeTest",
          "package": "regex-tdfa",
          "partial": "Make Test",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-MakeTest.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.MakeTest",
          "name": "test_multiline",
          "package": "regex-tdfa",
          "signature": "WhichTest -\u003e Index -\u003e Char -\u003e text -\u003e Bool",
          "source": "src/Text-Regex-TDFA-NewDFA-MakeTest.html#test_multiline",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA MakeTest",
          "module": "Text.Regex.TDFA.NewDFA.MakeTest",
          "name": "test_multiline",
          "normalized": "WhichTest-\u003eIndex-\u003eChar-\u003ea-\u003eBool",
          "package": "regex-tdfa",
          "signature": "WhichTest-\u003eIndex-\u003eChar-\u003etext-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-MakeTest.html#v:test_multiline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.MakeTest",
          "name": "test_singleline",
          "package": "regex-tdfa",
          "signature": "WhichTest -\u003e Index -\u003e Char -\u003e text -\u003e Bool",
          "source": "src/Text-Regex-TDFA-NewDFA-MakeTest.html#test_singleline",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA MakeTest",
          "module": "Text.Regex.TDFA.NewDFA.MakeTest",
          "name": "test_singleline",
          "normalized": "WhichTest-\u003eIndex-\u003eChar-\u003ea-\u003eBool",
          "package": "regex-tdfa",
          "signature": "WhichTest-\u003eIndex-\u003eChar-\u003etext-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-MakeTest.html#v:test_singleline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLike Engine, but merely checks to see whether any match at all is found.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.NewDFA.Tester",
          "name": "Tester",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-Tester.html",
          "type": "module"
        },
        "index": {
          "description": "Like Engine but merely checks to see whether any match at all is found",
          "hierarchy": "Text Regex TDFA NewDFA Tester",
          "module": "Text.Regex.TDFA.NewDFA.Tester",
          "name": "Tester",
          "package": "regex-tdfa",
          "partial": "Tester",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Tester.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Tester",
          "name": "matchTest",
          "package": "regex-tdfa",
          "signature": "Regex -\u003e text -\u003e Bool",
          "source": "src/Text-Regex-TDFA-NewDFA-Tester.html#matchTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Tester",
          "module": "Text.Regex.TDFA.NewDFA.Tester",
          "name": "matchTest",
          "normalized": "Regex-\u003ea-\u003eBool",
          "package": "regex-tdfa",
          "partial": "Test",
          "signature": "Regex-\u003etext-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Tester.html#v:matchTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Uncons",
          "name": "Uncons",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-Uncons.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Uncons",
          "module": "Text.Regex.TDFA.NewDFA.Uncons",
          "name": "Uncons",
          "package": "regex-tdfa",
          "partial": "Uncons",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Uncons.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Uncons",
          "name": "Uncons",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-NewDFA-Uncons.html#Uncons",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Uncons",
          "module": "Text.Regex.TDFA.NewDFA.Uncons",
          "name": "Uncons",
          "package": "regex-tdfa",
          "partial": "Uncons",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Uncons.html#t:Uncons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.NewDFA.Uncons",
          "name": "uncons",
          "package": "regex-tdfa",
          "signature": "a -\u003e Maybe (Char, a)",
          "source": "src/Text-Regex-TDFA-NewDFA-Uncons.html#uncons",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex TDFA NewDFA Uncons",
          "module": "Text.Regex.TDFA.NewDFA.Uncons",
          "name": "uncons",
          "normalized": "a-\u003eMaybe(Char,a)",
          "package": "regex-tdfa",
          "signature": "a-\u003eMaybe(Char,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-NewDFA-Uncons.html#v:uncons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis \u003ca\u003eText.Regex.TDFA.Pattern\u003c/a\u003e module provides the \u003ccode\u003e\u003ca\u003ePattern\u003c/a\u003e\u003c/code\u003e data\n type and its subtypes.  This \u003ccode\u003e\u003ca\u003ePattern\u003c/a\u003e\u003c/code\u003e type is used to represent\n the parsed form of a Regular Expression.  \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "Pattern",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Pattern.html",
          "type": "module"
        },
        "index": {
          "description": "This Text.Regex.TDFA.Pattern module provides the Pattern data type and its subtypes This Pattern type is used to represent the parsed form of Regular Expression",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "Pattern",
          "package": "regex-tdfa",
          "partial": "Pattern",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to track elements of the pattern that accept characters or \n are anchors\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "DoPa",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DoPa",
          "type": "newtype"
        },
        "index": {
          "description": "Used to track elements of the pattern that accept characters or are anchors",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "DoPa",
          "package": "regex-tdfa",
          "partial": "Do Pa",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#t:DoPa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGroupIndex is for indexing submatches from capturing\n parenthesized groups (PGroup/Group)\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "GroupIndex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#GroupIndex",
          "type": "type"
        },
        "index": {
          "description": "GroupIndex is for indexing submatches from capturing parenthesized groups PGroup Group",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "GroupIndex",
          "package": "regex-tdfa",
          "partial": "Group Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#t:GroupIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePattern is the type returned by the regular expression parser.\n This is consumed by the CorePattern module and the tender leaves\n are nibbled by the TNFA module.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "Pattern",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "data"
        },
        "index": {
          "description": "Pattern is the type returned by the regular expression parser This is consumed by the CorePattern module and the tender leaves are nibbled by the TNFA module",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "Pattern",
          "package": "regex-tdfa",
          "partial": "Pattern",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#t:Pattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSet",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSet",
          "package": "regex-tdfa",
          "partial": "Pattern Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#t:PatternSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCharacterClass",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetCharacterClass",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCharacterClass",
          "package": "regex-tdfa",
          "partial": "Pattern Set Character Class",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#t:PatternSetCharacterClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCollatingElement",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetCollatingElement",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCollatingElement",
          "package": "regex-tdfa",
          "partial": "Pattern Set Collating Element",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#t:PatternSetCollatingElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetEquivalenceClass",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetEquivalenceClass",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetEquivalenceClass",
          "package": "regex-tdfa",
          "partial": "Pattern Set Equivalence Class",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#t:PatternSetEquivalenceClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PAny",
          "package": "regex-tdfa",
          "signature": "PAny",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PAny",
          "package": "regex-tdfa",
          "partial": "PAny",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PAny"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PAnyNot",
          "package": "regex-tdfa",
          "signature": "PAnyNot",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PAnyNot",
          "package": "regex-tdfa",
          "partial": "PAny Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PAnyNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PBound",
          "package": "regex-tdfa",
          "signature": "PBound Int (Maybe Int) Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PBound",
          "package": "regex-tdfa",
          "partial": "PBound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PCarat",
          "package": "regex-tdfa",
          "signature": "PCarat",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PCarat",
          "package": "regex-tdfa",
          "partial": "PCarat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PCarat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PChar",
          "package": "regex-tdfa",
          "signature": "PChar",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PChar",
          "package": "regex-tdfa",
          "partial": "PChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PConcat",
          "package": "regex-tdfa",
          "signature": "PConcat [Pattern]",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PConcat",
          "normalized": "PConcat[Pattern]",
          "package": "regex-tdfa",
          "partial": "PConcat",
          "signature": "PConcat[Pattern]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PConcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PDollar",
          "package": "regex-tdfa",
          "signature": "PDollar",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PDollar",
          "package": "regex-tdfa",
          "partial": "PDollar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PDollar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PDot",
          "package": "regex-tdfa",
          "signature": "PDot",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PDot",
          "package": "regex-tdfa",
          "partial": "PDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PEmpty",
          "package": "regex-tdfa",
          "signature": "PEmpty",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PEmpty",
          "package": "regex-tdfa",
          "partial": "PEmpty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PEscape",
          "package": "regex-tdfa",
          "signature": "PEscape",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PEscape",
          "package": "regex-tdfa",
          "partial": "PEscape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PGroup",
          "package": "regex-tdfa",
          "signature": "PGroup (Maybe GroupIndex) Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PGroup",
          "package": "regex-tdfa",
          "partial": "PGroup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PNonCapture",
          "package": "regex-tdfa",
          "signature": "PNonCapture Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PNonCapture",
          "package": "regex-tdfa",
          "partial": "PNon Capture",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PNonCapture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PNonEmpty",
          "package": "regex-tdfa",
          "signature": "PNonEmpty Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PNonEmpty",
          "package": "regex-tdfa",
          "partial": "PNon Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PNonEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "POr",
          "package": "regex-tdfa",
          "signature": "POr [Pattern]",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "POr",
          "normalized": "POr[Pattern]",
          "package": "regex-tdfa",
          "partial": "POr",
          "signature": "POr[Pattern]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:POr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PPlus",
          "package": "regex-tdfa",
          "signature": "PPlus Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PPlus",
          "package": "regex-tdfa",
          "partial": "PPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PQuest",
          "package": "regex-tdfa",
          "signature": "PQuest Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PQuest",
          "package": "regex-tdfa",
          "partial": "PQuest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PQuest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PStar",
          "package": "regex-tdfa",
          "signature": "PStar Bool Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PStar",
          "package": "regex-tdfa",
          "partial": "PStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSet",
          "package": "regex-tdfa",
          "signature": "PatternSet (Maybe (Set Char)) (Maybe (Set PatternSetCharacterClass)) (Maybe (Set PatternSetCollatingElement)) (Maybe (Set PatternSetEquivalenceClass))",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSet",
          "package": "regex-tdfa",
          "partial": "Pattern Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PatternSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCharacterClass",
          "package": "regex-tdfa",
          "signature": "PatternSetCharacterClass",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetCharacterClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCharacterClass",
          "package": "regex-tdfa",
          "partial": "Pattern Set Character Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PatternSetCharacterClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCollatingElement",
          "package": "regex-tdfa",
          "signature": "PatternSetCollatingElement",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetCollatingElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetCollatingElement",
          "package": "regex-tdfa",
          "partial": "Pattern Set Collating Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PatternSetCollatingElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetEquivalenceClass",
          "package": "regex-tdfa",
          "signature": "PatternSetEquivalenceClass",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetEquivalenceClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "PatternSetEquivalenceClass",
          "package": "regex-tdfa",
          "partial": "Pattern Set Equivalence Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:PatternSetEquivalenceClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a Pattern transfomation function depth first\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "dfsPattern",
          "package": "regex-tdfa",
          "signature": "(Pattern -\u003e Pattern)-\u003e Pattern-\u003e Pattern",
          "type": "function"
        },
        "index": {
          "description": "Apply Pattern transfomation function depth first",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "dfsPattern",
          "normalized": "(Pattern-\u003ePattern)-\u003ePattern-\u003ePattern",
          "package": "regex-tdfa",
          "partial": "Pattern",
          "signature": "(Pattern-\u003ePattern)-\u003ePattern-\u003ePattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:dfsPattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "getDoPa",
          "package": "regex-tdfa",
          "signature": "DoPa",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "getDoPa",
          "package": "regex-tdfa",
          "partial": "Do Pa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:getDoPa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "getPatternChar",
          "package": "regex-tdfa",
          "signature": "Char",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "getPatternChar",
          "package": "regex-tdfa",
          "partial": "Pattern Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:getPatternChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "getPatternSet",
          "package": "regex-tdfa",
          "signature": "PatternSet",
          "source": "src/Text-Regex-TDFA-Pattern.html#Pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "getPatternSet",
          "package": "regex-tdfa",
          "partial": "Pattern Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:getPatternSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eI have not been checking, but this should have the property that\n parsing the resulting string should result in an identical Pattern.\n This is not true if starTrans has created PNonCapture and PNonEmpty\n values or a (PStar False).  The contents of a \u003ca\u003e[ ]\u003c/a\u003e grouping are\n always shown in a sorted canonical order.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "showPattern",
          "package": "regex-tdfa",
          "signature": "Pattern -\u003e String",
          "source": "src/Text-Regex-TDFA-Pattern.html#showPattern",
          "type": "function"
        },
        "index": {
          "description": "have not been checking but this should have the property that parsing the resulting string should result in an identical Pattern This is not true if starTrans has created PNonCapture and PNonEmpty values or PStar False The contents of grouping are always shown in sorted canonical order",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "showPattern",
          "normalized": "Pattern-\u003eString",
          "package": "regex-tdfa",
          "partial": "Pattern",
          "signature": "Pattern-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:showPattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to transform a pattern into an equivalent, but less\n redundant form.  Nested \u003ccode\u003e\u003ca\u003ePOr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ePConcat\u003c/a\u003e\u003c/code\u003e are flattened. PEmpty\n is propagated.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "simplify'",
          "package": "regex-tdfa",
          "signature": "Pattern -\u003e Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#simplify%27",
          "type": "function"
        },
        "index": {
          "description": "Function to transform pattern into an equivalent but less redundant form Nested POr and PConcat are flattened PEmpty is propagated",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "simplify'",
          "normalized": "Pattern-\u003ePattern",
          "package": "regex-tdfa",
          "signature": "Pattern-\u003ePattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:simplify-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo the transformation and simplification in a single traversal.\n This removes the PPlus, PQuest, and PBound values, changing to POr\n and PEmpty and PStar True/False.  For some PBound values it adds\n PNonEmpty and PNonCapture semantic marker.  It also simplifies to\n flatten out nested POr and PConcat instances and eliminate some\n unneeded PEmpty values.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "starTrans",
          "package": "regex-tdfa",
          "signature": "Pattern -\u003e Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#starTrans",
          "type": "function"
        },
        "index": {
          "description": "Do the transformation and simplification in single traversal This removes the PPlus PQuest and PBound values changing to POr and PEmpty and PStar True False For some PBound values it adds PNonEmpty and PNonCapture semantic marker It also simplifies to flatten out nested POr and PConcat instances and eliminate some unneeded PEmpty values",
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "starTrans",
          "normalized": "Pattern-\u003ePattern",
          "package": "regex-tdfa",
          "partial": "Trans",
          "signature": "Pattern-\u003ePattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:starTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "starTrans'",
          "package": "regex-tdfa",
          "signature": "Pattern -\u003e Pattern",
          "source": "src/Text-Regex-TDFA-Pattern.html#starTrans%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "starTrans'",
          "normalized": "Pattern-\u003ePattern",
          "package": "regex-tdfa",
          "partial": "Trans'",
          "signature": "Pattern-\u003ePattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:starTrans-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "unSCC",
          "package": "regex-tdfa",
          "signature": "String",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetCharacterClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "unSCC",
          "package": "regex-tdfa",
          "partial": "SCC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:unSCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "unSCE",
          "package": "regex-tdfa",
          "signature": "String",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetCollatingElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "unSCE",
          "package": "regex-tdfa",
          "partial": "SCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:unSCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Pattern",
          "name": "unSEC",
          "package": "regex-tdfa",
          "signature": "String",
          "source": "src/Text-Regex-TDFA-Pattern.html#PatternSetEquivalenceClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Pattern",
          "module": "Text.Regex.TDFA.Pattern",
          "name": "unSEC",
          "package": "regex-tdfa",
          "partial": "SEC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Pattern.html#v:unSEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is a POSIX version of parseRegex that allows NUL characters.\n Lazy\u003cem\u003ePossessive\u003c/em\u003eBackrefs are not recognized.  Anchors ^ and $ are\n recognized.\n\u003c/p\u003e\u003cp\u003eThe PGroup returned always have (Maybe GroupIndex) set to (Just _)\n and never to Nothing.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.ReadRegex",
          "name": "ReadRegex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-ReadRegex.html",
          "type": "module"
        },
        "index": {
          "description": "This is POSIX version of parseRegex that allows NUL characters Lazy Possessive Backrefs are not recognized Anchors and are recognized The PGroup returned always have Maybe GroupIndex set to Just and never to Nothing",
          "hierarchy": "Text Regex TDFA ReadRegex",
          "module": "Text.Regex.TDFA.ReadRegex",
          "name": "ReadRegex",
          "package": "regex-tdfa",
          "partial": "Read Regex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ReadRegex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn either an error message or a tuple of the Pattern and the\n largest group index and the largest DoPa index (both have smallest\n index of 1).  Since the regular expression is supplied as [Char] it\n automatically supports unicode and '\\NUL' characters.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.ReadRegex",
          "name": "parseRegex",
          "package": "regex-tdfa",
          "signature": "String -\u003e Either ParseError (Pattern, (GroupIndex, DoPa))",
          "source": "src/Text-Regex-TDFA-ReadRegex.html#parseRegex",
          "type": "function"
        },
        "index": {
          "description": "Return either an error message or tuple of the Pattern and the largest group index and the largest DoPa index both have smallest index of Since the regular expression is supplied as Char it automatically supports unicode and NUL characters",
          "hierarchy": "Text Regex TDFA ReadRegex",
          "module": "Text.Regex.TDFA.ReadRegex",
          "name": "parseRegex",
          "normalized": "String-\u003eEither ParseError(Pattern,(GroupIndex,DoPa))",
          "package": "regex-tdfa",
          "partial": "Regex",
          "signature": "String-\u003eEither ParseError(Pattern,(GroupIndex,DoPa))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-ReadRegex.html#v:parseRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules provides \u003ccode\u003e\u003ca\u003eRegexMaker\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRegexLike\u003c/a\u003e\u003c/code\u003e instances for using\n\u003ccode\u003eByteString\u003c/code\u003e with the DFA backend (\u003ca\u003eText.Regex.Lib.WrapDFAEngine\u003c/a\u003e and\n\u003ca\u003eText.Regex.Lazy.DFAEngineFPS\u003c/a\u003e).  This module is usually used via\nimport \u003ca\u003eText.Regex.TDFA\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "Sequence",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Sequence.html",
          "type": "module"
        },
        "index": {
          "description": "This modules provides RegexMaker and RegexLike instances for using ByteString with the DFA backend Text.Regex.Lib.WrapDFAEngine and Text.Regex.Lazy.DFAEngineFPS This module is usually used via import Text.Regex.TDFA This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex TDFA Sequence",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "Sequence",
          "package": "regex-tdfa",
          "partial": "Sequence",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Sequence.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "CompOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex TDFA Sequence",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "CompOption",
          "package": "regex-tdfa",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Sequence.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Sequence",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Sequence",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Sequence.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe TDFA backend specific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type, used by this module's RegexOptions and RegexMaker\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "Regex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The TDFA backend specific Regex type used by this module RegexOptions and RegexMaker",
          "hierarchy": "Text Regex TDFA Sequence",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "Regex",
          "package": "regex-tdfa",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Sequence.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Sequence",
          "name": "compile",
          "package": "regex-tdfa",
          "signature": "CompOption-\u003e ExecOption-\u003e Seq Char-\u003e Either String Regex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Sequence",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eSeq Char-\u003eEither String Regex",
          "package": "regex-tdfa",
          "signature": "CompOption-\u003eExecOption-\u003eSeq Char-\u003eEither String Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Sequence.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Sequence",
          "name": "execute",
          "package": "regex-tdfa",
          "signature": "Regex-\u003e Seq Char-\u003e Either String (Maybe MatchArray)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Sequence",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "execute",
          "normalized": "Regex-\u003eSeq Char-\u003eEither String(Maybe MatchArray)",
          "package": "regex-tdfa",
          "signature": "Regex-\u003eSeq Char-\u003eEither String(Maybe MatchArray)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Sequence.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.Sequence",
          "name": "regexec",
          "package": "regex-tdfa",
          "signature": "Regex-\u003e Seq Char-\u003e Either String (Maybe (Seq Char, Seq Char, Seq Char, [Seq Char]))",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA Sequence",
          "module": "Text.Regex.TDFA.Sequence",
          "name": "regexec",
          "normalized": "Regex-\u003eSeq Char-\u003eEither String(Maybe(Seq Char,Seq Char,Seq Char,[Seq Char]))",
          "package": "regex-tdfa",
          "signature": "Regex-\u003eSeq Char-\u003eEither String(Maybe(Seq Char,Seq Char,Seq Char,[Seq Char]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-Sequence.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis modules provides \u003ccode\u003e\u003ca\u003eRegexMaker\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRegexLike\u003c/a\u003e\u003c/code\u003e instances for using\n\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e with the TDFA backend.\n\u003c/p\u003e\u003cp\u003eThis exports instances of the high level API and the medium level\nAPI of \u003ccode\u003e\u003ca\u003ecompile\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eexecute\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eregexec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.String",
          "name": "String",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-String.html",
          "type": "module"
        },
        "index": {
          "description": "This modules provides RegexMaker and RegexLike instances for using String with the TDFA backend This exports instances of the high level API and the medium level API of compile execute and regexec",
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "String",
          "package": "regex-tdfa",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControl whether the pattern is multiline or case-sensitive like Text.Regex and whether to\n capture the subgroups (1, 2, etc).  Controls enabling extra anchor syntax.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.String",
          "name": "CompOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#CompOption",
          "type": "data"
        },
        "index": {
          "description": "Control whether the pattern is multiline or case-sensitive like Text.Regex and whether to capture the subgroups etc Controls enabling extra anchor syntax",
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "CompOption",
          "package": "regex-tdfa",
          "partial": "Comp Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#t:CompOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.String",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#ExecOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "ExecOption",
          "package": "regex-tdfa",
          "partial": "Exec Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#t:ExecOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-negative length of a match\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.String",
          "name": "MatchLength",
          "package": "regex-tdfa",
          "type": "type"
        },
        "index": {
          "description": "non-negative length of match",
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "MatchLength",
          "package": "regex-tdfa",
          "partial": "Match Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#t:MatchLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0 based index from start of source, or (-1) for unused\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.String",
          "name": "MatchOffset",
          "package": "regex-tdfa",
          "type": "type"
        },
        "index": {
          "description": "based index from start of source or for unused",
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "MatchOffset",
          "package": "regex-tdfa",
          "partial": "Match Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#t:MatchOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe TDFA backend specific \u003ccode\u003e\u003ca\u003eRegex\u003c/a\u003e\u003c/code\u003e type, used by this module's RegexOptions and RegexMaker\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.String",
          "name": "Regex",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#Regex",
          "type": "data"
        },
        "index": {
          "description": "The TDFA backend specific Regex type used by this module RegexOptions and RegexMaker",
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "Regex",
          "package": "regex-tdfa",
          "partial": "Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#t:Regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.String",
          "name": "compile",
          "package": "regex-tdfa",
          "signature": "CompOption-\u003e ExecOption-\u003e String-\u003e Either String Regex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "compile",
          "normalized": "CompOption-\u003eExecOption-\u003eString-\u003eEither String Regex",
          "package": "regex-tdfa",
          "signature": "CompOption-\u003eExecOption-\u003eString-\u003eEither String Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#v:compile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.String",
          "name": "execute",
          "package": "regex-tdfa",
          "signature": "Regex-\u003e String-\u003e Either String (Maybe MatchArray)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "execute",
          "normalized": "Regex-\u003eString-\u003eEither String(Maybe MatchArray)",
          "package": "regex-tdfa",
          "signature": "Regex-\u003eString-\u003eEither String(Maybe MatchArray)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#v:execute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.String",
          "name": "regexec",
          "package": "regex-tdfa",
          "signature": "Regex-\u003e String-\u003e Either String (Maybe (String, String, String, [String]))",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA String",
          "module": "Text.Regex.TDFA.String",
          "name": "regexec",
          "normalized": "Regex-\u003eString-\u003eEither String(Maybe(String,String,String,[String]))",
          "package": "regex-tdfa",
          "signature": "Regex-\u003eString-\u003eEither String(Maybe(String,String,String,[String]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-String.html#v:regexec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003eText.Regex.TDFA.TDFA\u003c/a\u003e converts the QNFA from TNFA into the DFA.\n A DFA state corresponds to a Set of QNFA states, repesented as list\n of Index which are used to lookup the DFA state in a lazy Trie\n which holds all possible subsets of QNFA states.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "TDFA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-TDFA.html",
          "type": "module"
        },
        "index": {
          "description": "Text.Regex.TDFA.TDFA converts the QNFA from TNFA into the DFA DFA state corresponds to Set of QNFA states repesented as list of Index which are used to lookup the DFA state in lazy Trie which holds all possible subsets of QNFA states",
          "hierarchy": "Text Regex TDFA TDFA",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "TDFA",
          "package": "regex-tdfa",
          "partial": "TDFA",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal DFA node, identified by the Set of indices of the QNFA\n nodes it represents.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "DFA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DFA",
          "type": "data"
        },
        "index": {
          "description": "Internal DFA node identified by the Set of indices of the QNFA nodes it represents",
          "hierarchy": "Text Regex TDFA TDFA",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "DFA",
          "package": "regex-tdfa",
          "partial": "DFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#t:DFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal to the DFA node\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "DT",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#DT",
          "type": "data"
        },
        "index": {
          "description": "Internal to the DFA node",
          "hierarchy": "Text Regex TDFA TDFA",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "DT",
          "package": "regex-tdfa",
          "partial": "DT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#t:DT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.TDFA",
          "name": "dfaMap",
          "package": "regex-tdfa",
          "signature": "DFA -\u003e Map SetIndex DFA",
          "source": "src/Text-Regex-TDFA-TDFA.html#dfaMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA TDFA",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "dfaMap",
          "normalized": "DFA-\u003eMap SetIndex DFA",
          "package": "regex-tdfa",
          "partial": "Map",
          "signature": "DFA-\u003eMap SetIndex DFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:dfaMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.TDFA",
          "name": "examineDFA",
          "package": "regex-tdfa",
          "signature": "Regex -\u003e String",
          "source": "src/Text-Regex-TDFA-TDFA.html#examineDFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA TDFA",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "examineDFA",
          "normalized": "Regex-\u003eString",
          "package": "regex-tdfa",
          "partial": "DFA",
          "signature": "Regex-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:examineDFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.TDFA",
          "name": "nfaToDFA",
          "package": "regex-tdfa",
          "signature": "((Index, Array Index QNFA), Array Tag OP, Array GroupIndex [GroupInfo]) -\u003e CompOption -\u003e ExecOption -\u003e Regex",
          "source": "src/Text-Regex-TDFA-TDFA.html#nfaToDFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA TDFA",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "nfaToDFA",
          "normalized": "((Index,Array Index QNFA),Array Tag OP,Array GroupIndex[GroupInfo])-\u003eCompOption-\u003eExecOption-\u003eRegex",
          "package": "regex-tdfa",
          "partial": "To DFA",
          "signature": "((Index,Array Index QNFA),Array Tag OP,Array GroupIndex[GroupInfo])-\u003eCompOption-\u003eExecOption-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:nfaToDFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.TDFA",
          "name": "patternToRegex",
          "package": "regex-tdfa",
          "signature": "(Pattern, (GroupIndex, DoPa)) -\u003e CompOption -\u003e ExecOption -\u003e Regex",
          "source": "src/Text-Regex-TDFA-TDFA.html#patternToRegex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA TDFA",
          "module": "Text.Regex.TDFA.TDFA",
          "name": "patternToRegex",
          "normalized": "(Pattern,(GroupIndex,DoPa))-\u003eCompOption-\u003eExecOption-\u003eRegex",
          "package": "regex-tdfa",
          "partial": "To Regex",
          "signature": "(Pattern,(GroupIndex,DoPa))-\u003eCompOption-\u003eExecOption-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TDFA.html#v:patternToRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003eText.Regex.TDFA.TNFA\u003c/a\u003e converts the CorePattern Q/P data (and its\n Pattern leafs) to a QNFA tagged non-deterministic finite automata.\n\u003c/p\u003e\u003cp\u003eThis holds every possible way to follow one state by another, while\n in the DFA these will be reduced by picking a single best\n transition for each (soure,destination) pair.  The transitions are\n heavily and often redundantly annotated with tasks to perform, and\n this redundancy is reduced when picking the best transition.  So\n far, keeping all this information has helped fix bugs in both the\n design and implementation.\n\u003c/p\u003e\u003cp\u003eThe QNFA for a Pattern with a starTraned Q/P form with N one\n character accepting leaves has at most N+1 nodes.  These nodes\n repesent the future choices after accepting a leaf.  The processing\n of Or nodes often reduces this number by sharing at the end of the\n different paths.  Turning off capturing while compiling the pattern\n may (future extension) reduce this further for some patterns by\n processing Star with optimizations.  This compact design also means\n that tags are assigned not just to be updated before taking a\n transition (PreUpdate) but also after the transition (PostUpdate).\n\u003c/p\u003e\u003cp\u003eUses recursive do notation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "TNFA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-TNFA.html",
          "type": "module"
        },
        "index": {
          "description": "Text.Regex.TDFA.TNFA converts the CorePattern data and its Pattern leafs to QNFA tagged non-deterministic finite automata This holds every possible way to follow one state by another while in the DFA these will be reduced by picking single best transition for each soure destination pair The transitions are heavily and often redundantly annotated with tasks to perform and this redundancy is reduced when picking the best transition So far keeping all this information has helped fix bugs in both the design and implementation The QNFA for Pattern with starTraned form with one character accepting leaves has at most nodes These nodes repesent the future choices after accepting leaf The processing of Or nodes often reduces this number by sharing at the end of the different paths Turning off capturing while compiling the pattern may future extension reduce this further for some patterns by processing Star with optimizations This compact design also means that tags are assigned not just to be updated before taking transition PreUpdate but also after the transition PostUpdate Uses recursive do notation",
          "hierarchy": "Text Regex TDFA TNFA",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "TNFA",
          "package": "regex-tdfa",
          "partial": "TNFA",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal NFA node type\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "QNFA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#QNFA",
          "type": "data"
        },
        "index": {
          "description": "Internal NFA node type",
          "hierarchy": "Text Regex TDFA TNFA",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "QNFA",
          "package": "regex-tdfa",
          "partial": "QNFA",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#t:QNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal to QNFA type.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "QT",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#QT",
          "type": "data"
        },
        "index": {
          "description": "Internal to QNFA type",
          "hierarchy": "Text Regex TDFA TNFA",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "QT",
          "package": "regex-tdfa",
          "partial": "QT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#t:QT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal type to represent the tagged transition from one QNFA to\n another (or itself).  The key is the Index of the destination QNFA.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "QTrans",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#QTrans",
          "type": "type"
        },
        "index": {
          "description": "Internal type to represent the tagged transition from one QNFA to another or itself The key is the Index of the destination QNFA",
          "hierarchy": "Text Regex TDFA TNFA",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "QTrans",
          "package": "regex-tdfa",
          "partial": "QTrans",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#t:QTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen attached to a QTrans the TagTask can be done before or after\n accepting the character.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "TagUpdate",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA-Common.html#TagUpdate",
          "type": "data"
        },
        "index": {
          "description": "When attached to QTrans the TagTask can be done before or after accepting the character",
          "hierarchy": "Text Regex TDFA TNFA",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "TagUpdate",
          "package": "regex-tdfa",
          "partial": "Tag Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#t:TagUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA.TNFA",
          "name": "patternToNFA",
          "package": "regex-tdfa",
          "signature": "CompOption -\u003e (Pattern, (GroupIndex, DoPa)) -\u003e ((Index, Array Index QNFA), Array Tag OP, Array GroupIndex [GroupInfo])",
          "source": "src/Text-Regex-TDFA-TNFA.html#patternToNFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA TNFA",
          "module": "Text.Regex.TDFA.TNFA",
          "name": "patternToNFA",
          "normalized": "CompOption-\u003e(Pattern,(GroupIndex,DoPa))-\u003e((Index,Array Index QNFA),Array Tag OP,Array GroupIndex[GroupInfo])",
          "package": "regex-tdfa",
          "partial": "To NFA",
          "signature": "CompOption-\u003e(Pattern,(GroupIndex,DoPa))-\u003e((Index,Array Index QNFA),Array Tag OP,Array GroupIndex[GroupInfo])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA-TNFA.html#v:patternToNFA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ca\u003eText.Regex.TDFA\u003c/a\u003e module provides a backend for regular\nexpressions. It provides instances for the classes defined and\ndocumented in \u003ca\u003eText.Regex.Base\u003c/a\u003e and re-exported by this module.  If\nyou import this along with other backends then you should do so with\nqualified imports (with renaming for convenience).\n\u003c/p\u003e\u003cp\u003eThis regex-tdfa package implements, correctly, POSIX extended regular\nexpressions.  It is highly unlikely that the regex-posix package on\nyour operating system is correct, see\nhttp:\u003cem/\u003ewww.haskell.org\u003cem\u003ehaskellwiki\u003c/em\u003eRegex_Posix for examples of your\nOS's bugs.\n\u003c/p\u003e\u003cp\u003eThis package does provide captured parenthesized subexpressions.\n\u003c/p\u003e\u003cp\u003eDepending on the text being searched this package supports Unicode.\nThe [Char] and (Seq Char) text types support Unicode.  The ByteString\nand ByteString.Lazy text types only support ASCII.  It is possible to\nsupport utf8 encoded ByteString.Lazy by using regex-tdfa and\nregex-tdfa-utf8 packages together  (required the utf8-string package).\n\u003c/p\u003e\u003cp\u003eAs of version 1.1.1 the following GNU extensions are recognized, all\nanchors:\n\u003c/p\u003e\u003cp\u003e\\` at beginning of entire text\n\u003c/p\u003e\u003cp\u003e\\' at end of entire text\n\u003c/p\u003e\u003cp\u003e\\\u003c at beginning of word\n\u003c/p\u003e\u003cp\u003e\\\u003e at end of word\n\u003c/p\u003e\u003cp\u003e\\b at either beginning or end of word\n\u003c/p\u003e\u003cp\u003e\\B at neither beginning nor end of word\n\u003c/p\u003e\u003cp\u003eThe above are controlled by the \u003ccode\u003e\u003ca\u003enewSyntax\u003c/a\u003e\u003c/code\u003e Bool in \u003ccode\u003e\u003ca\u003eCompOption\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhere the \u003ca\u003eword\u003c/a\u003e boundaries means between characters that are and are\nnot in the [:word:] character class which contains [a-zA-Z0-9_].  Note\nthat \u003c and b may match before the entire text and \u003e and b may\nmatch at the end of the entire text.\n\u003c/p\u003e\u003cp\u003eThere is no locale support, so collating elements like [.ch.] are\nsimply ignored and equivalence classes like [=a=] are converted to\njust [a].  The character classes like [:alnum:] are supported over\nASCII only, valid classes are alnum, digit, punct, alpha, graph,\nspace, blank, lower, upper, cntrl, print, xdigit, word.\n\u003c/p\u003e\u003cp\u003eThis package does not provide \u003ca\u003ebasic\u003c/a\u003e regular expressions.  This\npackage does not provide back references inside regular expressions.\n\u003c/p\u003e\u003cp\u003eThe package does not provide Perl style regular expressions.  Please\nlook at the regex-pcre and pcre-light packages instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.TDFA",
          "name": "TDFA",
          "package": "regex-tdfa",
          "source": "src/Text-Regex-TDFA.html",
          "type": "module"
        },
        "index": {
          "description": "The Text.Regex.TDFA module provides backend for regular expressions It provides instances for the classes defined and documented in Text.Regex.Base and re-exported by this module If you import this along with other backends then you should do so with qualified imports with renaming for convenience This regex-tdfa package implements correctly POSIX extended regular expressions It is highly unlikely that the regex-posix package on your operating system is correct see http www.haskell.org haskellwiki Regex Posix for examples of your OS bugs This package does provide captured parenthesized subexpressions Depending on the text being searched this package supports Unicode The Char and Seq Char text types support Unicode The ByteString and ByteString.Lazy text types only support ASCII It is possible to support utf8 encoded ByteString.Lazy by using regex-tdfa and regex-tdfa-utf8 packages together required the utf8-string package As of version the following GNU extensions are recognized all anchors at beginning of entire text at end of entire text at beginning of word at end of word at either beginning or end of word at neither beginning nor end of word The above are controlled by the newSyntax Bool in CompOption Where the word boundaries means between characters that are and are not in the word character class which contains a-zA-Z0-9 Note that and may match before the entire text and and may match at the end of the entire text There is no locale support so collating elements like ch are simply ignored and equivalence classes like are converted to just The character classes like alnum are supported over ASCII only valid classes are alnum digit punct alpha graph space blank lower upper cntrl print xdigit word This package does not provide basic regular expressions This package does not provide back references inside regular expressions The package does not provide Perl style regular expressions Please look at the regex-pcre and pcre-light packages instead",
          "hierarchy": "Text Regex TDFA",
          "module": "Text.Regex.TDFA",
          "name": "TDFA",
          "package": "regex-tdfa",
          "partial": "TDFA",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the pure functional matching operator.  If the target\n cannot be produced then some empty result will be returned.  If\n there is an error in processing, then \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e will be called.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA",
          "name": "(=~)",
          "package": "regex-tdfa",
          "signature": "source1 -\u003e source -\u003e target",
          "source": "src/Text-Regex-TDFA.html#%3D~",
          "type": "function"
        },
        "index": {
          "description": "This is the pure functional matching operator If the target cannot be produced then some empty result will be returned If there is an error in processing then error will be called",
          "hierarchy": "Text Regex TDFA",
          "module": "Text.Regex.TDFA",
          "name": "(=~) =~",
          "normalized": "a-\u003ea-\u003eb",
          "package": "regex-tdfa",
          "signature": "source-\u003esource-\u003etarget",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA.html#v:-61--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the monadic matching operator.  If a single match fails,\n then \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e will be called.\n\u003c/p\u003e",
          "module": "Text.Regex.TDFA",
          "name": "(=~~)",
          "package": "regex-tdfa",
          "signature": "source1 -\u003e source -\u003e m target",
          "source": "src/Text-Regex-TDFA.html#%3D~~",
          "type": "function"
        },
        "index": {
          "description": "This is the monadic matching operator If single match fails then fail will be called",
          "hierarchy": "Text Regex TDFA",
          "module": "Text.Regex.TDFA",
          "name": "(=~~) =~~",
          "normalized": "a-\u003ea-\u003eb c",
          "package": "regex-tdfa",
          "signature": "source-\u003esource-\u003em target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA.html#v:-61--126--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.TDFA",
          "name": "getVersion_Text_Regex_TDFA",
          "package": "regex-tdfa",
          "signature": "Version",
          "source": "src/Text-Regex-TDFA.html#getVersion_Text_Regex_TDFA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex TDFA",
          "module": "Text.Regex.TDFA",
          "name": "getVersion_Text_Regex_TDFA",
          "package": "regex-tdfa",
          "partial": "Version Text Regex TDFA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-tdfa/docs/Text-Regex-TDFA.html#v:getVersion_Text_Regex_TDFA"
      }
    }
  ]
]