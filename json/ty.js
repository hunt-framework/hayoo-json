[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "ty"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType class for typed type representations\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.IsTy",
          "name": "IsTy",
          "package": "ty",
          "source": "src/Data-IsTy.html",
          "type": "module"
        },
        "index": {
          "description": "Type class for typed type representations",
          "hierarchy": "Data IsTy",
          "module": "Data.IsTy",
          "name": "IsTy",
          "package": "ty",
          "partial": "Is Ty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-IsTy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for typed type representations\n\u003c/p\u003e",
          "module": "Data.IsTy",
          "name": "IsTy",
          "package": "ty",
          "source": "src/Data-IsTy.html#IsTy",
          "type": "class"
        },
        "index": {
          "description": "Type class for typed type representations",
          "hierarchy": "Data IsTy",
          "module": "Data.IsTy",
          "name": "IsTy",
          "package": "ty",
          "partial": "Is Ty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-IsTy.html#t:IsTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for typed type representations\n\u003c/p\u003e",
          "module": "Data.IsTy",
          "name": "IsTy2",
          "package": "ty",
          "source": "src/Data-IsTy.html#IsTy2",
          "type": "class"
        },
        "index": {
          "description": "Type class for typed type representations",
          "hierarchy": "Data IsTy",
          "module": "Data.IsTy",
          "name": "IsTy2",
          "package": "ty",
          "partial": "Is Ty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-IsTy.html#t:IsTy2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IsTy",
          "name": "Yes",
          "package": "ty",
          "source": "src/Data-IsTy.html#Yes",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data IsTy",
          "module": "Data.IsTy",
          "name": "Yes",
          "package": "ty",
          "partial": "Yes",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-IsTy.html#t:Yes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IsTy",
          "name": "Yes2",
          "package": "ty",
          "source": "src/Data-IsTy.html#Yes2",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data IsTy",
          "module": "Data.IsTy",
          "name": "Yes2",
          "package": "ty",
          "partial": "Yes",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-IsTy.html#t:Yes2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IsTy",
          "name": "tyEq",
          "package": "ty",
          "signature": "f a -\u003e f b -\u003e Maybe (a :=: b)",
          "source": "src/Data-IsTy.html#tyEq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IsTy",
          "module": "Data.IsTy",
          "name": "tyEq",
          "normalized": "a b-\u003ea c-\u003eMaybe(b c)",
          "package": "ty",
          "partial": "Eq",
          "signature": "f a-\u003ef b-\u003eMaybe(a b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-IsTy.html#v:tyEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IsTy",
          "name": "tyEq2",
          "package": "ty",
          "signature": "f a b -\u003e f c d -\u003e Maybe ((a, b) :=: (c, d))",
          "source": "src/Data-IsTy.html#tyEq2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IsTy",
          "module": "Data.IsTy",
          "name": "tyEq2",
          "normalized": "a b c-\u003ea d e-\u003eMaybe((b,c)(d,e))",
          "package": "ty",
          "partial": "Eq",
          "signature": "f a b-\u003ef c d-\u003eMaybe((a,b)(c,d))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-IsTy.html#v:tyEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType equality proofs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Proof.EQ",
          "name": "EQ",
          "package": "ty",
          "source": "src/Data-Proof-EQ.html",
          "type": "module"
        },
        "index": {
          "description": "Type equality proofs",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "EQ",
          "package": "ty",
          "partial": "EQ",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType equality proof\n\u003c/p\u003e",
          "module": "Data.Proof.EQ",
          "name": ":=:",
          "package": "ty",
          "source": "src/Data-Proof-EQ.html#%3A%3D%3A",
          "type": "data"
        },
        "index": {
          "description": "Type equality proof",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": ":=:",
          "package": "ty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#t::-61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Proof.EQ",
          "name": "Refl",
          "package": "ty",
          "signature": "a :=: a",
          "source": "src/Data-Proof-EQ.html#%3A%3D%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "Refl",
          "package": "ty",
          "partial": "Refl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#v:Refl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommutativity\n\u003c/p\u003e",
          "module": "Data.Proof.EQ",
          "name": "commEq",
          "package": "ty",
          "signature": "(a :=: a') -\u003e a' :=: a",
          "source": "src/Data-Proof-EQ.html#commEq",
          "type": "function"
        },
        "index": {
          "description": "Commutativity",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "commEq",
          "normalized": "(a b)-\u003eb a",
          "package": "ty",
          "partial": "Eq",
          "signature": "(a a')-\u003ea' a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#v:commEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift proof through a unary type constructor\n\u003c/p\u003e",
          "module": "Data.Proof.EQ",
          "name": "liftEq",
          "package": "ty",
          "signature": "(a :=: a') -\u003e f a :=: f a'",
          "source": "src/Data-Proof-EQ.html#liftEq",
          "type": "function"
        },
        "index": {
          "description": "Lift proof through unary type constructor",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "liftEq",
          "normalized": "(a b)-\u003ec a c b",
          "package": "ty",
          "partial": "Eq",
          "signature": "(a a')-\u003ef a f a'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#v:liftEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift proof through a binary type constructor (including '(,)')\n\u003c/p\u003e",
          "module": "Data.Proof.EQ",
          "name": "liftEq2",
          "package": "ty",
          "signature": "(a :=: a') -\u003e (b :=: b') -\u003e f a b :=: f a' b'",
          "source": "src/Data-Proof-EQ.html#liftEq2",
          "type": "function"
        },
        "index": {
          "description": "Lift proof through binary type constructor including",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "liftEq2",
          "normalized": "(a b)-\u003e(c d)-\u003ee a c e b d",
          "package": "ty",
          "partial": "Eq",
          "signature": "(a a')-\u003e(b b')-\u003ef a b f a' b'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#v:liftEq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift proof through a ternary type constructor (including '(,,)')\n\u003c/p\u003e",
          "module": "Data.Proof.EQ",
          "name": "liftEq3",
          "package": "ty",
          "signature": "(a :=: a') -\u003e (b :=: b') -\u003e (c :=: c') -\u003e f a b c :=: f a' b' c'",
          "source": "src/Data-Proof-EQ.html#liftEq3",
          "type": "function"
        },
        "index": {
          "description": "Lift proof through ternary type constructor including",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "liftEq3",
          "normalized": "(a b)-\u003e(c d)-\u003e(e f)-\u003eg a c e g b d f",
          "package": "ty",
          "partial": "Eq",
          "signature": "(a a')-\u003e(b b')-\u003e(c c')-\u003ef a b c f a' b' c'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#v:liftEq3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift proof through a quaternary type constructor (including '(,,,)')\n\u003c/p\u003e",
          "module": "Data.Proof.EQ",
          "name": "liftEq4",
          "package": "ty",
          "signature": "(a :=: a') -\u003e (b :=: b') -\u003e (c :=: c') -\u003e (d :=: d') -\u003e f a b c d :=: f a' b' c' d'",
          "source": "src/Data-Proof-EQ.html#liftEq4",
          "type": "function"
        },
        "index": {
          "description": "Lift proof through quaternary type constructor including",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "liftEq4",
          "normalized": "(a b)-\u003e(c d)-\u003e(e f)-\u003e(g h)-\u003ei a c e g i b d f h",
          "package": "ty",
          "partial": "Eq",
          "signature": "(a a')-\u003e(b b')-\u003e(c c')-\u003e(d d')-\u003ef a b c d f a' b' c' d'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#v:liftEq4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransitivity\n\u003c/p\u003e",
          "module": "Data.Proof.EQ",
          "name": "transEq",
          "package": "ty",
          "signature": "(a :=: a') -\u003e (a' :=: a'') -\u003e a :=: a''",
          "source": "src/Data-Proof-EQ.html#transEq",
          "type": "function"
        },
        "index": {
          "description": "Transitivity",
          "hierarchy": "Data Proof EQ",
          "module": "Data.Proof.EQ",
          "name": "transEq",
          "normalized": "(a b)-\u003e(b c)-\u003ea c",
          "package": "ty",
          "partial": "Eq",
          "signature": "(a a')-\u003e(a' a'')-\u003ea a''",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Proof-EQ.html#v:transEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTyped typerefs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Ty",
          "name": "Ty",
          "package": "ty",
          "source": "src/Data-Ty.html",
          "type": "module"
        },
        "index": {
          "description": "Typed typerefs",
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "Ty",
          "package": "ty",
          "partial": "Ty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ty",
          "name": "AsPairTy",
          "package": "ty",
          "source": "src/Data-Ty.html#AsPairTy",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "AsPairTy",
          "package": "ty",
          "partial": "As Pair Ty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#t:AsPairTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhantom type wrapper around a \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Ty",
          "name": "Ty",
          "package": "ty",
          "source": "src/Data-Ty.html#Ty",
          "type": "data"
        },
        "index": {
          "description": "Phantom type wrapper around TypeRep",
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "Ty",
          "package": "ty",
          "partial": "Ty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#t:Ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e allows a concrete representation of a type to\n be calculated.\n\u003c/p\u003e",
          "module": "Data.Ty",
          "name": "Typeable",
          "package": "ty",
          "type": "class"
        },
        "index": {
          "description": "The class Typeable allows concrete representation of type to be calculated",
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "Typeable",
          "package": "ty",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#t:Typeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquality of typed values. \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eRefl\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e means the the types match and the\n values match.\n\u003c/p\u003e",
          "module": "Data.Ty",
          "name": "(=:=)",
          "package": "ty",
          "signature": "a -\u003e b -\u003e Maybe (a :=: b)",
          "source": "src/Data-Ty.html#%3D%3A%3D",
          "type": "function"
        },
        "index": {
          "description": "Equality of typed values Just Refl means the the types match and the values match",
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "(=:=) =:=",
          "normalized": "a-\u003eb-\u003eMaybe(a b)",
          "package": "ty",
          "signature": "a-\u003eb-\u003eMaybe(a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:-61-:-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ty",
          "name": "PairTy",
          "package": "ty",
          "signature": "Ty a -\u003e Ty b -\u003e AsPairTy (a, b)",
          "source": "src/Data-Ty.html#AsPairTy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "PairTy",
          "normalized": "Ty a-\u003eTy b-\u003eAsPairTy(a,b)",
          "package": "ty",
          "partial": "Pair Ty",
          "signature": "Ty a-\u003eTy b-\u003eAsPairTy(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:PairTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ty",
          "name": "asPairTy",
          "package": "ty",
          "signature": "Ty t -\u003e Maybe (AsPairTy t)",
          "source": "src/Data-Ty.html#asPairTy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "asPairTy",
          "normalized": "Ty a-\u003eMaybe(AsPairTy a)",
          "package": "ty",
          "partial": "Pair Ty",
          "signature": "Ty t-\u003eMaybe(AsPairTy t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:asPairTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ty",
          "name": "ty",
          "package": "ty",
          "signature": "Ty a",
          "source": "src/Data-Ty.html#ty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "ty",
          "package": "ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTy\u003c/a\u003e\u003c/code\u003e of a value\n\u003c/p\u003e",
          "module": "Data.Ty",
          "name": "tyOf",
          "package": "ty",
          "signature": "a -\u003e Ty a",
          "source": "src/Data-Ty.html#tyOf",
          "type": "function"
        },
        "index": {
          "description": "The Ty of value",
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "tyOf",
          "normalized": "a-\u003eTy a",
          "package": "ty",
          "partial": "Of",
          "signature": "a-\u003eTy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:tyOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTy\u003c/a\u003e\u003c/code\u003e of a value from a constructor application\n\u003c/p\u003e",
          "module": "Data.Ty",
          "name": "tyOf1",
          "package": "ty",
          "signature": "f a -\u003e Ty a",
          "source": "src/Data-Ty.html#tyOf1",
          "type": "function"
        },
        "index": {
          "description": "The Ty of value from constructor application",
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "tyOf1",
          "normalized": "a b-\u003eTy b",
          "package": "ty",
          "partial": "Of",
          "signature": "f a-\u003eTy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:tyOf1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTy\u003c/a\u003e\u003c/code\u003e of a value from a nested constructor application\n\u003c/p\u003e",
          "module": "Data.Ty",
          "name": "tyOf2",
          "package": "ty",
          "signature": "g (f a) -\u003e Ty a",
          "source": "src/Data-Ty.html#tyOf2",
          "type": "function"
        },
        "index": {
          "description": "The Ty of value from nested constructor application",
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "tyOf2",
          "normalized": "a(b c)-\u003eTy c",
          "package": "ty",
          "partial": "Of",
          "signature": "g(f a)-\u003eTy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:tyOf2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ty",
          "name": "tyRep",
          "package": "ty",
          "signature": "Ty a -\u003e TypeRep",
          "source": "src/Data-Ty.html#tyRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ty",
          "module": "Data.Ty",
          "name": "tyRep",
          "normalized": "Ty a-\u003eTypeRep",
          "package": "ty",
          "partial": "Rep",
          "signature": "Ty a-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ty/docs/Data-Ty.html#v:tyRep"
      }
    }
  ]
]