[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hdf"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFaust signal processing block diagram model.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Faust",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html",
          "type": "module"
        },
        "index": {
          "description": "Faust signal processing block diagram model",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Faust",
          "package": "hdf",
          "partial": "Faust",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlock diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "BD",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#BD",
          "type": "data"
        },
        "index": {
          "description": "Block diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "BD",
          "package": "hdf",
          "partial": "BD",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:BD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNode degree as \u003cem\u003e(input,output)\u003c/em\u003e pair.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Degree",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Degree",
          "type": "type"
        },
        "index": {
          "description": "Node degree as input output pair",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Degree",
          "package": "hdf",
          "partial": "Degree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive edge, left hand \u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e, right hand side \u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e, right hand\n \u003ccode\u003e\u003ca\u003ePort_Index\u003c/a\u003e\u003c/code\u003e and edge \u003cem\u003etype\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Edge",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Edge",
          "type": "type"
        },
        "index": {
          "description": "Primitive edge left hand Id right hand side Id right hand Port Index and edge type",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Edge",
          "package": "hdf",
          "partial": "Edge",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFGL graph of \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Gr",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Gr",
          "type": "type"
        },
        "index": {
          "description": "FGL graph of BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Gr",
          "package": "hdf",
          "partial": "Gr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Gr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is a list of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e and a list of \u003ccode\u003e\u003ca\u003eEdge\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Graph",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Graph",
          "type": "type"
        },
        "index": {
          "description": "graph is list of Node and list of Edge",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Graph",
          "package": "hdf",
          "partial": "Graph",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive block diagram elements.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Node",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "data"
        },
        "index": {
          "description": "Primitive block diagram elements",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Node",
          "package": "hdf",
          "partial": "Node",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePort (input or output) at block diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Port",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Port",
          "type": "data"
        },
        "index": {
          "description": "Port input or output at block diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Port",
          "package": "hdf",
          "partial": "Port",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Port"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe index of an \u003ccode\u003e\u003ca\u003eInput_Port\u003c/a\u003e\u003c/code\u003e, all outputs are unary.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Port_Index",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Port_Index",
          "type": "type"
        },
        "index": {
          "description": "The index of an Input Port all outputs are unary",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Port_Index",
          "package": "hdf",
          "partial": "Port Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Port_Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003ewrite\u003c/em\u003e and \u003cem\u003eread\u003c/em\u003e \u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003es, and the wire type.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Rec_Id",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Rec_Id",
          "type": "type"
        },
        "index": {
          "description": "The write and read Id and the wire type",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Rec_Id",
          "package": "hdf",
          "partial": "Rec Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Rec_Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eWire\u003c/a\u003e\u003c/code\u003e runs between two \u003ccode\u003ePorts\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Wire",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Wire",
          "type": "type"
        },
        "index": {
          "description": "Wire runs between two Ports",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Wire",
          "package": "hdf",
          "partial": "Wire",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Wire"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of wire types.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Wire_Ty",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-Faust.html#Wire_Ty",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of wire types",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Wire_Ty",
          "package": "hdf",
          "partial": "Wire Ty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#t:Wire_Ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFaust uses single tilde, which is reserved by \u003ca\u003eGHC.Exts\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~~)",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#~~",
          "type": "function"
        },
        "index": {
          "description": "Faust uses single tilde which is reserved by GHC.Exts",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~~) ~~",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:-126--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFaust uses \u003ccode\u003e\u003c:\u003c/code\u003e, which is legal, however see \u003ccode\u003e\u003ca\u003e~:\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~\u003c:)",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#~%3C%3A",
          "type": "function"
        },
        "index": {
          "description": "Faust uses which is legal however see",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~\u003c:) ~\u003c:",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:-126--60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFaust uses comma, which is reserved by \u003ca\u003eData.Tuple\u003c/a\u003e, and indeed\n \u003ccode\u003e~,\u003c/code\u003e is not legal either.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~.)",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#~.",
          "type": "function"
        },
        "index": {
          "description": "Faust uses comma which is reserved by Data.Tuple and indeed is not legal either",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~.) ~.",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:-126-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFaust uses \u003ccode\u003e:\u003c/code\u003e, which is reserved by \u003ca\u003eData.List\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~:)",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#~%3A",
          "type": "function"
        },
        "index": {
          "description": "Faust uses which is reserved by Data.List",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~:) ~:",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:-126-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFaust uses \u003ccode\u003e:\u003e\u003c/code\u003e, however \u003ccode\u003e:\u003c/code\u003e is not allowed as a prefix.\n\u003c/p\u003e\u003cpre\u003e draw (graph (par_l [1,2,3,4] ~:\u003e i_mul))\n draw (graph (par_l [1,2,3] ~:\u003e i_negate))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~:\u003e)",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#~%3A%3E",
          "type": "function"
        },
        "index": {
          "description": "Faust uses however is not allowed as prefix draw graph par mul draw graph par negate",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "(~:\u003e) ~:\u003e",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:-126-:-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBackward edge.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Backward",
          "package": "hdf",
          "signature": "Backward Rec_Id",
          "source": "src/Sound-DF-Uniform-Faust.html#Wire_Ty",
          "type": "function"
        },
        "index": {
          "description": "Backward edge",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Backward",
          "package": "hdf",
          "partial": "Backward",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Backward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Constant",
          "package": "hdf",
          "signature": "Constant (Maybe Id) K",
          "source": "src/Sound-DF-Uniform-Faust.html#BD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Constant",
          "package": "hdf",
          "partial": "Constant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit wire from \u003cem\u003erecWr\u003c/em\u003e to \u003cem\u003erecRd\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Implicit_Backward",
          "package": "hdf",
          "signature": "Implicit_Backward",
          "source": "src/Sound-DF-Uniform-Faust.html#Wire_Ty",
          "type": "function"
        },
        "index": {
          "description": "Implicit wire from recWr to recRd",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Implicit_Backward",
          "package": "hdf",
          "partial": "Implicit Backward",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Implicit_Backward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit wire from \u003cem\u003erecRd\u003c/em\u003e to node.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Implicit_Normal",
          "package": "hdf",
          "signature": "Implicit_Normal",
          "source": "src/Sound-DF-Uniform-Faust.html#Wire_Ty",
          "type": "function"
        },
        "index": {
          "description": "Implicit wire from recRd to node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Implicit_Normal",
          "package": "hdf",
          "partial": "Implicit Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Implicit_Normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit wire from node to \u003cem\u003erecWr\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Implicit_Rec",
          "package": "hdf",
          "signature": "Implicit_Rec",
          "source": "src/Sound-DF-Uniform-Faust.html#Wire_Ty",
          "type": "function"
        },
        "index": {
          "description": "Implicit wire from node to recWr",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Implicit_Rec",
          "package": "hdf",
          "partial": "Implicit Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Implicit_Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Input_Port",
          "package": "hdf",
          "signature": "Input_Port",
          "source": "src/Sound-DF-Uniform-Faust.html#Port",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Input_Port",
          "package": "hdf",
          "partial": "Input Port",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Input_Port"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "N_Constant",
          "package": "hdf",
          "signature": "N_Constant",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "N_Constant",
          "package": "hdf",
          "partial": "Constant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:N_Constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "N_Prim",
          "package": "hdf",
          "signature": "N_Prim",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "N_Prim",
          "package": "hdf",
          "partial": "Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:N_Prim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal forward edge.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Normal",
          "package": "hdf",
          "signature": "Normal",
          "source": "src/Sound-DF-Uniform-Faust.html#Wire_Ty",
          "type": "function"
        },
        "index": {
          "description": "Normal forward edge",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Normal",
          "package": "hdf",
          "partial": "Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Output_Port",
          "package": "hdf",
          "signature": "Output_Port",
          "source": "src/Sound-DF-Uniform-Faust.html#Port",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Output_Port",
          "package": "hdf",
          "partial": "Output Port",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Output_Port"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Par",
          "package": "hdf",
          "signature": "Par BD BD",
          "source": "src/Sound-DF-Uniform-Faust.html#BD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Par",
          "package": "hdf",
          "partial": "Par",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Par"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Prim",
          "package": "hdf",
          "signature": "Prim (Maybe Id) String [TypeRep] (Maybe TypeRep)",
          "source": "src/Sound-DF-Uniform-Faust.html#BD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Prim",
          "normalized": "Prim(Maybe Id)String[TypeRep](Maybe TypeRep)",
          "package": "hdf",
          "partial": "Prim",
          "signature": "Prim(Maybe Id)String[TypeRep](Maybe TypeRep)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Prim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Rec",
          "package": "hdf",
          "signature": "Rec (Maybe [Rec_Id]) BD BD",
          "source": "src/Sound-DF-Uniform-Faust.html#BD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Rec",
          "normalized": "Rec(Maybe[Rec_Id])BD BD",
          "package": "hdf",
          "partial": "Rec",
          "signature": "Rec(Maybe[Rec_Id])BD BD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Seq",
          "package": "hdf",
          "signature": "Seq BD BD",
          "source": "src/Sound-DF-Uniform-Faust.html#BD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Seq",
          "package": "hdf",
          "partial": "Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "Split",
          "package": "hdf",
          "signature": "Split BD BD",
          "source": "src/Sound-DF-Uniform-Faust.html#BD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "Split",
          "package": "hdf",
          "partial": "Split",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:Split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the current \u003cem\u003eactual\u003c/em\u003e node \u003cem\u003eid\u003c/em\u003e from \u003ccode\u003e\u003ca\u003en_prim_id\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "actual_id",
          "package": "hdf",
          "signature": "Either Id (Id, Id) -\u003e Id",
          "source": "src/Sound-DF-Uniform-Faust.html#actual_id",
          "type": "function"
        },
        "index": {
          "description": "Extract the current actual node id from prim id",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "actual_id",
          "normalized": "Either Id(Id,Id)-\u003eId",
          "package": "hdf",
          "signature": "Either Id(Id,Id)-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:actual_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjacent elements of list.\n\u003c/p\u003e\u003cpre\u003e adjacent [1..4] == [(1,2),(3,4)]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "adjacent",
          "package": "hdf",
          "signature": "[t] -\u003e [(t, t)]",
          "source": "src/Sound-DF-Uniform-Faust.html#adjacent",
          "type": "function"
        },
        "index": {
          "description": "Adjacent elements of list adjacent",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "adjacent",
          "normalized": "[a]-\u003e[(a,a)]",
          "package": "hdf",
          "signature": "[t]-\u003e[(t,t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:adjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "audition",
          "package": "hdf",
          "signature": "[Message] -\u003e BD -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-Faust.html#audition",
          "type": "function"
        },
        "index": {
          "description": "Audition graph after sending initialisation messages",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "audition",
          "normalized": "[Message]-\u003eBD-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eBD-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:audition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold over \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e, signature as \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_foldl",
          "package": "hdf",
          "signature": "(t -\u003e BD -\u003e t) -\u003e t -\u003e BD -\u003e t",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_foldl",
          "type": "function"
        },
        "index": {
          "description": "Fold over BD signature as foldl",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_foldl",
          "normalized": "(a-\u003eBD-\u003ea)-\u003ea-\u003eBD-\u003ea",
          "package": "hdf",
          "signature": "(t-\u003eBD-\u003et)-\u003et-\u003eBD-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead identifier.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_id",
          "package": "hdf",
          "signature": "BD -\u003e Maybe Id",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_id",
          "type": "function"
        },
        "index": {
          "description": "Read identifier",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_id",
          "normalized": "BD-\u003eMaybe Id",
          "package": "hdf",
          "signature": "BD-\u003eMaybe Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate CGen \u003ccode\u003e\u003ca\u003eInstructions\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_instructions",
          "package": "hdf",
          "signature": "BD -\u003e Instructions",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_instructions",
          "type": "function"
        },
        "index": {
          "description": "Generate CGen Instructions for BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_instructions",
          "normalized": "BD-\u003eInstructions",
          "package": "hdf",
          "signature": "BD-\u003eInstructions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_instructions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoherence predicate, ie. is \u003ccode\u003e\u003ca\u003ebd_non_coherent\u003c/a\u003e\u003c/code\u003e empty.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_is_coherent",
          "package": "hdf",
          "signature": "BD -\u003e Bool",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_is_coherent",
          "type": "function"
        },
        "index": {
          "description": "Coherence predicate ie is bd non coherent empty",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_is_coherent",
          "normalized": "BD-\u003eBool",
          "package": "hdf",
          "signature": "BD-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_is_coherent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of non-coherent wires at diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_non_coherent",
          "package": "hdf",
          "signature": "BD -\u003e [Wire]",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_non_coherent",
          "type": "function"
        },
        "index": {
          "description": "The set of non-coherent wires at diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_non_coherent",
          "normalized": "BD-\u003e[Wire]",
          "package": "hdf",
          "signature": "BD-\u003e[Wire]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_non_coherent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_pp",
          "package": "hdf",
          "signature": "BD -\u003e String",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_pp",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_pp",
          "normalized": "BD-\u003eString",
          "package": "hdf",
          "signature": "BD-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eErroring \u003ccode\u003e\u003ca\u003ebd_id\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_req_id",
          "package": "hdf",
          "signature": "BD -\u003e Id",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_req_id",
          "type": "function"
        },
        "index": {
          "description": "Erroring bd id",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_req_id",
          "normalized": "BD-\u003eId",
          "package": "hdf",
          "signature": "BD-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_req_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet identifiers at \u003ccode\u003e\u003ca\u003eConstant\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ePrim\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eRec\u003c/a\u003e\u003c/code\u003e nodes.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_set_id",
          "package": "hdf",
          "signature": "BD -\u003e (Id, BD)",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_set_id",
          "type": "function"
        },
        "index": {
          "description": "Set identifiers at Constant Prim and Rec nodes",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_set_id",
          "normalized": "BD-\u003e(Id,BD)",
          "package": "hdf",
          "signature": "BD-\u003e(Id,BD)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_set_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiagram type signature, ie. \u003ccode\u003e\u003ca\u003eport_ty\u003c/a\u003e\u003c/code\u003e at \u003ccode\u003e\u003ca\u003eports\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_signature",
          "package": "hdf",
          "signature": "BD -\u003e ([TypeRep], [TypeRep])",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_signature",
          "type": "function"
        },
        "index": {
          "description": "Diagram type signature ie port ty at ports",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_signature",
          "normalized": "BD-\u003e([TypeRep],[TypeRep])",
          "package": "hdf",
          "signature": "BD-\u003e([TypeRep],[TypeRep])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_signature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-directed sum.\n\u003c/p\u003e\u003cpre\u003e draw (graph (bd_sum [1,2,3,4]))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_sum",
          "package": "hdf",
          "signature": "[BD] -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_sum",
          "type": "function"
        },
        "index": {
          "description": "Type-directed sum draw graph bd sum",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_sum",
          "normalized": "[BD]-\u003eBD",
          "package": "hdf",
          "signature": "[BD]-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraversal with state, signature as \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_traverse",
          "package": "hdf",
          "signature": "(st -\u003e BD -\u003e (st, BD)) -\u003e st -\u003e BD -\u003e (st, BD)",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_traverse",
          "type": "function"
        },
        "index": {
          "description": "Traversal with state signature as mapAccumL",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_traverse",
          "normalized": "(a-\u003eBD-\u003e(a,BD))-\u003ea-\u003eBD-\u003e(a,BD)",
          "package": "hdf",
          "signature": "(st-\u003eBD-\u003e(st,BD))-\u003est-\u003eBD-\u003e(st,BD)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_traverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of \u003cem\u003eoutput\u003c/em\u003e ports of \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_ty",
          "package": "hdf",
          "signature": "BD -\u003e [TypeRep]",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_ty",
          "type": "function"
        },
        "index": {
          "description": "Type of output ports of BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_ty",
          "normalized": "BD-\u003e[TypeRep]",
          "package": "hdf",
          "signature": "BD-\u003e[TypeRep]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of \u003cem\u003esingular\u003c/em\u003e output port of \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_ty1",
          "package": "hdf",
          "signature": "BD -\u003e Maybe TypeRep",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_ty1",
          "type": "function"
        },
        "index": {
          "description": "Type of singular output port of BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_ty1",
          "normalized": "BD-\u003eMaybe TypeRep",
          "package": "hdf",
          "signature": "BD-\u003eMaybe TypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_ty1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of \u003cem\u003euniform\u003c/em\u003e output ports of \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_ty_uniform",
          "package": "hdf",
          "signature": "BD -\u003e Maybe TypeRep",
          "source": "src/Sound-DF-Uniform-Faust.html#bd_ty_uniform",
          "type": "function"
        },
        "index": {
          "description": "Type of uniform output ports of BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bd_ty_uniform",
          "normalized": "BD-\u003eMaybe TypeRep",
          "package": "hdf",
          "signature": "BD-\u003eMaybe TypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bd_ty_uniform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBimap at tuple.\n\u003c/p\u003e\u003cpre\u003e bimap abs negate (-1,1) == (1,-1)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bimap",
          "package": "hdf",
          "signature": "(a -\u003e b) -\u003e (c -\u003e d) -\u003e (a, c) -\u003e (b, d)",
          "source": "src/Sound-DF-Uniform-Faust.html#bimap",
          "type": "function"
        },
        "index": {
          "description": "Bimap at tuple bimap abs negate",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "bimap",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003e(a,c)-\u003e(b,d)",
          "package": "hdf",
          "signature": "(a-\u003eb)-\u003e(c-\u003ed)-\u003e(a,c)-\u003e(b,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:bimap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of constants for CGen.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "cg_k",
          "package": "hdf",
          "signature": "[Node] -\u003e [(Id, K)]",
          "source": "src/Sound-DF-Uniform-Faust.html#cg_k",
          "type": "function"
        },
        "index": {
          "description": "List of constants for CGen",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "cg_k",
          "normalized": "[Node]-\u003e[(Id,K)]",
          "package": "hdf",
          "signature": "[Node]-\u003e[(Id,K)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:cg_k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eC_Call\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "cg_node_c_call",
          "package": "hdf",
          "signature": "[Edge] -\u003e Node -\u003e Maybe C_Call",
          "source": "src/Sound-DF-Uniform-Faust.html#cg_node_c_call",
          "type": "function"
        },
        "index": {
          "description": "Call of Node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "cg_node_c_call",
          "normalized": "[Edge]-\u003eNode-\u003eMaybe C_Call",
          "package": "hdf",
          "signature": "[Edge]-\u003eNode-\u003eMaybe C_Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:cg_node_c_call"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "cg_node_var",
          "package": "hdf",
          "signature": "Node -\u003e Maybe Var",
          "source": "src/Sound-DF-Uniform-Faust.html#cg_node_var",
          "type": "function"
        },
        "index": {
          "description": "Var of Node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "cg_node_var",
          "normalized": "Node-\u003eMaybe Var",
          "package": "hdf",
          "signature": "Node-\u003eMaybe Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:cg_node_var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDegree\u003c/a\u003e\u003c/code\u003e of block diagram \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "degree",
          "package": "hdf",
          "signature": "BD -\u003e Degree",
          "source": "src/Sound-DF-Uniform-Faust.html#degree",
          "type": "function"
        },
        "index": {
          "description": "Degree of block diagram BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "degree",
          "normalized": "BD-\u003eDegree",
          "package": "hdf",
          "signature": "BD-\u003eDegree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot description of \u003ccode\u003e\u003ca\u003eEdge\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "dot_edge",
          "package": "hdf",
          "signature": "Edge -\u003e String",
          "source": "src/Sound-DF-Uniform-Faust.html#dot_edge",
          "type": "function"
        },
        "index": {
          "description": "Dot description of Edge",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "dot_edge",
          "normalized": "Edge-\u003eString",
          "package": "hdf",
          "signature": "Edge-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:dot_edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot description of \u003ccode\u003e\u003ca\u003eGraph\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "dot_graph",
          "package": "hdf",
          "signature": "Graph -\u003e [String]",
          "source": "src/Sound-DF-Uniform-Faust.html#dot_graph",
          "type": "function"
        },
        "index": {
          "description": "Dot description of Graph",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "dot_graph",
          "normalized": "Graph-\u003e[String]",
          "package": "hdf",
          "signature": "Graph-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:dot_graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot description of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "dot_node",
          "package": "hdf",
          "signature": "Node -\u003e String",
          "source": "src/Sound-DF-Uniform-Faust.html#dot_node",
          "type": "function"
        },
        "index": {
          "description": "Dot description of Node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "dot_node",
          "normalized": "Node-\u003eString",
          "package": "hdf",
          "signature": "Node-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:dot_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edraw_dot\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edot_graph\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "draw",
          "package": "hdf",
          "signature": "Graph -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-Faust.html#draw",
          "type": "function"
        },
        "index": {
          "description": "draw dot of dot graph",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "draw",
          "normalized": "Graph-\u003eIO()",
          "package": "hdf",
          "signature": "Graph-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw dot graph.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "draw_dot",
          "package": "hdf",
          "signature": "String -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-Faust.html#draw_dot",
          "type": "function"
        },
        "index": {
          "description": "Draw dot graph",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "draw_dot",
          "normalized": "String-\u003eIO()",
          "package": "hdf",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:draw_dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eWire_Ty\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eEdge\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eImplicit_Backward\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "edge_is_implicit_backward",
          "package": "hdf",
          "signature": "Edge -\u003e Bool",
          "source": "src/Sound-DF-Uniform-Faust.html#edge_is_implicit_backward",
          "type": "function"
        },
        "index": {
          "description": "Is Wire Ty of Edge Implicit Backward",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "edge_is_implicit_backward",
          "normalized": "Edge-\u003eBool",
          "package": "hdf",
          "signature": "Edge-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:edge_is_implicit_backward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ewires_to_edges\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003ewires\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "edges",
          "package": "hdf",
          "signature": "Bool -\u003e BD -\u003e [Edge]",
          "source": "src/Sound-DF-Uniform-Faust.html#edges",
          "type": "function"
        },
        "index": {
          "description": "wires to edges of wires",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "edges",
          "normalized": "Bool-\u003eBD-\u003e[Edge]",
          "package": "hdf",
          "signature": "Bool-\u003eBD-\u003e[Edge]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFigure illustrating \u003ccode\u003e\u003ca\u003e~.\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e degree fig_3_2 == (2,2)\n draw (graph fig_3_2)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_2",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#fig_3_2",
          "type": "function"
        },
        "index": {
          "description": "Figure illustrating degree fig draw graph fig",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_2",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:fig_3_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFigure illustrating \u003ccode\u003e\u003ca\u003e~:\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e degree fig_3_3 == (4,1)\n bd_signature fig_3_3\n draw (graph fig_3_3)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_3",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#fig_3_3",
          "type": "function"
        },
        "index": {
          "description": "Figure illustrating degree fig bd signature fig draw graph fig",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_3",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:fig_3_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFigure illustrating \u003ccode\u003e\u003ca\u003e~\u003c:\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e degree fig_3_4 == (0,3)\n draw (graph fig_3_4)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_4",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#fig_3_4",
          "type": "function"
        },
        "index": {
          "description": "Figure illustrating degree fig draw graph fig",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_4",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:fig_3_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFigure illustrating \u003ccode\u003e\u003ca\u003e~:\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e degree fig_3_5 == (0,1)\n draw (graph fig_3_5)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_5",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#fig_3_5",
          "type": "function"
        },
        "index": {
          "description": "Figure illustrating degree fig draw graph fig",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_5",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:fig_3_5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFigure illustrating \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e degree fig_3_6 == (0,1)\n draw (graph fig_3_6)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_6",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#fig_3_6",
          "type": "function"
        },
        "index": {
          "description": "Figure illustrating degree fig draw graph fig",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_6",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:fig_3_6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant generating audible graph.\n\u003c/p\u003e\u003cpre\u003e draw (graph fig_3_6')\n gr_draw fig_3_6'\n audition [] fig_3_6'\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_6'",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#fig_3_6%27",
          "type": "function"
        },
        "index": {
          "description": "Variant generating audible graph draw graph fig gr draw fig audition fig",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "fig_3_6'",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:fig_3_6-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoerce \u003ccode\u003e\u003ca\u003efloat_t\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eint32_t\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "float_to_int32",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#float_to_int32",
          "type": "function"
        },
        "index": {
          "description": "Coerce float to int32",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "float_to_int32",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:float_to_int32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eBD\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eGr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "gr",
          "package": "hdf",
          "signature": "BD -\u003e Gr",
          "source": "src/Sound-DF-Uniform-Faust.html#gr",
          "type": "function"
        },
        "index": {
          "description": "Transform BD to Gr",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "gr",
          "normalized": "BD-\u003eGr",
          "package": "hdf",
          "signature": "BD-\u003eGr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:gr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake \u003ccode\u003edot\u003c/code\u003e rendering of graph at \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "gr_dot",
          "package": "hdf",
          "signature": "BD -\u003e String",
          "source": "src/Sound-DF-Uniform-Faust.html#gr_dot",
          "type": "function"
        },
        "index": {
          "description": "Make dot rendering of graph at Node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "gr_dot",
          "normalized": "BD-\u003eString",
          "package": "hdf",
          "signature": "BD-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:gr_dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edraw_dot\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003egr_dot\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "gr_draw",
          "package": "hdf",
          "signature": "BD -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-Faust.html#gr_draw",
          "type": "function"
        },
        "index": {
          "description": "draw dot of gr dot",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "gr_draw",
          "normalized": "BD-\u003eIO()",
          "package": "hdf",
          "signature": "BD-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:gr_draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct \u003ccode\u003e\u003ca\u003eGraph\u003c/a\u003e\u003c/code\u003e of block diagram without \u003cem\u003eimplicit\u003c/em\u003e edges.\n This graph will include backward arcs if the graph contains \u003cem\u003erec\u003c/em\u003es.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "graph",
          "package": "hdf",
          "signature": "BD -\u003e Graph",
          "source": "src/Sound-DF-Uniform-Faust.html#graph",
          "type": "function"
        },
        "index": {
          "description": "Construct Graph of block diagram without implicit edges This graph will include backward arcs if the graph contains rec",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "graph",
          "normalized": "BD-\u003eGraph",
          "package": "hdf",
          "signature": "BD-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct \u003ccode\u003e\u003ca\u003eGraph\u003c/a\u003e\u003c/code\u003e of block diagram, either with or without\n \u003cem\u003eimplicit\u003c/em\u003e edges.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "graph'",
          "package": "hdf",
          "signature": "Bool -\u003e BD -\u003e Graph",
          "source": "src/Sound-DF-Uniform-Faust.html#graph%27",
          "type": "function"
        },
        "index": {
          "description": "Construct Graph of block diagram either with or without implicit edges",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "graph'",
          "normalized": "Bool-\u003eBD-\u003eGraph",
          "package": "hdf",
          "signature": "Bool-\u003eBD-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:graph-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eint32_to_float\u003c/a\u003e\u003c/code\u003e and then scale to be in (-1,1).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i32_to_normal_f32",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i32_to_normal_f32",
          "type": "function"
        },
        "index": {
          "description": "int32 to float and then scale to be in",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i32_to_normal_f32",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i32_to_normal_f32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute value, ie. \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_abs",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_abs",
          "type": "function"
        },
        "index": {
          "description": "Absolute value ie abs of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_abs",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdddition, ie. \u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e (1 ~. 2) ~: i_add\n (1 :: BD) + 2\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_add",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_add",
          "type": "function"
        },
        "index": {
          "description": "Adddition ie of Num add BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_add",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInteger constant.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_constant",
          "package": "hdf",
          "signature": "Int -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_constant",
          "type": "function"
        },
        "index": {
          "description": "Integer constant",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_constant",
          "normalized": "Int-\u003eBD",
          "package": "hdf",
          "signature": "Int-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA counter, illustrating \u003cem\u003eidentity\u003c/em\u003e diagram.\n\u003c/p\u003e\u003cpre\u003e draw (graph (i_counter ~: i_negate))\n gr_draw (i_counter ~: i_negate)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_counter",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_counter",
          "type": "function"
        },
        "index": {
          "description": "counter illustrating identity diagram draw graph counter negate gr draw counter negate",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_counter",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_counter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivision, ie. \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_div",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_div",
          "type": "function"
        },
        "index": {
          "description": "Division ie div of Integral",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_div",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_identity",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_identity",
          "type": "function"
        },
        "index": {
          "description": "Identity diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_identity",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication, ie. \u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_mul",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_mul",
          "type": "function"
        },
        "index": {
          "description": "Multiplication ie of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_mul",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegation, ie. \u003ccode\u003e\u003ca\u003enegate\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_negate",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_negate",
          "type": "function"
        },
        "index": {
          "description": "Negation ie negate of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_negate",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eu_prim\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eint32_t\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_prim",
          "package": "hdf",
          "signature": "String -\u003e Int -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_prim",
          "type": "function"
        },
        "index": {
          "description": "prim of int32",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_prim",
          "normalized": "String-\u003eInt-\u003eBD",
          "package": "hdf",
          "signature": "String-\u003eInt-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_prim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtraction, ie. \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_sub",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#i_sub",
          "type": "function"
        },
        "index": {
          "description": "Subtraction ie of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "i_sub",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:i_sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edegree\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "in_degree",
          "package": "hdf",
          "signature": "BD -\u003e Int",
          "source": "src/Sound-DF-Uniform-Faust.html#in_degree",
          "type": "function"
        },
        "index": {
          "description": "fst of degree",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "in_degree",
          "normalized": "BD-\u003eInt",
          "package": "hdf",
          "signature": "BD-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:in_degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoerce \u003ccode\u003e\u003ca\u003eint32_t\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003efloat_t\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "int32_to_float",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#int32_to_float",
          "type": "function"
        },
        "index": {
          "description": "Coerce int32 to float",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "int32_to_float",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:int32_to_float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003emerge\u003c/em\u003e if diagrams cohere, else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.  Synonym of \u003ccode\u003e\u003ca\u003e~:\u003e\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "merge",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#merge",
          "type": "function"
        },
        "index": {
          "description": "merge if diagrams cohere else error Synonym of",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "merge",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf merge is legal, the number of in-edges per port at \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e merge_degree (par_l [1,2,3]) i_negate == Just 3\n merge_degree (par_l [1,2,3,4]) i_mul == Just 2\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "merge_degree",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e Maybe Int",
          "source": "src/Sound-DF-Uniform-Faust.html#merge_degree",
          "type": "function"
        },
        "index": {
          "description": "If merge is legal the number of in-edges per port at merge degree par negate Just merge degree par mul Just",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "merge_degree",
          "normalized": "BD-\u003eBD-\u003eMaybe Int",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:merge_degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003emerge\u003c/em\u003e if diagrams cohere.\n\u003c/p\u003e\u003cpre\u003e merge_m (par_l [1,2,3]) i_negate\n merge_m (par_l [1,2,3,4]) i_mul\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "merge_m",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e Maybe BD",
          "source": "src/Sound-DF-Uniform-Faust.html#merge_m",
          "type": "function"
        },
        "index": {
          "description": "merge if diagrams cohere merge par negate merge par mul",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "merge_m",
          "normalized": "BD-\u003eBD-\u003eMaybe BD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eMaybe BD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:merge_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_constant_id",
          "package": "hdf",
          "signature": "Id",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_constant_id",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:n_constant_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_constant_k",
          "package": "hdf",
          "signature": "K",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_constant_k",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:n_constant_k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_id",
          "package": "hdf",
          "signature": "Either Id (Id, Id)",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_id",
          "normalized": "Either Id(Id,Id)",
          "package": "hdf",
          "signature": "Either Id(Id,Id)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:n_prim_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_in_degree",
          "package": "hdf",
          "signature": "Int",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_in_degree",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:n_prim_in_degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_name",
          "package": "hdf",
          "signature": "String",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_name",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:n_prim_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_ty",
          "package": "hdf",
          "signature": "Maybe TypeRep",
          "source": "src/Sound-DF-Uniform-Faust.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "n_prim_ty",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:n_prim_ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEither \u003ccode\u003e\u003ca\u003en_constant_id\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eactual_id\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003en_prim_id\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_id",
          "package": "hdf",
          "signature": "Node -\u003e Id",
          "source": "src/Sound-DF-Uniform-Faust.html#node_id",
          "type": "function"
        },
        "index": {
          "description": "Either constant id or actual id of prim id",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_id",
          "normalized": "Node-\u003eId",
          "package": "hdf",
          "signature": "Node-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:node_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput references for \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_inputs",
          "package": "hdf",
          "signature": "[Edge] -\u003e Node -\u003e [(Var_Ty, Id)]",
          "source": "src/Sound-DF-Uniform-Faust.html#node_inputs",
          "type": "function"
        },
        "index": {
          "description": "Input references for Node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_inputs",
          "normalized": "[Edge]-\u003eNode-\u003e[(Var_Ty,Id)]",
          "package": "hdf",
          "signature": "[Edge]-\u003eNode-\u003e[(Var_Ty,Id)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:node_inputs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e with node.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_lift_id",
          "package": "hdf",
          "signature": "Node -\u003e (Id, Node)",
          "source": "src/Sound-DF-Uniform-Faust.html#node_lift_id",
          "type": "function"
        },
        "index": {
          "description": "Pair Node Id with node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_lift_id",
          "normalized": "Node-\u003e(Id,Node)",
          "package": "hdf",
          "signature": "Node-\u003e(Id,Node)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:node_lift_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput reference for \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_output",
          "package": "hdf",
          "signature": "Node -\u003e Maybe (Var_Ty, Id)",
          "source": "src/Sound-DF-Uniform-Faust.html#node_output",
          "type": "function"
        },
        "index": {
          "description": "Output reference for Node",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_output",
          "normalized": "Node-\u003eMaybe(Var_Ty,Id)",
          "package": "hdf",
          "signature": "Node-\u003eMaybe(Var_Ty,Id)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:node_output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer, and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_pp",
          "package": "hdf",
          "signature": "Node -\u003e String",
          "source": "src/Sound-DF-Uniform-Faust.html#node_pp",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer and Show instance",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_pp",
          "normalized": "Node-\u003eString",
          "package": "hdf",
          "signature": "Node-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:node_pp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput type of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e, if out degree non-zero.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_ty",
          "package": "hdf",
          "signature": "Node -\u003e Maybe TypeRep",
          "source": "src/Sound-DF-Uniform-Faust.html#node_ty",
          "type": "function"
        },
        "index": {
          "description": "Output type of Node if out degree non-zero",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "node_ty",
          "normalized": "Node-\u003eMaybe TypeRep",
          "package": "hdf",
          "signature": "Node-\u003eMaybe TypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:node_ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect all primitive nodes at a block diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "nodes",
          "package": "hdf",
          "signature": "Bool -\u003e BD -\u003e [Node]",
          "source": "src/Sound-DF-Uniform-Faust.html#nodes",
          "type": "function"
        },
        "index": {
          "description": "Collect all primitive nodes at block diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "nodes",
          "normalized": "Bool-\u003eBD-\u003e[Node]",
          "package": "hdf",
          "signature": "Bool-\u003eBD-\u003e[Node]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:nodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of \u003ccode\u003e\u003ca\u003eNormal\u003c/a\u003e\u003c/code\u003e wires between \u003ccode\u003e\u003ca\u003ePort\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "normal_wires",
          "package": "hdf",
          "signature": "[Port] -\u003e [Port] -\u003e [Wire]",
          "source": "src/Sound-DF-Uniform-Faust.html#normal_wires",
          "type": "function"
        },
        "index": {
          "description": "Set of Normal wires between Port",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "normal_wires",
          "normalized": "[Port]-\u003e[Port]-\u003e[Wire]",
          "package": "hdf",
          "signature": "[Port]-\u003e[Port]-\u003e[Wire]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:normal_wires"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle channel output.\n\u003c/p\u003e\u003cpre\u003e degree out1 == (1,0)\n bd_signature out1 == ([float_t],[])\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "out1",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#out1",
          "type": "function"
        },
        "index": {
          "description": "Single channel output degree out1 bd signature out1 float",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "out1",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:out1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esnd\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edegree\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "out_degree",
          "package": "hdf",
          "signature": "BD -\u003e Int",
          "source": "src/Sound-DF-Uniform-Faust.html#out_degree",
          "type": "function"
        },
        "index": {
          "description": "snd of degree",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "out_degree",
          "normalized": "BD-\u003eInt",
          "package": "hdf",
          "signature": "BD-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:out_degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold of \u003ccode\u003e\u003ca\u003ePar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e degree (par_l [1,2,3,4]) == (0,4)\n draw (graph (par_l [1,2,3,4] ~:\u003e i_mul))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "par_l",
          "package": "hdf",
          "signature": "[BD] -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#par_l",
          "type": "function"
        },
        "index": {
          "description": "Fold of Par degree par draw graph par mul",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "par_l",
          "normalized": "[BD]-\u003eBD",
          "package": "hdf",
          "signature": "[BD]-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:par_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "port_bd",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#Port",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "port_bd",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:port_bd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.Faust",
          "name": "port_index",
          "package": "hdf",
          "signature": "Port_Index",
          "source": "src/Sound-DF-Uniform-Faust.html#Port",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "port_index",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:port_index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of \u003ccode\u003e\u003ca\u003ePort\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "port_ty",
          "package": "hdf",
          "signature": "Port -\u003e TypeRep",
          "source": "src/Sound-DF-Uniform-Faust.html#port_ty",
          "type": "function"
        },
        "index": {
          "description": "Type of Port",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "port_ty",
          "normalized": "Port-\u003eTypeRep",
          "package": "hdf",
          "signature": "Port-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:port_ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe left and right \u003cem\u003eouter\u003c/em\u003e ports of a block diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ports",
          "package": "hdf",
          "signature": "BD -\u003e ([Port], [Port])",
          "source": "src/Sound-DF-Uniform-Faust.html#ports",
          "type": "function"
        },
        "index": {
          "description": "The left and right outer ports of block diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ports",
          "normalized": "BD-\u003e([Port],[Port])",
          "package": "hdf",
          "signature": "BD-\u003e([Port],[Port])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute value, ie. \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_abs",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_abs",
          "type": "function"
        },
        "index": {
          "description": "Absolute value ie abs of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_abs",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdddition, ie. \u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e (1 ~. 2) ~: i_add\n (1 :: BD) + 2\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_add",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_add",
          "type": "function"
        },
        "index": {
          "description": "Adddition ie of Num add BD",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_add",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReal constant.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_constant",
          "package": "hdf",
          "signature": "Float -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_constant",
          "type": "function"
        },
        "index": {
          "description": "Real constant",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_constant",
          "normalized": "Float-\u003eBD",
          "package": "hdf",
          "signature": "Float-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivision, ie. \u003ccode\u003e\u003ca\u003e/\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_div",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_div",
          "type": "function"
        },
        "index": {
          "description": "Division ie of Fractional",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_div",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_identity",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_identity",
          "type": "function"
        },
        "index": {
          "description": "Identity diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_identity",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication, ie. \u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_mul",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_mul",
          "type": "function"
        },
        "index": {
          "description": "Multiplication ie of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_mul",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegation, ie. \u003ccode\u003e\u003ca\u003enegate\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_negate",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_negate",
          "type": "function"
        },
        "index": {
          "description": "Negation ie negate of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_negate",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eu_prim\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003efloat_t\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_prim",
          "package": "hdf",
          "signature": "String -\u003e Int -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_prim",
          "type": "function"
        },
        "index": {
          "description": "prim of float",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_prim",
          "normalized": "String-\u003eInt-\u003eBD",
          "package": "hdf",
          "signature": "String-\u003eInt-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_prim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtraction, ie. \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_sub",
          "package": "hdf",
          "signature": "BD",
          "source": "src/Sound-DF-Uniform-Faust.html#r_sub",
          "type": "function"
        },
        "index": {
          "description": "Subtraction ie of Num",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "r_sub",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:r_sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003erec\u003c/em\u003e if diagrams cohere, else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.  Synonym of \u003ccode\u003e\u003ca\u003e~~\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#rec",
          "type": "function"
        },
        "index": {
          "description": "rec if diagrams cohere else error Synonym of",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet of \u003ccode\u003e\u003ca\u003eBackward\u003c/a\u003e\u003c/code\u003e wires between \u003ccode\u003e\u003ca\u003ePort\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_back_wires",
          "package": "hdf",
          "signature": "[Rec_Id] -\u003e [Port] -\u003e [Port] -\u003e [Wire]",
          "source": "src/Sound-DF-Uniform-Faust.html#rec_back_wires",
          "type": "function"
        },
        "index": {
          "description": "Set of Backward wires between Port",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_back_wires",
          "normalized": "[Rec_Id]-\u003e[Port]-\u003e[Port]-\u003e[Wire]",
          "package": "hdf",
          "signature": "[Rec_Id]-\u003e[Port]-\u003e[Port]-\u003e[Wire]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:rec_back_wires"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRec\u003c/a\u003e\u003c/code\u003e nodes introduce identifiers for each backward arc.  \u003cem\u003ek\u003c/em\u003e is\n the initial \u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e, \u003cem\u003en\u003c/em\u003e the number of arcs, and \u003cem\u003ety\u003c/em\u003e the arc types.\n\u003c/p\u003e\u003cpre\u003e rec_ids 5 2 [int32_t,float_t] == [(5,6,int32_t),(7,8,float_t)]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_ids",
          "package": "hdf",
          "signature": "Id -\u003e Int -\u003e [TypeRep] -\u003e [Rec_Id]",
          "source": "src/Sound-DF-Uniform-Faust.html#rec_ids",
          "type": "function"
        },
        "index": {
          "description": "Rec nodes introduce identifiers for each backward arc is the initial Id the number of arcs and ty the arc types rec ids int32 float int32 float",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_ids",
          "normalized": "Id-\u003eInt-\u003e[TypeRep]-\u003e[Rec_Id]",
          "package": "hdf",
          "signature": "Id-\u003eInt-\u003e[TypeRep]-\u003e[Rec_Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:rec_ids"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003erec\u003c/em\u003e if diagrams cohere.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_m",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e Maybe BD",
          "source": "src/Sound-DF-Uniform-Faust.html#rec_m",
          "type": "function"
        },
        "index": {
          "description": "rec if diagrams cohere",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_m",
          "normalized": "BD-\u003eBD-\u003eMaybe BD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eMaybe BD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:rec_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit \u003cem\u003erec\u003c/em\u003e nodes.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_nodes",
          "package": "hdf",
          "signature": "[Rec_Id] -\u003e [Node]",
          "source": "src/Sound-DF-Uniform-Faust.html#rec_nodes",
          "type": "function"
        },
        "index": {
          "description": "Implicit rec nodes",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_nodes",
          "normalized": "[Rec_Id]-\u003e[Node]",
          "package": "hdf",
          "signature": "[Rec_Id]-\u003e[Node]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:rec_nodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate to determine if \u003cem\u003ep\u003c/em\u003e can be \u003cem\u003erec\u003c/em\u003e onto \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_r",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e Bool",
          "source": "src/Sound-DF-Uniform-Faust.html#rec_r",
          "type": "function"
        },
        "index": {
          "description": "Predicate to determine if can be rec onto",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "rec_r",
          "normalized": "BD-\u003eBD-\u003eBool",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:rec_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003esplit\u003c/em\u003e if diagrams cohere, else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.  Synonym of \u003ccode\u003e\u003ca\u003e~\u003c:\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "split",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#split",
          "type": "function"
        },
        "index": {
          "description": "split if diagrams cohere else error Synonym of",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "split",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003esplit\u003c/em\u003e if diagrams cohere.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "split_m",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e Maybe BD",
          "source": "src/Sound-DF-Uniform-Faust.html#split_m",
          "type": "function"
        },
        "index": {
          "description": "split if diagrams cohere",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "split_m",
          "normalized": "BD-\u003eBD-\u003eMaybe BD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eMaybe BD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:split_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate to determine if \u003cem\u003ep\u003c/em\u003e can be \u003cem\u003esplit\u003c/em\u003e onto \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "split_r",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e Bool",
          "source": "src/Sound-DF-Uniform-Faust.html#split_r",
          "type": "function"
        },
        "index": {
          "description": "Predicate to determine if can be split onto",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "split_r",
          "normalized": "BD-\u003eBD-\u003eBool",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:split_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTopological sort of nodes (via \u003ccode\u003e\u003ca\u003egr\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "tsort",
          "package": "hdf",
          "signature": "BD -\u003e Graph",
          "source": "src/Sound-DF-Uniform-Faust.html#tsort",
          "type": "function"
        },
        "index": {
          "description": "Topological sort of nodes via gr",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "tsort",
          "normalized": "BD-\u003eGraph",
          "package": "hdf",
          "signature": "BD-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:tsort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following math operator, uniform types.\n\u003c/p\u003e\u003cpre\u003e 1.0 `ty_add` 2.0 == r_add\n (1 ~. 2) `ty_add` (3 ~. 4) == i_add\n 1.0 `ty_add` 2 == _|_\n draw (graph ((1 ~. 2) - (3 ~. 4)))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_add",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_add",
          "type": "function"
        },
        "index": {
          "description": "Type following math operator uniform types ty add add ty add add ty add draw graph",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_add",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following math operator, singular types.\n\u003c/p\u003e\u003cpre\u003e 1.0 `ty_add1` 2.0 == r_add\n 1.0 `ty_add1` 2 == _|_\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_add1",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_add1",
          "type": "function"
        },
        "index": {
          "description": "Type following math operator singular types ty add1 add ty add1",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_add1",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_add1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following binary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_binop",
          "package": "hdf",
          "signature": "(BD -\u003e Maybe TypeRep) -\u003e t -\u003e t -\u003e BD -\u003e BD -\u003e t",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_binop",
          "type": "function"
        },
        "index": {
          "description": "Type following binary operator",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_binop",
          "normalized": "(BD-\u003eMaybe TypeRep)-\u003ea-\u003ea-\u003eBD-\u003eBD-\u003ea",
          "package": "hdf",
          "signature": "(BD-\u003eMaybe TypeRep)-\u003et-\u003et-\u003eBD-\u003eBD-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_binop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following math operator, uniform types.\n\u003c/p\u003e\u003cpre\u003e 1.0 `ty_add` 2.0 == r_add\n (1 ~. 2) `ty_add` (3 ~. 4) == i_add\n 1.0 `ty_add` 2 == _|_\n draw (graph ((1 ~. 2) - (3 ~. 4)))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_div",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_div",
          "type": "function"
        },
        "index": {
          "description": "Type following math operator uniform types ty add add ty add add ty add draw graph",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_div",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following math operator, singular types.\n\u003c/p\u003e\u003cpre\u003e 1.0 `ty_add1` 2.0 == r_add\n 1.0 `ty_add1` 2 == _|_\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_div1",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_div1",
          "type": "function"
        },
        "index": {
          "description": "Type following math operator singular types ty add1 add ty add1",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_div1",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_div1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following math operator, uniform types.\n\u003c/p\u003e\u003cpre\u003e 1.0 `ty_add` 2.0 == r_add\n (1 ~. 2) `ty_add` (3 ~. 4) == i_add\n 1.0 `ty_add` 2 == _|_\n draw (graph ((1 ~. 2) - (3 ~. 4)))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_mul",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_mul",
          "type": "function"
        },
        "index": {
          "description": "Type following math operator uniform types ty add add ty add add ty add draw graph",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_mul",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following math operator, singular types.\n\u003c/p\u003e\u003cpre\u003e 1.0 `ty_add1` 2.0 == r_add\n 1.0 `ty_add1` 2 == _|_\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_mul1",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_mul1",
          "type": "function"
        },
        "index": {
          "description": "Type following math operator singular types ty add1 add ty add1",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_mul1",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_mul1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following math operator, uniform types.\n\u003c/p\u003e\u003cpre\u003e 1.0 `ty_add` 2.0 == r_add\n (1 ~. 2) `ty_add` (3 ~. 4) == i_add\n 1.0 `ty_add` 2 == _|_\n draw (graph ((1 ~. 2) - (3 ~. 4)))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_sub",
          "package": "hdf",
          "signature": "BD -\u003e BD -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_sub",
          "type": "function"
        },
        "index": {
          "description": "Type following math operator uniform types ty add add ty add add ty add draw graph",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_sub",
          "normalized": "BD-\u003eBD-\u003eBD",
          "package": "hdf",
          "signature": "BD-\u003eBD-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType following unary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_uop",
          "package": "hdf",
          "signature": "(BD -\u003e Maybe TypeRep) -\u003e t -\u003e t -\u003e BD -\u003e t",
          "source": "src/Sound-DF-Uniform-Faust.html#ty_uop",
          "type": "function"
        },
        "index": {
          "description": "Type following unary operator",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "ty_uop",
          "normalized": "(BD-\u003eMaybe TypeRep)-\u003ea-\u003ea-\u003eBD-\u003ea",
          "package": "hdf",
          "signature": "(BD-\u003eMaybe TypeRep)-\u003et-\u003et-\u003eBD-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:ty_uop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct uniform \u003cem\u003etype\u003c/em\u003e primitive diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "u_prim",
          "package": "hdf",
          "signature": "TypeRep -\u003e String -\u003e Int -\u003e BD",
          "source": "src/Sound-DF-Uniform-Faust.html#u_prim",
          "type": "function"
        },
        "index": {
          "description": "Construct uniform type primitive diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "u_prim",
          "normalized": "TypeRep-\u003eString-\u003eInt-\u003eBD",
          "package": "hdf",
          "signature": "TypeRep-\u003eString-\u003eInt-\u003eBD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:u_prim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA wire coheres if the \u003ccode\u003e\u003ca\u003eport_ty\u003c/a\u003e\u003c/code\u003e of the left and right hand sides\n are equal.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wire_coheres",
          "package": "hdf",
          "signature": "Wire -\u003e Bool",
          "source": "src/Sound-DF-Uniform-Faust.html#wire_coheres",
          "type": "function"
        },
        "index": {
          "description": "wire coheres if the port ty of the left and right hand sides are equal",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wire_coheres",
          "normalized": "Wire-\u003eBool",
          "package": "hdf",
          "signature": "Wire-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:wire_coheres"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWires are coloured according to type.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wire_colour",
          "package": "hdf",
          "signature": "Wire_Ty -\u003e String",
          "source": "src/Sound-DF-Uniform-Faust.html#wire_colour",
          "type": "function"
        },
        "index": {
          "description": "Wires are coloured according to type",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wire_colour",
          "normalized": "Wire_Ty-\u003eString",
          "package": "hdf",
          "signature": "Wire_Ty-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:wire_colour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA backward \u003ccode\u003e\u003ca\u003eWire\u003c/a\u003e\u003c/code\u003e will introduce three \u003cem\u003eimplicit\u003c/em\u003e edges, a\n \u003ccode\u003e\u003ca\u003eNormal\u003c/a\u003e\u003c/code\u003e wire introduces one \u003ccode\u003e\u003ca\u003eNormal\u003c/a\u003e\u003c/code\u003e edge.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wire_to_edges",
          "package": "hdf",
          "signature": "Bool -\u003e Wire -\u003e [Edge]",
          "source": "src/Sound-DF-Uniform-Faust.html#wire_to_edges",
          "type": "function"
        },
        "index": {
          "description": "backward Wire will introduce three implicit edges Normal wire introduces one Normal edge",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wire_to_edges",
          "normalized": "Bool-\u003eWire-\u003e[Edge]",
          "package": "hdf",
          "signature": "Bool-\u003eWire-\u003e[Edge]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:wire_to_edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInternal wires of a block diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wires",
          "package": "hdf",
          "signature": "BD -\u003e [Wire]",
          "source": "src/Sound-DF-Uniform-Faust.html#wires",
          "type": "function"
        },
        "index": {
          "description": "Internal wires of block diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wires",
          "normalized": "BD-\u003e[Wire]",
          "package": "hdf",
          "signature": "BD-\u003e[Wire]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:wires"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImmediate internal wires of a block diagram.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wires_immed",
          "package": "hdf",
          "signature": "BD -\u003e [Wire]",
          "source": "src/Sound-DF-Uniform-Faust.html#wires_immed",
          "type": "function"
        },
        "index": {
          "description": "Immediate internal wires of block diagram",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wires_immed",
          "normalized": "BD-\u003e[Wire]",
          "package": "hdf",
          "signature": "BD-\u003e[Wire]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:wires_immed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003ewire_to_edges\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wires_to_edges",
          "package": "hdf",
          "signature": "Bool -\u003e [Wire] -\u003e [Edge]",
          "source": "src/Sound-DF-Uniform-Faust.html#wires_to_edges",
          "type": "function"
        },
        "index": {
          "description": "concatMap of wire to edges",
          "hierarchy": "Sound DF Uniform Faust",
          "module": "Sound.DF.Uniform.Faust",
          "name": "wires_to_edges",
          "normalized": "Bool-\u003e[Wire]-\u003e[Edge]",
          "package": "hdf",
          "signature": "Bool-\u003e[Wire]-\u003e[Edge]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-Faust.html#v:wires_to_edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInteraction with \u003ccode\u003ejack-dl\u003c/code\u003e, \u003ccode\u003escsynth\u003c/code\u003e and \u003ccode\u003etext-dl\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "Audition",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-Audition.html",
          "type": "module"
        },
        "index": {
          "description": "Interaction with jack-dl scsynth and text-dl",
          "hierarchy": "Sound DF Uniform GADT Audition",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "Audition",
          "package": "hdf",
          "partial": "Audition",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Audition.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph at \u003ccode\u003ejack-dl\u003c/code\u003e after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "audition",
          "package": "hdf",
          "signature": "[Message] -\u003e DF () -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Audition.html#audition",
          "type": "function"
        },
        "index": {
          "description": "Audition graph at jack-dl after sending initialisation messages",
          "hierarchy": "Sound DF Uniform GADT Audition",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "audition",
          "normalized": "[Message]-\u003eDF()-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eDF()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Audition.html#v:audition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph at \u003ccode\u003eSC3\u003c/code\u003e after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "audition_sc3",
          "package": "hdf",
          "signature": "[Message] -\u003e DF () -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Audition.html#audition_sc3",
          "type": "function"
        },
        "index": {
          "description": "Audition graph at SC3 after sending initialisation messages",
          "hierarchy": "Sound DF Uniform GADT Audition",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "audition_sc3",
          "normalized": "[Message]-\u003eDF()-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eDF()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Audition.html#v:audition_sc3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph at \u003ccode\u003etext-dl\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "audition_text",
          "package": "hdf",
          "signature": "Int -\u003e DF () -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Audition.html#audition_text",
          "type": "function"
        },
        "index": {
          "description": "Audition graph at text-dl",
          "hierarchy": "Sound DF Uniform GADT Audition",
          "module": "Sound.DF.Uniform.GADT.Audition",
          "name": "audition_text",
          "normalized": "Int-\u003eDF()-\u003eIO()",
          "package": "hdf",
          "signature": "Int-\u003eDF()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Audition.html#v:audition_text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eData flow nodes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "DF",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html",
          "type": "module"
        },
        "index": {
          "description": "Data flow nodes",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "DF",
          "package": "hdf",
          "partial": "DF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Binary_Fn",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#Binary_Fn",
          "type": "type"
        },
        "index": {
          "description": "Binary function",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Binary_Fn",
          "package": "hdf",
          "partial": "Binary Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:Binary_Fn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Binary_Op",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#Binary_Op",
          "type": "type"
        },
        "index": {
          "description": "Binary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Binary_Op",
          "package": "hdf",
          "partial": "Binary Op",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:Binary_Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData flow node.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "DF",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "data"
        },
        "index": {
          "description": "Data flow node",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "DF",
          "package": "hdf",
          "partial": "DF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:DF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuaternary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Quaternary_Op",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#Quaternary_Op",
          "type": "type"
        },
        "index": {
          "description": "Quaternary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Quaternary_Op",
          "package": "hdf",
          "partial": "Quaternary Op",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:Quaternary_Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuinary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Quinary_Op",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#Quinary_Op",
          "type": "type"
        },
        "index": {
          "description": "Quinary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Quinary_Op",
          "package": "hdf",
          "partial": "Quinary Op",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:Quinary_Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSenary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Senary_Op",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#Senary_Op",
          "type": "type"
        },
        "index": {
          "description": "Senary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Senary_Op",
          "package": "hdf",
          "partial": "Senary Op",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:Senary_Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTernary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Ternary_Op",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#Ternary_Op",
          "type": "type"
        },
        "index": {
          "description": "Ternary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Ternary_Op",
          "package": "hdf",
          "partial": "Ternary Op",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:Ternary_Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Unary_Op",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#Unary_Op",
          "type": "type"
        },
        "index": {
          "description": "Unary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "Unary_Op",
          "package": "hdf",
          "partial": "Unary Op",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#t:Unary_Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "A",
          "package": "hdf",
          "signature": "Vec Float -\u003e DF (Vec Float)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "A",
          "normalized": "Vec Float-\u003eDF(Vec Float)",
          "package": "hdf",
          "signature": "Vec Float-\u003eDF(Vec Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "K",
          "package": "hdf",
          "signature": "a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "K",
          "normalized": "a-\u003eDF a",
          "package": "hdf",
          "signature": "a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "M",
          "package": "hdf",
          "signature": "DF a -\u003e DF () -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "M",
          "normalized": "DF a-\u003eDF()-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF()-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P0",
          "package": "hdf",
          "signature": "String -\u003e TypeRep -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P0",
          "normalized": "String-\u003eTypeRep-\u003eDF a",
          "package": "hdf",
          "signature": "String-\u003eTypeRep-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:P0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P1",
          "package": "hdf",
          "signature": "String -\u003e TypeRep -\u003e DF a -\u003e DF b",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P1",
          "normalized": "String-\u003eTypeRep-\u003eDF a-\u003eDF b",
          "package": "hdf",
          "signature": "String-\u003eTypeRep-\u003eDF a-\u003eDF b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:P1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P2",
          "package": "hdf",
          "signature": "String -\u003e TypeRep -\u003e DF a -\u003e DF b -\u003e DF c",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P2",
          "normalized": "String-\u003eTypeRep-\u003eDF a-\u003eDF b-\u003eDF c",
          "package": "hdf",
          "signature": "String-\u003eTypeRep-\u003eDF a-\u003eDF b-\u003eDF c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:P2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P3",
          "package": "hdf",
          "signature": "String -\u003e TypeRep -\u003e DF a -\u003e DF b -\u003e DF c -\u003e DF d",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "P3",
          "normalized": "String-\u003eTypeRep-\u003eDF a-\u003eDF b-\u003eDF c-\u003eDF d",
          "package": "hdf",
          "signature": "String-\u003eTypeRep-\u003eDF a-\u003eDF b-\u003eDF c-\u003eDF d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:P3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "R",
          "package": "hdf",
          "signature": "R_Id -\u003e TypeRep -\u003e Either a (DF b, DF a) -\u003e DF b",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "R",
          "normalized": "R_Id-\u003eTypeRep-\u003eEither a(DF b,DF a)-\u003eDF b",
          "package": "hdf",
          "signature": "R_Id-\u003eTypeRep-\u003eEither a(DF b,DF a)-\u003eDF b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray read.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "a_read",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#a_read",
          "type": "function"
        },
        "index": {
          "description": "Array read",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "a_read",
          "normalized": "DF(Vec Float)-\u003eDF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:a_read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray writ.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "a_write",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Int32 -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#a_write",
          "type": "function"
        },
        "index": {
          "description": "Array writ",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "a_write",
          "normalized": "DF(Vec Float)-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:a_write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuffer read, read from buffer \u003cem\u003ep\u003c/em\u003e at index \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "b_read",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#b_read",
          "type": "function"
        },
        "index": {
          "description": "Buffer read read from buffer at index",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "b_read",
          "normalized": "DF Int-\u003eDF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:b_read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuffer write, write to buffer \u003cem\u003ep\u003c/em\u003e at index \u003cem\u003eq\u003c/em\u003e value \u003cem\u003er\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "b_write",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Int32 -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#b_write",
          "type": "function"
        },
        "index": {
          "description": "Buffer write write to buffer at index value",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "b_write",
          "normalized": "DF Int-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:b_write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle control input.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "ctl1",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#ctl1",
          "type": "function"
        },
        "index": {
          "description": "Single control input",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "ctl1",
          "normalized": "DF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:ctl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptimising addition primitive.  If either input is a multiplier\n node, unfold to a multiplier-add node.\n\u003c/p\u003e\u003cpre\u003e df_add_optimise (2 * 3) (4::DF Int32)\n df_add_optimise (2::DF Int32) (3 * 4)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_add_optimise",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_add_optimise",
          "type": "function"
        },
        "index": {
          "description": "Optimising addition primitive If either input is multiplier node unfold to multiplier-add node df add optimise DF Int32 df add optimise DF Int32",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_add_optimise",
          "normalized": "DF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_add_optimise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical \u003ccode\u003e\u003ca\u003e&&\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_and",
          "package": "hdf",
          "signature": "DF Bool -\u003e DF Bool -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_and",
          "type": "function"
        },
        "index": {
          "description": "Logical",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_and",
          "normalized": "DF Bool-\u003eDF Bool-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF Bool-\u003eDF Bool-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ca\u003eData.Bits\u003c/a\u003e \u003ccode\u003e.&.\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_bw_and",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Int32 -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_bw_and",
          "type": "function"
        },
        "index": {
          "description": "Data.Bits",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_bw_and",
          "normalized": "DF Int-\u003eDF Int-\u003eDF Int",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Int-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_bw_and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ca\u003eData.Bits\u003c/a\u003e \u003ccode\u003ecomplement\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_bw_not",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_bw_not",
          "type": "function"
        },
        "index": {
          "description": "Data.Bits complement",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_bw_not",
          "normalized": "DF Int-\u003eDF Int",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_bw_not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ca\u003eData.Bits\u003c/a\u003e \u003ccode\u003e.|.\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_bw_or",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Int32 -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_bw_or",
          "type": "function"
        },
        "index": {
          "description": "Data.Bits",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_bw_or",
          "normalized": "DF Int-\u003eDF Int-\u003eDF Int",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Int-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_bw_or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eceilf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_ceilf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_ceilf",
          "type": "function"
        },
        "index": {
          "description": "ceilf",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_ceilf",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_ceilf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e, equal to.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_eq",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_eq",
          "type": "function"
        },
        "index": {
          "description": "equal to",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_eq",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform typed \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e to un-typed \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_erase",
          "package": "hdf",
          "signature": "DF a -\u003e UDF",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_erase",
          "type": "function"
        },
        "index": {
          "description": "Transform typed DF to un-typed UDF",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_erase",
          "normalized": "DF a-\u003eUDF",
          "package": "hdf",
          "signature": "DF a-\u003eUDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_erase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast floating point to integer.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_float_to_int32",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_float_to_int32",
          "type": "function"
        },
        "index": {
          "description": "Cast floating point to integer",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_float_to_int32",
          "normalized": "DF Float-\u003eDF Int",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_float_to_int32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efloorf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_floorf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_floorf",
          "type": "function"
        },
        "index": {
          "description": "floorf",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_floorf",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_floorf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFloating point modulo, ie. \u003ca\u003eForeign.C.Math\u003c/a\u003e \u003cem\u003efmodf\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_fmodf",
          "package": "hdf",
          "signature": "Binary_Op (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_fmodf",
          "type": "function"
        },
        "index": {
          "description": "Floating point modulo ie Foreign.C.Math fmodf",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_fmodf",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_fmodf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003e\u003c/a\u003e\u003c/code\u003e, greater than.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_gt",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_gt",
          "type": "function"
        },
        "index": {
          "description": "greater than",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_gt",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_gt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003e=\u003c/a\u003e\u003c/code\u003e, greater than or equal to.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_gte",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_gte",
          "type": "function"
        },
        "index": {
          "description": "greater than or equal to",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_gte",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_gte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast integer to floating point.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_int32_to_float",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_int32_to_float",
          "type": "function"
        },
        "index": {
          "description": "Cast integer to floating point",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_int32_to_float",
          "normalized": "DF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_int32_to_float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elrintf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_lrintf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_lrintf",
          "type": "function"
        },
        "index": {
          "description": "lrintf",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_lrintf",
          "normalized": "DF Float-\u003eDF Int",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_lrintf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e, less than.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_lt",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_lt",
          "type": "function"
        },
        "index": {
          "description": "less than",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_lt",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e, less than or equal to.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_lte",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_lte",
          "type": "function"
        },
        "index": {
          "description": "less than or equal to",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_lte",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_lte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e, select maximum.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_max",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_max",
          "type": "function"
        },
        "index": {
          "description": "max select maximum",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_max",
          "normalized": "DF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emin\u003c/a\u003e\u003c/code\u003e, select minimum.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_min",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_min",
          "type": "function"
        },
        "index": {
          "description": "min select minimum",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_min",
          "normalized": "DF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntegral modulo, ie. \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_mod",
          "package": "hdf",
          "signature": "Binary_Op (DF Int32)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_mod",
          "type": "function"
        },
        "index": {
          "description": "Integral modulo ie mod",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_mod",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e multiply and add.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_mul_add",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_mul_add",
          "type": "function"
        },
        "index": {
          "description": "DF multiply and add",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_mul_add",
          "normalized": "DF a-\u003eDF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_mul_add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_not",
          "package": "hdf",
          "signature": "DF Bool -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_not",
          "type": "function"
        },
        "index": {
          "description": "Logical not",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_not",
          "normalized": "DF Bool-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF Bool-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical \u003ccode\u003e\u003ca\u003e||\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_or",
          "package": "hdf",
          "signature": "DF Bool -\u003e DF Bool -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_or",
          "type": "function"
        },
        "index": {
          "description": "Logical",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_or",
          "normalized": "DF Bool-\u003eDF Bool-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF Bool-\u003eDF Bool-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of primitive if \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eP0\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eP1\u003c/a\u003e\u003c/code\u003e etc.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_primitive",
          "package": "hdf",
          "signature": "DF a -\u003e Maybe String",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_primitive",
          "type": "function"
        },
        "index": {
          "description": "Name of primitive if DF is P0 or P1 etc",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_primitive",
          "normalized": "DF a-\u003eMaybe String",
          "package": "hdf",
          "signature": "DF a-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_primitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eroundf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_roundf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_roundf",
          "type": "function"
        },
        "index": {
          "description": "roundf",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_roundf",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_roundf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edf_vec_size\u003c/a\u003e\u003c/code\u003e variant, tables have a guard point.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_tbl_size",
          "package": "hdf",
          "signature": "DF a -\u003e Maybe Int",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_tbl_size",
          "type": "function"
        },
        "index": {
          "description": "df vec size variant tables have guard point",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_tbl_size",
          "normalized": "DF a-\u003eMaybe Int",
          "package": "hdf",
          "signature": "DF a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_tbl_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypeable instance for \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e df_typeOf (C (undefined::Int32)) == int32_t\n df_typeOf (C (undefined::Float)) == float_t\n df_typeOf (A undefined) == vec_float_t\n df_typeOf (0::DF Int32) == int32_t\n df_typeOf (0.0::DF Float) == float_t\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_typeOf",
          "package": "hdf",
          "signature": "DF a -\u003e TypeRep",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_typeOf",
          "type": "function"
        },
        "index": {
          "description": "Typeable instance for DF df typeOf undefined Int32 int32 df typeOf undefined Float float df typeOf undefined vec float df typeOf DF Int32 int32 df typeOf DF Float float",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_typeOf",
          "normalized": "DF a-\u003eTypeRep",
          "package": "hdf",
          "partial": "Of",
          "signature": "DF a-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_typeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e constructor.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_vec",
          "package": "hdf",
          "signature": "V_Id -\u003e [Float] -\u003e DF (Vec Float)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_vec",
          "type": "function"
        },
        "index": {
          "description": "DF Vec constructor",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_vec",
          "normalized": "V_Id-\u003e[Float]-\u003eDF(Vec Float)",
          "package": "hdf",
          "signature": "V_Id-\u003e[Float]-\u003eDF(Vec Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e constructor.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_vec_m",
          "package": "hdf",
          "signature": "[Float] -\u003e m (DF (Vec Float))",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_vec_m",
          "type": "function"
        },
        "index": {
          "description": "Monadic DF Vec constructor",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_vec_m",
          "normalized": "[Float]-\u003ea(DF(Vec Float))",
          "package": "hdf",
          "signature": "[Float]-\u003em(DF(Vec Float))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_vec_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e size.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_vec_size",
          "package": "hdf",
          "signature": "DF a -\u003e Maybe Int",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#df_vec_size",
          "type": "function"
        },
        "index": {
          "description": "DF Vec size",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "df_vec_size",
          "normalized": "DF a-\u003eMaybe Int",
          "package": "hdf",
          "signature": "DF a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:df_vec_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale \u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e to (-1,1) normalised \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e maxBound == (2147483647::Int32)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "i32_to_normal_f32",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#i32_to_normal_f32",
          "type": "function"
        },
        "index": {
          "description": "Scale Int32 to normalised Float maxBound Int32",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "i32_to_normal_f32",
          "normalized": "DF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:i32_to_normal_f32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle channel input (channel 0).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "in1",
          "package": "hdf",
          "signature": "DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#in1",
          "type": "function"
        },
        "index": {
          "description": "Single channel input channel",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "in1",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:in1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mk_binop",
          "package": "hdf",
          "signature": "String -\u003e Binary_Op (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#mk_binop",
          "type": "function"
        },
        "index": {
          "description": "Binary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mk_binop",
          "normalized": "String-\u003eBinary_Op(DF a)",
          "package": "hdf",
          "signature": "String-\u003eBinary_Op(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:mk_binop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mk_ternaryop",
          "package": "hdf",
          "signature": "String -\u003e Ternary_Op (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#mk_ternaryop",
          "type": "function"
        },
        "index": {
          "description": "Binary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mk_ternaryop",
          "normalized": "String-\u003eTernary_Op(DF a)",
          "package": "hdf",
          "signature": "String-\u003eTernary_Op(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:mk_ternaryop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mk_uop",
          "package": "hdf",
          "signature": "String -\u003e Unary_Op (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#mk_uop",
          "type": "function"
        },
        "index": {
          "description": "Unary operator",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mk_uop",
          "normalized": "String-\u003eUnary_Op(DF a)",
          "package": "hdf",
          "signature": "String-\u003eUnary_Op(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:mk_uop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiple root graph (alias for M).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mrg",
          "package": "hdf",
          "signature": "DF a -\u003e DF () -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#mrg",
          "type": "function"
        },
        "index": {
          "description": "Multiple root graph alias for",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "mrg",
          "normalized": "DF a-\u003eDF()-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF()-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:mrg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle channel output (channel 0).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "out1",
          "package": "hdf",
          "signature": "DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#out1",
          "type": "function"
        },
        "index": {
          "description": "Single channel output channel",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "out1",
          "normalized": "DF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:out1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo channel output (channels 1 & 2).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "out2",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#out2",
          "type": "function"
        },
        "index": {
          "description": "Two channel output channels",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "out2",
          "normalized": "DF Float-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:out2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThree channel output.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "out3",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#out3",
          "type": "function"
        },
        "index": {
          "description": "Three channel output",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "out3",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:out3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHash-eq variant of \u003ccode\u003e\u003ca\u003erec_r\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_h",
          "package": "hdf",
          "signature": "a -\u003e (DF a -\u003e (DF b, DF a)) -\u003e DF b",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#rec_h",
          "type": "function"
        },
        "index": {
          "description": "Hash-eq variant of rec",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_h",
          "normalized": "a-\u003e(DF a-\u003e(DF b,DF a))-\u003eDF b",
          "package": "hdf",
          "signature": "a-\u003e(DF a-\u003e(DF b,DF a))-\u003eDF b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:rec_h"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic variant of \u003ccode\u003e\u003ca\u003erec_r\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_m",
          "package": "hdf",
          "signature": "a -\u003e (DF a -\u003e (DF b, DF a)) -\u003e m (DF b)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#rec_m",
          "type": "function"
        },
        "index": {
          "description": "Monadic variant of rec",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_m",
          "normalized": "a-\u003e(DF a-\u003e(DF b,DF a))-\u003ec(DF b)",
          "package": "hdf",
          "signature": "a-\u003e(DF a-\u003e(DF b,DF a))-\u003em(DF b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:rec_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003erec_m\u003c/a\u003e\u003c/code\u003e with monadic action in backward arc.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_mM",
          "package": "hdf",
          "signature": "a -\u003e (DF a -\u003e m (DF b, DF a)) -\u003e m (DF b)",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#rec_mM",
          "type": "function"
        },
        "index": {
          "description": "Variant of rec with monadic action in backward arc",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_mM",
          "normalized": "a-\u003e(DF a-\u003eb(DF c,DF a))-\u003eb(DF c)",
          "package": "hdf",
          "signature": "a-\u003e(DF a-\u003em(DF b,DF a))-\u003em(DF b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:rec_mM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntroduce backward arc with implicit unit delay.\n\u003c/p\u003e\u003cp\u003eThe function receives the previous output as input, initially \u003ccode\u003ey0\u003c/code\u003e,\n and returns a \u003cem\u003e(feed-forward,feed-backward)\u003c/em\u003e pair.\n\u003c/p\u003e\u003cpre\u003e rec_r (R_Id 0) (0::Int) ((\\i-\u003e(i,i)) . (+) 1)\n rec_r (R_Id 0) (0.0::Float) ((\\i-\u003e(i,i)) . (+) 1.0)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_r",
          "package": "hdf",
          "signature": "R_Id -\u003e a -\u003e (DF a -\u003e (DF b, DF a)) -\u003e DF b",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#rec_r",
          "type": "function"
        },
        "index": {
          "description": "Introduce backward arc with implicit unit delay The function receives the previous output as input initially y0 and returns feed-forward feed-backward pair rec Id Int rec Id Float",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "rec_r",
          "normalized": "R_Id-\u003ea-\u003e(DF a-\u003e(DF b,DF a))-\u003eDF b",
          "package": "hdf",
          "signature": "R_Id-\u003ea-\u003e(DF a-\u003e(DF b,DF a))-\u003eDF b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:rec_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003cem\u003ep\u003c/em\u003e then \u003cem\u003eq\u003c/em\u003e else \u003cem\u003er\u003c/em\u003e.  \u003cem\u003ep\u003c/em\u003e must have type bool, and \u003cem\u003eq\u003c/em\u003e\n and \u003cem\u003er\u003c/em\u003e must have equal types.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "select2",
          "package": "hdf",
          "signature": "DF Bool -\u003e DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#select2",
          "type": "function"
        },
        "index": {
          "description": "If then else must have type bool and and must have equal types",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "select2",
          "normalized": "DF Bool-\u003eDF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF Bool-\u003eDF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:select2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e at first frame of each control period.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "w_kr_edge",
          "package": "hdf",
          "signature": "DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#w_kr_edge",
          "type": "function"
        },
        "index": {
          "description": "True at first frame of each control period",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "w_kr_edge",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:w_kr_edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of frames in current control period.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "w_kr_nframes",
          "package": "hdf",
          "signature": "DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#w_kr_nframes",
          "type": "function"
        },
        "index": {
          "description": "Number of frames in current control period",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "w_kr_nframes",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:w_kr_nframes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperating sample rate.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "w_sample_rate",
          "package": "hdf",
          "signature": "DF Float",
          "source": "src/Sound-DF-Uniform-GADT-DF.html#w_sample_rate",
          "type": "function"
        },
        "index": {
          "description": "Operating sample rate",
          "hierarchy": "Sound DF Uniform GADT DF",
          "module": "Sound.DF.Uniform.GADT.DF",
          "name": "w_sample_rate",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-DF.html#v:w_sample_rate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGraph drawing\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "Draw",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-Draw.html",
          "type": "module"
        },
        "index": {
          "description": "Graph drawing",
          "hierarchy": "Sound DF Uniform GADT Draw",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "Draw",
          "package": "hdf",
          "partial": "Draw",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Draw.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edraw\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edf_erase\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "draw",
          "package": "hdf",
          "signature": "DF a -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Draw.html#draw",
          "type": "function"
        },
        "index": {
          "description": "draw of df erase",
          "hierarchy": "Sound DF Uniform GADT Draw",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "draw",
          "normalized": "DF a-\u003eIO()",
          "package": "hdf",
          "signature": "DF a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Draw.html#v:draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edraw'\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edf_erase\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "draw'",
          "package": "hdf",
          "signature": "DF a -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Draw.html#draw%27",
          "type": "function"
        },
        "index": {
          "description": "draw of df erase",
          "hierarchy": "Sound DF Uniform GADT Draw",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "draw'",
          "normalized": "DF a-\u003eIO()",
          "package": "hdf",
          "signature": "DF a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Draw.html#v:draw-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edraw\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edf_erase\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eevalId\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "drawM",
          "package": "hdf",
          "signature": "State Id (DF a) -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Draw.html#drawM",
          "type": "function"
        },
        "index": {
          "description": "draw of df erase of evalId",
          "hierarchy": "Sound DF Uniform GADT Draw",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "drawM",
          "normalized": "State Id(DF a)-\u003eIO()",
          "package": "hdf",
          "signature": "State Id(DF a)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Draw.html#v:drawM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egr_draw\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edf_erase\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "gr_draw",
          "package": "hdf",
          "signature": "DF a -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Draw.html#gr_draw",
          "type": "function"
        },
        "index": {
          "description": "gr draw of df erase",
          "hierarchy": "Sound DF Uniform GADT Draw",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "gr_draw",
          "normalized": "DF a-\u003eIO()",
          "package": "hdf",
          "signature": "DF a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Draw.html#v:gr_draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egr_draw'\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edf_erase\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "gr_draw'",
          "package": "hdf",
          "signature": "DF a -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Draw.html#gr_draw%27",
          "type": "function"
        },
        "index": {
          "description": "gr draw of df erase",
          "hierarchy": "Sound DF Uniform GADT Draw",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "gr_draw'",
          "normalized": "DF a-\u003eIO()",
          "package": "hdf",
          "signature": "DF a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Draw.html#v:gr_draw-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egr_draw\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003edf_erase\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eevalId\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "gr_drawM",
          "package": "hdf",
          "signature": "State Id (DF a) -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-GADT-Draw.html#gr_drawM",
          "type": "function"
        },
        "index": {
          "description": "gr draw of df erase of evalId",
          "hierarchy": "Sound DF Uniform GADT Draw",
          "module": "Sound.DF.Uniform.GADT.Draw",
          "name": "gr_drawM",
          "normalized": "State Id(DF a)-\u003eIO()",
          "package": "hdf",
          "signature": "State Id(DF a)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-Draw.html#v:gr_drawM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eData flow node functions, or unit generators.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "Monadic",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html",
          "type": "module"
        },
        "index": {
          "description": "Data flow node functions or unit generators",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "Monadic",
          "package": "hdf",
          "partial": "Monadic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate \u003cem\u003en\u003c/em\u003e second array, variant of \u003ccode\u003e\u003ca\u003edf_vec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_alloc_sec_m",
          "package": "hdf",
          "signature": "Float -\u003e m (DF (Vec Float))",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#a_alloc_sec_m",
          "type": "function"
        },
        "index": {
          "description": "Allocate second array variant of df vec",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_alloc_sec_m",
          "normalized": "Float-\u003ea(DF(Vec Float))",
          "package": "hdf",
          "signature": "Float-\u003em(DF(Vec Float))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:a_alloc_sec_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray delay.\n\u003c/p\u003e\u003cpre\u003e do {a \u003c- df_vec_m [0,1,2]\n    ;d \u003c- a_delay a 0.0 0\n    ;draw (a_delay a 0.0 0)}\n\u003c/pre\u003e\u003cpre\u003e do {f \u003c- sin_osc 0.1 0.0\n    ;o \u003c- sin_osc (f * 200.0 + 600.0) 0.0\n    ;a \u003c- df_vec_m (replicate 48000 0)\n    ;d \u003c- a_delay a o 24000\n    ;audition [] (out2 (o * 0.1) (d * 0.05))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_delay_m",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Float -\u003e DF Int32 -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#a_delay_m",
          "type": "function"
        },
        "index": {
          "description": "Array delay do df vec delay draw delay do sin osc sin osc df vec replicate delay audition out2",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_delay_m",
          "normalized": "DF(Vec Float)-\u003eDF Float-\u003eDF Int-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Float-\u003eDF Int-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:a_delay_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable lookup oscillator. \u003cem\u003eip\u003c/em\u003e is in (0,1).\n\u003c/p\u003e\u003cpre\u003e do {a \u003c- a_tbl_sin 256\n    ;f \u003c- a_osc a 4.0 0.0\n    ;o \u003c- a_osc a (f * 200.0 + 400.0) 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e\u003cp\u003eCancellation:\n\u003c/p\u003e\u003cpre\u003e do {a \u003c- a_tbl_sin 256\n    ;o1 \u003c- a_osc a 440.0 0.0\n    ;o2 \u003c- a_osc a 440.0 0.5\n    ;audition [] (out1 (o1 + o2))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_osc_m",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Float -\u003e Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#a_osc_m",
          "type": "function"
        },
        "index": {
          "description": "Table lookup oscillator ip is in do tbl sin osc osc audition out1 Cancellation do tbl sin o1 osc o2 osc audition out1 o1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_osc_m",
          "normalized": "DF(Vec Float)-\u003eDF Float-\u003eFloat-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Float-\u003eFloat-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:a_osc_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray fill function (sin).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_tbl_sin_m",
          "package": "hdf",
          "signature": "Int -\u003e m (DF (Vec Float))",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#a_tbl_sin_m",
          "type": "function"
        },
        "index": {
          "description": "Array fill function sin",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "a_tbl_sin_m",
          "normalized": "Int-\u003ea(DF(Vec Float))",
          "package": "hdf",
          "signature": "Int-\u003em(DF(Vec Float))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:a_tbl_sin_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdinary biquad filter section.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "biquad_m",
          "package": "hdf",
          "signature": "Quinary_Op (DF Float) -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#biquad_m",
          "type": "function"
        },
        "index": {
          "description": "Ordinary biquad filter section",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "biquad_m",
          "normalized": "Quinary_Op(DF Float)-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "Quinary_Op(DF Float)-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:biquad_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo zero fixed midpass filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "bpz2_m",
          "package": "hdf",
          "signature": "DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#bpz2_m",
          "type": "function"
        },
        "index": {
          "description": "Two zero fixed midpass filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "bpz2_m",
          "normalized": "DF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:bpz2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBrown noise (-1,1).  Generates noise whose spectrum falls off in\n power by 6 dB per octave.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- brown_noise_m\n    ;audition [] (out1 (n * 0.1))}\n\u003c/pre\u003e\u003cpre\u003e do {n \u003c- brown_noise_m\n    ;let f = lin_exp n (-1.0) 1.0 64.0 9600.0\n     in do {o \u003c- sin_osc f 0\n           ;audition [] (out1 (o * 0.1))}}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "brown_noise_m",
          "package": "hdf",
          "signature": "m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#brown_noise_m",
          "type": "function"
        },
        "index": {
          "description": "Brown noise Generates noise whose spectrum falls off in power by dB per octave do brown noise audition out1 do brown noise let lin exp in do sin osc audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "brown_noise_m",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:brown_noise_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo zero fixed midcut filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "brz2_m",
          "package": "hdf",
          "signature": "DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#brz2_m",
          "type": "function"
        },
        "index": {
          "description": "Two zero fixed midcut filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "brz2_m",
          "normalized": "DF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:brz2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-interpolating comb filter.  Inputs are: \u003cem\u003eb\u003c/em\u003e = buffer index,\n \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003edl\u003c/em\u003e = delay time, \u003cem\u003edc\u003c/em\u003e = decay time.\n\u003c/p\u003e\u003cp\u003eAll times are in seconds.  The decay time is the time for the\n echoes to decay by \u003ccode\u003e60\u003c/code\u003e decibels. If this time is negative then the\n feedback coefficient will be negative, thus emphasizing only odd\n harmonics at an octave lower.\n\u003c/p\u003e\u003cpre\u003e drawM (fmap out1 (buf_comb_n 0 0.0 0.0 0.0))\n\u003c/pre\u003e\u003cp\u003eComb used as a resonator. The resonant fundamental is equal to\n reciprocal of the delay time.\n\u003c/p\u003e\u003cpre\u003e import qualified Sound.SC3 as S\n\u003c/pre\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;dt \u003c- let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01\n           in fmap f (lf_saw 0.1 0.0)\n    ;c \u003c- buf_comb_n 0 (n * 0.1) dt 0.2\n    ;audition [S.b_alloc 0 48000 1] (out1 c)}\n\u003c/pre\u003e\u003cp\u003eComb used as an echo.\n\u003c/p\u003e\u003cpre\u003e do {i \u003c- impulse 0.5 0.0\n    ;n \u003c- white_noise_m\n    ;e \u003c- decay (i * 0.5) 0.2\n    ;c \u003c- buf_comb_n 0 (e * n) 0.2 3.0\n    ;audition [S.b_alloc 0 48000 1] (out1 c)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "buf_comb_n_m",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#buf_comb_n_m",
          "type": "function"
        },
        "index": {
          "description": "Non-interpolating comb filter Inputs are buffer index input signal dl delay time dc decay time All times are in seconds The decay time is the time for the echoes to decay by decibels If this time is negative then the feedback coefficient will be negative thus emphasizing only odd harmonics at an octave lower drawM fmap out1 buf comb Comb used as resonator The resonant fundamental is equal to reciprocal of the delay time import qualified Sound.SC3 as do white noise dt let lin exp in fmap lf saw buf comb dt audition S.b alloc out1 Comb used as an echo do impulse white noise decay buf comb audition S.b alloc out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "buf_comb_n_m",
          "normalized": "DF Int-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:buf_comb_n_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuffer delay.\n\u003c/p\u003e\u003cpre\u003e drawM (buf_delay 0 0.0 0)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "buf_delay_m",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float -\u003e DF Int32 -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#buf_delay_m",
          "type": "function"
        },
        "index": {
          "description": "Buffer delay drawM buf delay",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "buf_delay_m",
          "normalized": "DF Int-\u003eDF Float-\u003eDF Int-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float-\u003eDF Int-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:buf_delay_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray variant of \u003ccode\u003e\u003ca\u003ebuf_comb_n\u003c/a\u003e\u003c/code\u003e.  Max delay time is in seconds.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;dt \u003c- let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01\n           in fmap f (lf_saw 0.1 0.0)\n    ;c \u003c- comb_n 0.1 (n * 0.1) dt 0.2\n    ;audition [] (out1 c)}\n\u003c/pre\u003e\u003cpre\u003e do {i \u003c- impulse 0.5 0.0\n    ;n \u003c- white_noise_m\n    ;e \u003c- decay (i * 0.5) 0.2\n    ;c \u003c- comb_n 0.2 (e * n) 0.2 3.0\n    ;audition [] (out1 c)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "comb_n_m",
          "package": "hdf",
          "signature": "Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#comb_n_m",
          "type": "function"
        },
        "index": {
          "description": "Array variant of buf comb Max delay time is in seconds do white noise dt let lin exp in fmap lf saw comb dt audition out1 do impulse white noise decay comb audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "comb_n_m",
          "normalized": "Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:comb_n_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCounter from indicated initial value.\n\u003c/p\u003e\u003cpre\u003e draw =\u003c\u003c counter (0::Int32) 1\n drawM (counter (0.0::Float) 1.0)\n\u003c/pre\u003e\u003cpre\u003e audition_text 10 . out1 =\u003c\u003c counter_m 0.0 1.0\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "counter_m",
          "package": "hdf",
          "signature": "a -\u003e DF a -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#counter_m",
          "type": "function"
        },
        "index": {
          "description": "Counter from indicated initial value draw counter Int32 drawM counter Float audition text out1 counter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "counter_m",
          "normalized": "a-\u003eDF a-\u003eb(DF a)",
          "package": "hdf",
          "signature": "a-\u003eDF a-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:counter_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponential decay (equivalent to \u003ccode\u003edecay dcy - decay atk\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "decay2_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#decay2_m",
          "type": "function"
        },
        "index": {
          "description": "Exponential decay equivalent to decay dcy decay atk",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "decay2_m",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:decay2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponential decay. Inputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003et\u003c/em\u003e = decay\n time.  This is essentially the same as Integrator except that\n instead of supplying the coefficient directly, it is caculated from\n a 60 dB decay time. This is the time required for the integrator to\n lose 99.9 % of its value or -60dB. This is useful for exponential\n decaying envelopes triggered by impulses.\n\u003c/p\u003e\u003cp\u003eUsed as an envelope.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- brown_noise_m\n    ;f \u003c- lf_saw 0.1 0.0\n    ;i \u003c- impulse (lin_lin f (-1.0) 1.0 2.0 5.0) 0.25\n    ;e \u003c- decay i 0.2\n    ;audition [] (out1 (e * n))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "decay_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#decay_m",
          "type": "function"
        },
        "index": {
          "description": "Exponential decay Inputs are input signal decay time This is essentially the same as Integrator except that instead of supplying the coefficient directly it is caculated from dB decay time This is the time required for the integrator to lose of its value or dB This is useful for exponential decaying envelopes triggered by impulses Used as an envelope do brown noise lf saw impulse lin lin decay audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "decay_m",
          "normalized": "DF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:decay_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle sample delay.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "delay1_m",
          "package": "hdf",
          "signature": "DF a -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#delay1_m",
          "type": "function"
        },
        "index": {
          "description": "Single sample delay",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "delay1_m",
          "normalized": "DF a-\u003eb(DF a)",
          "package": "hdf",
          "signature": "DF a-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:delay1_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo sample delay.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "delay2_m",
          "package": "hdf",
          "signature": "DF a -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#delay2_m",
          "type": "function"
        },
        "index": {
          "description": "Two sample delay",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "delay2_m",
          "normalized": "DF a-\u003eb(DF a)",
          "package": "hdf",
          "signature": "DF a-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:delay2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle place finite impulse response filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "fir1_m",
          "package": "hdf",
          "signature": "Binary_Op (DF Float) -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#fir1_m",
          "type": "function"
        },
        "index": {
          "description": "Single place finite impulse response filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "fir1_m",
          "normalized": "Binary_Op(DF Float)-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "Binary_Op(DF Float)-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:fir1_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo place finite impulse response filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "fir2_m",
          "package": "hdf",
          "signature": "Ternary_Op (DF Float) -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#fir2_m",
          "type": "function"
        },
        "index": {
          "description": "Two place finite impulse response filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "fir2_m",
          "normalized": "Ternary_Op(DF Float)-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "Ternary_Op(DF Float)-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:fir2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle place infinite impulse response filter with indicated\n initial value.\n\u003c/p\u003e\u003cpre\u003e import Data.Int\n import Sound.DF.Uniform.GADT\n draw =\u003c\u003c iir1_m (0::Int32) (+) 1\n draw =\u003c\u003c iir1_m (0::Float) (+) 1\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "iir1_m",
          "package": "hdf",
          "signature": "a -\u003e Binary_Op (DF a) -\u003e DF a -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#iir1_m",
          "type": "function"
        },
        "index": {
          "description": "Single place infinite impulse response filter with indicated initial value import Data.Int import Sound.DF.Uniform.GADT draw iir1 Int32 draw iir1 Float",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "iir1_m",
          "normalized": "a-\u003eBinary_Op(DF a)-\u003eDF a-\u003eb(DF a)",
          "package": "hdf",
          "signature": "a-\u003eBinary_Op(DF a)-\u003eDF a-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:iir1_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo place infinite impulse response filter.  Inputs are: \u003cem\u003ef\u003c/em\u003e=\n function \u003ccode\u003e(x0 y1 y2 -\u003e y0)\u003c/code\u003e, \u003cem\u003ei\u003c/em\u003e = input signal.\n\u003c/p\u003e\u003cpre\u003e do {c1 \u003c- iir2 (\\x y1 _ -\u003e x + y1) 0.001\n    ;o1 \u003c- sin_osc (c1 + 220.0) 0\n    ;c2 \u003c- iir2 (\\x _ y2 -\u003e x + y2) 0.001\n    ;o2 \u003c- sin_osc (c2 + 220.0) 0\n    ;audition [] (out2 (o1 * 0.1) (o2 * 0.1))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "iir2_m",
          "package": "hdf",
          "signature": "Ternary_Op (DF a) -\u003e DF a -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#iir2_m",
          "type": "function"
        },
        "index": {
          "description": "Two place infinite impulse response filter Inputs are function x0 y1 y2 y0 input signal do c1 iir2 y1 y1 o1 sin osc c1 c2 iir2 y2 y2 o2 sin osc c2 audition out2 o1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "iir2_m",
          "normalized": "Ternary_Op(DF a)-\u003eDF a-\u003eb(DF a)",
          "package": "hdf",
          "signature": "Ternary_Op(DF a)-\u003eDF a-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:iir2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImpulse oscillator (non band limited).\n Outputs non band limited single sample impulses.\n Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hertz), \u003cem\u003eip\u003c/em\u003e = phase offset (0..1)\n\u003c/p\u003e\u003cpre\u003e do {o \u003c- impulse 800.0 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e\u003cpre\u003e do {f \u003c- fmap (\\x -\u003e x * 2500.0 + 2505.0) (sin_osc 0.25 0.0)\n    ;o \u003c- impulse f 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "impulse_m",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#impulse_m",
          "type": "function"
        },
        "index": {
          "description": "Impulse oscillator non band limited Outputs non band limited single sample impulses Inputs are frequency in hertz ip phase offset do impulse audition out1 do fmap sin osc impulse audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "impulse_m",
          "normalized": "DF Float-\u003eFloat-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:impulse_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNested lag filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lag2_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#lag2_m",
          "type": "function"
        },
        "index": {
          "description": "Nested lag filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lag2_m",
          "normalized": "DF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:lag2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwice nested lag filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lag3_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#lag3_m",
          "type": "function"
        },
        "index": {
          "description": "Twice nested lag filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lag3_m",
          "normalized": "DF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:lag3_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple averaging filter.  Inputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003et\u003c/em\u003e =\n lag time.\n\u003c/p\u003e\u003cpre\u003e do {s \u003c- sin_osc 0.05 0.0\n    ;let f = lin_lin s (-1.0) 1.0 220.0 440.0\n     in do {o \u003c- sin_osc f 0.0\n           ;f' \u003c- lag f 1.0\n           ;o' \u003c- sin_osc f' 0.0\n           ;audition [] (out2 (o * 0.2) (o' * 0.2))}}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lag_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#lag_m",
          "type": "function"
        },
        "index": {
          "description": "Simple averaging filter Inputs are input signal lag time do sin osc let lin lin in do sin osc lag sin osc audition out2",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lag_m",
          "normalized": "DF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:lag_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSample and hold. Holds input signal value when triggered.  Inputs\n are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003et\u003c/em\u003e = trigger.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;i \u003c- impulse_m 9.0 0.0\n    ;l \u003c- latch_m n (trigger i)\n    ;o \u003c- sin_osc (l * 400.0 + 500.0) 0.0\n    ;audition [] (out1 (o * 0.2))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "latch_m",
          "package": "hdf",
          "signature": "DF a -\u003e DF Bool -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#latch_m",
          "type": "function"
        },
        "index": {
          "description": "Sample and hold Holds input signal value when triggered Inputs are input signal trigger do white noise impulse latch trigger sin osc audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "latch_m",
          "normalized": "DF a-\u003eDF Bool-\u003eb(DF a)",
          "package": "hdf",
          "signature": "DF a-\u003eDF Bool-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:latch_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-band-limited pulse oscillator. Outputs a high value of one\n and a low value of zero. Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hertz),\n \u003cem\u003eip\u003c/em\u003e = initial phase (0,1), \u003cem\u003ew\u003c/em\u003e = pulse width duty cycle (0,1).\n\u003c/p\u003e\u003cpre\u003e do {o1 \u003c- fmap (\\x -\u003e x * 200.0 + 200.0) (lf_pulse 3.0 0.0 0.3)\n    ;o2 \u003c- fmap (\\x -\u003e x * 0.1) (lf_pulse o1 0.0 0.2)\n    ;audition [] (out1 o2)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lf_pulse_m",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#lf_pulse_m",
          "type": "function"
        },
        "index": {
          "description": "Non-band-limited pulse oscillator Outputs high value of one and low value of zero Inputs are frequency in hertz ip initial phase pulse width duty cycle do o1 fmap lf pulse o2 fmap lf pulse o1 audition out1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lf_pulse_m",
          "normalized": "DF Float-\u003eFloat-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:lf_pulse_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-band limited sawtooth oscillator.  Output ranges from -1 to +1.\n Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hertz), \u003cem\u003eip\u003c/em\u003e = initial phase (0,2).\n\u003c/p\u003e\u003cpre\u003e do {o \u003c- lf_saw 500.0 1.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e\u003cp\u003eUsed as both Oscillator and LFO.\n\u003c/p\u003e\u003cpre\u003e do {f \u003c- lf_saw 4.0 0.0\n    ;o \u003c- lf_saw (f * 400.0 + 400.0) 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lf_saw_m",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#lf_saw_m",
          "type": "function"
        },
        "index": {
          "description": "Non-band limited sawtooth oscillator Output ranges from to Inputs are frequency in hertz ip initial phase do lf saw audition out1 Used as both Oscillator and LFO do lf saw lf saw audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lf_saw_m",
          "normalized": "DF Float-\u003eFloat-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:lf_saw_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo point average filter\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lpz1_m",
          "package": "hdf",
          "signature": "DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#lpz1_m",
          "type": "function"
        },
        "index": {
          "description": "Two point average filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lpz1_m",
          "normalized": "DF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:lpz1_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo zero fixed lowpass filter\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lpz2_m",
          "package": "hdf",
          "signature": "DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#lpz2_m",
          "type": "function"
        },
        "index": {
          "description": "Two zero fixed lowpass filter",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "lpz2_m",
          "normalized": "DF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:lpz2_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne pole filter.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;f \u003c- one_pole (n * 0.5) 0.95\n    ;audition [] (out1 f)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "one_pole_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#one_pole_m",
          "type": "function"
        },
        "index": {
          "description": "One pole filter do white noise one pole audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "one_pole_m",
          "normalized": "DF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:one_pole_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne zero filter.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;f \u003c- one_zero (n * 0.5) 0.5\n    ;audition [] (out1 f)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "one_zero_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#one_zero_m",
          "type": "function"
        },
        "index": {
          "description": "One zero filter do white noise one zero audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "one_zero_m",
          "normalized": "DF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:one_zero_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003er\u003c/em\u003e = right hand edge, \u003cem\u003eip\u003c/em\u003e = initial phase, \u003cem\u003ex\u003c/em\u003e = increment\n\u003c/p\u003e\u003cpre\u003e draw =\u003c\u003c phasor_m 9.0 (4.5::Float) 0.5\n drawM (phasor_m 9 (0::Int32) 1)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "phasor_m",
          "package": "hdf",
          "signature": "DF a -\u003e a -\u003e DF a -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#phasor_m",
          "type": "function"
        },
        "index": {
          "description": "right hand edge ip initial phase increment draw phasor Float drawM phasor Int32",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "phasor_m",
          "normalized": "DF a-\u003ea-\u003eDF a-\u003eb(DF a)",
          "package": "hdf",
          "signature": "DF a-\u003ea-\u003eDF a-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:phasor_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA two pole resonant filter with zeroes at z = +/- 1. Based on\n K. Steiglitz, \"A Note on Constant-Gain Digital Resonators\",\n \u003cem\u003eComputer Music Journal\u003c/em\u003e, vol 18, no. 4, pp. 8-10, Winter 1994.\n The reciprocal of Q is used rather than Q because it saves a divide\n operation inside the unit generator.\n\u003c/p\u003e\u003cp\u003eInputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003ef\u003c/em\u003e = resonant frequency (in\n hertz), \u003cem\u003erq\u003c/em\u003e = bandwidth ratio (reciprocal of Q);where \u003cem\u003erq\u003c/em\u003e =\n bandwidth / centerFreq.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;r \u003c- resonz (n * 0.5) 440.0 0.1\n    ;audition [] (out1 r)}\n\u003c/pre\u003e\u003cp\u003eModulate frequency\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;f \u003c- fmap (\\x -\u003e x * 3500.0 + 4500.0) (lf_saw 0.1 0.0)\n    ;r \u003c- resonz (n * 0.5) f 0.05\n    ;audition [] (out1 r)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "resonz_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#resonz_m",
          "type": "function"
        },
        "index": {
          "description": "two pole resonant filter with zeroes at Based on Steiglitz Note on Constant-Gain Digital Resonators Computer Music Journal vol no pp Winter The reciprocal of is used rather than because it saves divide operation inside the unit generator Inputs are input signal resonant frequency in hertz rq bandwidth ratio reciprocal of where rq bandwidth centerFreq do white noise resonz audition out1 Modulate frequency do white noise fmap lf saw resonz audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "resonz_m",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:resonz_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResonant low pass filter. Inputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003ef\u003c/em\u003e =\n frequency (hertz), \u003cem\u003erq\u003c/em\u003e = reciprocal of Q (resonance).\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;f \u003c- fmap (\\x -\u003e x * 40.0 + 220.0) (sin_osc 0.5 0.0)\n    ;r \u003c- rlpf n f 0.1\n    ;audition [] (out1 r)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "rlpf_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#rlpf_m",
          "type": "function"
        },
        "index": {
          "description": "Resonant low pass filter Inputs are input signal frequency hertz rq reciprocal of resonance do white noise fmap sin osc rlpf audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "rlpf_m",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:rlpf_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSine oscillator.  Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hz), \u003cem\u003eip\u003c/em\u003e =\n initial phase.\n\u003c/p\u003e\u003cpre\u003e do {o \u003c- sin_osc 440.0 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e\u003cp\u003eUsed as both Oscillator and LFO.\n\u003c/p\u003e\u003cpre\u003e do {f \u003c- sin_osc 4.0 0.0\n    ;o \u003c- sin_osc (f * 200.0 + 400.0) 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e\u003cp\u003eCancellation.\n\u003c/p\u003e\u003cpre\u003e do {o1 \u003c- sin_osc 440.0 0.0\n    ;o2 \u003c- sin_osc 440.0 pi\n    ;audition [] (out1 (o1 + o2))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "sin_osc_m",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#sin_osc_m",
          "type": "function"
        },
        "index": {
          "description": "Sine oscillator Inputs are frequency in hz ip initial phase do sin osc audition out1 Used as both Oscillator and LFO do sin osc sin osc audition out1 Cancellation do o1 sin osc o2 sin osc pi audition out1 o1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "sin_osc_m",
          "normalized": "DF Float-\u003eFloat-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:sin_osc_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond order filter section.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "sos_m",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#sos_m",
          "type": "function"
        },
        "index": {
          "description": "Second order filter section",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "sos_m",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:sos_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ephasor\u003c/a\u003e\u003c/code\u003e for table of \u003cem\u003ez\u003c/em\u003e places. \u003cem\u003eip\u003c/em\u003e is in (0,1).\n\u003c/p\u003e\u003cpre\u003e drawM (phasor 64.0 (0.0::Float) (hz_to_incr k_sample_rate 64.0 330.0))\n drawM (tbl_phasor 64 0.0 330.0)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "tbl_phasor_m",
          "package": "hdf",
          "signature": "Int -\u003e Float -\u003e DF Float -\u003e m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#tbl_phasor_m",
          "type": "function"
        },
        "index": {
          "description": "phasor for table of places ip is in drawM phasor Float hz to incr sample rate drawM tbl phasor",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "tbl_phasor_m",
          "normalized": "Int-\u003eFloat-\u003eDF Float-\u003ea(DF Float)",
          "package": "hdf",
          "signature": "Int-\u003eFloat-\u003eDF Float-\u003em(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:tbl_phasor_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle sample delay with indicated initial value.\n\u003c/p\u003e\u003cpre\u003e drawM (unit_delay_m (0::Int32) 1)\n drawM (unit_delay_m (0.0::Float) 1.0)\n\u003c/pre\u003e\u003cpre\u003e do {c \u003c- counter_m 0 1.0\n    ;d \u003c- unit_delay_m 0 c\n    ;audition_text 12 (out2 c d)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "unit_delay_m",
          "package": "hdf",
          "signature": "a -\u003e DF a -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#unit_delay_m",
          "type": "function"
        },
        "index": {
          "description": "Single sample delay with indicated initial value drawM unit delay Int32 drawM unit delay Float do counter unit delay audition text out2",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "unit_delay_m",
          "normalized": "a-\u003eDF a-\u003eb(DF a)",
          "package": "hdf",
          "signature": "a-\u003eDF a-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:unit_delay_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhite noise (-1,1).  Generates noise whose spectrum has equal\n power at all frequencies.\n\u003c/p\u003e\u003cpre\u003e do {n \u003c- white_noise_m\n    ;audition [] (out1 (n * 0.1))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "white_noise_m",
          "package": "hdf",
          "signature": "m (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen-Monadic.html#white_noise_m",
          "type": "function"
        },
        "index": {
          "description": "White noise Generates noise whose spectrum has equal power at all frequencies do white noise audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen Monadic",
          "module": "Sound.DF.Uniform.GADT.UGen.Monadic",
          "name": "white_noise_m",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen-Monadic.html#v:white_noise_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eData flow node functions, or unit generators.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "UGen",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html",
          "type": "module"
        },
        "index": {
          "description": "Data flow node functions or unit generators",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "UGen",
          "package": "hdf",
          "partial": "UGen",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5-tuple\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "T5",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#T5",
          "type": "type"
        },
        "index": {
          "description": "tuple",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "T5",
          "package": "hdf",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#t:T5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocate \u003cem\u003en\u003c/em\u003e second array, variant of \u003ccode\u003e\u003ca\u003edf_vec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_alloc_sec",
          "package": "hdf",
          "signature": "V_Id -\u003e Float -\u003e DF (Vec Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#a_alloc_sec",
          "type": "function"
        },
        "index": {
          "description": "Allocate second array variant of df vec",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_alloc_sec",
          "normalized": "V_Id-\u003eFloat-\u003eDF(Vec Float)",
          "package": "hdf",
          "signature": "V_Id-\u003eFloat-\u003eDF(Vec Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:a_alloc_sec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray delay.\n\u003c/p\u003e\u003cpre\u003e do {a \u003c- df_vec_m [0,1,2]\n    ;draw (a_delay a 0.0 0)}\n\u003c/pre\u003e\u003cpre\u003e let {f = sin_osc 0.1 0.0\n     ;o = sin_osc (f * 200.0 + 600.0) 0.0\n     ;a = df_vec (V_Id 0) (replicate 48000 0)\n     ;d = a_delay a o 24000}\n in audition [] (out2 (o * 0.1) (d * 0.05))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_delay",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Float -\u003e DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#a_delay",
          "type": "function"
        },
        "index": {
          "description": "Array delay do df vec draw delay let sin osc sin osc df vec Id replicate delay in audition out2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_delay",
          "normalized": "DF(Vec Float)-\u003eDF Float-\u003eDF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Float-\u003eDF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:a_delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray delay with \u003cem\u003ephasor\u003c/em\u003e argument for write index.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_delay_ph",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Float -\u003e DF Int32 -\u003e DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#a_delay_ph",
          "type": "function"
        },
        "index": {
          "description": "Array delay with phasor argument for write index",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_delay_ph",
          "normalized": "DF(Vec Float)-\u003eDF Float-\u003eDF Int-\u003eDF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Float-\u003eDF Int-\u003eDF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:a_delay_ph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear interpolating variant of \u003ccode\u003e\u003ca\u003ea_read\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let {i = phasor 64.0 0 (hz_to_incr k_sample_rate 64.0 330.0)\n     ;a = a_tbl_sin (V_Id 0) 64\n     ;s = a_lerp a i}\n in audition [] (out1 (s * 0.2))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_lerp",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#a_lerp",
          "type": "function"
        },
        "index": {
          "description": "Linear interpolating variant of read let phasor hz to incr sample rate tbl sin Id lerp in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_lerp",
          "normalized": "DF(Vec Float)-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:a_lerp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable lookup oscillator. \u003cem\u003eip\u003c/em\u003e is in (0,1).\n\u003c/p\u003e\u003cpre\u003e let {a = a_tbl_sin (V_Id 0) 256\n     ;f = a_osc a 4.0 0.0\n     ;o = a_osc a (f * 200.0 + 400.0) 0.0}\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e\u003cp\u003eCancellation:\n\u003c/p\u003e\u003cpre\u003e let {a = a_tbl_sin (V_Id 0) 256\n     ;o1 = a_osc a 440.0 0.0\n     ;o2 = a_osc a 440.0 0.5}\n in audition [] (out1 (o1 + o2))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_osc",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Float -\u003e Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#a_osc",
          "type": "function"
        },
        "index": {
          "description": "Table lookup oscillator ip is in let tbl sin Id osc osc in audition out1 Cancellation let tbl sin Id o1 osc o2 osc in audition out1 o1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_osc",
          "normalized": "DF(Vec Float)-\u003eDF Float-\u003eFloat-\u003eDF Float",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Float-\u003eFloat-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:a_osc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray fill function (sin).\n\u003c/p\u003e\u003cpre\u003e do {i \u003c- phasor 64 0 1\n    ;a = a_tbl_sin (V_Id 0) 64\n    ;let s = a_read a i\n     in audition [] (out1 (s * 0.2))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_tbl_sin",
          "package": "hdf",
          "signature": "V_Id -\u003e Int -\u003e DF (Vec Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#a_tbl_sin",
          "type": "function"
        },
        "index": {
          "description": "Array fill function sin do phasor tbl sin Id let read in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "a_tbl_sin",
          "normalized": "V_Id-\u003eInt-\u003eDF(Vec Float)",
          "package": "hdf",
          "signature": "V_Id-\u003eInt-\u003eDF(Vec Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:a_tbl_sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdinary biquad filter section.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "biquad",
          "package": "hdf",
          "signature": "Quinary_Op (DF Float) -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#biquad",
          "type": "function"
        },
        "index": {
          "description": "Ordinary biquad filter section",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "biquad",
          "normalized": "Quinary_Op(DF Float)-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "Quinary_Op(DF Float)-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:biquad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo zero fixed midpass filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "bpz2",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#bpz2",
          "type": "function"
        },
        "index": {
          "description": "Two zero fixed midpass filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "bpz2",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:bpz2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBrown noise (-1,1).  Generates noise whose spectrum falls off in\n power by 6 dB per octave.\n\u003c/p\u003e\u003cpre\u003e let n = brown_noise 0\n in audition [] (out1 (n * 0.1))\n\u003c/pre\u003e\u003cpre\u003e let {n = brown_noise 0\n     ;f = lin_exp n (-1.0) 1.0 64.0 9600.0\n     ;o = sin_osc f 0}\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "brown_noise",
          "package": "hdf",
          "signature": "Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#brown_noise",
          "type": "function"
        },
        "index": {
          "description": "Brown noise Generates noise whose spectrum falls off in power by dB per octave let brown noise in audition out1 let brown noise lin exp sin osc in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "brown_noise",
          "normalized": "Int-\u003eDF Float",
          "package": "hdf",
          "signature": "Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:brown_noise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eiir1\u003c/a\u003e\u003c/code\u003e brown noise function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "brown_noise_f",
          "package": "hdf",
          "signature": "Binary_Op (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#brown_noise_f",
          "type": "function"
        },
        "index": {
          "description": "iir1 brown noise function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "brown_noise_f",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:brown_noise_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo zero fixed midcut filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "brz2",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#brz2",
          "type": "function"
        },
        "index": {
          "description": "Two zero fixed midcut filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "brz2",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:brz2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-interpolating comb filter.  Inputs are: \u003cem\u003eb\u003c/em\u003e = buffer index,\n \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003edl\u003c/em\u003e = delay time, \u003cem\u003edc\u003c/em\u003e = decay time.\n\u003c/p\u003e\u003cp\u003eAll times are in seconds.  The decay time is the time for the\n echoes to decay by \u003ccode\u003e60\u003c/code\u003e decibels. If this time is negative then the\n feedback coefficient will be negative, thus emphasizing only odd\n harmonics at an octave lower.\n\u003c/p\u003e\u003cpre\u003e draw (out1 (buf_comb_n 0 0.0 0.0 0.0))\n\u003c/pre\u003e\u003cp\u003eComb used as a resonator. The resonant fundamental is equal to\n reciprocal of the delay time.\n\u003c/p\u003e\u003cpre\u003e import qualified Sound.SC3 as S\n\u003c/pre\u003e\u003cpre\u003e let {n = white_noise 0\n     ;dt = let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01\n           in f (lf_saw 0.1 0.0)\n     ;c = buf_comb_n 0 (n * 0.1) dt 0.2}\n in audition [S.b_alloc 0 48000 1] (out1 c)\n\u003c/pre\u003e\u003cp\u003eComb used as an echo.\n\u003c/p\u003e\u003cpre\u003e let {i = impulse 0.5 0.0\n     ;n = white_noise 0\n     ;e = decay (i * 0.5) 0.2\n     ;c = buf_comb_n 0 (e * n) 0.2 3.0}\n in audition [S.b_alloc 0 48000 1] (out1 c)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "buf_comb_n",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#buf_comb_n",
          "type": "function"
        },
        "index": {
          "description": "Non-interpolating comb filter Inputs are buffer index input signal dl delay time dc decay time All times are in seconds The decay time is the time for the echoes to decay by decibels If this time is negative then the feedback coefficient will be negative thus emphasizing only odd harmonics at an octave lower draw out1 buf comb Comb used as resonator The resonant fundamental is equal to reciprocal of the delay time import qualified Sound.SC3 as let white noise dt let lin exp in lf saw buf comb dt in audition S.b alloc out1 Comb used as an echo let impulse white noise decay buf comb in audition S.b alloc out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "buf_comb_n",
          "normalized": "DF Int-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:buf_comb_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuffer delay.\n\u003c/p\u003e\u003cpre\u003e draw (buf_delay 0 0.0 0)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "buf_delay",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float -\u003e DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#buf_delay",
          "type": "function"
        },
        "index": {
          "description": "Buffer delay draw buf delay",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "buf_delay",
          "normalized": "DF Int-\u003eDF Float-\u003eDF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float-\u003eDF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:buf_delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate feedback multipler in comb filter circuit given \u003cem\u003edelay\u003c/em\u003e\n and \u003cem\u003edecay\u003c/em\u003e times.\n\u003c/p\u003e\u003cpre\u003e calc_fb 0.2 3.0 == 0.6309573444801932\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "calc_fb",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#calc_fb",
          "type": "function"
        },
        "index": {
          "description": "Calculate feedback multipler in comb filter circuit given delay and decay times calc fb",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "calc_fb",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:calc_fb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstrain p in (-q,q).\n\u003c/p\u003e\u003cpre\u003e let r = -10 : -10 : [-10,-9 .. 10]\n in map (flip clip2 10) [-12,-11 .. 12] == r\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "clip2",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#clip2",
          "type": "function"
        },
        "index": {
          "description": "Constrain in let in map flip clip2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "clip2",
          "normalized": "a-\u003ea-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:clip2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf 'q \u003e= p' then 'q - p' else \u003ccode\u003eq\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "clipr",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#clipr",
          "type": "function"
        },
        "index": {
          "description": "If then else",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "clipr",
          "normalized": "DF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:clipr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray variant of \u003ccode\u003e\u003ca\u003ebuf_comb_n\u003c/a\u003e\u003c/code\u003e.  Max delay time is in seconds.\n\u003c/p\u003e\u003cpre\u003e let {n = white_noise 0\n     ;dt = let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01\n           in f (lf_saw 0.1 0.0)\n     ;c = comb_n (V_Id 0) 0.1 (n * 0.1) dt 0.2}\n in audition [] (out1 c)\n\u003c/pre\u003e\u003cpre\u003e let {i = impulse 0.5 0.0\n     ;n = white_noise 0\n     ;e = decay (i * 0.5) 0.2\n     ;c = comb_n (V_Id 0) 0.2 (e * n) 0.2 3.0}\n in audition [] (out1 c)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "comb_n",
          "package": "hdf",
          "signature": "V_Id -\u003e Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#comb_n",
          "type": "function"
        },
        "index": {
          "description": "Array variant of buf comb Max delay time is in seconds let white noise dt let lin exp in lf saw comb Id dt in audition out1 let impulse white noise decay comb Id in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "comb_n",
          "normalized": "V_Id-\u003eFloat-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "V_Id-\u003eFloat-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:comb_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e values at input.\n\u003c/p\u003e\u003cpre\u003e let n = white_noise 0\n in audition_text 12 (out2 n (count_true (trigger n)))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "count_true",
          "package": "hdf",
          "signature": "DF Bool -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#count_true",
          "type": "function"
        },
        "index": {
          "description": "Count True values at input let white noise in audition text out2 count true trigger",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "count_true",
          "normalized": "DF Bool-\u003eDF a",
          "package": "hdf",
          "signature": "DF Bool-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:count_true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCounter from indicated initial value.\n\u003c/p\u003e\u003cpre\u003e draw (counter (0::Int32) 1)\n draw (counter (0.0::Float) 1.0)\n\u003c/pre\u003e\u003cpre\u003e audition_text 10 (out1 (counter 0.0 1.0))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "counter",
          "package": "hdf",
          "signature": "a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#counter",
          "type": "function"
        },
        "index": {
          "description": "Counter from indicated initial value draw counter Int32 draw counter Float audition text out1 counter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "counter",
          "normalized": "a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:counter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponential decay. Inputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003et\u003c/em\u003e = decay\n time.  This is essentially the same as Integrator except that\n instead of supplying the coefficient directly, it is caculated from\n a 60 dB decay time. This is the time required for the integrator to\n lose 99.9 % of its value or -60dB. This is useful for exponential\n decaying envelopes triggered by impulses.\n\u003c/p\u003e\u003cp\u003eUsed as an envelope.\n\u003c/p\u003e\u003cpre\u003e let {n = brown_noise 0\n     ;f = lf_saw 0.1 0.0\n     ;i = impulse (lin_lin f (-1.0) 1.0 2.0 5.0) 0.25\n     ;e = decay i 0.2}\n in audition [] (out1 (e * n))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "decay",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#decay",
          "type": "function"
        },
        "index": {
          "description": "Exponential decay Inputs are input signal decay time This is essentially the same as Integrator except that instead of supplying the coefficient directly it is caculated from dB decay time This is the time required for the integrator to lose of its value or dB This is useful for exponential decaying envelopes triggered by impulses Used as an envelope let brown noise lf saw impulse lin lin decay in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "decay",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:decay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponential decay (equivalent to \u003ccode\u003edecay dcy - decay atk\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "decay2",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#decay2",
          "type": "function"
        },
        "index": {
          "description": "Exponential decay equivalent to decay dcy decay atk",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "decay2",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:decay2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003edt\u003c/em\u003e construct \u003ccode\u003e\u003ca\u003eiir1\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edecay\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "decay_f",
          "package": "hdf",
          "signature": "DF Float -\u003e Binary_Op (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#decay_f",
          "type": "function"
        },
        "index": {
          "description": "Given dt construct iir1 decay function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "decay_f",
          "normalized": "DF Float-\u003eBinary_Op(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eBinary_Op(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:decay_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle sample delay.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "delay1",
          "package": "hdf",
          "signature": "DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#delay1",
          "type": "function"
        },
        "index": {
          "description": "Single sample delay",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "delay1",
          "normalized": "DF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:delay1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo sample delay.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "delay2",
          "package": "hdf",
          "signature": "DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#delay2",
          "type": "function"
        },
        "index": {
          "description": "Two sample delay",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "delay2",
          "normalized": "DF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:delay2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eclip2\u003c/a\u003e\u003c/code\u003e variant.\n\u003c/p\u003e\u003cpre\u003e do {o \u003c- sin_osc 440 0\n    ;audition [] (out1 (df_clip2 (o * 2) 0.1))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "df_clip2",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#df_clip2",
          "type": "function"
        },
        "index": {
          "description": "clip2 variant do sin osc audition out1 df clip2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "df_clip2",
          "normalized": "DF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:df_clip2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle place finite impulse response filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "fir1",
          "package": "hdf",
          "signature": "a -\u003e (DF a -\u003e DF a -\u003e DF b) -\u003e DF a -\u003e DF b",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#fir1",
          "type": "function"
        },
        "index": {
          "description": "Single place finite impulse response filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "fir1",
          "normalized": "a-\u003e(DF a-\u003eDF a-\u003eDF b)-\u003eDF a-\u003eDF b",
          "package": "hdf",
          "signature": "a-\u003e(DF a-\u003eDF a-\u003eDF b)-\u003eDF a-\u003eDF b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:fir1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo place finite impulse response filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "fir2",
          "package": "hdf",
          "signature": "Ternary_Op (DF Float) -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#fir2",
          "type": "function"
        },
        "index": {
          "description": "Two place finite impulse response filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "fir2",
          "normalized": "Ternary_Op(DF Float)-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "Ternary_Op(DF Float)-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:fir2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esos\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003ehpf_c\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "hpf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#hpf",
          "type": "function"
        },
        "index": {
          "description": "sos of hpf",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "hpf",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:hpf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2nd order Butterworth high-pass filter coefficients.\n\u003c/p\u003e\u003cpre\u003e hpf_c 48000.0 (440.0 :: DF Float)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "hpf_c",
          "package": "hdf",
          "signature": "t -\u003e t -\u003e T5 t",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#hpf_c",
          "type": "function"
        },
        "index": {
          "description": "nd order Butterworth high-pass filter coefficients hpf DF Float",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "hpf_c",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "hdf",
          "signature": "t-\u003et-\u003eT t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:hpf_c"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003esr\u003c/em\u003e = sample rate, \u003cem\u003er\u003c/em\u003e = cycle (two-pi), \u003cem\u003ehz\u003c/em\u003e = frequency\n\u003c/p\u003e\u003cpre\u003e hz_to_incr 48000 128 375 == 1\n hz_to_incr 48000 two_pi 458.3662361046586 == 6e-2\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "hz_to_incr",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#hz_to_incr",
          "type": "function"
        },
        "index": {
          "description": "sr sample rate cycle two-pi hz frequency hz to incr hz to incr two pi e-2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "hz_to_incr",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:hz_to_incr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle place infinite impulse response filter with indicated\n initial value.\n\u003c/p\u003e\u003cpre\u003e import Data.Int\n import Sound.DF.Uniform.GADT\n import Sound.DF.Uniform.LL.K\n\u003c/pre\u003e\u003cpre\u003e draw (iir1 (0::Int32) (+) 1)\n draw (iir1 (0::Float) (+) 1)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "iir1",
          "package": "hdf",
          "signature": "a -\u003e Binary_Op (DF a) -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#iir1",
          "type": "function"
        },
        "index": {
          "description": "Single place infinite impulse response filter with indicated initial value import Data.Int import Sound.DF.Uniform.GADT import Sound.DF.Uniform.LL.K draw iir1 Int32 draw iir1 Float",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "iir1",
          "normalized": "a-\u003eBinary_Op(DF a)-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "a-\u003eBinary_Op(DF a)-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:iir1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo place infinite impulse response filter.  Inputs are: \u003cem\u003ef\u003c/em\u003e=\n function \u003ccode\u003e(x0 y1 y2 -\u003e y0)\u003c/code\u003e, \u003cem\u003ei\u003c/em\u003e = input signal.\n\u003c/p\u003e\u003cpre\u003e let {c1 = iir2 (\\x y1 _ -\u003e x + y1) 0.001\n     ;o1 = sin_osc (c1 + 220.0) 0\n     ;c2 = iir2 (\\x _ y2 -\u003e x + y2) 0.001\n     ;o2 = sin_osc (c2 + 220.0) 0}\n in audition [] (out2 (o1 * 0.1) (o2 * 0.1))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "iir2",
          "package": "hdf",
          "signature": "Ternary_Op (DF a) -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#iir2",
          "type": "function"
        },
        "index": {
          "description": "Two place infinite impulse response filter Inputs are function x0 y1 y2 y0 input signal let c1 iir2 y1 y1 o1 sin osc c1 c2 iir2 y2 y2 o2 sin osc c2 in audition out2 o1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "iir2",
          "normalized": "Ternary_Op(DF a)-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "Ternary_Op(DF a)-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:iir2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImpulse oscillator (non band limited).\n Outputs non band limited single sample impulses.\n Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hertz), \u003cem\u003eip\u003c/em\u003e = phase offset (0..1)\n\u003c/p\u003e\u003cpre\u003e let o = impulse 800.0 0.0\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e\u003cpre\u003e let {f = sin_osc 0.25 0.0 * 2500.0 + 2505.0\n     ;o = impulse f 0.0}\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "impulse",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#impulse",
          "type": "function"
        },
        "index": {
          "description": "Impulse oscillator non band limited Outputs non band limited single sample impulses Inputs are frequency in hertz ip phase offset let impulse in audition out1 let sin osc impulse in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "impulse",
          "normalized": "DF Float-\u003eFloat-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:impulse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003ehz_to_incr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e incr_to_hz 48000 128 1 == 375\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "incr_to_hz",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#incr_to_hz",
          "type": "function"
        },
        "index": {
          "description": "Inverse of hz to incr incr to hz",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "incr_to_hz",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:incr_to_hz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompile time sample rate constant.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "k_sample_rate",
          "package": "hdf",
          "signature": "n",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#k_sample_rate",
          "type": "function"
        },
        "index": {
          "description": "Compile time sample rate constant",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "k_sample_rate",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:k_sample_rate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple averaging filter.  Inputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003et\u003c/em\u003e =\n lag time.\n\u003c/p\u003e\u003cpre\u003e let {s = sin_osc 0.05 0.0\n     ;f = lin_lin s (-1.0) 1.0 220.0 440.0\n     ;o = sin_osc f 0.0\n     ;f' = lag f 1.0\n     ;o' = sin_osc f' 0.0}\n in audition [] (out2 (o * 0.2) (o' * 0.2))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lag",
          "type": "function"
        },
        "index": {
          "description": "Simple averaging filter Inputs are input signal lag time let sin osc lin lin sin osc lag sin osc in audition out2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNested lag filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag2",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lag2",
          "type": "function"
        },
        "index": {
          "description": "Nested lag filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag2",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lag2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwice nested lag filter.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag3",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lag3",
          "type": "function"
        },
        "index": {
          "description": "Twice nested lag filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag3",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lag3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003et\u003c/em\u003e construct \u003ccode\u003e\u003ca\u003eiir1\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elag\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag_f",
          "package": "hdf",
          "signature": "DF Float -\u003e Binary_Op (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lag_f",
          "type": "function"
        },
        "index": {
          "description": "Given construct iir1 lag function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lag_f",
          "normalized": "DF Float-\u003eBinary_Op(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eBinary_Op(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lag_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSample and hold. Holds input signal value when triggered.  Inputs\n are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003et\u003c/em\u003e = trigger.\n\u003c/p\u003e\u003cpre\u003e let {n = white_noise 0\n     ;i = impulse 9.0 0.0\n     ;l = latch n (trigger i)\n     ;o = sin_osc (l * 400.0 + 500.0) 0.0}\n in audition [] (out1 (o * 0.2))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "latch",
          "package": "hdf",
          "signature": "DF a -\u003e DF Bool -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#latch",
          "type": "function"
        },
        "index": {
          "description": "Sample and hold Holds input signal value when triggered Inputs are input signal trigger let white noise impulse latch trigger sin osc in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "latch",
          "normalized": "DF a-\u003eDF Bool-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF Bool-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:latch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elcg_i32\u003c/a\u003e\u003c/code\u003e 1103515245 12345, so in (minBound,maxBound).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lcg_glibc",
          "package": "hdf",
          "signature": "Int32 -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lcg_glibc",
          "type": "function"
        },
        "index": {
          "description": "lcg i32 so in minBound maxBound",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lcg_glibc",
          "normalized": "Int-\u003eDF Int",
          "package": "hdf",
          "signature": "Int-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lcg_glibc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e linear congruential generator, hence signed modulo of\n \u003ccode\u003e2^32\u003c/code\u003e.  Note that the state and all internal math is 32bit.\n\u003c/p\u003e\u003cp\u003eSee \u003ca\u003ehttp://en.wikipedia.org/wiki/Linear_congruential_generator\u003c/a\u003e\n for possible parameters.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lcg_i32",
          "package": "hdf",
          "signature": "Int32 -\u003e Int32 -\u003e Int32 -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lcg_i32",
          "type": "function"
        },
        "index": {
          "description": "Int32 linear congruential generator hence signed modulo of Note that the state and all internal math is bit See http en.wikipedia.org wiki Linear congruential generator for possible parameters",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lcg_i32",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eDF Int",
          "package": "hdf",
          "signature": "Int-\u003eInt-\u003eInt-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lcg_i32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-band-limited pulse oscillator. Outputs a high value of one\n and a low value of zero. Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hertz),\n \u003cem\u003eip\u003c/em\u003e = initial phase (0,1), \u003cem\u003ew\u003c/em\u003e = pulse width duty cycle (0,1).\n\u003c/p\u003e\u003cpre\u003e let {o1 = lf_pulse 3.0 0.0 0.3 * 200.0 + 200.0\n     ;o2 = lf_pulse o1 0.0 0.2 * 0.1}\n in audition [] (out1 o2)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lf_pulse",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lf_pulse",
          "type": "function"
        },
        "index": {
          "description": "Non-band-limited pulse oscillator Outputs high value of one and low value of zero Inputs are frequency in hertz ip initial phase pulse width duty cycle let o1 lf pulse o2 lf pulse o1 in audition out1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lf_pulse",
          "normalized": "DF Float-\u003eFloat-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lf_pulse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-band limited sawtooth oscillator.  Output ranges from -1 to +1.\n Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hertz), \u003cem\u003eip\u003c/em\u003e = initial phase (0,2).\n\u003c/p\u003e\u003cpre\u003e let o = lf_saw 500.0 1.0\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e\u003cp\u003eUsed as both Oscillator and LFO.\n\u003c/p\u003e\u003cpre\u003e let {f = lf_saw 4.0 0.0\n     ;o = lf_saw (f * 400.0 + 400.0) 0.0}\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lf_saw",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lf_saw",
          "type": "function"
        },
        "index": {
          "description": "Non-band limited sawtooth oscillator Output ranges from to Inputs are frequency in hertz ip initial phase let lf saw in audition out1 Used as both Oscillator and LFO let lf saw lf saw in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lf_saw",
          "normalized": "DF Float-\u003eFloat-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lf_saw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponential range conversion.\n\u003c/p\u003e\u003cpre\u003e map (\\i -\u003e lin_exp i 1 2 1 3) [1,1.1 .. 2]\n\u003c/pre\u003e\u003cpre\u003e do {s \u003c- lf_saw 0.25 0.0\n    ;o \u003c- sin_osc (lin_exp (s + 1.0) 0.0 2.0 220.0 440.0) 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lin_exp",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lin_exp",
          "type": "function"
        },
        "index": {
          "description": "Exponential range conversion map lin exp do lf saw sin osc lin exp audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lin_exp",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lin_exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear range conversion.\n\u003c/p\u003e\u003cpre\u003e map (\\i -\u003e lin_lin i (-1) 1 0 1) [-1,-0.9 .. 1.0]\n\u003c/pre\u003e\u003cpre\u003e do {s \u003c- lf_saw 1.0 0.0\n    ;o \u003c- sin_osc (lin_lin s (-1.0) 1.0 220.0 440.0) 0.0\n    ;audition [] (out1 (o * 0.1))}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lin_lin",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lin_lin",
          "type": "function"
        },
        "index": {
          "description": "Linear range conversion map lin lin do lf saw sin osc lin lin audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lin_lin",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lin_lin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLinear pan.\n\u003c/p\u003e\u003cpre\u003e map (lin_pan2 1) [-1,0,1] == [(1,0),(0.5,0.5),(0,1)]\n\u003c/pre\u003e\u003cpre\u003e do {o \u003c- sin_osc 440.0 0.0\n    ;l \u003c- sin_osc 0.5 0.0\n    ;let (p,q) = lin_pan2 (o * 0.1) l\n     in audition [] (out2 p q)}\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lin_pan2",
          "package": "hdf",
          "signature": "t -\u003e t -\u003e (t, t)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lin_pan2",
          "type": "function"
        },
        "index": {
          "description": "Linear pan map lin pan2 do sin osc sin osc let lin pan2 in audition out2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lin_pan2",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "hdf",
          "signature": "t-\u003et-\u003e(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lin_pan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo point average filter\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lpz1",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lpz1",
          "type": "function"
        },
        "index": {
          "description": "Two point average filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lpz1",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lpz1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo zero fixed lowpass filter\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lpz2",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#lpz2",
          "type": "function"
        },
        "index": {
          "description": "Two zero fixed lowpass filter",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "lpz2",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:lpz2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMidi note number to cycles per second.\n\u003c/p\u003e\u003cpre\u003e midi_cps 69 == 440\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "midi_cps",
          "package": "hdf",
          "signature": "a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#midi_cps",
          "type": "function"
        },
        "index": {
          "description": "Midi note number to cycles per second midi cps",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "midi_cps",
          "normalized": "a-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:midi_cps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply and add.\n\u003c/p\u003e\u003cpre\u003e map (mul_add 2 3) [1,2] == [5,7] && map (mul_add 3 4) [1,2] == [7,10]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "mul_add",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a -\u003e a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#mul_add",
          "type": "function"
        },
        "index": {
          "description": "Multiply and add map mul add map mul add",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "mul_add",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:mul_add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edf_not\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003epositive\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "non_positive",
          "package": "hdf",
          "signature": "DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#non_positive",
          "type": "function"
        },
        "index": {
          "description": "df not of positive",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "non_positive",
          "normalized": "DF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:non_positive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne pole filter.\n\u003c/p\u003e\u003cpre\u003e let {n = white_noise 0\n     ;f = one_pole (n * 0.5) 0.95}\n in audition [] (out1 f)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_pole",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#one_pole",
          "type": "function"
        },
        "index": {
          "description": "One pole filter let white noise one pole in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_pole",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:one_pole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003ecf\u003c/em\u003e construct \u003ccode\u003e\u003ca\u003eiir1\u003c/a\u003e\u003c/code\u003e one-pole function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_pole_f",
          "package": "hdf",
          "signature": "a -\u003e Binary_Op a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#one_pole_f",
          "type": "function"
        },
        "index": {
          "description": "Given cf construct iir1 one-pole function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_pole_f",
          "normalized": "a-\u003eBinary_Op a",
          "package": "hdf",
          "signature": "a-\u003eBinary_Op a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:one_pole_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne zero filter.\n\u003c/p\u003e\u003cpre\u003e let {n = white_noise 0\n     ;f = one_zero (n * 0.5) 0.5}\n in audition [] (out1 f)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_zero",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#one_zero",
          "type": "function"
        },
        "index": {
          "description": "One zero filter let white noise one zero in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_zero",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:one_zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003ecf\u003c/em\u003e construct \u003ccode\u003e\u003ca\u003efir1\u003c/a\u003e\u003c/code\u003e one-zero function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_zero_f",
          "package": "hdf",
          "signature": "a -\u003e Binary_Op a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#one_zero_f",
          "type": "function"
        },
        "index": {
          "description": "Given cf construct fir1 one-zero function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "one_zero_f",
          "normalized": "a-\u003eBinary_Op a",
          "package": "hdf",
          "signature": "a-\u003eBinary_Op a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:one_zero_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003er\u003c/em\u003e = right hand edge, \u003cem\u003eip\u003c/em\u003e = initial phase, \u003cem\u003ex\u003c/em\u003e = increment\n\u003c/p\u003e\u003cpre\u003e draw (phasor 9.0 (4.5::Float) 0.5)\n draw (phasor 9 (0::Int32) 1)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "phasor",
          "package": "hdf",
          "signature": "DF a -\u003e a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#phasor",
          "type": "function"
        },
        "index": {
          "description": "right hand edge ip initial phase increment draw phasor Float draw phasor Int32",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "phasor",
          "normalized": "DF a-\u003ea-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003ea-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:phasor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edf_gt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "positive",
          "package": "hdf",
          "signature": "DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#positive",
          "type": "function"
        },
        "index": {
          "description": "df gt",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "positive",
          "normalized": "DF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:positive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePulse divider at \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "pulse_divider",
          "package": "hdf",
          "signature": "DF Bool -\u003e DF Int32 -\u003e DF Int32 -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#pulse_divider",
          "type": "function"
        },
        "index": {
          "description": "Pulse divider at Bool",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "pulse_divider",
          "normalized": "DF Bool-\u003eDF Int-\u003eDF Int-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF Bool-\u003eDF Int-\u003eDF Int-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:pulse_divider"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSC3 \u003ccode\u003ePulseDivider\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let n = white_noise 0\n in audition_text 12 (out2 n (pulse_divider' n 2 1))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "pulse_divider'",
          "package": "hdf",
          "signature": "DF a -\u003e DF Int32 -\u003e DF Int32 -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#pulse_divider%27",
          "type": "function"
        },
        "index": {
          "description": "SC3 PulseDivider let white noise in audition text out2 pulse divider",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "pulse_divider'",
          "normalized": "DF a-\u003eDF Int-\u003eDF Int-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF Int-\u003eDF Int-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:pulse_divider-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ei32_to_normal_f32\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003erandi\u003c/a\u003e\u003c/code\u003e, so in (0,1).\n\u003c/p\u003e\u003cpre\u003e audition_text 24 (out1 (randf 0))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "randf",
          "package": "hdf",
          "signature": "Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#randf",
          "type": "function"
        },
        "index": {
          "description": "i32 to normal f32 of randi so in audition text out1 randf",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "randf",
          "normalized": "Int-\u003eDF Float",
          "package": "hdf",
          "signature": "Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:randf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e of 'lcg_glibc, so in (0,maxBound).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "randi",
          "package": "hdf",
          "signature": "Int32 -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#randi",
          "type": "function"
        },
        "index": {
          "description": "abs of lcg glibc so in maxBound",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "randi",
          "normalized": "Int-\u003eDF Int",
          "package": "hdf",
          "signature": "Int-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:randi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA two pole resonant filter with zeroes at z = +/- 1. Based on\n K. Steiglitz, \"A Note on Constant-Gain Digital Resonators\",\n \u003cem\u003eComputer Music Journal\u003c/em\u003e, vol 18, no. 4, pp. 8-10, Winter 1994.\n The reciprocal of Q is used rather than Q because it saves a divide\n operation inside the unit generator.\n\u003c/p\u003e\u003cp\u003eInputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003ef\u003c/em\u003e = resonant frequency (in\n hertz), \u003cem\u003erq\u003c/em\u003e = bandwidth ratio (reciprocal of Q);where \u003cem\u003erq\u003c/em\u003e =\n bandwidth / centerFreq.\n\u003c/p\u003e\u003cpre\u003e let {n = white_noise 0\n     ;r = resonz (n * 0.5) 440.0 0.1}\n in audition [] (out1 r)\n\u003c/pre\u003e\u003cp\u003eModulate frequency\n\u003c/p\u003e\u003cpre\u003e let {n = white_noise 0\n     ;f = lf_saw 0.1 0.0 * 3500.0 + 4500.0\n     ;r = resonz (n * 0.5) f 0.05}\n in audition [] (out1 r)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "resonz",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#resonz",
          "type": "function"
        },
        "index": {
          "description": "two pole resonant filter with zeroes at Based on Steiglitz Note on Constant-Gain Digital Resonators Computer Music Journal vol no pp Winter The reciprocal of is used rather than because it saves divide operation inside the unit generator Inputs are input signal resonant frequency in hertz rq bandwidth ratio reciprocal of where rq bandwidth centerFreq let white noise resonz in audition out1 Modulate frequency let white noise lf saw resonz in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "resonz",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:resonz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003ef\u003c/em\u003e and \u003cem\u003erq\u003c/em\u003e construct \u003ccode\u003e\u003ca\u003eiir2\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eresonz\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "resonz_f",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e Ternary_Op (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#resonz_f",
          "type": "function"
        },
        "index": {
          "description": "Given and rq construct iir2 resonz function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "resonz_f",
          "normalized": "DF Float-\u003eDF Float-\u003eTernary_Op(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eTernary_Op(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:resonz_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResonant low pass filter. Inputs are: \u003cem\u003ei\u003c/em\u003e = input signal, \u003cem\u003ef\u003c/em\u003e =\n frequency (hertz), \u003cem\u003erq\u003c/em\u003e = reciprocal of Q (resonance).\n\u003c/p\u003e\u003cpre\u003e let {n = white_noise 0\n     ;f = sin_osc 0.5 0.0  * 40.0 + 220.0\n     ;r = rlpf n f 0.1}\n in audition [] (out1 r)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "rlpf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#rlpf",
          "type": "function"
        },
        "index": {
          "description": "Resonant low pass filter Inputs are input signal frequency hertz rq reciprocal of resonance let white noise sin osc rlpf in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "rlpf",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:rlpf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003ef\u003c/em\u003e and \u003cem\u003er\u003c/em\u003e construct \u003ccode\u003e\u003ca\u003eiir2\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003erlpf\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "rlpf_f",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e Ternary_Op (DF Float)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#rlpf_f",
          "type": "function"
        },
        "index": {
          "description": "Given and construct iir2 rlpf function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "rlpf_f",
          "normalized": "DF Float-\u003eDF Float-\u003eTernary_Op(DF Float)",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eTernary_Op(DF Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:rlpf_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSine oscillator.  Inputs are: \u003cem\u003ef\u003c/em\u003e = frequency (in hz), \u003cem\u003eip\u003c/em\u003e =\n initial phase.\n\u003c/p\u003e\u003cpre\u003e let o = sin_osc 440.0 0.0\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e\u003cp\u003eUsed as both Oscillator and LFO.\n\u003c/p\u003e\u003cpre\u003e let {f = sin_osc 4.0 0.0\n     ;o = sin_osc (f * 200.0 + 400.0) 0.0}\n in audition [] (out1 (o * 0.1))\n\u003c/pre\u003e\u003cp\u003eCancellation.\n\u003c/p\u003e\u003cpre\u003e let {o1 = sin_osc 440.0 0.0\n     ;o2 = sin_osc 440.0 pi}\n in audition [] (out1 (o1 + o2))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "sin_osc",
          "package": "hdf",
          "signature": "DF Float -\u003e Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#sin_osc",
          "type": "function"
        },
        "index": {
          "description": "Sine oscillator Inputs are frequency in hz ip initial phase let sin osc in audition out1 Used as both Oscillator and LFO let sin osc sin osc in audition out1 Cancellation let o1 sin osc o2 sin osc pi in audition out1 o1 o2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "sin_osc",
          "normalized": "DF Float-\u003eFloat-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eFloat-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:sin_osc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond order filter section.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "sos",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#sos",
          "type": "function"
        },
        "index": {
          "description": "Second order filter section",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "sos",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:sos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven coefficients construct \u003ccode\u003e\u003ca\u003ebiquad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003esos\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "sos_f",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e Quinary_Op a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#sos_f",
          "type": "function"
        },
        "index": {
          "description": "Given coefficients construct biquad sos function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "sos_f",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eQuinary_Op a",
          "package": "hdf",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eQuinary_Op a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:sos_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuplicate a value into a tuple.\n\u003c/p\u003e\u003cpre\u003e split 1 == (1,1)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "split",
          "package": "hdf",
          "signature": "a -\u003e (a, a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#split",
          "type": "function"
        },
        "index": {
          "description": "Duplicate value into tuple split",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "split",
          "normalized": "a-\u003e(a,a)",
          "package": "hdf",
          "signature": "a-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReversed tuple constructor, (ie. \u003ccode\u003eflip (,)\u003c/code\u003e)\n\u003c/p\u003e\u003cpre\u003e swap 2 1 == (1,2)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "swap",
          "package": "hdf",
          "signature": "a -\u003e b -\u003e (b, a)",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#swap",
          "type": "function"
        },
        "index": {
          "description": "Reversed tuple constructor ie flip swap",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "swap",
          "normalized": "a-\u003eb-\u003e(b,a)",
          "package": "hdf",
          "signature": "a-\u003eb-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd guard point.\n\u003c/p\u003e\u003cpre\u003e tbl_guard [1,2,3] == [1,2,3,1]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "tbl_guard",
          "package": "hdf",
          "signature": "[a] -\u003e [a]",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#tbl_guard",
          "type": "function"
        },
        "index": {
          "description": "Add guard point tbl guard",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "tbl_guard",
          "normalized": "[a]-\u003e[a]",
          "package": "hdf",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:tbl_guard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ephasor\u003c/a\u003e\u003c/code\u003e for table of \u003cem\u003ez\u003c/em\u003e places. \u003cem\u003eip\u003c/em\u003e is in (0,1).\n\u003c/p\u003e\u003cpre\u003e draw (phasor 64.0 (0.0::Float) (hz_to_incr k_sample_rate 64.0 330.0))\n draw (tbl_phasor 64 0.0 330.0)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "tbl_phasor",
          "package": "hdf",
          "signature": "Int -\u003e Float -\u003e DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#tbl_phasor",
          "type": "function"
        },
        "index": {
          "description": "phasor for table of places ip is in draw phasor Float hz to incr sample rate draw tbl phasor",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "tbl_phasor",
          "normalized": "Int-\u003eFloat-\u003eDF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "Int-\u003eFloat-\u003eDF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:tbl_phasor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate guarded sin table.\n\u003c/p\u003e\u003cpre\u003e map (round . (* 100)) (tbl_sin 12) == [0,50,87,100,87,50,0,-50,-87,-100,-87,-50,0]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "tbl_sin",
          "package": "hdf",
          "signature": "Int -\u003e [n]",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#tbl_sin",
          "type": "function"
        },
        "index": {
          "description": "Generate guarded sin table map round tbl sin",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "tbl_sin",
          "normalized": "Int-\u003e[a]",
          "package": "hdf",
          "signature": "Int-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:tbl_sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue on non-positive to positive transition.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "trigger",
          "package": "hdf",
          "signature": "DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#trigger",
          "type": "function"
        },
        "index": {
          "description": "True on non-positive to positive transition",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "trigger",
          "normalized": "DF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:trigger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efir1\u003c/a\u003e\u003c/code\u003e \u003cem\u003etrigger\u003c/em\u003e function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "trigger_f",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#trigger_f",
          "type": "function"
        },
        "index": {
          "description": "fir1 trigger function",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "trigger_f",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:trigger_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo pi.\n\u003c/p\u003e\u003cpre\u003e two_pi == 6.283185307179586\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "two_pi",
          "package": "hdf",
          "signature": "a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#two_pi",
          "type": "function"
        },
        "index": {
          "description": "Two pi two pi",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "two_pi",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:two_pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle sample delay with indicated initial value.\n\u003c/p\u003e\u003cpre\u003e draw (unit_delay (0::Int32) 1)\n draw (unit_delay (0.0::Float) 1.0)\n\u003c/pre\u003e\u003cpre\u003e let {c = counter 0.0 1.0\n     ;d = unit_delay 0.0 c}\n in audition_text 12 (out2 c d)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "unit_delay",
          "package": "hdf",
          "signature": "a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#unit_delay",
          "type": "function"
        },
        "index": {
          "description": "Single sample delay with indicated initial value draw unit delay Int32 draw unit delay Float let counter unit delay in audition text out2",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "unit_delay",
          "normalized": "a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:unit_delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironment value, equal to \u003ccode\u003e\u003ccode\u003e\u003ca\u003etwo_pi\u003c/a\u003e\u003c/code\u003e / \u003ccode\u003e\u003ca\u003ew_sample_rate\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "w_radians_per_sample",
          "package": "hdf",
          "signature": "DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#w_radians_per_sample",
          "type": "function"
        },
        "index": {
          "description": "Environment value equal to two pi sample rate",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "w_radians_per_sample",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:w_radians_per_sample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhite noise (-1,1).  Generates noise whose spectrum has equal\n power at all frequencies.\n\u003c/p\u003e\u003cpre\u003e audition_text 24 (out1 (white_noise 0))\n\u003c/pre\u003e\u003cpre\u003e let n = white_noise 0 * 0.1\n in draw (out1 (n - n))\n\u003c/pre\u003e\u003cpre\u003e let {n = white_noise 0 * 0.1\n     ;m = white_noise 5 * 0.1}\n in audition [] (out1 (n - m))\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "white_noise",
          "package": "hdf",
          "signature": "Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-GADT-UGen.html#white_noise",
          "type": "function"
        },
        "index": {
          "description": "White noise Generates noise whose spectrum has equal power at all frequencies audition text out1 white noise let white noise in draw out1 let white noise white noise in audition out1",
          "hierarchy": "Sound DF Uniform GADT UGen",
          "module": "Sound.DF.Uniform.GADT.UGen",
          "name": "white_noise",
          "normalized": "Int-\u003eDF Float",
          "package": "hdf",
          "signature": "Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT-UGen.html#v:white_noise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTop level module for uniform rate model \u003ccode\u003ehdf\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e import Sound.DF.Uniform.GADT\n draw (lf_pulse 0.09 0.0 0.16)\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.GADT",
          "name": "GADT",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-GADT.html",
          "type": "module"
        },
        "index": {
          "description": "Top level module for uniform rate model hdf import Sound.DF.Uniform.GADT draw lf pulse",
          "hierarchy": "Sound DF Uniform GADT",
          "module": "Sound.DF.Uniform.GADT",
          "name": "GADT",
          "package": "hdf",
          "partial": "GADT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-GADT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInteraction with \u003ccode\u003ejack-dl\u003c/code\u003e, \u003ccode\u003escsynth\u003c/code\u003e and \u003ccode\u003etext-dl\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "Audition",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-Audition.html",
          "type": "module"
        },
        "index": {
          "description": "Interaction with jack-dl scsynth and text-dl",
          "hierarchy": "Sound DF Uniform LL Audition",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "Audition",
          "package": "hdf",
          "partial": "Audition",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Audition.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "audition",
          "package": "hdf",
          "signature": "[Message] -\u003e Instructions -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-LL-Audition.html#audition",
          "type": "function"
        },
        "index": {
          "description": "Audition graph after sending initialisation messages",
          "hierarchy": "Sound DF Uniform LL Audition",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "audition",
          "normalized": "[Message]-\u003eInstructions-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eInstructions-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Audition.html#v:audition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "audition_sc3",
          "package": "hdf",
          "signature": "[Message] -\u003e Instructions -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-LL-Audition.html#audition_sc3",
          "type": "function"
        },
        "index": {
          "description": "Audition graph after sending initialisation messages",
          "hierarchy": "Sound DF Uniform LL Audition",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "audition_sc3",
          "normalized": "[Message]-\u003eInstructions-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eInstructions-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Audition.html#v:audition_sc3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition at \u003ccode\u003etext-dl\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "audition_text",
          "package": "hdf",
          "signature": "Int -\u003e Instructions -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-LL-Audition.html#audition_text",
          "type": "function"
        },
        "index": {
          "description": "Audition at text-dl",
          "hierarchy": "Sound DF Uniform LL Audition",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "audition_text",
          "normalized": "Int-\u003eInstructions-\u003eIO()",
          "package": "hdf",
          "signature": "Int-\u003eInstructions-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Audition.html#v:audition_text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoad graph.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "u_cmd_g_load",
          "package": "hdf",
          "signature": "Int -\u003e Int -\u003e String -\u003e Message",
          "source": "src/Sound-DF-Uniform-LL-Audition.html#u_cmd_g_load",
          "type": "function"
        },
        "index": {
          "description": "Load graph",
          "hierarchy": "Sound DF Uniform LL Audition",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "u_cmd_g_load",
          "normalized": "Int-\u003eInt-\u003eString-\u003eMessage",
          "package": "hdf",
          "signature": "Int-\u003eInt-\u003eString-\u003eMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Audition.html#v:u_cmd_g_load"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun action with \u003ccode\u003eUDP\u003c/code\u003e link to \u003ccode\u003ejack-dl\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "with_jack_dl",
          "package": "hdf",
          "signature": "Connection UDP a -\u003e IO a",
          "source": "src/Sound-DF-Uniform-LL-Audition.html#with_jack_dl",
          "type": "function"
        },
        "index": {
          "description": "Run action with UDP link to jack-dl",
          "hierarchy": "Sound DF Uniform LL Audition",
          "module": "Sound.DF.Uniform.LL.Audition",
          "name": "with_jack_dl",
          "normalized": "Connection UDP a-\u003eIO a",
          "package": "hdf",
          "signature": "Connection UDP a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Audition.html#v:with_jack_dl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eC code generator\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "CGen",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html",
          "type": "module"
        },
        "index": {
          "description": "code generator",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "CGen",
          "package": "hdf",
          "partial": "CGen",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC function call.  (comment?,function,arguments)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_Call",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#C_Call",
          "type": "type"
        },
        "index": {
          "description": "function call comment function arguments",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_Call",
          "package": "hdf",
          "partial": "Call",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:C_Call"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC comment.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_Comment",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#C_Comment",
          "type": "type"
        },
        "index": {
          "description": "comment",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_Comment",
          "package": "hdf",
          "partial": "Comment",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:C_Comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQualified name, (structure,access,member).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_QName",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#C_QName",
          "type": "type"
        },
        "index": {
          "description": "Qualified name structure access member",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_QName",
          "package": "hdf",
          "partial": "QName",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:C_QName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC type.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_Type",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#C_Type",
          "type": "type"
        },
        "index": {
          "description": "type",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "C_Type",
          "package": "hdf",
          "partial": "Type",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:C_Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of code hosts.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Host",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Host",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of code hosts",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Host",
          "package": "hdf",
          "partial": "Host",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:Host"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of constants, list of variables, list of c-calls.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Instructions",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Instructions",
          "type": "type"
        },
        "index": {
          "description": "List of constants list of variables list of c-calls",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Instructions",
          "package": "hdf",
          "partial": "Instructions",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:Instructions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(Type,Array,Label,Initialised)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Var",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Var",
          "type": "type"
        },
        "index": {
          "description": "Type Array Label Initialised",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Var",
          "package": "hdf",
          "partial": "Var",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of variable types.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Var_Ty",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Var_Ty",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of variable types",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Var_Ty",
          "package": "hdf",
          "partial": "Var Ty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#t:Var_Ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Buf_Var",
          "package": "hdf",
          "signature": "Buf_Var Int",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Var_Ty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Buf_Var",
          "package": "hdf",
          "partial": "Buf Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:Buf_Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "JACK",
          "package": "hdf",
          "signature": "JACK",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Host",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "JACK",
          "package": "hdf",
          "partial": "JACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:JACK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Rec_Var",
          "package": "hdf",
          "signature": "Rec_Var",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Var_Ty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Rec_Var",
          "package": "hdf",
          "partial": "Rec Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:Rec_Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "SC3",
          "package": "hdf",
          "signature": "SC3",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Host",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "SC3",
          "package": "hdf",
          "partial": "SC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:SC3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Std_Var",
          "package": "hdf",
          "signature": "Std_Var",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Var_Ty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Std_Var",
          "package": "hdf",
          "partial": "Std Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:Std_Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Text",
          "package": "hdf",
          "signature": "Text",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#Host",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "Text",
          "package": "hdf",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBracket list with elements.\n\u003c/p\u003e\u003cpre\u003e bracket ('\u003c','\u003e') \"float\" == \"\u003cfloat\u003e\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "bracket",
          "package": "hdf",
          "signature": "(a, a) -\u003e [a] -\u003e [a]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#bracket",
          "type": "function"
        },
        "index": {
          "description": "Bracket list with elements bracket float float",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "bracket",
          "normalized": "(a,a)-\u003e[a]-\u003e[a]",
          "package": "hdf",
          "signature": "(a,a)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate \u003ccode\u003e\u003ca\u003eBuf_Var\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "buffer_var",
          "package": "hdf",
          "signature": "Id -\u003e Vec Float -\u003e Var",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#buffer_var",
          "type": "function"
        },
        "index": {
          "description": "Generate Buf Var from Vec",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "buffer_var",
          "normalized": "Id-\u003eVec Float-\u003eVar",
          "package": "hdf",
          "signature": "Id-\u003eVec Float-\u003eVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:buffer_var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQualify name if required.  The \u003cem\u003erf\u003c/em\u003e flag indicates if array is a\n reference or an allocation.\n\u003c/p\u003e\u003cpre\u003e c_array_qual (Vec_Port float_t 3) \"a\" True == \"*a\"\n c_array_qual (Vec_Port float_t 3) \"a\" False == \"a[3]\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_array_qual",
          "package": "hdf",
          "signature": "Maybe Int -\u003e String -\u003e Bool -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_array_qual",
          "type": "function"
        },
        "index": {
          "description": "Qualify name if required The rf flag indicates if array is reference or an allocation array qual Vec Port float True array qual Vec Port float False",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_array_qual",
          "normalized": "Maybe Int-\u003eString-\u003eBool-\u003eString",
          "package": "hdf",
          "signature": "Maybe Int-\u003eString-\u003eBool-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_array_qual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a function/macro call.\n\u003c/p\u003e\u003cpre\u003e c_call (Nothing,\"f\",[\"0\",\"1\"]) == \"f(0,1);\"\n c_call (\"c\",\"f\",[\"0\",\"1\"]) == \"f(0,1); /* c */\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_call",
          "package": "hdf",
          "signature": "C_Call -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_call",
          "type": "function"
        },
        "index": {
          "description": "Construct function macro call call Nothing call",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_call",
          "normalized": "C_Call-\u003eString",
          "package": "hdf",
          "signature": "C_Call-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_call"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd comment markers.\n\u003c/p\u003e\u003cpre\u003e c_comment \"c\" == \"/* c */\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_comment",
          "package": "hdf",
          "signature": "String -\u003e C_Comment",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_comment",
          "type": "function"
        },
        "index": {
          "description": "Add comment markers comment",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_comment",
          "normalized": "String-\u003eC_Comment",
          "package": "hdf",
          "signature": "String-\u003eC_Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ec_init_var\u003c/a\u003e\u003c/code\u003e for constant.\n\u003c/p\u003e\u003cpre\u003e c_const (0,I 1) == [\"m.n_0 = 1;\"]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_const",
          "package": "hdf",
          "signature": "(Id, K) -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_const",
          "type": "function"
        },
        "index": {
          "description": "init var for constant const m.n",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_const",
          "normalized": "(Id,K)-\u003e[String]",
          "package": "hdf",
          "signature": "(Id,K)-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise \u003ccode\u003e\u003ca\u003eC_QName\u003c/a\u003e\u003c/code\u003e to value.\n\u003c/p\u003e\u003cpre\u003e c_init_atom (\"s\",\".\",\"r\") 5 == \"s.m = 5;\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_init_atom",
          "package": "hdf",
          "signature": "C_QName -\u003e a -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_init_atom",
          "type": "function"
        },
        "index": {
          "description": "Initialise QName to value init atom s.m",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_init_atom",
          "normalized": "C_QName-\u003ea-\u003eString",
          "package": "hdf",
          "signature": "C_QName-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_init_atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise \u003ccode\u003e\u003ca\u003eC_QName\u003c/a\u003e\u003c/code\u003e to value or array.\n\u003c/p\u003e\u003cpre\u003e let {qn = (\"s\",\"-\u003e\",\"r\")\n     ;r = [\"for(int i=0;i \u003c 2;i++) {s-\u003er[i] = 0;}\",\"s-\u003er[2] = 1;\"]}\n in c_init_var qn (Right [0,0,1]) == r\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_init_var",
          "package": "hdf",
          "signature": "C_QName -\u003e Either n [n] -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_init_var",
          "type": "function"
        },
        "index": {
          "description": "Initialise QName to value or array let qn for int in init var qn Right",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_init_var",
          "normalized": "C_QName-\u003eEither a[a]-\u003e[String]",
          "package": "hdf",
          "signature": "C_QName-\u003eEither n[n]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_init_var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise \u003ccode\u003e\u003ca\u003eC_QName\u003c/a\u003e\u003c/code\u003e to array.  Generates loop code for sequences\n of equal initial values.\n\u003c/p\u003e\u003cpre\u003e c_init_vec (\"s\",\".\",\"r\") [0,1] == [\"s.r[0] = 0;\"\n                                   ,\"s.r[1] = 1;\"]\n\u003c/pre\u003e\u003cpre\u003e let r = [\"for(int i=0;i \u003c 2;i++) {s.r[i] = 0;}\"]\n in c_init_vec (\"s\",\".\",\"r\") [0,0] == r\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_init_vec",
          "package": "hdf",
          "signature": "C_QName -\u003e [a] -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_init_vec",
          "type": "function"
        },
        "index": {
          "description": "Initialise QName to array Generates loop code for sequences of equal initial values init vec s.r s.r let for int s.r in init vec",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_init_vec",
          "normalized": "C_QName-\u003e[a]-\u003e[String]",
          "package": "hdf",
          "signature": "C_QName-\u003e[a]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_init_vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eC_Type\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e c_typerep_ctype bool_t == \"bool\"\n c_typerep_ctype (typeOf (0.0::Float)) == \"float\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_typerep_ctype",
          "package": "hdf",
          "signature": "TypeRep -\u003e C_Type",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#c_typerep_ctype",
          "type": "function"
        },
        "index": {
          "description": "Translate TypeRep to Type typerep ctype bool bool typerep ctype typeOf Float float",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "c_typerep_ctype",
          "normalized": "TypeRep-\u003eC_Type",
          "package": "hdf",
          "signature": "TypeRep-\u003eC_Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:c_typerep_ctype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an identifier.\n\u003c/p\u003e\u003cpre\u003e clabel (Std_Var,0) == \"n_0\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "clabel",
          "package": "hdf",
          "signature": "(Var_Ty, Id) -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#clabel",
          "type": "function"
        },
        "index": {
          "description": "Construct an identifier clabel Std Var",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "clabel",
          "normalized": "(Var_Ty,Id)-\u003eString",
          "package": "hdf",
          "signature": "(Var_Ty,Id)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:clabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe structure for all memory stores.  In the uniform model this\n is a notational convenience only.  In a partioned model it is\n functional.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "cmem",
          "package": "hdf",
          "signature": "[Var] -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#cmem",
          "type": "function"
        },
        "index": {
          "description": "The structure for all memory stores In the uniform model this is notational convenience only In partioned model it is functional",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "cmem",
          "normalized": "[Var]-\u003e[String]",
          "package": "hdf",
          "signature": "[Var]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:cmem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate C code for graph.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "code_gen",
          "package": "hdf",
          "signature": "Host -\u003e Instructions -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#code_gen",
          "type": "function"
        },
        "index": {
          "description": "Generate code for graph",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "code_gen",
          "normalized": "Host-\u003eInstructions-\u003eString",
          "package": "hdf",
          "signature": "Host-\u003eInstructions-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:code_gen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe structure for stateful \u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "cstate",
          "package": "hdf",
          "signature": "[Var] -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#cstate",
          "type": "function"
        },
        "index": {
          "description": "The structure for stateful Var",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "cstate",
          "normalized": "[Var]-\u003e[String]",
          "package": "hdf",
          "signature": "[Var]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:cstate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate C code, write file to disk and call the GNU C compiler\n   to build shared library.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dl_gen",
          "package": "hdf",
          "signature": "FilePath -\u003e (Host, FilePath) -\u003e Instructions -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#dl_gen",
          "type": "function"
        },
        "index": {
          "description": "Generate code write file to disk and call the GNU compiler to build shared library",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dl_gen",
          "normalized": "FilePath-\u003e(Host,FilePath)-\u003eInstructions-\u003eIO()",
          "package": "hdf",
          "signature": "FilePath-\u003e(Host,FilePath)-\u003eInstructions-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:dl_gen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC declarations for DSP functions (memreq,init and step).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_fun_decl",
          "package": "hdf",
          "signature": "[String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#dsp_fun_decl",
          "type": "function"
        },
        "index": {
          "description": "declarations for DSP functions memreq init and step",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_fun_decl",
          "normalized": "[String]",
          "package": "hdf",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:dsp_fun_decl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate dsp_init function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_init",
          "package": "hdf",
          "signature": "[Var] -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#dsp_init",
          "type": "function"
        },
        "index": {
          "description": "Generate dsp init function",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_init",
          "normalized": "[Var]-\u003e[String]",
          "package": "hdf",
          "signature": "[Var]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:dsp_init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate dsp_memreq function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_memreq",
          "package": "hdf",
          "signature": "[String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#dsp_memreq",
          "type": "function"
        },
        "index": {
          "description": "Generate dsp memreq function",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_memreq",
          "normalized": "[String]",
          "package": "hdf",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:dsp_memreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate \u003ccode\u003edsp_step\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_step",
          "package": "hdf",
          "signature": "Instructions -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#dsp_step",
          "type": "function"
        },
        "index": {
          "description": "Generate dsp step function",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dsp_step",
          "normalized": "Instructions-\u003e[String]",
          "package": "hdf",
          "signature": "Instructions-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:dsp_step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntegrate, with implicit \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e dx_d [5,6] == [0,5,11]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dx_d",
          "package": "hdf",
          "signature": "[n] -\u003e [n]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#dx_d",
          "type": "function"
        },
        "index": {
          "description": "Integrate with implicit dx",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "dx_d",
          "normalized": "[a]-\u003e[a]",
          "package": "hdf",
          "signature": "[n]-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:dx_d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a C \u003ccode\u003estruct\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e, predicate determines if array\n variables are refernces or allocations.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "gen_var_struct",
          "package": "hdf",
          "signature": "String -\u003e (Var -\u003e Bool) -\u003e [Var] -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#gen_var_struct",
          "type": "function"
        },
        "index": {
          "description": "Generate struct for Var predicate determines if array variables are refernces or allocations",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "gen_var_struct",
          "normalized": "String-\u003e(Var-\u003eBool)-\u003e[Var]-\u003e[String]",
          "package": "hdf",
          "signature": "String-\u003e(Var-\u003eBool)-\u003e[Var]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:gen_var_struct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate compiler command for \u003ccode\u003e\u003ca\u003eHost\u003c/a\u003e\u003c/code\u003e given \u003ccode\u003einclude\u003c/code\u003e directory\n prefix.\n\u003c/p\u003e\u003cpre\u003e host_compiler_cmd (JACK,\"/home/rohan/opt\")\n host_compiler_cmd (SC3,\"/home/rohan/opt\")\n host_compiler_cmd (Text,\"/home/rohan/opt\")\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "host_compiler_cmd",
          "package": "hdf",
          "signature": "(Host, FilePath) -\u003e (String, [String])",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#host_compiler_cmd",
          "type": "function"
        },
        "index": {
          "description": "Generate compiler command for Host given include directory prefix host compiler cmd JACK home rohan opt host compiler cmd SC3 home rohan opt host compiler cmd Text home rohan opt",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "host_compiler_cmd",
          "normalized": "(Host,FilePath)-\u003e(String,[String])",
          "package": "hdf",
          "signature": "(Host,FilePath)-\u003e(String,[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:host_compiler_cmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHost specific form of \u003ccode\u003e\u003ca\u003edsp_fun_decl\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003eextern C\u003c/code\u003e where required).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "host_dsp_fun_decl",
          "package": "hdf",
          "signature": "Host -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#host_dsp_fun_decl",
          "type": "function"
        },
        "index": {
          "description": "Host specific form of dsp fun decl extern where required",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "host_dsp_fun_decl",
          "normalized": "Host-\u003e[String]",
          "package": "hdf",
          "signature": "Host-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:host_dsp_fun_decl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHost specific \u003ccode\u003e#include\u003c/code\u003e file.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "host_include",
          "package": "hdf",
          "signature": "Host -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#host_include",
          "type": "function"
        },
        "index": {
          "description": "Host specific include file",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "host_include",
          "normalized": "Host-\u003eString",
          "package": "hdf",
          "signature": "Host-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:host_include"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-\u003ccode\u003e\u003ca\u003eStd_Var\u003c/a\u003e\u003c/code\u003e are stateful, ie. \u003ccode\u003e\u003ca\u003eRec_Var\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eBuf_Var\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "is_stateful",
          "package": "hdf",
          "signature": "Var -\u003e Bool",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#is_stateful",
          "type": "function"
        },
        "index": {
          "description": "Non Std Var are stateful ie Rec Var and Buf Var",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "is_stateful",
          "normalized": "Var-\u003eBool",
          "package": "hdf",
          "signature": "Var-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:is_stateful"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eRec_Var\u003c/a\u003e\u003c/code\u003e are stateful and \u003cem\u003eatom\u003c/em\u003es.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "is_stateful_atom",
          "package": "hdf",
          "signature": "Var -\u003e Bool",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#is_stateful_atom",
          "type": "function"
        },
        "index": {
          "description": "Rec Var are stateful and atom",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "is_stateful_atom",
          "normalized": "Var-\u003eBool",
          "package": "hdf",
          "signature": "Var-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:is_stateful_atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate \u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eK\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "k_var",
          "package": "hdf",
          "signature": "Id -\u003e Var_Ty -\u003e K -\u003e Var",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#k_var",
          "type": "function"
        },
        "index": {
          "description": "Generate Var from",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "k_var",
          "normalized": "Id-\u003eVar_Ty-\u003eK-\u003eVar",
          "package": "hdf",
          "signature": "Id-\u003eVar_Ty-\u003eK-\u003eVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:k_var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant with \u003ccode\u003em.\u003c/code\u003e prefix.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "m_clabel",
          "package": "hdf",
          "signature": "(Var_Ty, Id) -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#m_clabel",
          "type": "function"
        },
        "index": {
          "description": "Variant with prefix",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "m_clabel",
          "normalized": "(Var_Ty,Id)-\u003eString",
          "package": "hdf",
          "signature": "(Var_Ty,Id)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:m_clabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eclabel\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eStd_Var\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e std_clabel 0 == \"n_0\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "std_clabel",
          "package": "hdf",
          "signature": "Id -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#std_clabel",
          "type": "function"
        },
        "index": {
          "description": "clabel of Std Var std clabel",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "std_clabel",
          "normalized": "Id-\u003eString",
          "package": "hdf",
          "signature": "Id-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:std_clabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e C declaration, \u003cem\u003erf\u003c/em\u003e determines \u003ccode\u003e\u003ca\u003ec_array_qual\u003c/a\u003e\u003c/code\u003e form.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_decl",
          "package": "hdf",
          "signature": "Bool -\u003e Var -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#var_decl",
          "type": "function"
        },
        "index": {
          "description": "Var declaration rf determines array qual form",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_decl",
          "normalized": "Bool-\u003eVar-\u003eString",
          "package": "hdf",
          "signature": "Bool-\u003eVar-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:var_decl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ec_init_var\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_init",
          "package": "hdf",
          "signature": "String -\u003e String -\u003e Var -\u003e [String]",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#var_init",
          "type": "function"
        },
        "index": {
          "description": "init var of Var",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_init",
          "normalized": "String-\u003eString-\u003eVar-\u003e[String]",
          "package": "hdf",
          "signature": "String-\u003eString-\u003eVar-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:var_init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e name.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_nm",
          "package": "hdf",
          "signature": "Var -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#var_nm",
          "type": "function"
        },
        "index": {
          "description": "Var name",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_nm",
          "normalized": "Var-\u003eString",
          "package": "hdf",
          "signature": "Var-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:var_nm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe character prefix for a \u003ccode\u003e\u003ca\u003eVar\u003c/a\u003e\u003c/code\u003e name is given by the \u003ccode\u003e\u003ca\u003eVar_Ty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_ty_char",
          "package": "hdf",
          "signature": "Var_Ty -\u003e Char",
          "source": "src/Sound-DF-Uniform-LL-CGen.html#var_ty_char",
          "type": "function"
        },
        "index": {
          "description": "The character prefix for Var name is given by the Var Ty",
          "hierarchy": "Sound DF Uniform LL CGen",
          "module": "Sound.DF.Uniform.LL.CGen",
          "name": "var_ty_char",
          "normalized": "Var_Ty-\u003eChar",
          "package": "hdf",
          "signature": "Var_Ty-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-CGen.html#v:var_ty_char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOSC graph commands.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.LL.Command",
          "name": "Command",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-Command.html",
          "type": "module"
        },
        "index": {
          "description": "OSC graph commands",
          "hierarchy": "Sound DF Uniform LL Command",
          "module": "Sound.DF.Uniform.LL.Command",
          "name": "Command",
          "package": "hdf",
          "partial": "Command",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Command.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoad graph.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Command",
          "name": "g_load",
          "package": "hdf",
          "signature": "String -\u003e Message",
          "source": "src/Sound-DF-Uniform-LL-Command.html#g_load",
          "type": "function"
        },
        "index": {
          "description": "Load graph",
          "hierarchy": "Sound DF Uniform LL Command",
          "module": "Sound.DF.Uniform.LL.Command",
          "name": "g_load",
          "normalized": "String-\u003eMessage",
          "package": "hdf",
          "signature": "String-\u003eMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Command.html#v:g_load"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnload graph.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Command",
          "name": "g_unload",
          "package": "hdf",
          "signature": "Message",
          "source": "src/Sound-DF-Uniform-LL-Command.html#g_unload",
          "type": "function"
        },
        "index": {
          "description": "Unload graph",
          "hierarchy": "Sound DF Uniform LL Command",
          "module": "Sound.DF.Uniform.LL.Command",
          "name": "g_unload",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Command.html#v:g_unload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eElementary dot.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "Dot",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-Dot.html",
          "type": "module"
        },
        "index": {
          "description": "Elementary dot",
          "hierarchy": "Sound DF Uniform LL Dot",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "Dot",
          "package": "hdf",
          "partial": "Dot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Dot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot notation for \u003cem\u003ekey,value\u003c/em\u003e attributes.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_attr",
          "package": "hdf",
          "signature": "[(String, String)] -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-Dot.html#dot_attr",
          "type": "function"
        },
        "index": {
          "description": "Dot notation for key value attributes",
          "hierarchy": "Sound DF Uniform LL Dot",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_attr",
          "normalized": "[(String,String)]-\u003eString",
          "package": "hdf",
          "signature": "[(String,String)]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Dot.html#v:dot_attr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot node as \u003cem\u003erecord\u003c/em\u003e.  Constant values are drawn directly into\n input ports.  The \u003cem\u003enm\u003c/em\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e has the \u003ccode\u003edf_\u003c/code\u003e prefix removed for\n printing.\n\u003c/p\u003e\u003cpre\u003e dot_rec 0 \"nm\" [] (Just float_t)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_rec",
          "package": "hdf",
          "signature": "Id -\u003e String -\u003e [Either Int K] -\u003e Maybe TypeRep -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-Dot.html#dot_rec",
          "type": "function"
        },
        "index": {
          "description": "Dot node as record Constant values are drawn directly into input ports The nm String has the df prefix removed for printing dot rec nm Just float",
          "hierarchy": "Sound DF Uniform LL Dot",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_rec",
          "normalized": "Id-\u003eString-\u003e[Either Int K]-\u003eMaybe TypeRep-\u003eString",
          "package": "hdf",
          "signature": "Id-\u003eString-\u003e[Either Int K]-\u003eMaybe TypeRep-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Dot.html#v:dot_rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant where \u003ccode\u003e\u003ca\u003enil_t\u003c/a\u003e\u003c/code\u003e indicates no output.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_rec'",
          "package": "hdf",
          "signature": "Id -\u003e String -\u003e [Either Int K] -\u003e TypeRep -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-Dot.html#dot_rec%27",
          "type": "function"
        },
        "index": {
          "description": "Variant where nil indicates no output",
          "hierarchy": "Sound DF Uniform LL Dot",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_rec'",
          "normalized": "Id-\u003eString-\u003e[Either Int K]-\u003eTypeRep-\u003eString",
          "package": "hdf",
          "signature": "Id-\u003eString-\u003e[Either Int K]-\u003eTypeRep-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Dot.html#v:dot_rec-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake arguments input for \u003ccode\u003e\u003ca\u003edot_rec\u003c/a\u003e\u003c/code\u003e from arity.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_rec_ar",
          "package": "hdf",
          "signature": "Int -\u003e [Either Int K]",
          "source": "src/Sound-DF-Uniform-LL-Dot.html#dot_rec_ar",
          "type": "function"
        },
        "index": {
          "description": "Make arguments input for dot rec from arity",
          "hierarchy": "Sound DF Uniform LL Dot",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "dot_rec_ar",
          "normalized": "Int-\u003e[Either Int K]",
          "package": "hdf",
          "signature": "Int-\u003e[Either Int K]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Dot.html#v:dot_rec_ar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap from \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e to colour name.\n\u003c/p\u003e\u003cpre\u003e map (ty_colour . Just) [int32_t,float_t] == [\"orange\",\"blue\"]\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "ty_colour",
          "package": "hdf",
          "signature": "Maybe TypeRep -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-Dot.html#ty_colour",
          "type": "function"
        },
        "index": {
          "description": "Map from TypeRep to colour name map ty colour Just int32 float orange blue",
          "hierarchy": "Sound DF Uniform LL Dot",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "ty_colour",
          "normalized": "Maybe TypeRep-\u003eString",
          "package": "hdf",
          "signature": "Maybe TypeRep-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Dot.html#v:ty_colour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft & right bracket.\n\u003c/p\u003e\u003cpre\u003e w_bracket '(' ')' \"parentheses\" == \"(parentheses)\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "w_bracket",
          "package": "hdf",
          "signature": "a -\u003e a -\u003e [a] -\u003e [a]",
          "source": "src/Sound-DF-Uniform-LL-Dot.html#w_bracket",
          "type": "function"
        },
        "index": {
          "description": "Left right bracket bracket parentheses parentheses",
          "hierarchy": "Sound DF Uniform LL Dot",
          "module": "Sound.DF.Uniform.LL.Dot",
          "name": "w_bracket",
          "normalized": "a-\u003ea-\u003e[a]-\u003e[a]",
          "package": "hdf",
          "signature": "a-\u003ea-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-Dot.html#v:w_bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eData flow wire values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-K.html",
          "type": "module"
        },
        "index": {
          "description": "Data flow wire values",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K",
          "package": "hdf",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum type for wire values.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-K.html#K",
          "type": "data"
        },
        "index": {
          "description": "Sum type for wire values",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K",
          "package": "hdf",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#t:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for values that can be lifted to \u003ccode\u003e\u003ca\u003eK\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K'",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-K.html#K%27",
          "type": "class"
        },
        "index": {
          "description": "Class for values that can be lifted to",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K'",
          "package": "hdf",
          "partial": "K'",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#t:K-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposite of \u003ccode\u003e\u003ca\u003eK_Ord\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K_Num",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-K.html#K_Num",
          "type": "class"
        },
        "index": {
          "description": "Composite of Ord and Num",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K_Num",
          "package": "hdf",
          "partial": "Num",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#t:K_Num"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposite of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eK'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K_Ord",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-K.html#K_Ord",
          "type": "class"
        },
        "index": {
          "description": "Composite of Ord and",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "K_Ord",
          "package": "hdf",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#t:K_Ord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector identifier.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "V_Id",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-K.html#V_Id",
          "type": "data"
        },
        "index": {
          "description": "Vector identifier",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "V_Id",
          "package": "hdf",
          "partial": "Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#t:V_Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector type.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "Vec",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-K.html#Vec",
          "type": "data"
        },
        "index": {
          "description": "Vector type",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "Vec",
          "package": "hdf",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#t:Vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "B",
          "package": "hdf",
          "signature": "B Bool",
          "source": "src/Sound-DF-Uniform-LL-K.html#K",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "B",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "F",
          "package": "hdf",
          "signature": "F Float",
          "source": "src/Sound-DF-Uniform-LL-K.html#K",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "F",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "I",
          "package": "hdf",
          "signature": "I Int32",
          "source": "src/Sound-DF-Uniform-LL-K.html#K",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "I",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "N",
          "package": "hdf",
          "signature": "N ()",
          "source": "src/Sound-DF-Uniform-LL-K.html#K",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "N",
          "normalized": "N()",
          "package": "hdf",
          "signature": "N()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:N"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "V",
          "package": "hdf",
          "signature": "V (Vec Float)",
          "source": "src/Sound-DF-Uniform-LL-K.html#K",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "V",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "V_Id",
          "package": "hdf",
          "signature": "V_Id Id",
          "source": "src/Sound-DF-Uniform-LL-K.html#V_Id",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "V_Id",
          "package": "hdf",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:V_Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "Vec",
          "package": "hdf",
          "signature": "Vec V_Id Int [a]",
          "source": "src/Sound-DF-Uniform-LL-K.html#Vec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "Vec",
          "normalized": "Vec V_Id Int[a]",
          "package": "hdf",
          "partial": "Vec",
          "signature": "Vec V_Id Int[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:Vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etypeOf\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "bool_t",
          "package": "hdf",
          "signature": "TypeRep",
          "source": "src/Sound-DF-Uniform-LL-K.html#bool_t",
          "type": "function"
        },
        "index": {
          "description": "typeOf of Bool",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "bool_t",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:bool_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etypeOf\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "float_t",
          "package": "hdf",
          "signature": "TypeRep",
          "source": "src/Sound-DF-Uniform-LL-K.html#float_t",
          "type": "function"
        },
        "index": {
          "description": "typeOf of Float",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "float_t",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:float_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etypeOf\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "int32_t",
          "package": "hdf",
          "signature": "TypeRep",
          "source": "src/Sound-DF-Uniform-LL-K.html#int32_t",
          "type": "function"
        },
        "index": {
          "description": "typeOf of Int32",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "int32_t",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:int32_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcise pretty printer and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003e\u003ca\u003eK\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "k_concise",
          "package": "hdf",
          "signature": "K -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-K.html#k_concise",
          "type": "function"
        },
        "index": {
          "description": "Concise pretty printer and Show instance for",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "k_concise",
          "normalized": "K-\u003eString",
          "package": "hdf",
          "signature": "K-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:k_concise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003e\u003ca\u003eK\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003emap k_typeOf [B False,I 0,F 0.0] == [bool_t,int32_t,float_t]\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "k_typeOf",
          "package": "hdf",
          "signature": "K -\u003e TypeRep",
          "source": "src/Sound-DF-Uniform-LL-K.html#k_typeOf",
          "type": "function"
        },
        "index": {
          "description": "Typeable instance for map typeOf False bool int32 float",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "k_typeOf",
          "normalized": "K-\u003eTypeRep",
          "package": "hdf",
          "partial": "Of",
          "signature": "K-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:k_typeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etypeOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e()\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "nil_t",
          "package": "hdf",
          "signature": "TypeRep",
          "source": "src/Sound-DF-Uniform-LL-K.html#nil_t",
          "type": "function"
        },
        "index": {
          "description": "typeOf",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "nil_t",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:nil_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.K",
          "name": "to_k",
          "package": "hdf",
          "signature": "a -\u003e K",
          "source": "src/Sound-DF-Uniform-LL-K.html#to_k",
          "type": "method"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "to_k",
          "normalized": "a-\u003eK",
          "package": "hdf",
          "signature": "a-\u003eK",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:to_k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcise pretty printer and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e vec_concise (Vec (V_Id 0) 1 [0]) == \"vec(0,1)\"\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "vec_concise",
          "package": "hdf",
          "signature": "Vec a -\u003e String",
          "source": "src/Sound-DF-Uniform-LL-K.html#vec_concise",
          "type": "function"
        },
        "index": {
          "description": "Concise pretty printer and Show instance for Vec vec concise Vec Id vec",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "vec_concise",
          "normalized": "Vec a-\u003eString",
          "package": "hdf",
          "signature": "Vec a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:vec_concise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etypeOf\u003c/a\u003e\u003c/code\u003e of (\u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "vec_float_t",
          "package": "hdf",
          "signature": "TypeRep",
          "source": "src/Sound-DF-Uniform-LL-K.html#vec_float_t",
          "type": "function"
        },
        "index": {
          "description": "typeOf of Vec Float",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "vec_float_t",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:vec_float_t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eV_Id\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "vec_id",
          "package": "hdf",
          "signature": "Vec t -\u003e Id",
          "source": "src/Sound-DF-Uniform-LL-K.html#vec_id",
          "type": "function"
        },
        "index": {
          "description": "Id of Id of Vec",
          "hierarchy": "Sound DF Uniform LL K",
          "module": "Sound.DF.Uniform.LL.K",
          "name": "vec_id",
          "normalized": "Vec a-\u003eId",
          "package": "hdf",
          "signature": "Vec t-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-K.html#v:vec_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnique identifiers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "UId",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-UId.html",
          "type": "module"
        },
        "index": {
          "description": "Unique identifiers",
          "hierarchy": "Sound DF Uniform LL UId",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "UId",
          "package": "hdf",
          "partial": "UId",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-UId.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentifiers are integers.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "Id",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-UId.html#Id",
          "type": "type"
        },
        "index": {
          "description": "Identifiers are integers",
          "hierarchy": "Sound DF Uniform LL UId",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "Id",
          "package": "hdf",
          "partial": "Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-UId.html#t:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of monads generating identifers\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "UId",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL-UId.html#UId",
          "type": "class"
        },
        "index": {
          "description": "Class of monads generating identifers",
          "hierarchy": "Sound DF Uniform LL UId",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "UId",
          "package": "hdf",
          "partial": "UId",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-UId.html#t:UId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate \u003cem\u003em\u003c/em\u003e \u003ccode\u003eDF\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "evalId",
          "package": "hdf",
          "signature": "State Id a -\u003e a",
          "source": "src/Sound-DF-Uniform-LL-UId.html#evalId",
          "type": "function"
        },
        "index": {
          "description": "Evaluate DF",
          "hierarchy": "Sound DF Uniform LL UId",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "evalId",
          "normalized": "State Id a-\u003ea",
          "package": "hdf",
          "partial": "Id",
          "signature": "State Id a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-UId.html#v:evalId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "generateId",
          "package": "hdf",
          "signature": "m Id",
          "source": "src/Sound-DF-Uniform-LL-UId.html#generateId",
          "type": "method"
        },
        "index": {
          "hierarchy": "Sound DF Uniform LL UId",
          "module": "Sound.DF.Uniform.LL.UId",
          "name": "generateId",
          "package": "hdf",
          "partial": "Id",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL-UId.html#v:generateId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComposite of all low-level modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.LL",
          "name": "LL",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-LL.html",
          "type": "module"
        },
        "index": {
          "description": "Composite of all low-level modules",
          "hierarchy": "Sound DF Uniform LL",
          "module": "Sound.DF.Uniform.LL",
          "name": "LL",
          "package": "hdf",
          "partial": "LL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-LL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInteraction with \u003ccode\u003ejack-dl\u003c/code\u003e, \u003ccode\u003escsynth\u003c/code\u003e and \u003ccode\u003etext-dl\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "Audition",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-PhT-Audition.html",
          "type": "module"
        },
        "index": {
          "description": "Interaction with jack-dl scsynth and text-dl",
          "hierarchy": "Sound DF Uniform PhT Audition",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "Audition",
          "package": "hdf",
          "partial": "Audition",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Audition.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "audition",
          "package": "hdf",
          "signature": "[Message] -\u003e DF () -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-PhT-Audition.html#audition",
          "type": "function"
        },
        "index": {
          "description": "Audition graph after sending initialisation messages",
          "hierarchy": "Sound DF Uniform PhT Audition",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "audition",
          "normalized": "[Message]-\u003eDF()-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eDF()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Audition.html#v:audition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "audition_sc3",
          "package": "hdf",
          "signature": "[Message] -\u003e DF () -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-PhT-Audition.html#audition_sc3",
          "type": "function"
        },
        "index": {
          "description": "Audition graph after sending initialisation messages",
          "hierarchy": "Sound DF Uniform PhT Audition",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "audition_sc3",
          "normalized": "[Message]-\u003eDF()-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eDF()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Audition.html#v:audition_sc3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition at \u003ccode\u003etext-dl\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "audition_text",
          "package": "hdf",
          "signature": "Int -\u003e DF () -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-PhT-Audition.html#audition_text",
          "type": "function"
        },
        "index": {
          "description": "Audition at text-dl",
          "hierarchy": "Sound DF Uniform PhT Audition",
          "module": "Sound.DF.Uniform.PhT.Audition",
          "name": "audition_text",
          "normalized": "Int-\u003eDF()-\u003eIO()",
          "package": "hdf",
          "signature": "Int-\u003eDF()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Audition.html#v:audition_text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGraph drawing\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.PhT.Draw",
          "name": "Draw",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-PhT-Draw.html",
          "type": "module"
        },
        "index": {
          "description": "Graph drawing",
          "hierarchy": "Sound DF Uniform PhT Draw",
          "module": "Sound.DF.Uniform.PhT.Draw",
          "name": "Draw",
          "package": "hdf",
          "partial": "Draw",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Draw.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView graph using graphviz.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Draw",
          "name": "draw",
          "package": "hdf",
          "signature": "DF a -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-PhT-Draw.html#draw",
          "type": "function"
        },
        "index": {
          "description": "View graph using graphviz",
          "hierarchy": "Sound DF Uniform PhT Draw",
          "module": "Sound.DF.Uniform.PhT.Draw",
          "name": "draw",
          "normalized": "DF a-\u003eIO()",
          "package": "hdf",
          "signature": "DF a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Draw.html#v:draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.PhT.Draw",
          "name": "drawM",
          "package": "hdf",
          "signature": "State Id (DF a) -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-PhT-Draw.html#drawM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform PhT Draw",
          "module": "Sound.DF.Uniform.PhT.Draw",
          "name": "drawM",
          "normalized": "State Id(DF a)-\u003eIO()",
          "package": "hdf",
          "signature": "State Id(DF a)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Draw.html#v:drawM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eData flow nodes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "Node",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-PhT-Node.html",
          "type": "module"
        },
        "index": {
          "description": "Data flow nodes",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "Node",
          "package": "hdf",
          "partial": "Node",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData flow node with phantom type.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "DF",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#DF",
          "type": "data"
        },
        "index": {
          "description": "Data flow node with phantom type",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "DF",
          "package": "hdf",
          "partial": "DF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#t:DF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant with phantom type.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "KT",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#KT",
          "type": "data"
        },
        "index": {
          "description": "Constant with phantom type",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "KT",
          "package": "hdf",
          "partial": "KT",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#t:KT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "DF",
          "package": "hdf",
          "signature": "DF",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "DF",
          "package": "hdf",
          "partial": "DF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:DF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "KT",
          "package": "hdf",
          "signature": "KT",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#KT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "KT",
          "package": "hdf",
          "partial": "KT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:KT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray read.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "a_read",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#a_read",
          "type": "function"
        },
        "index": {
          "description": "Array read",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "a_read",
          "normalized": "DF(Vec Float)-\u003eDF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:a_read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray write.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "a_write",
          "package": "hdf",
          "signature": "DF (Vec Float) -\u003e DF Int32 -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#a_write",
          "type": "function"
        },
        "index": {
          "description": "Array write",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "a_write",
          "normalized": "DF(Vec Float)-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF(Vec Float)-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:a_write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive unary operator with separate primitives for integral\n and floating types.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "alt_unary_operator",
          "package": "hdf",
          "signature": "(String, String) -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#alt_unary_operator",
          "type": "function"
        },
        "index": {
          "description": "Primitive unary operator with separate primitives for integral and floating types",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "alt_unary_operator",
          "normalized": "(String,String)-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "(String,String)-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:alt_unary_operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuffer read, read from buffer \u003cem\u003ep\u003c/em\u003e at index \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "b_read",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#b_read",
          "type": "function"
        },
        "index": {
          "description": "Buffer read read from buffer at index",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "b_read",
          "normalized": "DF Int-\u003eDF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:b_read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuffer write, write to buffer \u003cem\u003ep\u003c/em\u003e at index \u003cem\u003eq\u003c/em\u003e value \u003cem\u003er\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "b_write",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Int32 -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#b_write",
          "type": "function"
        },
        "index": {
          "description": "Buffer write write to buffer at index value",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "b_write",
          "normalized": "DF Int-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Int-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:b_write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive binary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "binary_operator",
          "package": "hdf",
          "signature": "String -\u003e DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#binary_operator",
          "type": "function"
        },
        "index": {
          "description": "Primitive binary operator",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "binary_operator",
          "normalized": "String-\u003eDF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "String-\u003eDF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:binary_operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive comparator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "comparison_operator",
          "package": "hdf",
          "signature": "String -\u003e DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#comparison_operator",
          "type": "function"
        },
        "index": {
          "description": "Primitive comparator",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "comparison_operator",
          "normalized": "String-\u003eDF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "String-\u003eDF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:comparison_operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle control input.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "ctl1",
          "package": "hdf",
          "signature": "DF Int32 -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#ctl1",
          "type": "function"
        },
        "index": {
          "description": "Single control input",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "ctl1",
          "normalized": "DF Int-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Int-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:ctl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_Float",
          "package": "hdf",
          "signature": "Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_Float",
          "type": "function"
        },
        "index": {
          "description": "Lift Float to DF",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_Float",
          "normalized": "Float-\u003eDF Float",
          "package": "hdf",
          "partial": "Float",
          "signature": "Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift \u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_Int32",
          "package": "hdf",
          "signature": "Int32 -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_Int32",
          "type": "function"
        },
        "index": {
          "description": "Lift Int32 to DF",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_Int32",
          "normalized": "Int-\u003eDF Int",
          "package": "hdf",
          "partial": "Int",
          "signature": "Int-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_Int32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eceilf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_ceilingf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_ceilingf",
          "type": "function"
        },
        "index": {
          "description": "ceilf",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_ceilingf",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_ceilingf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e, equal to.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_eq",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_eq",
          "type": "function"
        },
        "index": {
          "description": "equal to",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_eq",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efloorf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_floorf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_floorf",
          "type": "function"
        },
        "index": {
          "description": "floorf",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_floorf",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_floorf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003e\u003c/a\u003e\u003c/code\u003e, greater than.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_gt",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_gt",
          "type": "function"
        },
        "index": {
          "description": "greater than",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_gt",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_gt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003e=\u003c/a\u003e\u003c/code\u003e, greater than or equal to.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_gte",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_gte",
          "type": "function"
        },
        "index": {
          "description": "greater than or equal to",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_gte",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_gte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elrintf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_lrintf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Int32",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_lrintf",
          "type": "function"
        },
        "index": {
          "description": "lrintf",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_lrintf",
          "normalized": "DF Float-\u003eDF Int",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_lrintf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e, less than.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_lt",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_lt",
          "type": "function"
        },
        "index": {
          "description": "less than",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_lt",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eroundf(3)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_roundf",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_roundf",
          "type": "function"
        },
        "index": {
          "description": "roundf",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_roundf",
          "normalized": "DF Float-\u003eDF Float",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_roundf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTables have a guard point.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_tbl_size",
          "package": "hdf",
          "signature": "DF a -\u003e Maybe Int",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_tbl_size",
          "type": "function"
        },
        "index": {
          "description": "Tables have guard point",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_tbl_size",
          "normalized": "DF a-\u003eMaybe Int",
          "package": "hdf",
          "signature": "DF a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_tbl_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etypeOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_type",
          "package": "hdf",
          "signature": "DF a -\u003e TypeRep",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_type",
          "type": "function"
        },
        "index": {
          "description": "typeOf DF",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_type",
          "normalized": "DF a-\u003eTypeRep",
          "package": "hdf",
          "signature": "DF a-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_udf",
          "package": "hdf",
          "signature": "UDF",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#DF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_udf",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_udf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift list of float to \u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eVec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_vec_m",
          "package": "hdf",
          "signature": "[Float] -\u003e m (DF (Vec Float))",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#df_vec_m",
          "type": "function"
        },
        "index": {
          "description": "Lift list of float to DF Vec",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "df_vec_m",
          "normalized": "[Float]-\u003ea(DF(Vec Float))",
          "package": "hdf",
          "signature": "[Float]-\u003em(DF(Vec Float))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:df_vec_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e to constant, ie. \u003ccode\u003e\u003ca\u003eKT\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "k_Float",
          "package": "hdf",
          "signature": "Float -\u003e KT Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#k_Float",
          "type": "function"
        },
        "index": {
          "description": "Lift Float to constant ie KT of",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "k_Float",
          "normalized": "Float-\u003eKT Float",
          "package": "hdf",
          "partial": "Float",
          "signature": "Float-\u003eKT Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:k_Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift \u003ccode\u003e\u003ca\u003eInt32\u003c/a\u003e\u003c/code\u003e to constant, ie. \u003ccode\u003e\u003ca\u003eKT\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eI\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "k_Int32",
          "package": "hdf",
          "signature": "Int32 -\u003e KT Int32",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#k_Int32",
          "type": "function"
        },
        "index": {
          "description": "Lift Int32 to constant ie KT of",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "k_Int32",
          "normalized": "Int-\u003eKT Int",
          "package": "hdf",
          "partial": "Int",
          "signature": "Int-\u003eKT Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:k_Int32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA zero with unresolved type, ie. \u003ccode\u003e\u003ca\u003eKT\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eF\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "k_zero",
          "package": "hdf",
          "signature": "KT ty",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#k_zero",
          "type": "function"
        },
        "index": {
          "description": "zero with unresolved type ie KT of of",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "k_zero",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:k_zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "kt_k",
          "package": "hdf",
          "signature": "K",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#KT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "kt_k",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:kt_k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eDF\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eUDF_P\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "mk_a",
          "package": "hdf",
          "signature": "String -\u003e [DF a] -\u003e TypeRep -\u003e DF ty",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#mk_a",
          "type": "function"
        },
        "index": {
          "description": "DF of UDF",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "mk_a",
          "normalized": "String-\u003e[DF a]-\u003eTypeRep-\u003eDF b",
          "package": "hdf",
          "signature": "String-\u003e[DF a]-\u003eTypeRep-\u003eDF ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:mk_a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiple root graph.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "mrg",
          "package": "hdf",
          "signature": "DF a -\u003e DF () -\u003e DF a",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#mrg",
          "type": "function"
        },
        "index": {
          "description": "Multiple root graph",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "mrg",
          "normalized": "DF a-\u003eDF()-\u003eDF a",
          "package": "hdf",
          "signature": "DF a-\u003eDF()-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:mrg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e, less than or equal to.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "n_lte",
          "package": "hdf",
          "signature": "DF a -\u003e DF a -\u003e DF Bool",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#n_lte",
          "type": "function"
        },
        "index": {
          "description": "less than or equal to",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "n_lte",
          "normalized": "DF a-\u003eDF a-\u003eDF Bool",
          "package": "hdf",
          "signature": "DF a-\u003eDF a-\u003eDF Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:n_lte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle channel output.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "out1",
          "package": "hdf",
          "signature": "DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#out1",
          "type": "function"
        },
        "index": {
          "description": "Single channel output",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "out1",
          "normalized": "DF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:out1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo channel output.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "out2",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#out2",
          "type": "function"
        },
        "index": {
          "description": "Two channel output",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "out2",
          "normalized": "DF Float-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:out2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThree channel output.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "out3",
          "package": "hdf",
          "signature": "DF Float -\u003e DF Float -\u003e DF Float -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#out3",
          "type": "function"
        },
        "index": {
          "description": "Three channel output",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "out3",
          "normalized": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF()",
          "package": "hdf",
          "signature": "DF Float-\u003eDF Float-\u003eDF Float-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:out3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic variant of rec_r.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "rec",
          "package": "hdf",
          "signature": "KT a -\u003e (DF a -\u003e (DF a, DF a)) -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#rec",
          "type": "function"
        },
        "index": {
          "description": "Monadic variant of rec",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "rec",
          "normalized": "KT a-\u003e(DF a-\u003e(DF a,DF a))-\u003eb(DF a)",
          "package": "hdf",
          "signature": "KT a-\u003e(DF a-\u003e(DF a,DF a))-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntroduce backward arc with implicit unit delay.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "rec_r",
          "package": "hdf",
          "signature": "R_Id -\u003e KT a -\u003e (DF a -\u003e (DF a, DF a)) -\u003e DF a",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#rec_r",
          "type": "function"
        },
        "index": {
          "description": "Introduce backward arc with implicit unit delay",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "rec_r",
          "normalized": "R_Id-\u003eKT a-\u003e(DF a-\u003e(DF a,DF a))-\u003eDF a",
          "package": "hdf",
          "signature": "R_Id-\u003eKT a-\u003e(DF a-\u003e(DF a,DF a))-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:rec_r"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant or rec with monadic action in backward arc.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "recm",
          "package": "hdf",
          "signature": "KT a -\u003e (DF a -\u003e m (DF a, DF a)) -\u003e m (DF a)",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#recm",
          "type": "function"
        },
        "index": {
          "description": "Variant or rec with monadic action in backward arc",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "recm",
          "normalized": "KT a-\u003e(DF a-\u003eb(DF a,DF a))-\u003eb(DF a)",
          "package": "hdf",
          "signature": "KT a-\u003e(DF a-\u003em(DF a,DF a))-\u003em(DF a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:recm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003cem\u003ep\u003c/em\u003e then \u003cem\u003eq\u003c/em\u003e else \u003cem\u003er\u003c/em\u003e.  \u003cem\u003ep\u003c/em\u003e must have type bool, and \u003cem\u003eq\u003c/em\u003e\n and \u003cem\u003er\u003c/em\u003e must have equal types.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "select2",
          "package": "hdf",
          "signature": "DF Bool -\u003e DF a -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#select2",
          "type": "function"
        },
        "index": {
          "description": "If then else must have type bool and and must have equal types",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "select2",
          "normalized": "DF Bool-\u003eDF a-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "DF Bool-\u003eDF a-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:select2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive sink.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "sink_node",
          "package": "hdf",
          "signature": "String -\u003e [DF a] -\u003e DF ()",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#sink_node",
          "type": "function"
        },
        "index": {
          "description": "Primitive sink",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "sink_node",
          "normalized": "String-\u003e[DF a]-\u003eDF()",
          "package": "hdf",
          "signature": "String-\u003e[DF a]-\u003eDF()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:sink_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive unary operator.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "unary_operator",
          "package": "hdf",
          "signature": "String -\u003e DF a -\u003e DF a",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#unary_operator",
          "type": "function"
        },
        "index": {
          "description": "Primitive unary operator",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "unary_operator",
          "normalized": "String-\u003eDF a-\u003eDF a",
          "package": "hdf",
          "signature": "String-\u003eDF a-\u003eDF a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:unary_operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperating sample rate.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "w_sample_rate",
          "package": "hdf",
          "signature": "DF Float",
          "source": "src/Sound-DF-Uniform-PhT-Node.html#w_sample_rate",
          "type": "function"
        },
        "index": {
          "description": "Operating sample rate",
          "hierarchy": "Sound DF Uniform PhT Node",
          "module": "Sound.DF.Uniform.PhT.Node",
          "name": "w_sample_rate",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT-Node.html#v:w_sample_rate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTop level module for \u003cem\u003ePhT\u003c/em\u003e uniform rate model \u003ccode\u003ehdf\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.PhT",
          "name": "PhT",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-PhT.html",
          "type": "module"
        },
        "index": {
          "description": "Top level module for PhT uniform rate model hdf",
          "hierarchy": "Sound DF Uniform PhT",
          "module": "Sound.DF.Uniform.PhT",
          "name": "PhT",
          "package": "hdf",
          "partial": "Ph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-PhT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUntyped \u003cem\u003eDF\u003c/em\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html",
          "type": "module"
        },
        "index": {
          "description": "Untyped DF",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF",
          "package": "hdf",
          "partial": "UDF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant graph form associating the list of \u003cem\u003ein\u003c/em\u003e edges with each\n \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Analysis",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Analysis",
          "type": "type"
        },
        "index": {
          "description": "variant graph form associating the list of in edges with each Node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Analysis",
          "package": "hdf",
          "partial": "Analysis",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Analysis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdge from left hand side node to right hand side port.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Edge",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Edge",
          "type": "type"
        },
        "index": {
          "description": "Edge from left hand side node to right hand side port",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Edge",
          "package": "hdf",
          "partial": "Edge",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of \u003ccode\u003e\u003ca\u003eEdge\u003c/a\u003e\u003c/code\u003e types.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Edge_Ty",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Edge_Ty",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of Edge types",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Edge_Ty",
          "package": "hdf",
          "partial": "Edge Ty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Edge_Ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFGL graph with \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e label.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Gr",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Gr",
          "type": "type"
        },
        "index": {
          "description": "FGL graph with UDF label",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Gr",
          "package": "hdf",
          "partial": "Gr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Gr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFGL graph with pretty-printed \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e label.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Gr'",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Gr%27",
          "type": "type"
        },
        "index": {
          "description": "FGL graph with pretty-printed UDF label",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Gr'",
          "package": "hdf",
          "partial": "Gr'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Gr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA graph is a list of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003es and \u003ccode\u003e\u003ca\u003eEdge\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Graph",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Graph",
          "type": "type"
        },
        "index": {
          "description": "graph is list of Node and Edge",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Graph",
          "package": "hdf",
          "partial": "Graph",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA node is a \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e with associated \u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Node",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Node",
          "type": "type"
        },
        "index": {
          "description": "node is UDF with associated Id",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Node",
          "package": "hdf",
          "partial": "Node",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndex for input port.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Port_Index",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#Port_Index",
          "type": "type"
        },
        "index": {
          "description": "Index for input port",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Port_Index",
          "package": "hdf",
          "partial": "Port Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:Port_Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecursion identifier.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "R_Id",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#R_Id",
          "type": "data"
        },
        "index": {
          "description": "Recursion identifier",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "R_Id",
          "package": "hdf",
          "partial": "Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:R_Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUn-typed data-flow node.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF",
          "package": "hdf",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "data"
        },
        "index": {
          "description": "Un-typed data-flow node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF",
          "package": "hdf",
          "partial": "UDF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#t:UDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdge \u003cem\u003eto\u003c/em\u003e recRd node (from recWr)\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Implicit_Edge",
          "package": "hdf",
          "signature": "Implicit_Edge Int",
          "source": "src/Sound-DF-Uniform-UDF.html#Edge_Ty",
          "type": "function"
        },
        "index": {
          "description": "Edge to recRd node from recWr",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Implicit_Edge",
          "package": "hdf",
          "partial": "Implicit Edge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:Implicit_Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "Normal_Edge",
          "package": "hdf",
          "signature": "Normal_Edge",
          "source": "src/Sound-DF-Uniform-UDF.html#Edge_Ty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Normal_Edge",
          "package": "hdf",
          "partial": "Normal Edge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:Normal_Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "R_Id",
          "package": "hdf",
          "signature": "R_Id Id",
          "source": "src/Sound-DF-Uniform-UDF.html#R_Id",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "R_Id",
          "package": "hdf",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:R_Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdge \u003cem\u003efrom\u003c/em\u003e recRd node\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Rec_Rd_Edge",
          "package": "hdf",
          "signature": "Rec_Rd_Edge Id",
          "source": "src/Sound-DF-Uniform-UDF.html#Edge_Ty",
          "type": "function"
        },
        "index": {
          "description": "Edge from recRd node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Rec_Rd_Edge",
          "package": "hdf",
          "partial": "Rec Rd Edge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:Rec_Rd_Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdge \u003cem\u003eto\u003c/em\u003e recWr node\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Rec_Wr_Edge",
          "package": "hdf",
          "signature": "Rec_Wr_Edge Id",
          "source": "src/Sound-DF-Uniform-UDF.html#Edge_Ty",
          "type": "function"
        },
        "index": {
          "description": "Edge to recWr node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "Rec_Wr_Edge",
          "package": "hdf",
          "partial": "Rec Wr Edge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:Rec_Wr_Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_A",
          "package": "hdf",
          "signature": "UDF_A",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_A",
          "package": "hdf",
          "partial": "UDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:UDF_A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_K",
          "package": "hdf",
          "signature": "UDF_K",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_K",
          "package": "hdf",
          "partial": "UDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:UDF_K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_M",
          "package": "hdf",
          "signature": "UDF_M UDF UDF",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_M",
          "package": "hdf",
          "partial": "UDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:UDF_M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_P",
          "package": "hdf",
          "signature": "UDF_P String TypeRep [UDF]",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_P",
          "normalized": "UDF_P String TypeRep[UDF]",
          "package": "hdf",
          "partial": "UDF",
          "signature": "UDF_P String TypeRep[UDF]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:UDF_P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_R",
          "package": "hdf",
          "signature": "UDF_R R_Id (Either K (UDF, UDF))",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "UDF_R",
          "normalized": "UDF_R R_Id(Either K(UDF,UDF))",
          "package": "hdf",
          "partial": "UDF",
          "signature": "UDF_R R_Id(Either K(UDF,UDF))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:UDF_R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabel nodes and list incoming edges.  Multiple-root nodes are\n erased.\n\u003c/p\u003e\u003cpre\u003e analyse (udf_elem c)\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "analyse",
          "package": "hdf",
          "signature": "[UDF] -\u003e Analysis",
          "source": "src/Sound-DF-Uniform-UDF.html#analyse",
          "type": "function"
        },
        "index": {
          "description": "Label nodes and list incoming edges Multiple-root nodes are erased analyse udf elem",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "analyse",
          "normalized": "[UDF]-\u003eAnalysis",
          "package": "hdf",
          "signature": "[UDF]-\u003eAnalysis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:analyse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "audition",
          "package": "hdf",
          "signature": "[Message] -\u003e UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#audition",
          "type": "function"
        },
        "index": {
          "description": "Audition graph after sending initialisation messages",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "audition",
          "normalized": "[Message]-\u003eUDF-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eUDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:audition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition graph after sending initialisation messages.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "audition_sc3",
          "package": "hdf",
          "signature": "[Message] -\u003e UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#audition_sc3",
          "type": "function"
        },
        "index": {
          "description": "Audition graph after sending initialisation messages",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "audition_sc3",
          "normalized": "[Message]-\u003eUDF-\u003eIO()",
          "package": "hdf",
          "signature": "[Message]-\u003eUDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:audition_sc3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAudition at \u003ccode\u003etext-dl\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "audition_text",
          "package": "hdf",
          "signature": "Int -\u003e UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#audition_text",
          "type": "function"
        },
        "index": {
          "description": "Audition at text-dl",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "audition_text",
          "normalized": "Int-\u003eUDF-\u003eIO()",
          "package": "hdf",
          "signature": "Int-\u003eUDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:audition_text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake \u003ccode\u003e\u003ca\u003edot_rec\u003c/a\u003e\u003c/code\u003e \u003cem\u003earguments\u003c/em\u003e input.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_ar",
          "package": "hdf",
          "signature": "[UDF] -\u003e [Either Int K]",
          "source": "src/Sound-DF-Uniform-UDF.html#dot_ar",
          "type": "function"
        },
        "index": {
          "description": "Make dot rec arguments input",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_ar",
          "normalized": "[UDF]-\u003e[Either Int K]",
          "package": "hdf",
          "signature": "[UDF]-\u003e[Either Int K]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:dot_ar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView dot graph.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_draw",
          "package": "hdf",
          "signature": "String -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#dot_draw",
          "type": "function"
        },
        "index": {
          "description": "View dot graph",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_draw",
          "normalized": "String-\u003eIO()",
          "package": "hdf",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:dot_draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot notation of \u003ccode\u003e\u003ca\u003eEdge\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_edge",
          "package": "hdf",
          "signature": "Edge -\u003e String",
          "source": "src/Sound-DF-Uniform-UDF.html#dot_edge",
          "type": "function"
        },
        "index": {
          "description": "Dot notation of Edge",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_edge",
          "normalized": "Edge-\u003eString",
          "package": "hdf",
          "signature": "Edge-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:dot_edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot notation of \u003ccode\u003e\u003ca\u003eGraph\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_graph",
          "package": "hdf",
          "signature": "Graph -\u003e [String]",
          "source": "src/Sound-DF-Uniform-UDF.html#dot_graph",
          "type": "function"
        },
        "index": {
          "description": "Dot notation of Graph",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_graph",
          "normalized": "Graph-\u003e[String]",
          "package": "hdf",
          "signature": "Graph-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:dot_graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot notation of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_node",
          "package": "hdf",
          "signature": "Node -\u003e String",
          "source": "src/Sound-DF-Uniform-UDF.html#dot_node",
          "type": "function"
        },
        "index": {
          "description": "Dot notation of Node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "dot_node",
          "normalized": "Node-\u003eString",
          "package": "hdf",
          "signature": "Node-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:dot_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw graph, transformed by \u003ccode\u003e\u003ca\u003evgraph_direct\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "draw",
          "package": "hdf",
          "signature": "UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#draw",
          "type": "function"
        },
        "index": {
          "description": "Draw graph transformed by vgraph direct",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "draw",
          "normalized": "UDF-\u003eIO()",
          "package": "hdf",
          "signature": "UDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw graph, transformed by \u003ccode\u003e\u003ca\u003evgraph_impl\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "draw'",
          "package": "hdf",
          "signature": "UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#draw%27",
          "type": "function"
        },
        "index": {
          "description": "Draw graph transformed by vgraph impl",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "draw'",
          "normalized": "UDF-\u003eIO()",
          "package": "hdf",
          "signature": "UDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:draw-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdges are coloured according to their type.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "edge_ty_colour",
          "package": "hdf",
          "signature": "Edge_Ty -\u003e String",
          "source": "src/Sound-DF-Uniform-UDF.html#edge_ty_colour",
          "type": "function"
        },
        "index": {
          "description": "Edges are coloured according to their type",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "edge_ty_colour",
          "normalized": "Edge_Ty-\u003eString",
          "package": "hdf",
          "signature": "Edge_Ty-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:edge_ty_colour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty printer for \u003ccode\u003e\u003ca\u003eEdge_Ty\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "edge_ty_concise",
          "package": "hdf",
          "signature": "Edge_Ty -\u003e String",
          "source": "src/Sound-DF-Uniform-UDF.html#edge_ty_concise",
          "type": "function"
        },
        "index": {
          "description": "Pretty printer for Edge Ty and Show instance",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "edge_ty_concise",
          "normalized": "Edge_Ty-\u003eString",
          "package": "hdf",
          "signature": "Edge_Ty-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:edge_ty_concise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList \u003cem\u003eincoming\u003c/em\u003e node edges.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "edges",
          "package": "hdf",
          "signature": "[Node] -\u003e UDF -\u003e [Edge]",
          "source": "src/Sound-DF-Uniform-UDF.html#edges",
          "type": "function"
        },
        "index": {
          "description": "List incoming node edges",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "edges",
          "normalized": "[Node]-\u003eUDF-\u003e[Edge]",
          "package": "hdf",
          "signature": "[Node]-\u003eUDF-\u003e[Edge]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003efind_in_edge_m\u003c/a\u003e\u003c/code\u003e that \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "find_in_edge",
          "package": "hdf",
          "signature": "[Edge] -\u003e (Id, Port_Index) -\u003e Edge",
          "source": "src/Sound-DF-Uniform-UDF.html#find_in_edge",
          "type": "function"
        },
        "index": {
          "description": "Variant of find in edge that error",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "find_in_edge",
          "normalized": "[Edge]-\u003e(Id,Port_Index)-\u003eEdge",
          "package": "hdf",
          "signature": "[Edge]-\u003e(Id,Port_Index)-\u003eEdge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:find_in_edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind edge with indicated right hand side port.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "find_in_edge_m",
          "package": "hdf",
          "signature": "[Edge] -\u003e (Id, Port_Index) -\u003e Maybe Edge",
          "source": "src/Sound-DF-Uniform-UDF.html#find_in_edge_m",
          "type": "function"
        },
        "index": {
          "description": "Find edge with indicated right hand side port",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "find_in_edge_m",
          "normalized": "[Edge]-\u003e(Id,Port_Index)-\u003eMaybe Edge",
          "package": "hdf",
          "signature": "[Edge]-\u003e(Id,Port_Index)-\u003eMaybe Edge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:find_in_edge_m"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake \u003ccode\u003edot\u003c/code\u003e rendering of graph at \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e, via \u003ccode\u003e\u003ca\u003evgraph_direct\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_dot",
          "package": "hdf",
          "signature": "UDF -\u003e String",
          "source": "src/Sound-DF-Uniform-UDF.html#gr_dot",
          "type": "function"
        },
        "index": {
          "description": "Make dot rendering of graph at Node via vgraph direct",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_dot",
          "normalized": "UDF-\u003eString",
          "package": "hdf",
          "signature": "UDF-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:gr_dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake \u003ccode\u003edot\u003c/code\u003e rendering of graph at \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e, via \u003ccode\u003e\u003ca\u003evgraph_impl\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_dot'",
          "package": "hdf",
          "signature": "UDF -\u003e String",
          "source": "src/Sound-DF-Uniform-UDF.html#gr_dot%27",
          "type": "function"
        },
        "index": {
          "description": "Make dot rendering of graph at Node via vgraph impl",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_dot'",
          "normalized": "UDF-\u003eString",
          "package": "hdf",
          "signature": "UDF-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:gr_dot-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw graph, via \u003ccode\u003e\u003ca\u003egr_dot\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_draw",
          "package": "hdf",
          "signature": "UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#gr_draw",
          "type": "function"
        },
        "index": {
          "description": "Draw graph via gr dot",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_draw",
          "normalized": "UDF-\u003eIO()",
          "package": "hdf",
          "signature": "UDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:gr_draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw graph, via \u003ccode\u003e\u003ca\u003egr_dot'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_draw'",
          "package": "hdf",
          "signature": "UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#gr_draw%27",
          "type": "function"
        },
        "index": {
          "description": "Draw graph via gr dot",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "gr_draw'",
          "normalized": "UDF-\u003eIO()",
          "package": "hdf",
          "signature": "UDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:gr_draw-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate graph (node list and edge list).\n\u003c/p\u003e\u003cpre\u003e import Sound.DF.Uniform.GADT\n import qualified Sound.DF.Uniform.UDF as U\n\u003c/pre\u003e\u003cpre\u003e let g = iir1 (0.0::Float) (+) 1\n let c = df_erase g\n\u003c/pre\u003e\u003cpre\u003e map U.udf_concise (U.udf_elem c)\n \u003e [recWr,df_add:Float,1.0,recRd:0.0,df_add:Float,1.0,recRd:0.0]\n\u003c/pre\u003e\u003cpre\u003e U.vgraph_direct (U.graph c)\n \u003e ([(1,wR_1),(2,df_add:Float),(3,1.0),(4,rR_1:0.0)]\n \u003e ,[(2,1,0),(3,2,0),(4,2,1)])\n\u003c/pre\u003e\u003cpre\u003e U.draw c\n\u003c/pre\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "graph",
          "package": "hdf",
          "signature": "UDF -\u003e Graph",
          "source": "src/Sound-DF-Uniform-UDF.html#graph",
          "type": "function"
        },
        "index": {
          "description": "Generate graph node list and edge list import Sound.DF.Uniform.GADT import qualified Sound.DF.Uniform.UDF as let iir1 Float let df erase map U.udf concise U.udf elem recWr df add Float recRd df add Float recRd U.vgraph direct U.graph wR df add Float rR U.draw",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "graph",
          "normalized": "UDF-\u003eGraph",
          "package": "hdf",
          "signature": "UDF-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit edge from wR to rW.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "implicit_edge",
          "package": "hdf",
          "signature": "[Node] -\u003e Node -\u003e Maybe Edge",
          "source": "src/Sound-DF-Uniform-UDF.html#implicit_edge",
          "type": "function"
        },
        "index": {
          "description": "Implicit edge from wR to rW",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "implicit_edge",
          "normalized": "[Node]-\u003eNode-\u003eMaybe Edge",
          "package": "hdf",
          "signature": "[Node]-\u003eNode-\u003eMaybe Edge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:implicit_edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform \u003ccode\u003e\u003ca\u003eRec_Rd_Edge\u003c/a\u003e\u003c/code\u003e to resolved \u003ccode\u003e\u003ca\u003eImplicit_Edge\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "implicit_edge'",
          "package": "hdf",
          "signature": "[Edge] -\u003e Edge -\u003e Maybe Edge",
          "source": "src/Sound-DF-Uniform-UDF.html#implicit_edge%27",
          "type": "function"
        },
        "index": {
          "description": "Transform Rec Rd Edge to resolved Implicit Edge",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "implicit_edge'",
          "normalized": "[Edge]-\u003eEdge-\u003eMaybe Edge",
          "package": "hdf",
          "signature": "[Edge]-\u003eEdge-\u003eMaybe Edge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:implicit_edge-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eUDF_K\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "is_k_node",
          "package": "hdf",
          "signature": "Node -\u003e Bool",
          "source": "src/Sound-DF-Uniform-UDF.html#is_k_node",
          "type": "function"
        },
        "index": {
          "description": "Is Node UDF",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "is_k_node",
          "normalized": "Node-\u003eBool",
          "package": "hdf",
          "signature": "Node-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:is_k_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eEdge\u003c/a\u003e\u003c/code\u003e is orphaned if it refers to a \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e that is not in the\n node list.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "is_orphan_edge",
          "package": "hdf",
          "signature": "[Node] -\u003e Edge -\u003e Bool",
          "source": "src/Sound-DF-Uniform-UDF.html#is_orphan_edge",
          "type": "function"
        },
        "index": {
          "description": "An Edge is orphaned if it refers to Node that is not in the node list",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "is_orphan_edge",
          "normalized": "[Node]-\u003eEdge-\u003eBool",
          "package": "hdf",
          "signature": "[Node]-\u003eEdge-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:is_orphan_edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eUDF_R\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "is_rec_node",
          "package": "hdf",
          "signature": "Node -\u003e Bool",
          "source": "src/Sound-DF-Uniform-UDF.html#is_rec_node",
          "type": "function"
        },
        "index": {
          "description": "Is Node UDF",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "is_rec_node",
          "normalized": "Node-\u003eBool",
          "package": "hdf",
          "signature": "Node-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:is_rec_node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant nodes.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "k_nodes",
          "package": "hdf",
          "signature": "[Node] -\u003e [(Id, K)]",
          "source": "src/Sound-DF-Uniform-UDF.html#k_nodes",
          "type": "function"
        },
        "index": {
          "description": "Constant nodes",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "k_nodes",
          "normalized": "[Node]-\u003e[(Id,K)]",
          "package": "hdf",
          "signature": "[Node]-\u003e[(Id,K)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:k_nodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead label of node.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "label",
          "package": "hdf",
          "signature": "[Node] -\u003e UDF -\u003e Id",
          "source": "src/Sound-DF-Uniform-UDF.html#label",
          "type": "function"
        },
        "index": {
          "description": "Read label of node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "label",
          "normalized": "[Node]-\u003eUDF-\u003eId",
          "package": "hdf",
          "signature": "[Node]-\u003eUDF-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e form of \u003ccode\u003e\u003ca\u003eUDF_R\u003c/a\u003e\u003c/code\u003e with indicated \u003ccode\u003e\u003ca\u003eR_Id\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "match_rec",
          "package": "hdf",
          "signature": "R_Id -\u003e Node -\u003e Bool",
          "source": "src/Sound-DF-Uniform-UDF.html#match_rec",
          "type": "function"
        },
        "index": {
          "description": "True if Node is Right form of UDF with indicated Id",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "match_rec",
          "normalized": "R_Id-\u003eNode-\u003eBool",
          "package": "hdf",
          "signature": "R_Id-\u003eNode-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:match_rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossible c-call code statement.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_c_call",
          "package": "hdf",
          "signature": "(Node, [Edge]) -\u003e Maybe C_Call",
          "source": "src/Sound-DF-Uniform-UDF.html#node_c_call",
          "type": "function"
        },
        "index": {
          "description": "Possible c-call code statement",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_c_call",
          "normalized": "(Node,[Edge])-\u003eMaybe C_Call",
          "package": "hdf",
          "signature": "(Node,[Edge])-\u003eMaybe C_Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:node_c_call"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eId\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_id",
          "package": "hdf",
          "signature": "Node -\u003e Id",
          "source": "src/Sound-DF-Uniform-UDF.html#node_id",
          "type": "function"
        },
        "index": {
          "description": "Id of Node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_id",
          "normalized": "Node-\u003eId",
          "package": "hdf",
          "signature": "Node-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:node_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_udf",
          "package": "hdf",
          "signature": "Node -\u003e UDF",
          "source": "src/Sound-DF-Uniform-UDF.html#node_udf",
          "type": "function"
        },
        "index": {
          "description": "UDF of Node",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_udf",
          "normalized": "Node-\u003eUDF",
          "package": "hdf",
          "signature": "Node-\u003eUDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:node_udf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of required variable declarations.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_vars",
          "package": "hdf",
          "signature": "Node -\u003e [Var]",
          "source": "src/Sound-DF-Uniform-UDF.html#node_vars",
          "type": "function"
        },
        "index": {
          "description": "List of required variable declarations",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "node_vars",
          "normalized": "Node-\u003e[Var]",
          "package": "hdf",
          "signature": "Node-\u003e[Var]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:node_vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrace in edges until arrival at a \u003ccode\u003e\u003ca\u003eRec_Wr_Edge\u003c/a\u003e\u003c/code\u003e that is not\n proceeded by an \u003ccode\u003e\u003ca\u003eImplicit_Edge\u003c/a\u003e\u003c/code\u003e.  This traces the \u003cem\u003edepth\u003c/em\u003e of the\n chain, however that is not currently drawn.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "solve_rec_edge",
          "package": "hdf",
          "signature": "Int -\u003e [Edge] -\u003e (Id, Port_Index) -\u003e (Int, Id)",
          "source": "src/Sound-DF-Uniform-UDF.html#solve_rec_edge",
          "type": "function"
        },
        "index": {
          "description": "Trace in edges until arrival at Rec Wr Edge that is not proceeded by an Implicit Edge This traces the depth of the chain however that is not currently drawn",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "solve_rec_edge",
          "normalized": "Int-\u003e[Edge]-\u003e(Id,Port_Index)-\u003e(Int,Id)",
          "package": "hdf",
          "signature": "Int-\u003e[Edge]-\u003e(Id,Port_Index)-\u003e(Int,Id)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:solve_rec_edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform node to source, see through \u003ccode\u003e\u003ca\u003eUDF_R\u003c/a\u003e\u003c/code\u003e (rec) and \u003ccode\u003e\u003ca\u003eUDF_M\u003c/a\u003e\u003c/code\u003e (mrg).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "source",
          "package": "hdf",
          "signature": "[Node] -\u003e UDF -\u003e Id",
          "source": "src/Sound-DF-Uniform-UDF.html#source",
          "type": "function"
        },
        "index": {
          "description": "Transform node to source see through UDF rec and UDF mrg",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "source",
          "normalized": "[Node]-\u003eUDF-\u003eId",
          "package": "hdf",
          "signature": "[Node]-\u003eUDF-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:source"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTopological sort of nodes (via \u003ccode\u003e\u003ca\u003eudf_gr\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "tsort",
          "package": "hdf",
          "signature": "UDF -\u003e [UDF]",
          "source": "src/Sound-DF-Uniform-UDF.html#tsort",
          "type": "function"
        },
        "index": {
          "description": "Topological sort of nodes via udf gr",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "tsort",
          "normalized": "UDF-\u003e[UDF]",
          "package": "hdf",
          "signature": "UDF-\u003e[UDF]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:tsort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_a",
          "package": "hdf",
          "signature": "Vec Float",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_a",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_a"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcise pretty printer for \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_concise",
          "package": "hdf",
          "signature": "UDF -\u003e String",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_concise",
          "type": "function"
        },
        "index": {
          "description": "Concise pretty printer for UDF",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_concise",
          "normalized": "UDF-\u003eString",
          "package": "hdf",
          "signature": "UDF-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_concise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edl_gen\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eudf_instructions\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_dl_gen",
          "package": "hdf",
          "signature": "FilePath -\u003e (Host, FilePath) -\u003e UDF -\u003e IO ()",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_dl_gen",
          "type": "function"
        },
        "index": {
          "description": "dl gen of udf instructions",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_dl_gen",
          "normalized": "FilePath-\u003e(Host,FilePath)-\u003eUDF-\u003eIO()",
          "package": "hdf",
          "signature": "FilePath-\u003e(Host,FilePath)-\u003eUDF-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_dl_gen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of \u003cem\u003eout\u003c/em\u003e edge of \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_edge_ty",
          "package": "hdf",
          "signature": "UDF -\u003e Edge_Ty",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_edge_ty",
          "type": "function"
        },
        "index": {
          "description": "Type of out edge of UDF",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_edge_ty",
          "normalized": "UDF-\u003eEdge_Ty",
          "package": "hdf",
          "signature": "UDF-\u003eEdge_Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_edge_ty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList elements in left biased order.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_elem",
          "package": "hdf",
          "signature": "UDF -\u003e [UDF]",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_elem",
          "type": "function"
        },
        "index": {
          "description": "List elements in left biased order",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_elem",
          "normalized": "UDF-\u003e[UDF]",
          "package": "hdf",
          "signature": "UDF-\u003e[UDF]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_elem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate \u003ccode\u003e\u003ca\u003eGr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_gr",
          "package": "hdf",
          "signature": "Graph -\u003e Gr",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_gr",
          "type": "function"
        },
        "index": {
          "description": "Generate Gr",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_gr",
          "normalized": "Graph-\u003eGr",
          "package": "hdf",
          "signature": "Graph-\u003eGr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_gr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate \u003ccode\u003e\u003ca\u003eGr'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_gr'",
          "package": "hdf",
          "signature": "Graph -\u003e Gr'",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_gr%27",
          "type": "function"
        },
        "index": {
          "description": "Generate Gr",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_gr'",
          "normalized": "Graph-\u003eGr'",
          "package": "hdf",
          "signature": "Graph-\u003eGr'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_gr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate \u003ccode\u003e\u003ca\u003eInstructions\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_instructions",
          "package": "hdf",
          "signature": "UDF -\u003e Instructions",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_instructions",
          "type": "function"
        },
        "index": {
          "description": "Generate Instructions from UDF",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_instructions",
          "normalized": "UDF-\u003eInstructions",
          "package": "hdf",
          "signature": "UDF-\u003eInstructions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_instructions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_k",
          "package": "hdf",
          "signature": "K",
          "source": "src/Sound-DF-Uniform-UDF.html#UDF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_k",
          "package": "hdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_k"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaybe variant of \u003ccode\u003e\u003ca\u003eudf_k\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_k'",
          "package": "hdf",
          "signature": "UDF -\u003e Maybe K",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_k%27",
          "type": "function"
        },
        "index": {
          "description": "Maybe variant of udf",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_k'",
          "normalized": "UDF-\u003eMaybe K",
          "package": "hdf",
          "signature": "UDF-\u003eMaybe K",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_k-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraversal with state, signature as \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_traverse",
          "package": "hdf",
          "signature": "(st -\u003e UDF -\u003e (st, UDF)) -\u003e st -\u003e UDF -\u003e (st, UDF)",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_traverse",
          "type": "function"
        },
        "index": {
          "description": "Traversal with state signature as mapAccumL",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_traverse",
          "normalized": "(a-\u003eUDF-\u003e(a,UDF))-\u003ea-\u003eUDF-\u003e(a,UDF)",
          "package": "hdf",
          "signature": "(st-\u003eUDF-\u003e(st,UDF))-\u003est-\u003eUDF-\u003e(st,UDF)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_traverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput type of \u003ccode\u003e\u003ca\u003eUDF\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_typeOf",
          "package": "hdf",
          "signature": "UDF -\u003e TypeRep",
          "source": "src/Sound-DF-Uniform-UDF.html#udf_typeOf",
          "type": "function"
        },
        "index": {
          "description": "Output type of UDF",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "udf_typeOf",
          "normalized": "UDF-\u003eTypeRep",
          "package": "hdf",
          "partial": "Of",
          "signature": "UDF-\u003eTypeRep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:udf_typeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform the actual graph into a viewing graph by deleting\n \u003cem\u003erecWr\u003c/em\u003e and \u003cem\u003erecRd\u003c/em\u003e nodes and drawing a direct backward edge.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "vgraph_direct",
          "package": "hdf",
          "signature": "Graph -\u003e Graph",
          "source": "src/Sound-DF-Uniform-UDF.html#vgraph_direct",
          "type": "function"
        },
        "index": {
          "description": "Transform the actual graph into viewing graph by deleting recWr and recRd nodes and drawing direct backward edge",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "vgraph_direct",
          "normalized": "Graph-\u003eGraph",
          "package": "hdf",
          "signature": "Graph-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:vgraph_direct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform the actual graph into a viewing graph by adding\n implicit edges from \u003cem\u003erecWr\u003c/em\u003e to \u003cem\u003erecRd\u003c/em\u003e nodes.\n\u003c/p\u003e",
          "module": "Sound.DF.Uniform.UDF",
          "name": "vgraph_impl",
          "package": "hdf",
          "signature": "Graph -\u003e Graph",
          "source": "src/Sound-DF-Uniform-UDF.html#vgraph_impl",
          "type": "function"
        },
        "index": {
          "description": "Transform the actual graph into viewing graph by adding implicit edges from recWr to recRd nodes",
          "hierarchy": "Sound DF Uniform UDF",
          "module": "Sound.DF.Uniform.UDF",
          "name": "vgraph_impl",
          "normalized": "Graph-\u003eGraph",
          "package": "hdf",
          "signature": "Graph-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hdf/docs/Sound-DF-Uniform-UDF.html#v:vgraph_impl"
      }
    }
  ]
]