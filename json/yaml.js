[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "yaml"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eJust a re-export of \u003ccode\u003eData.Yaml\u003c/code\u003e. In the future, this will be the canonical\n name for that module's contents.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Yaml.Aeson",
          "name": "Aeson",
          "package": "yaml",
          "source": "src/Data-Yaml-Aeson.html",
          "type": "module"
        },
        "index": {
          "description": "Just re-export of Data.Yaml In the future this will be the canonical name for that module contents",
          "hierarchy": "Data Yaml Aeson",
          "module": "Data.Yaml.Aeson",
          "name": "Aeson",
          "package": "yaml",
          "partial": "Aeson",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Aeson.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNOTE: This module is a highly experimental preview release. It may change\n drastically, or be entirely removed, in a future release.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Yaml.Builder",
          "name": "Builder",
          "package": "yaml",
          "source": "src/Data-Yaml-Builder.html",
          "type": "module"
        },
        "index": {
          "description": "NOTE This module is highly experimental preview release It may change drastically or be entirely removed in future release",
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "Builder",
          "package": "yaml",
          "partial": "Builder",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "ToYaml",
          "package": "yaml",
          "source": "src/Data-Yaml-Builder.html#ToYaml",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "ToYaml",
          "package": "yaml",
          "partial": "To Yaml",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#t:ToYaml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "YamlBuilder",
          "package": "yaml",
          "source": "src/Data-Yaml-Builder.html#YamlBuilder",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "YamlBuilder",
          "package": "yaml",
          "partial": "Yaml Builder",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#t:YamlBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "(.=)",
          "package": "yaml",
          "signature": "Text -\u003e a -\u003e (Text, YamlBuilder)",
          "source": "src/Data-Yaml-Builder.html#.%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "(.=) .=",
          "normalized": "Text-\u003ea-\u003e(Text,YamlBuilder)",
          "package": "yaml",
          "signature": "Text-\u003ea-\u003e(Text,YamlBuilder)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "YamlBuilder",
          "package": "yaml",
          "signature": "YamlBuilder",
          "source": "src/Data-Yaml-Builder.html#YamlBuilder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "YamlBuilder",
          "package": "yaml",
          "partial": "Yaml Builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:YamlBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "array",
          "package": "yaml",
          "signature": "[YamlBuilder] -\u003e YamlBuilder",
          "source": "src/Data-Yaml-Builder.html#array",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "array",
          "normalized": "[YamlBuilder]-\u003eYamlBuilder",
          "package": "yaml",
          "signature": "[YamlBuilder]-\u003eYamlBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "mapping",
          "package": "yaml",
          "signature": "[(Text, YamlBuilder)] -\u003e YamlBuilder",
          "source": "src/Data-Yaml-Builder.html#mapping",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "mapping",
          "normalized": "[(Text,YamlBuilder)]-\u003eYamlBuilder",
          "package": "yaml",
          "signature": "[(Text,YamlBuilder)]-\u003eYamlBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:mapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "string",
          "package": "yaml",
          "signature": "Text -\u003e YamlBuilder",
          "source": "src/Data-Yaml-Builder.html#string",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "string",
          "normalized": "Text-\u003eYamlBuilder",
          "package": "yaml",
          "signature": "Text-\u003eYamlBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "toByteString",
          "package": "yaml",
          "signature": "a -\u003e ByteString",
          "source": "src/Data-Yaml-Builder.html#toByteString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "toByteString",
          "normalized": "a-\u003eByteString",
          "package": "yaml",
          "partial": "Byte String",
          "signature": "a-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:toByteString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "toYaml",
          "package": "yaml",
          "signature": "a -\u003e YamlBuilder",
          "source": "src/Data-Yaml-Builder.html#toYaml",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "toYaml",
          "normalized": "a-\u003eYamlBuilder",
          "package": "yaml",
          "partial": "Yaml",
          "signature": "a-\u003eYamlBuilder",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:toYaml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "unYamlBuilder",
          "package": "yaml",
          "signature": "[Event] -\u003e [Event]",
          "source": "src/Data-Yaml-Builder.html#YamlBuilder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "unYamlBuilder",
          "normalized": "[Event]-\u003e[Event]",
          "package": "yaml",
          "partial": "Yaml Builder",
          "signature": "[Event]-\u003e[Event]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:unYamlBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Builder",
          "name": "writeYamlFile",
          "package": "yaml",
          "signature": "FilePath -\u003e a -\u003e IO ()",
          "source": "src/Data-Yaml-Builder.html#writeYamlFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Builder",
          "module": "Data.Yaml.Builder",
          "name": "writeYamlFile",
          "normalized": "FilePath-\u003ea-\u003eIO()",
          "package": "yaml",
          "partial": "Yaml File",
          "signature": "FilePath-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Builder.html#v:writeYamlFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNOTE: This module is a highly experimental preview release. It may change\n drastically, or be entirely removed, in a future release.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Yaml.Parser",
          "name": "Parser",
          "package": "yaml",
          "source": "src/Data-Yaml-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "NOTE This module is highly experimental preview release It may change drastically or be entirely removed in future release",
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "Parser",
          "package": "yaml",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "AnchorMap",
          "package": "yaml",
          "source": "src/Data-Yaml-Parser.html#AnchorMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "AnchorMap",
          "package": "yaml",
          "partial": "Anchor Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#t:AnchorMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "FromYaml",
          "package": "yaml",
          "source": "src/Data-Yaml-Parser.html#FromYaml",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "FromYaml",
          "package": "yaml",
          "partial": "From Yaml",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#t:FromYaml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "RawDoc",
          "package": "yaml",
          "source": "src/Data-Yaml-Parser.html#RawDoc",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "RawDoc",
          "package": "yaml",
          "partial": "Raw Doc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#t:RawDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "YamlParseException",
          "package": "yaml",
          "source": "src/Data-Yaml-Parser.html#YamlParseException",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "YamlParseException",
          "package": "yaml",
          "partial": "Yaml Parse Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#t:YamlParseException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "YamlParser",
          "package": "yaml",
          "source": "src/Data-Yaml-Parser.html#YamlParser",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "YamlParser",
          "package": "yaml",
          "partial": "Yaml Parser",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#t:YamlParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "YamlValue",
          "package": "yaml",
          "source": "src/Data-Yaml-Parser.html#YamlValue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "YamlValue",
          "package": "yaml",
          "partial": "Yaml Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#t:YamlValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "(.:)",
          "package": "yaml",
          "signature": "[(Text, YamlValue)] -\u003e Text -\u003e YamlParser a",
          "source": "src/Data-Yaml-Parser.html#.%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "(.:) .:",
          "normalized": "[(Text,YamlValue)]-\u003eText-\u003eYamlParser a",
          "package": "yaml",
          "signature": "[(Text,YamlValue)]-\u003eText-\u003eYamlParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:.:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "Alias",
          "package": "yaml",
          "signature": "Alias AnchorName",
          "source": "src/Data-Yaml-Parser.html#YamlValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "Alias",
          "package": "yaml",
          "partial": "Alias",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:Alias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "FromYamlException",
          "package": "yaml",
          "signature": "FromYamlException Text",
          "source": "src/Data-Yaml-Parser.html#YamlParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "FromYamlException",
          "package": "yaml",
          "partial": "From Yaml Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:FromYamlException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "Mapping",
          "package": "yaml",
          "signature": "Mapping [(Text, YamlValue)] Anchor",
          "source": "src/Data-Yaml-Parser.html#YamlValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "Mapping",
          "normalized": "Mapping[(Text,YamlValue)]Anchor",
          "package": "yaml",
          "partial": "Mapping",
          "signature": "Mapping[(Text,YamlValue)]Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:Mapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "RawDoc",
          "package": "yaml",
          "signature": "RawDoc YamlValue AnchorMap",
          "source": "src/Data-Yaml-Parser.html#RawDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "RawDoc",
          "package": "yaml",
          "partial": "Raw Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:RawDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "Scalar",
          "package": "yaml",
          "signature": "Scalar ByteString Tag Style Anchor",
          "source": "src/Data-Yaml-Parser.html#YamlValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "Scalar",
          "package": "yaml",
          "partial": "Scalar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:Scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "Sequence",
          "package": "yaml",
          "signature": "Sequence [YamlValue] Anchor",
          "source": "src/Data-Yaml-Parser.html#YamlValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "Sequence",
          "normalized": "Sequence[YamlValue]Anchor",
          "package": "yaml",
          "partial": "Sequence",
          "signature": "Sequence[YamlValue]Anchor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:Sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "UnexpectedEndOfEvents",
          "package": "yaml",
          "signature": "UnexpectedEndOfEvents",
          "source": "src/Data-Yaml-Parser.html#YamlParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "UnexpectedEndOfEvents",
          "package": "yaml",
          "partial": "Unexpected End Of Events",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:UnexpectedEndOfEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "UnexpectedEvent",
          "package": "yaml",
          "signature": "UnexpectedEvent Event",
          "source": "src/Data-Yaml-Parser.html#YamlParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "UnexpectedEvent",
          "package": "yaml",
          "partial": "Unexpected Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:UnexpectedEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "YamlParser",
          "package": "yaml",
          "signature": "YamlParser",
          "source": "src/Data-Yaml-Parser.html#YamlParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "YamlParser",
          "package": "yaml",
          "partial": "Yaml Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:YamlParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "fromYaml",
          "package": "yaml",
          "signature": "YamlValue -\u003e YamlParser a",
          "source": "src/Data-Yaml-Parser.html#fromYaml",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "fromYaml",
          "normalized": "YamlValue-\u003eYamlParser a",
          "package": "yaml",
          "partial": "Yaml",
          "signature": "YamlValue-\u003eYamlParser a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:fromYaml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "lookupAnchor",
          "package": "yaml",
          "signature": "AnchorName -\u003e YamlParser (Maybe YamlValue)",
          "source": "src/Data-Yaml-Parser.html#lookupAnchor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "lookupAnchor",
          "normalized": "AnchorName-\u003eYamlParser(Maybe YamlValue)",
          "package": "yaml",
          "partial": "Anchor",
          "signature": "AnchorName-\u003eYamlParser(Maybe YamlValue)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:lookupAnchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "parseRawDoc",
          "package": "yaml",
          "signature": "RawDoc -\u003e m a",
          "source": "src/Data-Yaml-Parser.html#parseRawDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "parseRawDoc",
          "normalized": "RawDoc-\u003ea b",
          "package": "yaml",
          "partial": "Raw Doc",
          "signature": "RawDoc-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:parseRawDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "readYamlFile",
          "package": "yaml",
          "signature": "FilePath -\u003e IO a",
          "source": "src/Data-Yaml-Parser.html#readYamlFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "readYamlFile",
          "normalized": "FilePath-\u003eIO a",
          "package": "yaml",
          "partial": "Yaml File",
          "signature": "FilePath-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:readYamlFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "sinkRawDoc",
          "package": "yaml",
          "signature": "Consumer Event m RawDoc",
          "source": "src/Data-Yaml-Parser.html#sinkRawDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "sinkRawDoc",
          "package": "yaml",
          "partial": "Raw Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:sinkRawDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "sinkValue",
          "package": "yaml",
          "signature": "Consumer Event (WriterT AnchorMap m) YamlValue",
          "source": "src/Data-Yaml-Parser.html#sinkValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "sinkValue",
          "package": "yaml",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:sinkValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "typeMismatch",
          "package": "yaml",
          "signature": "Text -\u003e YamlValue -\u003e YamlParser a",
          "source": "src/Data-Yaml-Parser.html#typeMismatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "typeMismatch",
          "normalized": "Text-\u003eYamlValue-\u003eYamlParser a",
          "package": "yaml",
          "partial": "Mismatch",
          "signature": "Text-\u003eYamlValue-\u003eYamlParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:typeMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "unYamlParser",
          "package": "yaml",
          "signature": "AnchorMap -\u003e Either Text a",
          "source": "src/Data-Yaml-Parser.html#YamlParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "unYamlParser",
          "normalized": "AnchorMap-\u003eEither Text a",
          "package": "yaml",
          "partial": "Yaml Parser",
          "signature": "AnchorMap-\u003eEither Text a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:unYamlParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "withAnchor",
          "package": "yaml",
          "signature": "AnchorName -\u003e Text -\u003e (YamlValue -\u003e YamlParser a) -\u003e YamlParser a",
          "source": "src/Data-Yaml-Parser.html#withAnchor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "withAnchor",
          "normalized": "AnchorName-\u003eText-\u003e(YamlValue-\u003eYamlParser a)-\u003eYamlParser a",
          "package": "yaml",
          "partial": "Anchor",
          "signature": "AnchorName-\u003eText-\u003e(YamlValue-\u003eYamlParser a)-\u003eYamlParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:withAnchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "withMapping",
          "package": "yaml",
          "signature": "Text -\u003e ([(Text, YamlValue)] -\u003e YamlParser a) -\u003e YamlValue -\u003e YamlParser a",
          "source": "src/Data-Yaml-Parser.html#withMapping",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "withMapping",
          "normalized": "Text-\u003e([(Text,YamlValue)]-\u003eYamlParser a)-\u003eYamlValue-\u003eYamlParser a",
          "package": "yaml",
          "partial": "Mapping",
          "signature": "Text-\u003e([(Text,YamlValue)]-\u003eYamlParser a)-\u003eYamlValue-\u003eYamlParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:withMapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "withSequence",
          "package": "yaml",
          "signature": "Text -\u003e ([YamlValue] -\u003e YamlParser a) -\u003e YamlValue -\u003e YamlParser a",
          "source": "src/Data-Yaml-Parser.html#withSequence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "withSequence",
          "normalized": "Text-\u003e([YamlValue]-\u003eYamlParser a)-\u003eYamlValue-\u003eYamlParser a",
          "package": "yaml",
          "partial": "Sequence",
          "signature": "Text-\u003e([YamlValue]-\u003eYamlParser a)-\u003eYamlValue-\u003eYamlParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:withSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml.Parser",
          "name": "withText",
          "package": "yaml",
          "signature": "Text -\u003e (Text -\u003e YamlParser a) -\u003e YamlValue -\u003e YamlParser a",
          "source": "src/Data-Yaml-Parser.html#withText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml Parser",
          "module": "Data.Yaml.Parser",
          "name": "withText",
          "normalized": "Text-\u003e(Text-\u003eYamlParser a)-\u003eYamlValue-\u003eYamlParser a",
          "package": "yaml",
          "partial": "Text",
          "signature": "Text-\u003e(Text-\u003eYamlParser a)-\u003eYamlValue-\u003eYamlParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml-Parser.html#v:withText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvides a high-level interface for processing YAML files.\n\u003c/p\u003e\u003cp\u003eThis module reuses most of the infrastructure from the \u003ccode\u003eaeson\u003c/code\u003e package.\n This means that you can use all of the existing tools for JSON\n processing for processing YAML files. As a result, much of the\n documentation below mentions JSON; do not let that confuse you, it's\n intentional.\n\u003c/p\u003e\u003cp\u003eFor the most part, YAML content translates directly into JSON, and\n therefore there is very little data loss. If you need to deal with YAML\n more directly (e.g., directly deal with aliases), you should use the\n \u003ca\u003eText.Libyaml\u003c/a\u003e module instead.\n\u003c/p\u003e\u003cp\u003eFor documentation on the \u003ccode\u003eaeson\u003c/code\u003e types, functions, classes, and\n operators, please see the \u003ccode\u003eData.Aeson\u003c/code\u003e module of the \u003ccode\u003eaeson\u003c/code\u003e package.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Yaml",
          "name": "Yaml",
          "package": "yaml",
          "source": "src/Data-Yaml.html",
          "type": "module"
        },
        "index": {
          "description": "Provides high-level interface for processing YAML files This module reuses most of the infrastructure from the aeson package This means that you can use all of the existing tools for JSON processing for processing YAML files As result much of the documentation below mentions JSON do not let that confuse you it intentional For the most part YAML content translates directly into JSON and therefore there is very little data loss If you need to deal with YAML more directly e.g directly deal with aliases you should use the Text.Libyaml module instead For documentation on the aeson types functions classes and operators please see the Data.Aeson module of the aeson package",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Yaml",
          "package": "yaml",
          "partial": "Yaml",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA JSON \"array\" (sequence).\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "Array",
          "package": "yaml",
          "type": "type"
        },
        "index": {
          "description": "JSON array sequence",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Array",
          "package": "yaml",
          "partial": "Array",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type that can be converted from JSON, with the possibility of\n failure.\n\u003c/p\u003e\u003cp\u003eWhen writing an instance, use \u003ccode\u003eempty\u003c/code\u003e, \u003ccode\u003emzero\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e to make a\n conversion fail, e.g. if an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e is missing a required key, or\n the value is of the wrong type.\n\u003c/p\u003e\u003cp\u003eAn example type and instance:\n\u003c/p\u003e\u003cpre\u003e{-# LANGUAGE OverloadedStrings #-}\n\ndata Coord { x :: Double, y :: Double }\n\ninstance FromJSON Coord where\n   parseJSON (\u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e v) = Coord    \u003ccode\u003e\u003c$\u003e\u003c/code\u003e\n                          v \u003ccode\u003e.:\u003c/code\u003e \"x\" \u003ccode\u003e\u003c*\u003e\u003c/code\u003e\n                          v \u003ccode\u003e.:\u003c/code\u003e \"y\"\n\n-- A non-\u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e value is of the wrong type, so use \u003ccode\u003emzero\u003c/code\u003e to fail.\n   parseJSON _          = \u003ccode\u003emzero\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eNote the use of the \u003ccode\u003eOverloadedStrings\u003c/code\u003e language extension which enables\n \u003ccode\u003eText\u003c/code\u003e values to be written as string literals.\n\u003c/p\u003e\u003cp\u003eInstead of manually writing your \u003ccode\u003e\u003ca\u003eFromJSON\u003c/a\u003e\u003c/code\u003e instance, there are three options\n to do it automatically:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003eData.Aeson.TH\u003c/a\u003e provides template-haskell functions which will derive an\n instance at compile-time. The generated instance is optimized for your type\n so will probably be more efficient than the following two options:\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eData.Aeson.Generic\u003c/a\u003e provides a generic \u003ccode\u003efromJSON\u003c/code\u003e function that parses to\n any type which is an instance of \u003ccode\u003eData\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e If your compiler has support for the \u003ccode\u003eDeriveGeneric\u003c/code\u003e and\n \u003ccode\u003eDefaultSignatures\u003c/code\u003e language extensions, \u003ccode\u003eparseJSON\u003c/code\u003e will have a default\n generic implementation.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTo use this, simply add a \u003ccode\u003ederiving \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e clause to your datatype and\n declare a \u003ccode\u003eFromJSON\u003c/code\u003e instance for your datatype without giving a definition\n for \u003ccode\u003eparseJSON\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example the previous example can be simplified to just:\n\u003c/p\u003e\u003cpre\u003e{-# LANGUAGE DeriveGeneric #-}\n\nimport GHC.Generics\n\ndata Coord { x :: Double, y :: Double } deriving Generic\n\ninstance FromJSON Coord\n\u003c/pre\u003e\u003cp\u003eNote that, instead of using \u003ccode\u003eDefaultSignatures\u003c/code\u003e, it's also possible\n to parameterize the generic decoding using \u003ccode\u003e\u003ca\u003egenericParseJSON\u003c/a\u003e\u003c/code\u003e applied\n to your encoding/decoding \u003ccode\u003e\u003ca\u003eOptions\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n instance FromJSON Coord where\n     parseJSON = \u003ccode\u003e\u003ca\u003egenericParseJSON\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultOptions\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Yaml",
          "name": "FromJSON",
          "package": "yaml",
          "type": "class"
        },
        "index": {
          "description": "type that can be converted from JSON with the possibility of failure When writing an instance use empty mzero or fail to make conversion fail e.g if an Object is missing required key or the value is of the wrong type An example type and instance LANGUAGE OverloadedStrings data Coord Double Double instance FromJSON Coord where parseJSON Object Coord non Object value is of the wrong type so use mzero to fail parseJSON mzero Note the use of the OverloadedStrings language extension which enables Text values to be written as string literals Instead of manually writing your FromJSON instance there are three options to do it automatically Data.Aeson.TH provides template-haskell functions which will derive an instance at compile-time The generated instance is optimized for your type so will probably be more efficient than the following two options Data.Aeson.Generic provides generic fromJSON function that parses to any type which is an instance of Data If your compiler has support for the DeriveGeneric and DefaultSignatures language extensions parseJSON will have default generic implementation To use this simply add deriving Generic clause to your datatype and declare FromJSON instance for your datatype without giving definition for parseJSON For example the previous example can be simplified to just LANGUAGE DeriveGeneric import GHC.Generics data Coord Double Double deriving Generic instance FromJSON Coord Note that instead of using DefaultSignatures it also possible to parameterize the generic decoding using genericParseJSON applied to your encoding decoding Options instance FromJSON Coord where parseJSON genericParseJSON defaultOptions",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "FromJSON",
          "package": "yaml",
          "partial": "From JSON",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:FromJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA JSON \"object\" (key/value map).\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "Object",
          "package": "yaml",
          "type": "type"
        },
        "index": {
          "description": "JSON object key value map",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Object",
          "package": "yaml",
          "partial": "Object",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:Object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "ParseException",
          "package": "yaml",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "ParseException",
          "package": "yaml",
          "partial": "Parse Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:ParseException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA continuation-based parser type.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "Parser",
          "package": "yaml",
          "type": "data"
        },
        "index": {
          "description": "continuation-based parser type",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Parser",
          "package": "yaml",
          "partial": "Parser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type that can be converted to JSON.\n\u003c/p\u003e\u003cp\u003eAn example type and instance:\n\u003c/p\u003e\u003cpre\u003e{-# LANGUAGE OverloadedStrings #-}\n\ndata Coord { x :: Double, y :: Double }\n\ninstance ToJSON Coord where\n   toJSON (Coord x y) = \u003ccode\u003e\u003ca\u003eobject\u003c/a\u003e\u003c/code\u003e [\"x\" \u003ccode\u003e.=\u003c/code\u003e x, \"y\" \u003ccode\u003e.=\u003c/code\u003e y]\n\u003c/pre\u003e\u003cp\u003eNote the use of the \u003ccode\u003eOverloadedStrings\u003c/code\u003e language extension which enables\n \u003ccode\u003eText\u003c/code\u003e values to be written as string literals.\n\u003c/p\u003e\u003cp\u003eInstead of manually writing your \u003ccode\u003e\u003ca\u003eToJSON\u003c/a\u003e\u003c/code\u003e instance, there are three options\n to do it automatically:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003eData.Aeson.TH\u003c/a\u003e provides template-haskell functions which will derive an\n instance at compile-time. The generated instance is optimized for your type\n so will probably be more efficient than the following two options:\n\u003c/li\u003e\u003cli\u003e \u003ca\u003eData.Aeson.Generic\u003c/a\u003e provides a generic \u003ccode\u003etoJSON\u003c/code\u003e function that accepts any\n type which is an instance of \u003ccode\u003eData\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e If your compiler has support for the \u003ccode\u003eDeriveGeneric\u003c/code\u003e and\n \u003ccode\u003eDefaultSignatures\u003c/code\u003e language extensions (GHC 7.2 and newer),\n \u003ccode\u003etoJSON\u003c/code\u003e will have a default generic implementation.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTo use the latter option, simply add a \u003ccode\u003ederiving \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e clause to your\n datatype and declare a \u003ccode\u003eToJSON\u003c/code\u003e instance for your datatype without giving a\n definition for \u003ccode\u003etoJSON\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example the previous example can be simplified to just:\n\u003c/p\u003e\u003cpre\u003e{-# LANGUAGE DeriveGeneric #-}\n\nimport GHC.Generics\n\ndata Coord { x :: Double, y :: Double } deriving Generic\n\ninstance ToJSON Coord\n\u003c/pre\u003e\u003cp\u003eNote that, instead of using \u003ccode\u003eDefaultSignatures\u003c/code\u003e, it's also possible\n to parameterize the generic encoding using \u003ccode\u003e\u003ca\u003egenericToJSON\u003c/a\u003e\u003c/code\u003e applied\n to your encoding/decoding \u003ccode\u003e\u003ca\u003eOptions\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n instance ToJSON Coord where\n     toJSON = \u003ccode\u003e\u003ca\u003egenericToJSON\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultOptions\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Yaml",
          "name": "ToJSON",
          "package": "yaml",
          "type": "class"
        },
        "index": {
          "description": "type that can be converted to JSON An example type and instance LANGUAGE OverloadedStrings data Coord Double Double instance ToJSON Coord where toJSON Coord object Note the use of the OverloadedStrings language extension which enables Text values to be written as string literals Instead of manually writing your ToJSON instance there are three options to do it automatically Data.Aeson.TH provides template-haskell functions which will derive an instance at compile-time The generated instance is optimized for your type so will probably be more efficient than the following two options Data.Aeson.Generic provides generic toJSON function that accepts any type which is an instance of Data If your compiler has support for the DeriveGeneric and DefaultSignatures language extensions GHC and newer toJSON will have default generic implementation To use the latter option simply add deriving Generic clause to your datatype and declare ToJSON instance for your datatype without giving definition for toJSON For example the previous example can be simplified to just LANGUAGE DeriveGeneric import GHC.Generics data Coord Double Double deriving Generic instance ToJSON Coord Note that instead of using DefaultSignatures it also possible to parameterize the generic encoding using genericToJSON applied to your encoding decoding Options instance ToJSON Coord where toJSON genericToJSON defaultOptions",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "ToJSON",
          "package": "yaml",
          "partial": "To JSON",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:ToJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA JSON value represented as a Haskell value.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "Value",
          "package": "yaml",
          "type": "data"
        },
        "index": {
          "description": "JSON value represented as Haskell value",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Value",
          "package": "yaml",
          "partial": "Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "YamlException",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#YamlException",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "YamlException",
          "package": "yaml",
          "partial": "Yaml Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:YamlException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe pointer position\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "YamlMark",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#YamlMark",
          "type": "data"
        },
        "index": {
          "description": "The pointer position",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "YamlMark",
          "package": "yaml",
          "partial": "Yaml Mark",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#t:YamlMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for use in combination with \u003ccode\u003e\u003ca\u003e.:?\u003c/a\u003e\u003c/code\u003e to provide default\n values for optional JSON object fields.\n\u003c/p\u003e\u003cp\u003eThis combinator is most useful if the key and value can be absent\n from an object without affecting its validity and we know a default\n value to assign in that case.  If the key and value are mandatory,\n use '(.:)' instead.\n\u003c/p\u003e\u003cp\u003eExample usage:\n\u003c/p\u003e\u003cpre\u003e v1 \u003c- o \u003ccode\u003e\u003ca\u003e.:?\u003c/a\u003e\u003c/code\u003e \"opt_field_with_dfl\" .!= \"default_val\"\n v2 \u003c- o \u003ccode\u003e\u003ca\u003e.:\u003c/a\u003e\u003c/code\u003e  \"mandatory_field\"\n v3 \u003c- o \u003ccode\u003e\u003ca\u003e.:?\u003c/a\u003e\u003c/code\u003e \"opt_field2\"\n\u003c/pre\u003e",
          "module": "Data.Yaml",
          "name": "(.!=)",
          "package": "yaml",
          "signature": "Parser (Maybe a) -\u003e a -\u003e Parser a",
          "type": "function"
        },
        "index": {
          "description": "Helper for use in combination with to provide default values for optional JSON object fields This combinator is most useful if the key and value can be absent from an object without affecting its validity and we know default value to assign in that case If the key and value are mandatory use instead Example usage v1 opt field with dfl default val v2 mandatory field v3 opt field2",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "(.!=) .!=",
          "normalized": "Parser(Maybe a)-\u003ea-\u003eParser a",
          "package": "yaml",
          "signature": "Parser(Maybe a)-\u003ea-\u003eParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:.-33--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003ePair\u003c/a\u003e\u003c/code\u003e from a key and a value.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "(.=)",
          "package": "yaml",
          "signature": "Text -\u003e a -\u003e Pair",
          "type": "function"
        },
        "index": {
          "description": "Construct Pair from key and value",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "(.=) .=",
          "normalized": "Text-\u003ea-\u003ePair",
          "package": "yaml",
          "signature": "Text-\u003ea-\u003ePair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the value associated with the given key of an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e.\n The result is \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e if the key is not present or the value cannot\n be converted to the desired type.\n\u003c/p\u003e\u003cp\u003eThis accessor is appropriate if the key and value \u003cem\u003emust\u003c/em\u003e be present\n in an object for it to be valid.  If the key and value are\n optional, use '(.:?)' instead.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "(.:)",
          "package": "yaml",
          "signature": "Object -\u003e Text -\u003e Parser a",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the value associated with the given key of an Object The result is empty if the key is not present or the value cannot be converted to the desired type This accessor is appropriate if the key and value must be present in an object for it to be valid If the key and value are optional use instead",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "(.:) .:",
          "normalized": "Object-\u003eText-\u003eParser a",
          "package": "yaml",
          "signature": "Object-\u003eText-\u003eParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:.:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the value associated with the given key of an \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e.\n The result is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the key is not present, or \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e if\n the value cannot be converted to the desired type.\n\u003c/p\u003e\u003cp\u003eThis accessor is most useful if the key and value can be absent\n from an object without affecting its validity.  If the key and\n value are mandatory, use '(.:)' instead.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "(.:?)",
          "package": "yaml",
          "signature": "Object -\u003e Text -\u003e Parser (Maybe a)",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the value associated with the given key of an Object The result is Nothing if the key is not present or empty if the value cannot be converted to the desired type This accessor is most useful if the key and value can be absent from an object without affecting its validity If the key and value are mandatory use instead",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "(.:?) .:?",
          "normalized": "Object-\u003eText-\u003eParser(Maybe a)",
          "package": "yaml",
          "signature": "Object-\u003eText-\u003eParser(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:.:-63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "AesonException",
          "package": "yaml",
          "signature": "AesonException String",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "AesonException",
          "package": "yaml",
          "partial": "Aeson Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:AesonException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "Array",
          "package": "yaml",
          "signature": "Array !Array",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Array",
          "package": "yaml",
          "partial": "Array",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "Bool",
          "package": "yaml",
          "signature": "Bool !Bool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Bool",
          "package": "yaml",
          "partial": "Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:Bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "InvalidYaml",
          "package": "yaml",
          "signature": "InvalidYaml (Maybe YamlException)",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "InvalidYaml",
          "package": "yaml",
          "partial": "Invalid Yaml",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:InvalidYaml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "NonScalarKey",
          "package": "yaml",
          "signature": "NonScalarKey",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "NonScalarKey",
          "package": "yaml",
          "partial": "Non Scalar Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:NonScalarKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "Null",
          "package": "yaml",
          "signature": "Null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Null",
          "package": "yaml",
          "partial": "Null",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:Null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "Number",
          "package": "yaml",
          "signature": "Number !Scientific",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Number",
          "package": "yaml",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "Object",
          "package": "yaml",
          "signature": "Object !Object",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "Object",
          "package": "yaml",
          "partial": "Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:Object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "OtherParseException",
          "package": "yaml",
          "signature": "OtherParseException SomeException",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "OtherParseException",
          "package": "yaml",
          "partial": "Other Parse Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:OtherParseException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "String",
          "package": "yaml",
          "signature": "String !Text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "String",
          "package": "yaml",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "UnexpectedEvent",
          "package": "yaml",
          "signature": "UnexpectedEvent",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "UnexpectedEvent",
          "package": "yaml",
          "partial": "Unexpected Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:UnexpectedEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "UnknownAlias",
          "package": "yaml",
          "signature": "UnknownAlias",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "UnknownAlias",
          "package": "yaml",
          "partial": "Unknown Alias",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:UnknownAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "YamlException",
          "package": "yaml",
          "signature": "YamlException String",
          "source": "src/Text-Libyaml.html#YamlException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:YamlException\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:YamlException\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "YamlException",
          "package": "yaml",
          "partial": "Yaml Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:YamlException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "YamlMark",
          "package": "yaml",
          "signature": "YamlMark",
          "source": "src/Text-Libyaml.html#YamlMark",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:YamlMark\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:YamlMark\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "YamlMark",
          "package": "yaml",
          "partial": "Yaml Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:YamlMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eproblem, context, index, position line, position column\n\u003c/p\u003e",
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "YamlParseException",
          "package": "yaml",
          "signature": "YamlParseException",
          "source": "src/Text-Libyaml.html#YamlException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:YamlParseException\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:YamlParseException\"]"
        },
        "index": {
          "description": "problem context index position line position column",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "YamlParseException",
          "package": "yaml",
          "partial": "Yaml Parse Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:YamlParseException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "_anchorName",
          "package": "yaml",
          "signature": "AnchorName",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "_anchorName",
          "package": "yaml",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:_anchorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "_expected",
          "package": "yaml",
          "signature": "Maybe Event",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "_expected",
          "package": "yaml",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:_expected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "_received",
          "package": "yaml",
          "signature": "Maybe Event",
          "source": "src/Data-Yaml.html#ParseException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "_received",
          "package": "yaml",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:_received"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "array",
          "package": "yaml",
          "signature": "[Value] -\u003e Value",
          "source": "src/Data-Yaml.html#array",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "array",
          "normalized": "[Value]-\u003eValue",
          "package": "yaml",
          "signature": "[Value]-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "decode",
          "package": "yaml",
          "signature": "ByteString -\u003e Maybe a",
          "source": "src/Data-Yaml.html#decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "decode",
          "normalized": "ByteString-\u003eMaybe a",
          "package": "yaml",
          "signature": "ByteString-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "decodeEither",
          "package": "yaml",
          "signature": "ByteString -\u003e Either String a",
          "source": "src/Data-Yaml.html#decodeEither",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "decodeEither",
          "normalized": "ByteString-\u003eEither String a",
          "package": "yaml",
          "partial": "Either",
          "signature": "ByteString-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:decodeEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMore helpful version of \u003ccode\u003e\u003ca\u003edecodeEither\u003c/a\u003e\u003c/code\u003e which returns the \u003ccode\u003e\u003ca\u003eYamlException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSince 0.8.3\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "decodeEither'",
          "package": "yaml",
          "signature": "ByteString -\u003e Either ParseException a",
          "source": "src/Data-Yaml.html#decodeEither%27",
          "type": "function"
        },
        "index": {
          "description": "More helpful version of decodeEither which returns the YamlException Since",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "decodeEither'",
          "normalized": "ByteString-\u003eEither ParseException a",
          "package": "yaml",
          "partial": "Either'",
          "signature": "ByteString-\u003eEither ParseException a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:decodeEither-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "decodeFile",
          "package": "yaml",
          "signature": "FilePath -\u003e IO (Maybe a)",
          "source": "src/Data-Yaml.html#decodeFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "decodeFile",
          "normalized": "FilePath-\u003eIO(Maybe a)",
          "package": "yaml",
          "partial": "File",
          "signature": "FilePath-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:decodeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003edecodeFile\u003c/a\u003e\u003c/code\u003e which should not throw runtime exceptions.\n\u003c/p\u003e\u003cp\u003eSince 0.8.4\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "decodeFileEither",
          "package": "yaml",
          "signature": "FilePath -\u003e IO (Either ParseException a)",
          "source": "src/Data-Yaml.html#decodeFileEither",
          "type": "function"
        },
        "index": {
          "description": "version of decodeFile which should not throw runtime exceptions Since",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "decodeFileEither",
          "normalized": "FilePath-\u003eIO(Either ParseException a)",
          "package": "yaml",
          "partial": "File Either",
          "signature": "FilePath-\u003eIO(Either ParseException a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:decodeFileEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "decodeHelper",
          "package": "yaml",
          "signature": "Source Parse Event -\u003e IO (Either ParseException (Either String a))",
          "source": "src/Data-Yaml.html#decodeHelper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "decodeHelper",
          "normalized": "Source Parse Event-\u003eIO(Either ParseException(Either String a))",
          "package": "yaml",
          "partial": "Helper",
          "signature": "Source Parse Event-\u003eIO(Either ParseException(Either String a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:decodeHelper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "encode",
          "package": "yaml",
          "signature": "a -\u003e ByteString",
          "source": "src/Data-Yaml.html#encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "encode",
          "normalized": "a-\u003eByteString",
          "package": "yaml",
          "signature": "a-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "encodeFile",
          "package": "yaml",
          "signature": "FilePath -\u003e a -\u003e IO ()",
          "source": "src/Data-Yaml.html#encodeFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "encodeFile",
          "normalized": "FilePath-\u003ea-\u003eIO()",
          "package": "yaml",
          "partial": "File",
          "signature": "FilePath-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:encodeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e from a list of name/value \u003ccode\u003e\u003ca\u003ePair\u003c/a\u003e\u003c/code\u003es.  If duplicate\n keys arise, earlier keys and their associated values win.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "object",
          "package": "yaml",
          "signature": "[Pair] -\u003e Value",
          "type": "function"
        },
        "index": {
          "description": "Create Value from list of name value Pair If duplicate keys arise earlier keys and their associated values win",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "object",
          "normalized": "[Pair]-\u003eValue",
          "package": "yaml",
          "signature": "[Pair]-\u003eValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e with an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e result type.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "parseEither",
          "package": "yaml",
          "signature": "(a -\u003e Parser b) -\u003e a -\u003e Either String b",
          "type": "function"
        },
        "index": {
          "description": "Run Parser with an Either result type",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "parseEither",
          "normalized": "(a-\u003eParser b)-\u003ea-\u003eEither String b",
          "package": "yaml",
          "partial": "Either",
          "signature": "(a-\u003eParser b)-\u003ea-\u003eEither String b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:parseEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "parseJSON",
          "package": "yaml",
          "signature": "Value -\u003e Parser a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "parseJSON",
          "normalized": "Value-\u003eParser a",
          "package": "yaml",
          "partial": "JSON",
          "signature": "Value-\u003eParser a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:parseJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e result type.\n\u003c/p\u003e",
          "module": "Data.Yaml",
          "name": "parseMaybe",
          "package": "yaml",
          "signature": "(a -\u003e Parser b) -\u003e a -\u003e Maybe b",
          "type": "function"
        },
        "index": {
          "description": "Run Parser with Maybe result type",
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "parseMaybe",
          "normalized": "(a-\u003eParser b)-\u003ea-\u003eMaybe b",
          "package": "yaml",
          "partial": "Maybe",
          "signature": "(a-\u003eParser b)-\u003ea-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:parseMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "parseMonad",
          "package": "yaml",
          "signature": "(a -\u003e Parser b) -\u003e a -\u003e m b",
          "source": "src/Data-Yaml.html#parseMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "parseMonad",
          "normalized": "(a-\u003eParser b)-\u003ea-\u003ec b",
          "package": "yaml",
          "partial": "Monad",
          "signature": "(a-\u003eParser b)-\u003ea-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:parseMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Yaml",
          "name": "toJSON",
          "package": "yaml",
          "signature": "a -\u003e Value",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "toJSON",
          "normalized": "a-\u003eValue",
          "package": "yaml",
          "partial": "JSON",
          "signature": "a-\u003eValue",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:toJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "yamlColumn",
          "package": "yaml",
          "signature": "Int",
          "source": "src/Text-Libyaml.html#YamlMark",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlColumn\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:yamlColumn\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "yamlColumn",
          "package": "yaml",
          "partial": "Column",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlColumn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "yamlContext",
          "package": "yaml",
          "signature": "String",
          "source": "src/Text-Libyaml.html#YamlException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlContext\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:yamlContext\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "yamlContext",
          "package": "yaml",
          "partial": "Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "yamlIndex",
          "package": "yaml",
          "signature": "Int",
          "source": "src/Text-Libyaml.html#YamlMark",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlIndex\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:yamlIndex\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "yamlIndex",
          "package": "yaml",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "yamlLine",
          "package": "yaml",
          "signature": "Int",
          "source": "src/Text-Libyaml.html#YamlMark",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlLine\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:yamlLine\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "yamlLine",
          "package": "yaml",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "yamlProblem",
          "package": "yaml",
          "signature": "String",
          "source": "src/Text-Libyaml.html#YamlException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlProblem\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:yamlProblem\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "yamlProblem",
          "package": "yaml",
          "partial": "Problem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlProblem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Yaml\",\"Text.Libyaml\"]",
          "name": "yamlProblemMark",
          "package": "yaml",
          "signature": "YamlMark",
          "source": "src/Text-Libyaml.html#YamlException",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlProblemMark\",\"http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:yamlProblemMark\"]"
        },
        "index": {
          "hierarchy": "Data Yaml",
          "module": "Data.Yaml",
          "name": "yamlProblemMark",
          "package": "yaml",
          "partial": "Problem Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Data-Yaml.html#v:yamlProblemMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLow-level, streaming YAML interface. For a higher-level interface, see\n \u003ca\u003eData.Yaml\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Libyaml",
          "name": "Libyaml",
          "package": "yaml",
          "source": "src/Text-Libyaml.html",
          "type": "module"
        },
        "index": {
          "description": "Low-level streaming YAML interface For higher-level interface see Data.Yaml",
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Libyaml",
          "package": "yaml",
          "partial": "Libyaml",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Anchor",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#Anchor",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Anchor",
          "package": "yaml",
          "partial": "Anchor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#t:Anchor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "AnchorName",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#AnchorName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "AnchorName",
          "package": "yaml",
          "partial": "Anchor Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#t:AnchorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Event",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#Event",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Event",
          "package": "yaml",
          "partial": "Event",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#t:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Style",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#Style",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Style",
          "package": "yaml",
          "partial": "Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#t:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Tag",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Tag",
          "package": "yaml",
          "partial": "Tag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#t:Tag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "YamlException",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#YamlException",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "YamlException",
          "package": "yaml",
          "partial": "Yaml Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#t:YamlException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe pointer position\n\u003c/p\u003e",
          "module": "Text.Libyaml",
          "name": "YamlMark",
          "package": "yaml",
          "source": "src/Text-Libyaml.html#YamlMark",
          "type": "data"
        },
        "index": {
          "description": "The pointer position",
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "YamlMark",
          "package": "yaml",
          "partial": "Yaml Mark",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#t:YamlMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Any",
          "package": "yaml",
          "signature": "Any",
          "source": "src/Text-Libyaml.html#Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Any",
          "package": "yaml",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:Any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "BoolTag",
          "package": "yaml",
          "signature": "BoolTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "BoolTag",
          "package": "yaml",
          "partial": "Bool Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:BoolTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "DoubleQuoted",
          "package": "yaml",
          "signature": "DoubleQuoted",
          "source": "src/Text-Libyaml.html#Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "DoubleQuoted",
          "package": "yaml",
          "partial": "Double Quoted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:DoubleQuoted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventAlias",
          "package": "yaml",
          "signature": "EventAlias !AnchorName",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventAlias",
          "package": "yaml",
          "partial": "Event Alias",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventDocumentEnd",
          "package": "yaml",
          "signature": "EventDocumentEnd",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventDocumentEnd",
          "package": "yaml",
          "partial": "Event Document End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventDocumentEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventDocumentStart",
          "package": "yaml",
          "signature": "EventDocumentStart",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventDocumentStart",
          "package": "yaml",
          "partial": "Event Document Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventDocumentStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventMappingEnd",
          "package": "yaml",
          "signature": "EventMappingEnd",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventMappingEnd",
          "package": "yaml",
          "partial": "Event Mapping End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventMappingEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventMappingStart",
          "package": "yaml",
          "signature": "EventMappingStart !Anchor",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventMappingStart",
          "package": "yaml",
          "partial": "Event Mapping Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventMappingStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventScalar",
          "package": "yaml",
          "signature": "EventScalar !ByteString !Tag !Style !Anchor",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventScalar",
          "package": "yaml",
          "partial": "Event Scalar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventSequenceEnd",
          "package": "yaml",
          "signature": "EventSequenceEnd",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventSequenceEnd",
          "package": "yaml",
          "partial": "Event Sequence End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventSequenceEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventSequenceStart",
          "package": "yaml",
          "signature": "EventSequenceStart !Anchor",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventSequenceStart",
          "package": "yaml",
          "partial": "Event Sequence Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventSequenceStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventStreamEnd",
          "package": "yaml",
          "signature": "EventStreamEnd",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventStreamEnd",
          "package": "yaml",
          "partial": "Event Stream End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventStreamEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "EventStreamStart",
          "package": "yaml",
          "signature": "EventStreamStart",
          "source": "src/Text-Libyaml.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "EventStreamStart",
          "package": "yaml",
          "partial": "Event Stream Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:EventStreamStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "FloatTag",
          "package": "yaml",
          "signature": "FloatTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "FloatTag",
          "package": "yaml",
          "partial": "Float Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:FloatTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Folded",
          "package": "yaml",
          "signature": "Folded",
          "source": "src/Text-Libyaml.html#Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Folded",
          "package": "yaml",
          "partial": "Folded",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:Folded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "IntTag",
          "package": "yaml",
          "signature": "IntTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "IntTag",
          "package": "yaml",
          "partial": "Int Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:IntTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Literal",
          "package": "yaml",
          "signature": "Literal",
          "source": "src/Text-Libyaml.html#Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Literal",
          "package": "yaml",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "MapTag",
          "package": "yaml",
          "signature": "MapTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "MapTag",
          "package": "yaml",
          "partial": "Map Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:MapTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "NoTag",
          "package": "yaml",
          "signature": "NoTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "NoTag",
          "package": "yaml",
          "partial": "No Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:NoTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "NullTag",
          "package": "yaml",
          "signature": "NullTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "NullTag",
          "package": "yaml",
          "partial": "Null Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:NullTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "Plain",
          "package": "yaml",
          "signature": "Plain",
          "source": "src/Text-Libyaml.html#Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "Plain",
          "package": "yaml",
          "partial": "Plain",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:Plain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "PlainNoTag",
          "package": "yaml",
          "signature": "PlainNoTag",
          "source": "src/Text-Libyaml.html#Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "PlainNoTag",
          "package": "yaml",
          "partial": "Plain No Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:PlainNoTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "SeqTag",
          "package": "yaml",
          "signature": "SeqTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "SeqTag",
          "package": "yaml",
          "partial": "Seq Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:SeqTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "SetTag",
          "package": "yaml",
          "signature": "SetTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "SetTag",
          "package": "yaml",
          "partial": "Set Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:SetTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "SingleQuoted",
          "package": "yaml",
          "signature": "SingleQuoted",
          "source": "src/Text-Libyaml.html#Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "SingleQuoted",
          "package": "yaml",
          "partial": "Single Quoted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:SingleQuoted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "StrTag",
          "package": "yaml",
          "signature": "StrTag",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "StrTag",
          "package": "yaml",
          "partial": "Str Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:StrTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "UriTag",
          "package": "yaml",
          "signature": "UriTag String",
          "source": "src/Text-Libyaml.html#Tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "UriTag",
          "package": "yaml",
          "partial": "Uri Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:UriTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "decode",
          "package": "yaml",
          "signature": "ByteString -\u003e Producer m Event",
          "source": "src/Text-Libyaml.html#decode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "decode",
          "normalized": "ByteString-\u003eProducer a Event",
          "package": "yaml",
          "signature": "ByteString-\u003eProducer m Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "decodeFile",
          "package": "yaml",
          "signature": "FilePath -\u003e Producer m Event",
          "source": "src/Text-Libyaml.html#decodeFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "decodeFile",
          "normalized": "FilePath-\u003eProducer a Event",
          "package": "yaml",
          "partial": "File",
          "signature": "FilePath-\u003eProducer m Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:decodeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "encode",
          "package": "yaml",
          "signature": "Consumer Event m ByteString",
          "source": "src/Text-Libyaml.html#encode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "encode",
          "package": "yaml",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Libyaml",
          "name": "encodeFile",
          "package": "yaml",
          "signature": "FilePath -\u003e Consumer Event m ()",
          "source": "src/Text-Libyaml.html#encodeFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Libyaml",
          "module": "Text.Libyaml",
          "name": "encodeFile",
          "normalized": "FilePath-\u003eConsumer Event a()",
          "package": "yaml",
          "partial": "File",
          "signature": "FilePath-\u003eConsumer Event m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yaml/docs/Text-Libyaml.html#v:encodeFile"
      }
    }
  ]
]