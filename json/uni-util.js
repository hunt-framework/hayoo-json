[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "uni-util"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAtomString atomises strings.  Right now this code\n is not very efficient but it shouldn't be too hard\n to improve.\n\u003c/p\u003e\u003cp\u003eThis code includes no less that 3 uses of unsafePerformIO.  Oh well.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.AtomString",
          "name": "AtomString",
          "package": "uni-util",
          "source": "src/Util-AtomString.html",
          "type": "module"
        },
        "index": {
          "description": "AtomString atomises strings Right now this code is not very efficient but it shouldn be too hard to improve This code includes no less that uses of unsafePerformIO Oh well",
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "AtomString",
          "package": "uni-util",
          "partial": "Atom String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "AtomString",
          "package": "uni-util",
          "source": "src/Util-AtomString.html#AtomString",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "AtomString",
          "package": "uni-util",
          "partial": "Atom String",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#t:AtomString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "Str",
          "package": "uni-util",
          "source": "src/Util-AtomString.html#Str",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "Str",
          "package": "uni-util",
          "partial": "Str",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#t:Str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "StringClass",
          "package": "uni-util",
          "source": "src/Util-AtomString.html#StringClass",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "StringClass",
          "package": "uni-util",
          "partial": "String Class",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#t:StringClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "Str",
          "package": "uni-util",
          "signature": "Str a",
          "source": "src/Util-AtomString.html#Str",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "Str",
          "package": "uni-util",
          "partial": "Str",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:Str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "firstAtomString",
          "package": "uni-util",
          "signature": "AtomString",
          "source": "src/Util-AtomString.html#firstAtomString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "firstAtomString",
          "package": "uni-util",
          "partial": "Atom String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:firstAtomString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "fromString",
          "package": "uni-util",
          "signature": "String -\u003e stringClass",
          "source": "src/Util-AtomString.html#fromString",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "fromString",
          "normalized": "String-\u003ea",
          "package": "uni-util",
          "partial": "String",
          "signature": "String-\u003estringClass",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:fromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "fromStringError",
          "package": "uni-util",
          "signature": "String -\u003e a",
          "source": "src/Util-AtomString.html#fromStringError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "fromStringError",
          "normalized": "String-\u003ea",
          "package": "uni-util",
          "partial": "String Error",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:fromStringError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "fromStringWE",
          "package": "uni-util",
          "signature": "String -\u003e WithError stringClass",
          "source": "src/Util-AtomString.html#fromStringWE",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "fromStringWE",
          "normalized": "String-\u003eWithError a",
          "package": "uni-util",
          "partial": "String WE",
          "signature": "String-\u003eWithError stringClass",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:fromStringWE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "fromStringWEHacked",
          "package": "uni-util",
          "signature": "String -\u003e IO (WithError stringClass)",
          "source": "src/Util-AtomString.html#fromStringWEHacked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "fromStringWEHacked",
          "normalized": "String-\u003eIO(WithError a)",
          "package": "uni-util",
          "partial": "String WEHacked",
          "signature": "String-\u003eIO(WithError stringClass)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:fromStringWEHacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "mkFromStringWE",
          "package": "uni-util",
          "signature": "Parser stringClass -\u003e String -\u003e String -\u003e WithError stringClass",
          "source": "src/Util-AtomString.html#mkFromStringWE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "mkFromStringWE",
          "normalized": "Parser a-\u003eString-\u003eString-\u003eWithError a",
          "package": "uni-util",
          "partial": "From String WE",
          "signature": "Parser stringClass-\u003eString-\u003eString-\u003eWithError stringClass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:mkFromStringWE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.AtomString",
          "name": "toString",
          "package": "uni-util",
          "signature": "stringClass -\u003e String",
          "source": "src/Util-AtomString.html#toString",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util AtomString",
          "module": "Util.AtomString",
          "name": "toString",
          "normalized": "a-\u003eString",
          "package": "uni-util",
          "partial": "String",
          "signature": "stringClass-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-AtomString.html#v:toString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLibrary for converting types to and from binary, so that they can\nbe written to and from files, stored compactly in memory, and so on.\n\u003c/p\u003e\u003cp\u003eThis is a preliminary version of the library, hence I have decided\n\u003cem\u003enot\u003c/em\u003e to optimise heavily, beyond putting in strictness annotations\nin where they seem appropriate.\n\u003c/p\u003e\u003cp\u003eA good place to start optimising would probably be the separate\n\u003ca\u003eBytes\u003c/a\u003e libary.\n\u003c/p\u003e\u003cp\u003eSee also \u003ca\u003eBinaryInstances\u003c/a\u003e, which declares instances for the standard\ntypes (and one or two others), \u003ca\u003eBinaryUtils\u003c/a\u003e, which contains\n(mostly) material for declaring new instances, \u003ca\u003eBinaryExtras\u003c/a\u003e,\nwhich contains other miscellaneous utilities, and finally\n\u003ca\u003eBinaryAll\u003c/a\u003e which just imports and reexports everything. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Binary",
          "name": "Binary",
          "package": "uni-util",
          "source": "src/Util-Binary.html",
          "type": "module"
        },
        "index": {
          "description": "Library for converting types to and from binary so that they can be written to and from files stored compactly in memory and so on This is preliminary version of the library hence have decided not to optimise heavily beyond putting in strictness annotations in where they seem appropriate good place to start optimising would probably be the separate Bytes libary See also BinaryInstances which declares instances for the standard types and one or two others BinaryUtils which contains mostly material for declaring new instances BinaryExtras which contains other miscellaneous utilities and finally BinaryAll which just imports and reexports everything",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "Binary",
          "package": "uni-util",
          "partial": "Binary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSomewhere to where you write binary data in memory.\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "BinArea",
          "package": "uni-util",
          "source": "src/Util-Binary.html#BinArea",
          "type": "data"
        },
        "index": {
          "description": "Somewhere to where you write binary data in memory",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "BinArea",
          "package": "uni-util",
          "partial": "Bin Area",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#t:BinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "HasBinary",
          "package": "uni-util",
          "source": "src/Util-Binary.html#HasBinary",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "HasBinary",
          "package": "uni-util",
          "partial": "Has Binary",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#t:HasBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA source of binary data\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "ReadBinary",
          "package": "uni-util",
          "source": "src/Util-Binary.html#ReadBinary",
          "type": "data"
        },
        "index": {
          "description": "source of binary data",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "ReadBinary",
          "package": "uni-util",
          "partial": "Read Binary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#t:ReadBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea state monad containing the BinArea.\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "StateBinArea",
          "package": "uni-util",
          "source": "src/Util-Binary.html#StateBinArea",
          "type": "type"
        },
        "index": {
          "description": "state monad containing the BinArea",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "StateBinArea",
          "package": "uni-util",
          "partial": "State Bin Area",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#t:StateBinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA consumer of binary data\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "WriteBinary",
          "package": "uni-util",
          "source": "src/Util-Binary.html#WriteBinary",
          "type": "data"
        },
        "index": {
          "description": "consumer of binary data",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "WriteBinary",
          "package": "uni-util",
          "partial": "Write Binary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#t:WriteBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "ReadBinary",
          "package": "uni-util",
          "signature": "ReadBinary",
          "source": "src/Util-Binary.html#ReadBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "ReadBinary",
          "package": "uni-util",
          "partial": "Read Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:ReadBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "WriteBinary",
          "package": "uni-util",
          "signature": "WriteBinary",
          "source": "src/Util-Binary.html#WriteBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "WriteBinary",
          "package": "uni-util",
          "partial": "Write Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:WriteBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "checkFullBinArea",
          "package": "uni-util",
          "signature": "BinArea -\u003e IO ()",
          "source": "src/Util-Binary.html#checkFullBinArea",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "checkFullBinArea",
          "normalized": "BinArea-\u003eIO()",
          "package": "uni-util",
          "partial": "Full Bin Area",
          "signature": "BinArea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:checkFullBinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all the data currently in the \u003ccode\u003e\u003ca\u003eBinArea\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "closeBinArea",
          "package": "uni-util",
          "signature": "BinArea -\u003e IO (Bytes, Int)",
          "source": "src/Util-Binary.html#closeBinArea",
          "type": "function"
        },
        "index": {
          "description": "Return all the data currently in the BinArea",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "closeBinArea",
          "normalized": "BinArea-\u003eIO(Bytes,Int)",
          "package": "uni-util",
          "partial": "Bin Area",
          "signature": "BinArea-\u003eIO(Bytes,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:closeBinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead an (a) from a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "hRead",
          "package": "uni-util",
          "signature": "Handle -\u003e IO a",
          "source": "src/Util-Binary.html#hRead",
          "type": "function"
        },
        "index": {
          "description": "Read an from Handle",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "hRead",
          "normalized": "Handle-\u003eIO a",
          "package": "uni-util",
          "partial": "Read",
          "signature": "Handle-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:hRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite an (a) to a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "hWrite",
          "package": "uni-util",
          "signature": "Handle -\u003e a -\u003e IO ()",
          "source": "src/Util-Binary.html#hWrite",
          "type": "function"
        },
        "index": {
          "description": "Write an to Handle",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "hWrite",
          "normalized": "Handle-\u003ea-\u003eIO()",
          "package": "uni-util",
          "partial": "Write",
          "signature": "Handle-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:hWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform the monad used by a \u003ccode\u003e\u003ca\u003eReadBinary\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "liftReadBinary",
          "package": "uni-util",
          "signature": "(forall a.  m a -\u003e n a) -\u003e ReadBinary m -\u003e ReadBinary n",
          "source": "src/Util-Binary.html#liftReadBinary",
          "type": "function"
        },
        "index": {
          "description": "Transform the monad used by ReadBinary",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "liftReadBinary",
          "normalized": "(a b c d-\u003ee d)-\u003eReadBinary c-\u003eReadBinary e",
          "package": "uni-util",
          "partial": "Read Binary",
          "signature": "(forall a. m a-\u003en a)-\u003eReadBinary m-\u003eReadBinary n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:liftReadBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform the monad used by a \u003ccode\u003e\u003ca\u003eWriteBinary\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "liftWriteBinary",
          "package": "uni-util",
          "signature": "(forall a.  m a -\u003e n a) -\u003e WriteBinary m -\u003e WriteBinary n",
          "source": "src/Util-Binary.html#liftWriteBinary",
          "type": "function"
        },
        "index": {
          "description": "Transform the monad used by WriteBinary",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "liftWriteBinary",
          "normalized": "(a b c d-\u003ee d)-\u003eWriteBinary c-\u003eWriteBinary e",
          "package": "uni-util",
          "partial": "Write Binary",
          "signature": "(forall a. m a-\u003en a)-\u003eWriteBinary m-\u003eWriteBinary n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:liftWriteBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn binary data in memory into a \u003ccode\u003e\u003ca\u003eBinArea\u003c/a\u003e\u003c/code\u003e (so that you can\nread from it). \n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "mkBinArea",
          "package": "uni-util",
          "signature": "(Bytes, Int) -\u003e BinArea",
          "source": "src/Util-Binary.html#mkBinArea",
          "type": "function"
        },
        "index": {
          "description": "Turn binary data in memory into BinArea so that you can read from it",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "mkBinArea",
          "normalized": "(Bytes,Int)-\u003eBinArea",
          "package": "uni-util",
          "partial": "Bin Area",
          "signature": "(Bytes,Int)-\u003eBinArea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:mkBinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an empty \u003ccode\u003e\u003ca\u003eBinArea\u003c/a\u003e\u003c/code\u003e, given the initial size.\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "mkEmptyBinArea",
          "package": "uni-util",
          "signature": "Int -\u003e IO BinArea",
          "source": "src/Util-Binary.html#mkEmptyBinArea",
          "type": "function"
        },
        "index": {
          "description": "Create an empty BinArea given the initial size",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "mkEmptyBinArea",
          "normalized": "Int-\u003eIO BinArea",
          "package": "uni-util",
          "partial": "Empty Bin Area",
          "signature": "Int-\u003eIO BinArea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:mkEmptyBinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "readBin",
          "package": "uni-util",
          "signature": "readBin",
          "source": "src/Util-Binary.html#readBin",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "readBin",
          "package": "uni-util",
          "partial": "Bin",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:readBin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA BinArea as a source of binary data.\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "readBinaryBinArea",
          "package": "uni-util",
          "signature": "ReadBinary StateBinArea",
          "source": "src/Util-Binary.html#readBinaryBinArea",
          "type": "function"
        },
        "index": {
          "description": "BinArea as source of binary data",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "readBinaryBinArea",
          "package": "uni-util",
          "partial": "Binary Bin Area",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:readBinaryBinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread one byte\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "readByte",
          "package": "uni-util",
          "signature": "m Byte",
          "source": "src/Util-Binary.html#ReadBinary",
          "type": "function"
        },
        "index": {
          "description": "read one byte",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "readByte",
          "package": "uni-util",
          "partial": "Byte",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:readByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread multiple bytes\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "readBytes",
          "package": "uni-util",
          "signature": "Int -\u003e m Bytes",
          "source": "src/Util-Binary.html#ReadBinary",
          "type": "function"
        },
        "index": {
          "description": "read multiple bytes",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "readBytes",
          "normalized": "Int-\u003ea Bytes",
          "package": "uni-util",
          "partial": "Bytes",
          "signature": "Int-\u003em Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:readBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a value from binary data in memory.  The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e is the length,\nand there will be an error if this is either too small or too large. \n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "readFromBytes",
          "package": "uni-util",
          "signature": "(Bytes, Int) -\u003e IO a",
          "source": "src/Util-Binary.html#readFromBytes",
          "type": "function"
        },
        "index": {
          "description": "Read value from binary data in memory The Int is the length and there will be an error if this is either too small or too large",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "readFromBytes",
          "normalized": "(Bytes,Int)-\u003eIO a",
          "package": "uni-util",
          "partial": "From Bytes",
          "signature": "(Bytes,Int)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:readFromBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "toReadBinaryHandle",
          "package": "uni-util",
          "signature": "Handle -\u003e ReadBinary IO",
          "source": "src/Util-Binary.html#toReadBinaryHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "toReadBinaryHandle",
          "normalized": "Handle-\u003eReadBinary IO",
          "package": "uni-util",
          "partial": "Read Binary Handle",
          "signature": "Handle-\u003eReadBinary IO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:toReadBinaryHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "toWriteBinaryHandle",
          "package": "uni-util",
          "signature": "Handle -\u003e WriteBinary IO",
          "source": "src/Util-Binary.html#toWriteBinaryHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "toWriteBinaryHandle",
          "normalized": "Handle-\u003eWriteBinary IO",
          "package": "uni-util",
          "partial": "Write Binary Handle",
          "signature": "Handle-\u003eWriteBinary IO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:toWriteBinaryHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Binary",
          "name": "writeBin",
          "package": "uni-util",
          "signature": "writeBin",
          "source": "src/Util-Binary.html#writeBin",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "writeBin",
          "package": "uni-util",
          "partial": "Bin",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:writeBin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBinArea\u003c/a\u003e\u003c/code\u003e as somewhere to put binary data.\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "writeBinaryBinArea",
          "package": "uni-util",
          "signature": "WriteBinary StateBinArea",
          "source": "src/Util-Binary.html#writeBinaryBinArea",
          "type": "function"
        },
        "index": {
          "description": "BinArea as somewhere to put binary data",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "writeBinaryBinArea",
          "package": "uni-util",
          "partial": "Binary Bin Area",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:writeBinaryBinArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrite one byte\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "writeByte",
          "package": "uni-util",
          "signature": "Byte -\u003e m ()",
          "source": "src/Util-Binary.html#WriteBinary",
          "type": "function"
        },
        "index": {
          "description": "write one byte",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "writeByte",
          "normalized": "Byte-\u003ea()",
          "package": "uni-util",
          "partial": "Byte",
          "signature": "Byte-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:writeByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrite multiple bytes\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "writeBytes",
          "package": "uni-util",
          "signature": "Bytes -\u003e Int -\u003e m ()",
          "source": "src/Util-Binary.html#WriteBinary",
          "type": "function"
        },
        "index": {
          "description": "write multiple bytes",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "writeBytes",
          "normalized": "Bytes-\u003eInt-\u003ea()",
          "package": "uni-util",
          "partial": "Bytes",
          "signature": "Bytes-\u003eInt-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:writeBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite an (a) to memory.  The \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e is the length of the area.\n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "writeToBytes",
          "package": "uni-util",
          "signature": "a -\u003e IO (Bytes, Int)",
          "source": "src/Util-Binary.html#writeToBytes",
          "type": "function"
        },
        "index": {
          "description": "Write an to memory The Int is the length of the area",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "writeToBytes",
          "normalized": "a-\u003eIO(Bytes,Int)",
          "package": "uni-util",
          "partial": "To Bytes",
          "signature": "a-\u003eIO(Bytes,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:writeToBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite an (a) to memory.\nThe integer argument is an initial guess at the number of bytes\nthat will be needed.  This should be greater than 0.  If it is\ntoo small, there will be unnecessary reallocations; if too large,\ntoo much memory will be used. \n\u003c/p\u003e",
          "module": "Util.Binary",
          "name": "writeToBytes0",
          "package": "uni-util",
          "signature": "Int -\u003e a -\u003e IO (Bytes, Int)",
          "source": "src/Util-Binary.html#writeToBytes0",
          "type": "function"
        },
        "index": {
          "description": "Write an to memory The integer argument is an initial guess at the number of bytes that will be needed This should be greater than If it is too small there will be unnecessary reallocations if too large too much memory will be used",
          "hierarchy": "Util Binary",
          "module": "Util.Binary",
          "name": "writeToBytes0",
          "normalized": "Int-\u003ea-\u003eIO(Bytes,Int)",
          "package": "uni-util",
          "partial": "To Bytes",
          "signature": "Int-\u003ea-\u003eIO(Bytes,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Binary.html#v:writeToBytes0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule which includes all the Binary stuff.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.BinaryAll",
          "name": "BinaryAll",
          "package": "uni-util",
          "source": "src/Util-BinaryAll.html",
          "type": "module"
        },
        "index": {
          "description": "Module which includes all the Binary stuff",
          "hierarchy": "Util BinaryAll",
          "module": "Util.BinaryAll",
          "name": "BinaryAll",
          "package": "uni-util",
          "partial": "Binary All",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryAll.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains various extra Binary instances, for example ones\n which are particular GHC or uni-specific.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.BinaryExtras",
          "name": "BinaryExtras",
          "package": "uni-util",
          "source": "src/Util-BinaryExtras.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains various extra Binary instances for example ones which are particular GHC or uni-specific",
          "hierarchy": "Util BinaryExtras",
          "module": "Util.BinaryExtras",
          "name": "BinaryExtras",
          "package": "uni-util",
          "partial": "Binary Extras",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryExtras.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead something, but throw an exception if there is an attempt to\n read too many characters.\n\u003c/p\u003e",
          "module": "Util.BinaryExtras",
          "name": "hReadLtd",
          "package": "uni-util",
          "signature": "Int-\u003e Handle-\u003e IO (WithError a)",
          "type": "function"
        },
        "index": {
          "description": "Read something but throw an exception if there is an attempt to read too many characters",
          "hierarchy": "Util BinaryExtras",
          "module": "Util.BinaryExtras",
          "name": "hReadLtd",
          "normalized": "Int-\u003eHandle-\u003eIO(WithError a)",
          "package": "uni-util",
          "partial": "Read Ltd",
          "signature": "Int-\u003eHandle-\u003eIO(WithError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryExtras.html#v:hReadLtd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTime this code was written.  We bung this definition in here\n because this module needs GHC-specific access to ClockTime anyway.\n\u003c/p\u003e",
          "module": "Util.BinaryExtras",
          "name": "initialClockTime",
          "package": "uni-util",
          "signature": "ClockTime",
          "source": "src/Util-BinaryExtras.html#initialClockTime",
          "type": "function"
        },
        "index": {
          "description": "Time this code was written We bung this definition in here because this module needs GHC-specific access to ClockTime anyway",
          "hierarchy": "Util BinaryExtras",
          "module": "Util.BinaryExtras",
          "name": "initialClockTime",
          "package": "uni-util",
          "partial": "Clock Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryExtras.html#v:initialClockTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInstances of the \u003ccode\u003e\u003ca\u003eHasBinary\u003c/a\u003e\u003c/code\u003e class.  This includes the\n standard types (except of course for things like function types and\n IO) plus a few others.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.BinaryInstances",
          "name": "BinaryInstances",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html",
          "type": "module"
        },
        "index": {
          "description": "Instances of the HasBinary class This includes the standard types except of course for things like function types and IO plus few others",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "BinaryInstances",
          "package": "uni-util",
          "partial": "Binary Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a rather inelegant way of encoding a type with up to\n 5 alternatives.  If 5 is too many, use () for the others, if too\n few use \u003ccode\u003e\u003ca\u003eHasWrapper\u003c/a\u003e\u003c/code\u003e.  In fact \u003ccode\u003e\u003ca\u003eHasWrapper\u003c/a\u003e\u003c/code\u003e is probably better\n anyway.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "Choice5",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html#Choice5",
          "type": "data"
        },
        "index": {
          "description": "This is rather inelegant way of encoding type with up to alternatives If is too many use for the others if too few use HasWrapper In fact HasWrapper is probably better anyway",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Choice5",
          "package": "uni-util",
          "partial": "Choice",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#t:Choice5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class allowing you to handle types with up to 256 alternatives.\n If this all seems to complicated, look at the source file and\n the example for the \"Tree\" data type.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "HasWrapper",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html#HasWrapper",
          "type": "class"
        },
        "index": {
          "description": "class allowing you to handle types with up to alternatives If this all seems to complicated look at the source file and the example for the Tree data type",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "HasWrapper",
          "package": "uni-util",
          "partial": "Has Wrapper",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#t:HasWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype alias for things we want to encode or decode via their\n \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e representation.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "ReadShow",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html#ReadShow",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype alias for things we want to encode or decode via their Read or Show String representation",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "ReadShow",
          "package": "uni-util",
          "partial": "Read Show",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#t:ReadShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue the \u003ccode\u003e\u003ca\u003eHasWrapper\u003c/a\u003e\u003c/code\u003e instance generates from \u003ccode\u003e\u003ca\u003eunWrap\u003c/a\u003e\u003c/code\u003e to\n indicate how we should write some value to binary.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "UnWrap",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html#UnWrap",
          "type": "data"
        },
        "index": {
          "description": "Value the HasWrapper instance generates from unWrap to indicate how we should write some value to binary",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "UnWrap",
          "package": "uni-util",
          "partial": "Un Wrap",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#t:UnWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an \u003ccode\u003enewtype\u003c/code\u003e alias for integral types where the user promises\n that the value will be non-negative, and so saves us a bit.\n This is what we use for character data incidentally, so that\n ASCII characters with codes \u003c128 can be encoded (as themselves) in\n just one byte.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "Unsigned",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html#Unsigned",
          "type": "newtype"
        },
        "index": {
          "description": "This is an newtype alias for integral types where the user promises that the value will be non-negative and so saves us bit This is what we use for character data incidentally so that ASCII characters with codes can be encoded as themselves in just one byte",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Unsigned",
          "package": "uni-util",
          "partial": "Unsigned",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#t:Unsigned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "ViaEnum",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html#ViaEnum",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "ViaEnum",
          "package": "uni-util",
          "partial": "Via Enum",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#t:ViaEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewtype alias you need to wrap around something which instances\n \u003ccode\u003e\u003ca\u003eHasWrapper\u003c/a\u003e\u003c/code\u003e to get an actual HasBinary instance.  You will then\n need something like this:\n\u003c/p\u003e\u003cpre\u003e instance Monad m =\u003e HasBinary a m where\n   writeBin = mapWrite Wrapped\n   readBin = mapRead wrapped\n\u003c/pre\u003e",
          "module": "Util.BinaryInstances",
          "name": "Wrapped",
          "package": "uni-util",
          "source": "src/Util-BinaryInstances.html#Wrapped",
          "type": "newtype"
        },
        "index": {
          "description": "Newtype alias you need to wrap around something which instances HasWrapper to get an actual HasBinary instance You will then need something like this instance Monad HasBinary where writeBin mapWrite Wrapped readBin mapRead wrapped",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Wrapped",
          "package": "uni-util",
          "partial": "Wrapped",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#t:Wrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "Choice1",
          "package": "uni-util",
          "signature": "Choice1 v1",
          "source": "src/Util-BinaryInstances.html#Choice5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Choice1",
          "package": "uni-util",
          "partial": "Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:Choice1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "Choice2",
          "package": "uni-util",
          "signature": "Choice2 v2",
          "source": "src/Util-BinaryInstances.html#Choice5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Choice2",
          "package": "uni-util",
          "partial": "Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:Choice2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "Choice3",
          "package": "uni-util",
          "signature": "Choice3 v3",
          "source": "src/Util-BinaryInstances.html#Choice5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Choice3",
          "package": "uni-util",
          "partial": "Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:Choice3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "Choice4",
          "package": "uni-util",
          "signature": "Choice4 v4",
          "source": "src/Util-BinaryInstances.html#Choice5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Choice4",
          "package": "uni-util",
          "partial": "Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:Choice4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "Choice5",
          "package": "uni-util",
          "signature": "Choice5 v5",
          "source": "src/Util-BinaryInstances.html#Choice5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Choice5",
          "package": "uni-util",
          "partial": "Choice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:Choice5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "ReadShow",
          "package": "uni-util",
          "signature": "ReadShow a",
          "source": "src/Util-BinaryInstances.html#ReadShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "ReadShow",
          "package": "uni-util",
          "partial": "Read Show",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:ReadShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "UnWrap",
          "package": "uni-util",
          "signature": "UnWrap Byte val",
          "source": "src/Util-BinaryInstances.html#UnWrap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "UnWrap",
          "package": "uni-util",
          "partial": "Un Wrap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:UnWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "Unsigned",
          "package": "uni-util",
          "signature": "Unsigned integral",
          "source": "src/Util-BinaryInstances.html#Unsigned",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Unsigned",
          "package": "uni-util",
          "partial": "Unsigned",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:Unsigned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "ViaEnum",
          "package": "uni-util",
          "signature": "ViaEnum",
          "source": "src/Util-BinaryInstances.html#ViaEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "ViaEnum",
          "package": "uni-util",
          "partial": "Via Enum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:ViaEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "Wrapped",
          "package": "uni-util",
          "signature": "Wrapped",
          "source": "src/Util-BinaryInstances.html#Wrapped",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "Wrapped",
          "package": "uni-util",
          "partial": "Wrapped",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:Wrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "enum",
          "package": "uni-util",
          "signature": "a",
          "source": "src/Util-BinaryInstances.html#ViaEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "enum",
          "package": "uni-util",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "unWrap",
          "package": "uni-util",
          "signature": "unWrap",
          "source": "src/Util-BinaryInstances.html#unWrap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "unWrap",
          "package": "uni-util",
          "partial": "Wrap",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:unWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eWrap\u003c/code\u003e value for constructor with no arguments.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "wrap0",
          "package": "uni-util",
          "signature": "Byte -\u003e wrapper -\u003e Wrap wrapper m",
          "source": "src/Util-BinaryInstances.html#wrap0",
          "type": "function"
        },
        "index": {
          "description": "Wrap value for constructor with no arguments",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "wrap0",
          "normalized": "Byte-\u003ea-\u003eWrap a b",
          "package": "uni-util",
          "signature": "Byte-\u003ewrapper-\u003eWrap wrapper m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:wrap0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eWrap\u003c/code\u003e value for constructor with 1 argument.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "wrap1",
          "package": "uni-util",
          "signature": "Byte -\u003e (val -\u003e wrapper) -\u003e Wrap wrapper m",
          "source": "src/Util-BinaryInstances.html#wrap1",
          "type": "function"
        },
        "index": {
          "description": "Wrap value for constructor with argument",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "wrap1",
          "normalized": "Byte-\u003e(a-\u003eb)-\u003eWrap b c",
          "package": "uni-util",
          "signature": "Byte-\u003e(val-\u003ewrapper)-\u003eWrap wrapper m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:wrap1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eWrap\u003c/code\u003e value for constructor with 2 arguments.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "wrap2",
          "package": "uni-util",
          "signature": "Byte -\u003e (val1 -\u003e val2 -\u003e wrapper) -\u003e Wrap wrapper m",
          "source": "src/Util-BinaryInstances.html#wrap2",
          "type": "function"
        },
        "index": {
          "description": "Wrap value for constructor with arguments",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "wrap2",
          "normalized": "Byte-\u003e(a-\u003ea-\u003eb)-\u003eWrap b c",
          "package": "uni-util",
          "signature": "Byte-\u003e(val-\u003eval-\u003ewrapper)-\u003eWrap wrapper m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:wrap2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eWrap\u003c/code\u003e value for constructor with 3 arguments.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "wrap3",
          "package": "uni-util",
          "signature": "Byte -\u003e (val1 -\u003e val2 -\u003e val3 -\u003e wrapper) -\u003e Wrap wrapper m",
          "source": "src/Util-BinaryInstances.html#wrap3",
          "type": "function"
        },
        "index": {
          "description": "Wrap value for constructor with arguments",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "wrap3",
          "normalized": "Byte-\u003e(a-\u003ea-\u003ea-\u003eb)-\u003eWrap b c",
          "package": "uni-util",
          "signature": "Byte-\u003e(val-\u003eval-\u003eval-\u003ewrapper)-\u003eWrap wrapper m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:wrap3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eWrap\u003c/code\u003e value for constructor with 4 arguments.\n\u003c/p\u003e",
          "module": "Util.BinaryInstances",
          "name": "wrap4",
          "package": "uni-util",
          "signature": "Byte -\u003e (val1 -\u003e val2 -\u003e val3 -\u003e val4 -\u003e wrapper) -\u003e Wrap wrapper m",
          "source": "src/Util-BinaryInstances.html#wrap4",
          "type": "function"
        },
        "index": {
          "description": "Wrap value for constructor with arguments",
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "wrap4",
          "normalized": "Byte-\u003e(a-\u003ea-\u003ea-\u003ea-\u003eb)-\u003eWrap b c",
          "package": "uni-util",
          "signature": "Byte-\u003e(val-\u003eval-\u003eval-\u003eval-\u003ewrapper)-\u003eWrap wrapper m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:wrap4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "wrapped",
          "package": "uni-util",
          "signature": "a",
          "source": "src/Util-BinaryInstances.html#Wrapped",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "wrapped",
          "package": "uni-util",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:wrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryInstances",
          "name": "wraps",
          "package": "uni-util",
          "signature": "wraps",
          "source": "src/Util-BinaryInstances.html#wraps",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util BinaryInstances",
          "module": "Util.BinaryInstances",
          "name": "wraps",
          "package": "uni-util",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryInstances.html#v:wraps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious functions for declaring new instances of Binary for types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.BinaryUtils",
          "name": "BinaryUtils",
          "package": "uni-util",
          "source": "src/Util-BinaryUtils.html",
          "type": "module"
        },
        "index": {
          "description": "Various functions for declaring new instances of Binary for types",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "BinaryUtils",
          "package": "uni-util",
          "partial": "Binary Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monad which hides an additional value which the \u003ccode\u003e\u003ca\u003eHasBinary\u003c/a\u003e\u003c/code\u003e\n instances should be able to get at.  This is used, for example,\n by \u003ca\u003eCodedValue\u003c/a\u003e, to make the \u003ccode\u003eView\u003c/code\u003e available to instances.\n\u003c/p\u003e",
          "module": "Util.BinaryUtils",
          "name": "ArgMonad",
          "package": "uni-util",
          "source": "src/Util-BinaryUtils.html#ArgMonad",
          "type": "data"
        },
        "index": {
          "description": "monad which hides an additional value which the HasBinary instances should be able to get at This is used for example by CodedValue to make the View available to instances",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "ArgMonad",
          "package": "uni-util",
          "partial": "Arg Monad",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#t:ArgMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "WrapBinary",
          "package": "uni-util",
          "source": "src/Util-BinaryUtils.html#WrapBinary",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "WrapBinary",
          "package": "uni-util",
          "partial": "Wrap Binary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#t:WrapBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA wrapper for instances of Binary.  This can be written, but not\n read (since we wouldn't know what type to decode).\n\u003c/p\u003e",
          "module": "Util.BinaryUtils",
          "name": "WrappedBinary",
          "package": "uni-util",
          "source": "src/Util-BinaryUtils.html#WrappedBinary",
          "type": "data"
        },
        "index": {
          "description": "wrapper for instances of Binary This can be written but not read since we wouldn know what type to decode",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "WrappedBinary",
          "package": "uni-util",
          "partial": "Wrapped Binary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#t:WrappedBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "WrapBinary",
          "package": "uni-util",
          "signature": "WrapBinary v",
          "source": "src/Util-BinaryUtils.html#WrapBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "WrapBinary",
          "package": "uni-util",
          "partial": "Wrap Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:WrapBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "WrappedBinary",
          "package": "uni-util",
          "signature": "WrappedBinary v",
          "source": "src/Util-BinaryUtils.html#WrappedBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "WrappedBinary",
          "package": "uni-util",
          "partial": "Wrapped Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:WrappedBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a \u003ccode\u003e\u003ca\u003eWrappedBinary\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.BinaryUtils",
          "name": "hWriteWrappedBinary",
          "package": "uni-util",
          "signature": "Handle -\u003e WrappedBinary -\u003e IO ()",
          "source": "src/Util-BinaryUtils.html#hWriteWrappedBinary",
          "type": "function"
        },
        "index": {
          "description": "Write WrappedBinary",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "hWriteWrappedBinary",
          "normalized": "Handle-\u003eWrappedBinary-\u003eIO()",
          "package": "uni-util",
          "partial": "Write Wrapped Binary",
          "signature": "Handle-\u003eWrappedBinary-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:hWriteWrappedBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a function which converts something we can already read from\n binary to (a), return a \u003ccode\u003e\u003ca\u003ereadBin\u003c/a\u003e\u003c/code\u003e function to be used in instances\n of \u003ccode\u003e\u003ca\u003eHasBinary\u003c/a\u003e\u003c/code\u003e (a).\n\u003c/p\u003e",
          "module": "Util.BinaryUtils",
          "name": "mapRead",
          "package": "uni-util",
          "signature": "(b -\u003e a) -\u003e ReadBinary m -\u003e m a",
          "source": "src/Util-BinaryUtils.html#mapRead",
          "type": "function"
        },
        "index": {
          "description": "Given function which converts something we can already read from binary to return readBin function to be used in instances of HasBinary",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "mapRead",
          "normalized": "(a-\u003eb)-\u003eReadBinary c-\u003ec b",
          "package": "uni-util",
          "partial": "Read",
          "signature": "(b-\u003ea)-\u003eReadBinary m-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:mapRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLIke \u003ccode\u003e\u003ca\u003emapRead\u003c/a\u003e\u003c/code\u003e, but the conversion function is also allowed to use\n \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.BinaryUtils",
          "name": "mapReadIO",
          "package": "uni-util",
          "signature": "(b -\u003e IO a) -\u003e ReadBinary m -\u003e m a",
          "source": "src/Util-BinaryUtils.html#mapReadIO",
          "type": "function"
        },
        "index": {
          "description": "LIke mapRead but the conversion function is also allowed to use IO",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "mapReadIO",
          "normalized": "(a-\u003eIO b)-\u003eReadBinary c-\u003ec b",
          "package": "uni-util",
          "partial": "Read IO",
          "signature": "(b-\u003eIO a)-\u003eReadBinary m-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:mapReadIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a function which converts an (a) to something we can already\n convert to binary, return a \u003ccode\u003e\u003ca\u003ewriteBin\u003c/a\u003e\u003c/code\u003e function to be used in\n instances of \u003ccode\u003e\u003ca\u003eHasBinary\u003c/a\u003e\u003c/code\u003e (a).\n\u003c/p\u003e",
          "module": "Util.BinaryUtils",
          "name": "mapWrite",
          "package": "uni-util",
          "signature": "(a -\u003e b) -\u003e WriteBinary m -\u003e a -\u003e m ()",
          "source": "src/Util-BinaryUtils.html#mapWrite",
          "type": "function"
        },
        "index": {
          "description": "Given function which converts an to something we can already convert to binary return writeBin function to be used in instances of HasBinary",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "mapWrite",
          "normalized": "(a-\u003eb)-\u003eWriteBinary c-\u003ea-\u003ec()",
          "package": "uni-util",
          "partial": "Write",
          "signature": "(a-\u003eb)-\u003eWriteBinary m-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:mapWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003emapWrite\u003c/a\u003e\u003c/code\u003e, but the conversion function is also allowed to use\n \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.BinaryUtils",
          "name": "mapWriteIO",
          "package": "uni-util",
          "signature": "(a -\u003e IO b) -\u003e WriteBinary m -\u003e a -\u003e m ()",
          "source": "src/Util-BinaryUtils.html#mapWriteIO",
          "type": "function"
        },
        "index": {
          "description": "Like mapWrite but the conversion function is also allowed to use IO",
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "mapWriteIO",
          "normalized": "(a-\u003eIO b)-\u003eWriteBinary c-\u003ea-\u003ec()",
          "package": "uni-util",
          "partial": "Write IO",
          "signature": "(a-\u003eIO b)-\u003eWriteBinary m-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:mapWriteIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "mkArgMonad",
          "package": "uni-util",
          "signature": "(arg -\u003e m a) -\u003e ArgMonad arg m a",
          "source": "src/Util-BinaryUtils.html#mkArgMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "mkArgMonad",
          "normalized": "(a-\u003eb c)-\u003eArgMonad a b c",
          "package": "uni-util",
          "partial": "Arg Monad",
          "signature": "(arg-\u003em a)-\u003eArgMonad arg m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:mkArgMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "readBinaryToArgMonad",
          "package": "uni-util",
          "signature": "ReadBinary m -\u003e ReadBinary (ArgMonad arg m)",
          "source": "src/Util-BinaryUtils.html#readBinaryToArgMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "readBinaryToArgMonad",
          "normalized": "ReadBinary a-\u003eReadBinary(ArgMonad b a)",
          "package": "uni-util",
          "partial": "Binary To Arg Monad",
          "signature": "ReadBinary m-\u003eReadBinary(ArgMonad arg m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:readBinaryToArgMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "runArgMonad",
          "package": "uni-util",
          "signature": "arg -\u003e ArgMonad arg m a -\u003e m a",
          "source": "src/Util-BinaryUtils.html#runArgMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "runArgMonad",
          "normalized": "a-\u003eArgMonad a b c-\u003eb c",
          "package": "uni-util",
          "partial": "Arg Monad",
          "signature": "arg-\u003eArgMonad arg m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:runArgMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "toArgMonad",
          "package": "uni-util",
          "signature": "m a -\u003e ArgMonad arg m a",
          "source": "src/Util-BinaryUtils.html#toArgMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "toArgMonad",
          "normalized": "a b-\u003eArgMonad c a b",
          "package": "uni-util",
          "partial": "Arg Monad",
          "signature": "m a-\u003eArgMonad arg m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:toArgMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.BinaryUtils",
          "name": "writeBinaryToArgMonad",
          "package": "uni-util",
          "signature": "WriteBinary m -\u003e WriteBinary (ArgMonad arg m)",
          "source": "src/Util-BinaryUtils.html#writeBinaryToArgMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util BinaryUtils",
          "module": "Util.BinaryUtils",
          "name": "writeBinaryToArgMonad",
          "normalized": "WriteBinary a-\u003eWriteBinary(ArgMonad b a)",
          "package": "uni-util",
          "partial": "Binary To Arg Monad",
          "signature": "WriteBinary m-\u003eWriteBinary(ArgMonad arg m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-BinaryUtils.html#v:writeBinaryToArgMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Broadcaster\u003cem\u003eSimpleBroadcaster is a variable Source\u003c/em\u003eSimpleSource paired\n with its update function\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Broadcaster",
          "name": "Broadcaster",
          "package": "uni-util",
          "source": "src/Util-Broadcaster.html",
          "type": "module"
        },
        "index": {
          "description": "Broadcaster SimpleBroadcaster is variable Source SimpleSource paired with its update function",
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "Broadcaster",
          "package": "uni-util",
          "partial": "Broadcaster",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "Broadcaster",
          "package": "uni-util",
          "source": "src/Util-Broadcaster.html#Broadcaster",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "Broadcaster",
          "package": "uni-util",
          "partial": "Broadcaster",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#t:Broadcaster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "BroadcasterClass",
          "package": "uni-util",
          "source": "src/Util-Broadcaster.html#BroadcasterClass",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "BroadcasterClass",
          "package": "uni-util",
          "partial": "Broadcaster Class",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#t:BroadcasterClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "GeneralBroadcaster",
          "package": "uni-util",
          "source": "src/Util-Broadcaster.html#GeneralBroadcaster",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "GeneralBroadcaster",
          "package": "uni-util",
          "partial": "General Broadcaster",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#t:GeneralBroadcaster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "SimpleBroadcaster",
          "package": "uni-util",
          "source": "src/Util-Broadcaster.html#SimpleBroadcaster",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "SimpleBroadcaster",
          "package": "uni-util",
          "partial": "Simple Broadcaster",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#t:SimpleBroadcaster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "applyGeneralUpdate",
          "package": "uni-util",
          "signature": "GeneralBroadcaster x d -\u003e (x -\u003e (x, [d], extra)) -\u003e IO extra",
          "source": "src/Util-Broadcaster.html#applyGeneralUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "applyGeneralUpdate",
          "normalized": "GeneralBroadcaster a b-\u003e(a-\u003e(a,[b],c))-\u003eIO c",
          "package": "uni-util",
          "partial": "General Update",
          "signature": "GeneralBroadcaster x d-\u003e(x-\u003e(x,[d],extra))-\u003eIO extra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:applyGeneralUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "applySimpleUpdate",
          "package": "uni-util",
          "signature": "SimpleBroadcaster x -\u003e (x -\u003e x) -\u003e IO ()",
          "source": "src/Util-Broadcaster.html#applySimpleUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "applySimpleUpdate",
          "normalized": "SimpleBroadcaster a-\u003e(a-\u003ea)-\u003eIO()",
          "package": "uni-util",
          "partial": "Simple Update",
          "signature": "SimpleBroadcaster x-\u003e(x-\u003ex)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:applySimpleUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "applySimpleUpdate'",
          "package": "uni-util",
          "signature": "SimpleBroadcaster x -\u003e (x -\u003e (x, y)) -\u003e IO y",
          "source": "src/Util-Broadcaster.html#applySimpleUpdate%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "applySimpleUpdate'",
          "normalized": "SimpleBroadcaster a-\u003e(a-\u003e(a,b))-\u003eIO b",
          "package": "uni-util",
          "partial": "Simple Update'",
          "signature": "SimpleBroadcaster x-\u003e(x-\u003e(x,y))-\u003eIO y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:applySimpleUpdate-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "applyUpdate",
          "package": "uni-util",
          "signature": "Broadcaster x d -\u003e (x -\u003e (x, [d])) -\u003e IO ()",
          "source": "src/Util-Broadcaster.html#applyUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "applyUpdate",
          "normalized": "Broadcaster a b-\u003e(a-\u003e(a,[b]))-\u003eIO()",
          "package": "uni-util",
          "partial": "Update",
          "signature": "Broadcaster x d-\u003e(x-\u003e(x,[d]))-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:applyUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "broadcast",
          "package": "uni-util",
          "signature": "broadcaster -\u003e value -\u003e IO ()",
          "source": "src/Util-Broadcaster.html#broadcast",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "broadcast",
          "normalized": "a-\u003eb-\u003eIO()",
          "package": "uni-util",
          "signature": "broadcaster-\u003evalue-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:broadcast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a SimpleSource by another which mirrors it, but only copies\n from it once, hopefully saving CPU time.\n The IO action stops the mirroring.\n\u003c/p\u003e",
          "module": "Util.Broadcaster",
          "name": "mirrorSimpleSource",
          "package": "uni-util",
          "signature": "SimpleSource a -\u003e IO (SimpleSource a, IO ())",
          "source": "src/Util-Broadcaster.html#mirrorSimpleSource",
          "type": "function"
        },
        "index": {
          "description": "Replace SimpleSource by another which mirrors it but only copies from it once hopefully saving CPU time The IO action stops the mirroring",
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "mirrorSimpleSource",
          "normalized": "SimpleSource a-\u003eIO(SimpleSource a,IO())",
          "package": "uni-util",
          "partial": "Simple Source",
          "signature": "SimpleSource a-\u003eIO(SimpleSource a,IO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:mirrorSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a SimpleSource by another which mirrors it, but only copies\n from it once, hopefully saving CPU time.  In addition, block all\n update while the Delayer is delaying things.\n\u003c/p\u003e",
          "module": "Util.Broadcaster",
          "name": "mirrorSimpleSourceWithDelayer",
          "package": "uni-util",
          "signature": "Delayer -\u003e SimpleSource a -\u003e IO (SimpleSource a, IO ())",
          "source": "src/Util-Broadcaster.html#mirrorSimpleSourceWithDelayer",
          "type": "function"
        },
        "index": {
          "description": "Replace SimpleSource by another which mirrors it but only copies from it once hopefully saving CPU time In addition block all update while the Delayer is delaying things",
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "mirrorSimpleSourceWithDelayer",
          "normalized": "Delayer-\u003eSimpleSource a-\u003eIO(SimpleSource a,IO())",
          "package": "uni-util",
          "partial": "Simple Source With Delayer",
          "signature": "Delayer-\u003eSimpleSource a-\u003eIO(SimpleSource a,IO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:mirrorSimpleSourceWithDelayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "newBroadcaster",
          "package": "uni-util",
          "signature": "x -\u003e IO (Broadcaster x d)",
          "source": "src/Util-Broadcaster.html#newBroadcaster",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "newBroadcaster",
          "normalized": "a-\u003eIO(Broadcaster a b)",
          "package": "uni-util",
          "partial": "Broadcaster",
          "signature": "x-\u003eIO(Broadcaster x d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:newBroadcaster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "newGeneralBroadcaster",
          "package": "uni-util",
          "signature": "x -\u003e IO (GeneralBroadcaster x d)",
          "source": "src/Util-Broadcaster.html#newGeneralBroadcaster",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "newGeneralBroadcaster",
          "normalized": "a-\u003eIO(GeneralBroadcaster a b)",
          "package": "uni-util",
          "partial": "General Broadcaster",
          "signature": "x-\u003eIO(GeneralBroadcaster x d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:newGeneralBroadcaster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Broadcaster",
          "name": "newSimpleBroadcaster",
          "package": "uni-util",
          "signature": "x -\u003e IO (SimpleBroadcaster x)",
          "source": "src/Util-Broadcaster.html#newSimpleBroadcaster",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "newSimpleBroadcaster",
          "normalized": "a-\u003eIO(SimpleBroadcaster a)",
          "package": "uni-util",
          "partial": "Simple Broadcaster",
          "signature": "x-\u003eIO(SimpleBroadcaster x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:newSimpleBroadcaster"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a SimpleSource by another which comes with a switch-off function,\n which temporarily blocks further updates.\n The action returned by the switch-off function switches the source back on\n again.\n\u003c/p\u003e",
          "module": "Util.Broadcaster",
          "name": "switchOffSimpleSource",
          "package": "uni-util",
          "signature": "SimpleSource a -\u003e IO (SimpleSource a, IO (IO ()))",
          "source": "src/Util-Broadcaster.html#switchOffSimpleSource",
          "type": "function"
        },
        "index": {
          "description": "Replace SimpleSource by another which comes with switch-off function which temporarily blocks further updates The action returned by the switch-off function switches the source back on again",
          "hierarchy": "Util Broadcaster",
          "module": "Util.Broadcaster",
          "name": "switchOffSimpleSource",
          "normalized": "SimpleSource a-\u003eIO(SimpleSource a,IO(IO()))",
          "package": "uni-util",
          "partial": "Off Simple Source",
          "signature": "SimpleSource a-\u003eIO(SimpleSource a,IO(IO()))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Broadcaster.html#v:switchOffSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis defines primitive byte operations, to be used with binary conversion.\n For the present we use the FFI.  There are probably lots of better ways.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Bytes",
          "name": "Bytes",
          "package": "uni-util",
          "source": "src/Util-Bytes.html",
          "type": "module"
        },
        "index": {
          "description": "This defines primitive byte operations to be used with binary conversion For the present we use the FFI There are probably lots of better ways",
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "Bytes",
          "package": "uni-util",
          "partial": "Bytes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "Byte",
          "package": "uni-util",
          "source": "src/Util-Bytes.html#Byte",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "Byte",
          "package": "uni-util",
          "partial": "Byte",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#t:Byte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "Bytes",
          "package": "uni-util",
          "source": "src/Util-Bytes.html#Bytes",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "Bytes",
          "package": "uni-util",
          "partial": "Bytes",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#t:Bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "bytesAlloca",
          "package": "uni-util",
          "signature": "Int -\u003e (Bytes -\u003e IO a) -\u003e IO a",
          "source": "src/Util-Bytes.html#bytesAlloca",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "bytesAlloca",
          "normalized": "Int-\u003e(Bytes-\u003eIO a)-\u003eIO a",
          "package": "uni-util",
          "partial": "Alloca",
          "signature": "Int-\u003e(Bytes-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:bytesAlloca"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "bytesFree",
          "package": "uni-util",
          "signature": "Bytes -\u003e IO ()",
          "source": "src/Util-Bytes.html#bytesFree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "bytesFree",
          "normalized": "Bytes-\u003eIO()",
          "package": "uni-util",
          "partial": "Free",
          "signature": "Bytes-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:bytesFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "bytesMalloc",
          "package": "uni-util",
          "signature": "Int -\u003e IO Bytes",
          "source": "src/Util-Bytes.html#bytesMalloc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "bytesMalloc",
          "normalized": "Int-\u003eIO Bytes",
          "package": "uni-util",
          "partial": "Malloc",
          "signature": "Int-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:bytesMalloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "bytesReAlloc",
          "package": "uni-util",
          "signature": "Bytes -\u003e Int -\u003e IO Bytes",
          "source": "src/Util-Bytes.html#bytesReAlloc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "bytesReAlloc",
          "normalized": "Bytes-\u003eInt-\u003eIO Bytes",
          "package": "uni-util",
          "partial": "Re Alloc",
          "signature": "Bytes-\u003eInt-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:bytesReAlloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "compareBytes",
          "package": "uni-util",
          "signature": "Bytes -\u003e Bytes -\u003e Int -\u003e IO Ordering",
          "source": "src/Util-Bytes.html#compareBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "compareBytes",
          "normalized": "Bytes-\u003eBytes-\u003eInt-\u003eIO Ordering",
          "package": "uni-util",
          "partial": "Bytes",
          "signature": "Bytes-\u003eBytes-\u003eInt-\u003eIO Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:compareBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "getByteFromBytes",
          "package": "uni-util",
          "signature": "Bytes -\u003e Int -\u003e IO Byte",
          "source": "src/Util-Bytes.html#getByteFromBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "getByteFromBytes",
          "normalized": "Bytes-\u003eInt-\u003eIO Byte",
          "package": "uni-util",
          "partial": "Byte From Bytes",
          "signature": "Bytes-\u003eInt-\u003eIO Byte",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:getByteFromBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "hGetByte",
          "package": "uni-util",
          "signature": "Handle -\u003e IO Byte",
          "source": "src/Util-Bytes.html#hGetByte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "hGetByte",
          "normalized": "Handle-\u003eIO Byte",
          "package": "uni-util",
          "partial": "Get Byte",
          "signature": "Handle-\u003eIO Byte",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:hGetByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "hGetBytes",
          "package": "uni-util",
          "signature": "Handle -\u003e Int -\u003e IO Bytes",
          "source": "src/Util-Bytes.html#hGetBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "hGetBytes",
          "normalized": "Handle-\u003eInt-\u003eIO Bytes",
          "package": "uni-util",
          "partial": "Get Bytes",
          "signature": "Handle-\u003eInt-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:hGetBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "hPutByte",
          "package": "uni-util",
          "signature": "Handle -\u003e Byte -\u003e IO ()",
          "source": "src/Util-Bytes.html#hPutByte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "hPutByte",
          "normalized": "Handle-\u003eByte-\u003eIO()",
          "package": "uni-util",
          "partial": "Put Byte",
          "signature": "Handle-\u003eByte-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:hPutByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "hPutBytes",
          "package": "uni-util",
          "signature": "Handle -\u003e Bytes -\u003e Int -\u003e IO ()",
          "source": "src/Util-Bytes.html#hPutBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "hPutBytes",
          "normalized": "Handle-\u003eBytes-\u003eInt-\u003eIO()",
          "package": "uni-util",
          "partial": "Put Bytes",
          "signature": "Handle-\u003eBytes-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:hPutBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "mkBytes",
          "package": "uni-util",
          "signature": "Ptr CChar -\u003e Bytes",
          "source": "src/Util-Bytes.html#mkBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "mkBytes",
          "normalized": "Ptr CChar-\u003eBytes",
          "package": "uni-util",
          "partial": "Bytes",
          "signature": "Ptr CChar-\u003eBytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:mkBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "putByteToBytes",
          "package": "uni-util",
          "signature": "Byte -\u003e Bytes -\u003e Int -\u003e IO ()",
          "source": "src/Util-Bytes.html#putByteToBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "putByteToBytes",
          "normalized": "Byte-\u003eBytes-\u003eInt-\u003eIO()",
          "package": "uni-util",
          "partial": "Byte To Bytes",
          "signature": "Byte-\u003eBytes-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:putByteToBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "putBytesToBytes",
          "package": "uni-util",
          "signature": "Bytes -\u003e Int -\u003e Bytes -\u003e Int -\u003e Int -\u003e IO ()",
          "source": "src/Util-Bytes.html#putBytesToBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "putBytesToBytes",
          "normalized": "Bytes-\u003eInt-\u003eBytes-\u003eInt-\u003eInt-\u003eIO()",
          "package": "uni-util",
          "partial": "Bytes To Bytes",
          "signature": "Bytes-\u003eInt-\u003eBytes-\u003eInt-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:putBytesToBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "unMkBytes",
          "package": "uni-util",
          "signature": "Bytes -\u003e Ptr CChar",
          "source": "src/Util-Bytes.html#unMkBytes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "unMkBytes",
          "normalized": "Bytes-\u003ePtr CChar",
          "package": "uni-util",
          "partial": "Mk Bytes",
          "signature": "Bytes-\u003ePtr CChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:unMkBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Bytes",
          "name": "withBytesAsCChars",
          "package": "uni-util",
          "signature": "Bytes -\u003e (Ptr CChar -\u003e IO a) -\u003e IO a",
          "source": "src/Util-Bytes.html#withBytesAsCChars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Bytes",
          "module": "Util.Bytes",
          "name": "withBytesAsCChars",
          "normalized": "Bytes-\u003e(Ptr CChar-\u003eIO a)-\u003eIO a",
          "package": "uni-util",
          "partial": "Bytes As CChars",
          "signature": "Bytes-\u003e(Ptr CChar-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Bytes.html#v:withBytesAsCChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Cache module allows us to cache results of expensive stateful\n computations in memory.\n Possible improvements -\n    (1) use hashing instead\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Cache",
          "name": "Cache",
          "package": "uni-util",
          "source": "src/Util-Cache.html",
          "type": "module"
        },
        "index": {
          "description": "The Cache module allows us to cache results of expensive stateful computations in memory Possible improvements use hashing instead",
          "hierarchy": "Util Cache",
          "module": "Util.Cache",
          "name": "Cache",
          "package": "uni-util",
          "partial": "Cache",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Cache.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Cache",
          "name": "Cache",
          "package": "uni-util",
          "source": "src/Util-Cache.html#Cache",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Cache",
          "module": "Util.Cache",
          "name": "Cache",
          "package": "uni-util",
          "partial": "Cache",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Cache.html#t:Cache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Cache",
          "name": "getCached",
          "package": "uni-util",
          "signature": "Cache key elt -\u003e key -\u003e IO elt",
          "source": "src/Util-Cache.html#getCached",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Cache",
          "module": "Util.Cache",
          "name": "getCached",
          "normalized": "Cache a b-\u003ea-\u003eIO b",
          "package": "uni-util",
          "partial": "Cached",
          "signature": "Cache key elt-\u003ekey-\u003eIO elt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Cache.html#v:getCached"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Cache",
          "name": "newCache",
          "package": "uni-util",
          "signature": "(key -\u003e IO elt) -\u003e IO (Cache key elt)",
          "source": "src/Util-Cache.html#newCache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Cache",
          "module": "Util.Cache",
          "name": "newCache",
          "normalized": "(a-\u003eIO b)-\u003eIO(Cache a b)",
          "package": "uni-util",
          "partial": "Cache",
          "signature": "(key-\u003eIO elt)-\u003eIO(Cache key elt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Cache.html#v:newCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements displaying ClockTime as a String which does NOT\n depend on the time-zone.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.ClockTimeToString",
          "name": "ClockTimeToString",
          "package": "uni-util",
          "source": "src/Util-ClockTimeToString.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements displaying ClockTime as String which does NOT depend on the time-zone",
          "hierarchy": "Util ClockTimeToString",
          "module": "Util.ClockTimeToString",
          "name": "ClockTimeToString",
          "package": "uni-util",
          "partial": "Clock Time To String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ClockTimeToString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a ClockTime to a String.\n This has the format\n    \u003coptional sign\u003e\u003cdigits\u003e+\u003cdigits\u003e\n where the digits encode two integers N1 and N2 (in order) representing\n the time elapsed since 00:00:00 UTC on 1 Jan 1970.  This will be\n N1 + (N2 / 10^12) seconds.  0\u003c=N2\u003c10^12.\n\u003c/p\u003e",
          "module": "Util.ClockTimeToString",
          "name": "clockTimeToString",
          "package": "uni-util",
          "signature": "ClockTime -\u003e String",
          "source": "src/Util-ClockTimeToString.html#clockTimeToString",
          "type": "function"
        },
        "index": {
          "description": "Convert ClockTime to String This has the format optional sign digits digits where the digits encode two integers N1 and N2 in order representing the time elapsed since UTC on Jan This will be N1 N2 seconds N2",
          "hierarchy": "Util ClockTimeToString",
          "module": "Util.ClockTimeToString",
          "name": "clockTimeToString",
          "normalized": "ClockTime-\u003eString",
          "package": "uni-util",
          "partial": "Time To String",
          "signature": "ClockTime-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ClockTimeToString.html#v:clockTimeToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a validly formatted String to a ClockTime.\n\u003c/p\u003e",
          "module": "Util.ClockTimeToString",
          "name": "stringToClockTime",
          "package": "uni-util",
          "signature": "String -\u003e ClockTime",
          "source": "src/Util-ClockTimeToString.html#stringToClockTime",
          "type": "function"
        },
        "index": {
          "description": "Convert validly formatted String to ClockTime",
          "hierarchy": "Util ClockTimeToString",
          "module": "Util.ClockTimeToString",
          "name": "stringToClockTime",
          "normalized": "String-\u003eClockTime",
          "package": "uni-util",
          "partial": "To Clock Time",
          "signature": "String-\u003eClockTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ClockTimeToString.html#v:stringToClockTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWe provide a format-string-like way of describing how to call particular\n tools.  Thus the input is\n (1) a particular format string\n (2) a partial map from upper-case letters to strings; we call these strings\n     the _insert_ strings.\n We map the format string to an output string in which combinations\n of the form\n %[upper-case-letter]\n in the format string are replaced by the corresponding insert string; if no\n such string exists this is an error.\n\u003c/p\u003e\u003cp\u003eWe also provide a mechanism for \u003ca\u003eescaping\u003c/a\u003e the insert strings.\n Specifically, there is a fixed partial map from lower-case letters to\n functions :: String -\u003e String; these functions we call the transformers.\n For a combination of the form\n %[lower-case-letter-1]...[lower-case-letter-n][upper-case-letter]\n we take the insert string corresponding to upper-case-letter, and then\n pass it through the transformers corresponding to lower-case-letter-n,\n and so on down to the transformer corresponding to lower-case-letter-1.\n\u003c/p\u003e\u003cp\u003eInstead of [upper-case-letter] we may also write \u003ca\u003e%\u003c/a\u003e in which case the\n insert string is just \u003ca\u003e%\u003c/a\u003e; thus \u003ca\u003e%%\u003c/a\u003e transforms to \u003ca\u003e%\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eSections of the input string not containing % are left untouched.\n\u003c/p\u003e\u003cp\u003eDefined transformers with their corresponding letters:\n    b  transformer suitable for escaping bash strings quoted with \u003ca\u003e.\n    e  transformer suitable for escaping emacs lisp strings quoted with \u003c/a\u003e.\n None of these transformers insert the closing or end quotes, allowing you\n to use them in the middle of strings.\n\u003c/p\u003e\u003cp\u003eOther transformers will be added as the need arises.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.CommandStringSub",
          "name": "CommandStringSub",
          "package": "uni-util",
          "source": "src/Util-CommandStringSub.html",
          "type": "module"
        },
        "index": {
          "description": "We provide format-string-like way of describing how to call particular tools Thus the input is particular format string partial map from upper-case letters to strings we call these strings the insert strings We map the format string to an output string in which combinations of the form upper-case-letter in the format string are replaced by the corresponding insert string if no such string exists this is an error We also provide mechanism for escaping the insert strings Specifically there is fixed partial map from lower-case letters to functions String String these functions we call the transformers For combination of the form lower-case-letter-1 lower-case-letter-n upper-case-letter we take the insert string corresponding to upper-case-letter and then pass it through the transformers corresponding to lower-case-letter-n and so on down to the transformer corresponding to lower-case-letter-1 Instead of upper-case-letter we may also write in which case the insert string is just thus transforms to Sections of the input string not containing are left untouched Defined transformers with their corresponding letters transformer suitable for escaping bash strings quoted with transformer suitable for escaping emacs lisp strings quoted with None of these transformers insert the closing or end quotes allowing you to use them in the middle of strings Other transformers will be added as the need arises",
          "hierarchy": "Util CommandStringSub",
          "module": "Util.CommandStringSub",
          "name": "CommandStringSub",
          "package": "uni-util",
          "partial": "Command String Sub",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CommandStringSub.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CommandStringSub",
          "name": "CompiledFormatString",
          "package": "uni-util",
          "source": "src/Util-CommandStringSub.html#CompiledFormatString",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util CommandStringSub",
          "module": "Util.CommandStringSub",
          "name": "CompiledFormatString",
          "package": "uni-util",
          "partial": "Compiled Format String",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CommandStringSub.html#t:CompiledFormatString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CommandStringSub",
          "name": "bashEscape",
          "package": "uni-util",
          "signature": "String -\u003e String",
          "source": "src/Util-CommandStringSub.html#bashEscape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util CommandStringSub",
          "module": "Util.CommandStringSub",
          "name": "bashEscape",
          "normalized": "String-\u003eString",
          "package": "uni-util",
          "partial": "Escape",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CommandStringSub.html#v:bashEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CommandStringSub",
          "name": "compileFormatString",
          "package": "uni-util",
          "signature": "String -\u003e WithError CompiledFormatString",
          "source": "src/Util-CommandStringSub.html#compileFormatString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util CommandStringSub",
          "module": "Util.CommandStringSub",
          "name": "compileFormatString",
          "normalized": "String-\u003eWithError CompiledFormatString",
          "package": "uni-util",
          "partial": "Format String",
          "signature": "String-\u003eWithError CompiledFormatString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CommandStringSub.html#v:compileFormatString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CommandStringSub",
          "name": "doFormatString",
          "package": "uni-util",
          "signature": "String -\u003e (Char -\u003e Maybe String) -\u003e String",
          "source": "src/Util-CommandStringSub.html#doFormatString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util CommandStringSub",
          "module": "Util.CommandStringSub",
          "name": "doFormatString",
          "normalized": "String-\u003e(Char-\u003eMaybe String)-\u003eString",
          "package": "uni-util",
          "partial": "Format String",
          "signature": "String-\u003e(Char-\u003eMaybe String)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CommandStringSub.html#v:doFormatString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CommandStringSub",
          "name": "emacsEscape",
          "package": "uni-util",
          "signature": "String -\u003e String",
          "source": "src/Util-CommandStringSub.html#emacsEscape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util CommandStringSub",
          "module": "Util.CommandStringSub",
          "name": "emacsEscape",
          "normalized": "String-\u003eString",
          "package": "uni-util",
          "partial": "Escape",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CommandStringSub.html#v:emacsEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CommandStringSub",
          "name": "runFormatString",
          "package": "uni-util",
          "signature": "CompiledFormatString -\u003e (Char -\u003e Maybe String) -\u003e WithError String",
          "source": "src/Util-CommandStringSub.html#runFormatString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util CommandStringSub",
          "module": "Util.CommandStringSub",
          "name": "runFormatString",
          "normalized": "CompiledFormatString-\u003e(Char-\u003eMaybe String)-\u003eWithError String",
          "package": "uni-util",
          "partial": "Format String",
          "signature": "CompiledFormatString-\u003e(Char-\u003eMaybe String)-\u003eWithError String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CommandStringSub.html#v:runFormatString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains flags which control compilation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.CompileFlags",
          "name": "CompileFlags",
          "package": "uni-util",
          "source": "src/Util-CompileFlags.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains flags which control compilation",
          "hierarchy": "Util CompileFlags",
          "module": "Util.CompileFlags",
          "name": "CompileFlags",
          "package": "uni-util",
          "partial": "Compile Flags",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CompileFlags.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CompileFlags",
          "name": "isDebug",
          "package": "uni-util",
          "signature": "Bool",
          "source": "src/Util-CompileFlags.html#isDebug",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util CompileFlags",
          "module": "Util.CompileFlags",
          "name": "isDebug",
          "package": "uni-util",
          "partial": "Debug",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CompileFlags.html#v:isDebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.CompileFlags",
          "name": "uniVersion",
          "package": "uni-util",
          "signature": "String",
          "source": "src/Util-CompileFlags.html#uniVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util CompileFlags",
          "module": "Util.CompileFlags",
          "name": "uniVersion",
          "package": "uni-util",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-CompileFlags.html#v:uniVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "Computation",
          "package": "uni-util",
          "source": "src/Util-Computation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "Computation",
          "package": "uni-util",
          "partial": "Computation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "Answer",
          "package": "uni-util",
          "source": "src/Util-Computation.html#Answer",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "Answer",
          "package": "uni-util",
          "partial": "Answer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#t:Answer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "Config",
          "package": "uni-util",
          "source": "src/Util-Computation.html#Config",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "Config",
          "package": "uni-util",
          "partial": "Config",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#t:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "HasConfig",
          "package": "uni-util",
          "source": "src/Util-Computation.html#HasConfig",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "HasConfig",
          "package": "uni-util",
          "partial": "Has Config",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#t:HasConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "MonadWithError",
          "package": "uni-util",
          "source": "src/Util-Computation.html#MonadWithError",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "MonadWithError",
          "package": "uni-util",
          "partial": "Monad With Error",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#t:MonadWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "WithError",
          "package": "uni-util",
          "source": "src/Util-Computation.html#WithError",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "WithError",
          "package": "uni-util",
          "partial": "With Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#t:WithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "(#)",
          "package": "uni-util",
          "signature": "a -\u003e (a -\u003e b) -\u003e b",
          "source": "src/Util-Computation.html#%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "(#) #",
          "normalized": "a-\u003e(a-\u003eb)-\u003eb",
          "package": "uni-util",
          "signature": "a-\u003e(a-\u003eb)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "($$)",
          "package": "uni-util",
          "signature": "option -\u003e configuration -\u003e configuration",
          "source": "src/Util-Computation.html#%24%24",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "($$) $$",
          "normalized": "a-\u003eb-\u003eb",
          "package": "uni-util",
          "signature": "option-\u003econfiguration-\u003econfiguration",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:-36--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "MonadWithError",
          "package": "uni-util",
          "signature": "MonadWithError (m (WithError a))",
          "source": "src/Util-Computation.html#MonadWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "MonadWithError",
          "package": "uni-util",
          "partial": "Monad With Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:MonadWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "coerceWithError",
          "package": "uni-util",
          "signature": "WithError a -\u003e a",
          "source": "src/Util-Computation.html#coerceWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "coerceWithError",
          "normalized": "WithError a-\u003ea",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "WithError a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:coerceWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "coerceWithErrorIO",
          "package": "uni-util",
          "signature": "WithError a -\u003e IO a",
          "source": "src/Util-Computation.html#coerceWithErrorIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "coerceWithErrorIO",
          "normalized": "WithError a-\u003eIO a",
          "package": "uni-util",
          "partial": "With Error IO",
          "signature": "WithError a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:coerceWithErrorIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecoerce or use the supplied break function (to be used with\n \u003ccode\u003e\u003ca\u003eaddFallOut\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreak",
          "package": "uni-util",
          "signature": "(String -\u003e a) -\u003e WithError a -\u003e a",
          "source": "src/Util-Computation.html#coerceWithErrorOrBreak",
          "type": "function"
        },
        "index": {
          "description": "coerce or use the supplied break function to be used with addFallOut",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreak",
          "normalized": "(String-\u003ea)-\u003eWithError a-\u003ea",
          "package": "uni-util",
          "partial": "With Error Or Break",
          "signature": "(String-\u003ea)-\u003eWithError a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:coerceWithErrorOrBreak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecoerce or use the supplied break function (to be used with\n \u003ccode\u003e\u003ca\u003eaddFallOut\u003c/a\u003e\u003c/code\u003e)\n The value is evaluated immediately.\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreakIO",
          "package": "uni-util",
          "signature": "(String -\u003e a) -\u003e WithError a -\u003e IO a",
          "source": "src/Util-Computation.html#coerceWithErrorOrBreakIO",
          "type": "function"
        },
        "index": {
          "description": "coerce or use the supplied break function to be used with addFallOut The value is evaluated immediately",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreakIO",
          "normalized": "(String-\u003ea)-\u003eWithError a-\u003eIO a",
          "package": "uni-util",
          "partial": "With Error Or Break IO",
          "signature": "(String-\u003ea)-\u003eWithError a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:coerceWithErrorOrBreakIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecoerce or use the supplied break function (to be used with\n \u003ccode\u003e\u003ca\u003eaddFallOut\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eThe first argument is prepended to any error message.\n The value is evaluated immediately.\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreakIOPrefix",
          "package": "uni-util",
          "signature": "String -\u003e (String -\u003e a) -\u003e WithError a -\u003e IO a",
          "source": "src/Util-Computation.html#coerceWithErrorOrBreakIOPrefix",
          "type": "function"
        },
        "index": {
          "description": "coerce or use the supplied break function to be used with addFallOut The first argument is prepended to any error message The value is evaluated immediately",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreakIOPrefix",
          "normalized": "String-\u003e(String-\u003ea)-\u003eWithError a-\u003eIO a",
          "package": "uni-util",
          "partial": "With Error Or Break IOPrefix",
          "signature": "String-\u003e(String-\u003ea)-\u003eWithError a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:coerceWithErrorOrBreakIOPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecoerce or use the supplied break function (to be used with\n \u003ccode\u003e\u003ca\u003eaddFallOut\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eThe first argument is prepended to any error message.\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreakPrefix",
          "package": "uni-util",
          "signature": "String -\u003e (String -\u003e a) -\u003e WithError a -\u003e a",
          "source": "src/Util-Computation.html#coerceWithErrorOrBreakPrefix",
          "type": "function"
        },
        "index": {
          "description": "coerce or use the supplied break function to be used with addFallOut The first argument is prepended to any error message",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "coerceWithErrorOrBreakPrefix",
          "normalized": "String-\u003e(String-\u003ea)-\u003eWithError a-\u003ea",
          "package": "uni-util",
          "partial": "With Error Or Break Prefix",
          "signature": "String-\u003e(String-\u003ea)-\u003eWithError a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:coerceWithErrorOrBreakPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "coerceWithErrorStringIO",
          "package": "uni-util",
          "signature": "String -\u003e WithError a -\u003e IO a",
          "source": "src/Util-Computation.html#coerceWithErrorStringIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "coerceWithErrorStringIO",
          "normalized": "String-\u003eWithError a-\u003eIO a",
          "package": "uni-util",
          "partial": "With Error String IO",
          "signature": "String-\u003eWithError a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:coerceWithErrorStringIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "concatWithError",
          "package": "uni-util",
          "signature": "[WithError a] -\u003e WithError [a]",
          "source": "src/Util-Computation.html#concatWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "concatWithError",
          "normalized": "[WithError a]-\u003eWithError[a]",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "[WithError a]-\u003eWithError[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:concatWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "config",
          "package": "uni-util",
          "signature": "IO () -\u003e Config w",
          "source": "src/Util-Computation.html#config",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "config",
          "normalized": "IO()-\u003eConfig a",
          "package": "uni-util",
          "signature": "IO()-\u003eConfig w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "configUsed",
          "package": "uni-util",
          "signature": "option -\u003e configuration -\u003e Bool",
          "source": "src/Util-Computation.html#configUsed",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "configUsed",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "uni-util",
          "partial": "Used",
          "signature": "option-\u003econfiguration-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:configUsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "configure",
          "package": "uni-util",
          "signature": "w -\u003e [Config w] -\u003e IO w",
          "source": "src/Util-Computation.html#configure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "configure",
          "normalized": "a-\u003e[Config a]-\u003eIO a",
          "package": "uni-util",
          "signature": "w-\u003e[Config w]-\u003eIO w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:configure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "done",
          "package": "uni-util",
          "signature": "m ()",
          "source": "src/Util-Computation.html#done",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "done",
          "normalized": "a()",
          "package": "uni-util",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:done"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "exceptionToError",
          "package": "uni-util",
          "signature": "(e -\u003e Maybe String) -\u003e IO a -\u003e IO (WithError a)",
          "source": "src/Util-Computation.html#exceptionToError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "exceptionToError",
          "normalized": "(a-\u003eMaybe String)-\u003eIO b-\u003eIO(WithError b)",
          "package": "uni-util",
          "partial": "To Error",
          "signature": "(e-\u003eMaybe String)-\u003eIO a-\u003eIO(WithError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:exceptionToError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "foreach",
          "package": "uni-util",
          "signature": "[a] -\u003e (a -\u003e m b) -\u003e m ()",
          "source": "src/Util-Computation.html#foreach",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "foreach",
          "normalized": "[a]-\u003e(a-\u003eb c)-\u003eb()",
          "package": "uni-util",
          "signature": "[a]-\u003e(a-\u003em b)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:foreach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eforever\u003c/a\u003e\u003c/code\u003e act\u003c/code\u003e repeats the action infinitely.\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "forever",
          "package": "uni-util",
          "signature": "m a -\u003e m b",
          "type": "function"
        },
        "index": {
          "description": "forever act repeats the action infinitely",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "forever",
          "normalized": "a b-\u003ea c",
          "package": "uni-util",
          "signature": "m a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:forever"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "foreverUntil",
          "package": "uni-util",
          "signature": "m Bool -\u003e m ()",
          "source": "src/Util-Computation.html#foreverUntil",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "foreverUntil",
          "normalized": "a Bool-\u003ea()",
          "package": "uni-util",
          "partial": "Until",
          "signature": "m Bool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:foreverUntil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "fromWithError",
          "package": "uni-util",
          "signature": "WithError a -\u003e Either String a",
          "source": "src/Util-Computation.html#fromWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "fromWithError",
          "normalized": "WithError a-\u003eEither String a",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "WithError a-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:fromWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "fromWithError1",
          "package": "uni-util",
          "signature": "a -\u003e WithError a -\u003e a",
          "source": "src/Util-Computation.html#fromWithError1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "fromWithError1",
          "normalized": "a-\u003eWithError a-\u003ea",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "a-\u003eWithError a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:fromWithError1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "hasError",
          "package": "uni-util",
          "signature": "String -\u003e WithError a",
          "source": "src/Util-Computation.html#hasError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "hasError",
          "normalized": "String-\u003eWithError a",
          "package": "uni-util",
          "partial": "Error",
          "signature": "String-\u003eWithError a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:hasError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "hasValue",
          "package": "uni-util",
          "signature": "a -\u003e WithError a",
          "source": "src/Util-Computation.html#hasValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "hasValue",
          "normalized": "a-\u003eWithError a",
          "package": "uni-util",
          "partial": "Value",
          "signature": "a-\u003eWithError a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:hasValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "incase",
          "package": "uni-util",
          "signature": "Maybe a -\u003e (a -\u003e IO b) -\u003e IO ()",
          "source": "src/Util-Computation.html#incase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "incase",
          "normalized": "Maybe a-\u003e(a-\u003eIO b)-\u003eIO()",
          "package": "uni-util",
          "signature": "Maybe a-\u003e(a-\u003eIO b)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:incase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "isError",
          "package": "uni-util",
          "signature": "WithError a -\u003e Bool",
          "source": "src/Util-Computation.html#isError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "isError",
          "normalized": "WithError a-\u003eBool",
          "package": "uni-util",
          "partial": "Error",
          "signature": "WithError a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:isError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "listWithError",
          "package": "uni-util",
          "signature": "[WithError a] -\u003e WithError [a]",
          "source": "src/Util-Computation.html#listWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "listWithError",
          "normalized": "[WithError a]-\u003eWithError[a]",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "[WithError a]-\u003eWithError[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:listWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "mapWithError",
          "package": "uni-util",
          "signature": "(a -\u003e b) -\u003e WithError a -\u003e WithError b",
          "source": "src/Util-Computation.html#mapWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "mapWithError",
          "normalized": "(a-\u003eb)-\u003eWithError a-\u003eWithError b",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "(a-\u003eb)-\u003eWithError a-\u003eWithError b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:mapWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "mapWithError'",
          "package": "uni-util",
          "signature": "(a -\u003e WithError b) -\u003e WithError a -\u003e WithError b",
          "source": "src/Util-Computation.html#mapWithError%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "mapWithError'",
          "normalized": "(a-\u003eWithError b)-\u003eWithError a-\u003eWithError b",
          "package": "uni-util",
          "partial": "With Error'",
          "signature": "(a-\u003eWithError b)-\u003eWithError a-\u003eWithError b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:mapWithError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "mapWithErrorIO",
          "package": "uni-util",
          "signature": "(a -\u003e IO b) -\u003e WithError a -\u003e IO (WithError b)",
          "source": "src/Util-Computation.html#mapWithErrorIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "mapWithErrorIO",
          "normalized": "(a-\u003eIO b)-\u003eWithError a-\u003eIO(WithError b)",
          "package": "uni-util",
          "partial": "With Error IO",
          "signature": "(a-\u003eIO b)-\u003eWithError a-\u003eIO(WithError b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:mapWithErrorIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "mapWithErrorIO'",
          "package": "uni-util",
          "signature": "(a -\u003e IO (WithError b)) -\u003e WithError a -\u003e IO (WithError b)",
          "source": "src/Util-Computation.html#mapWithErrorIO%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "mapWithErrorIO'",
          "normalized": "(a-\u003eIO(WithError b))-\u003eWithError a-\u003eIO(WithError b)",
          "package": "uni-util",
          "partial": "With Error IO'",
          "signature": "(a-\u003eIO(WithError b))-\u003eWithError a-\u003eIO(WithError b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:mapWithErrorIO-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "monadifyWithError",
          "package": "uni-util",
          "signature": "WithError a -\u003e MonadWithError m a",
          "source": "src/Util-Computation.html#monadifyWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "monadifyWithError",
          "normalized": "WithError a-\u003eMonadWithError b a",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "WithError a-\u003eMonadWithError m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:monadifyWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "pairWithError",
          "package": "uni-util",
          "signature": "WithError a -\u003e WithError b -\u003e WithError (a, b)",
          "source": "src/Util-Computation.html#pairWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "pairWithError",
          "normalized": "WithError a-\u003eWithError b-\u003eWithError(a,b)",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "WithError a-\u003eWithError b-\u003eWithError(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:pairWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "propagate",
          "package": "uni-util",
          "signature": "Answer a -\u003e IO a",
          "source": "src/Util-Computation.html#propagate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "propagate",
          "normalized": "Answer a-\u003eIO a",
          "package": "uni-util",
          "signature": "Answer a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:propagate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "raise",
          "package": "uni-util",
          "signature": "IOError -\u003e IO a",
          "source": "src/Util-Computation.html#raise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "raise",
          "normalized": "IOError-\u003eIO a",
          "package": "uni-util",
          "signature": "IOError-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:raise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "swapIOWithError",
          "package": "uni-util",
          "signature": "WithError (IO a) -\u003e IO (WithError a)",
          "source": "src/Util-Computation.html#swapIOWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "swapIOWithError",
          "normalized": "WithError(IO a)-\u003eIO(WithError a)",
          "package": "uni-util",
          "partial": "IOWith Error",
          "signature": "WithError(IO a)-\u003eIO(WithError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:swapIOWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "toMonadWithError",
          "package": "uni-util",
          "signature": "m a -\u003e MonadWithError m a",
          "source": "src/Util-Computation.html#toMonadWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "toMonadWithError",
          "normalized": "a b-\u003eMonadWithError a b",
          "package": "uni-util",
          "partial": "Monad With Error",
          "signature": "m a-\u003eMonadWithError m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:toMonadWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "toWithError",
          "package": "uni-util",
          "signature": "Either String a -\u003e WithError a",
          "source": "src/Util-Computation.html#toWithError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "toWithError",
          "normalized": "Either String a-\u003eWithError a",
          "package": "uni-util",
          "partial": "With Error",
          "signature": "Either String a-\u003eWithError a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:toWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e, but returns an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e result which is\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e a)\u003c/code\u003e if no exception of type \u003ccode\u003ee\u003c/code\u003e was raised, or \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e ex)\u003c/code\u003e\n if an exception of type \u003ccode\u003ee\u003c/code\u003e was raised and its value is \u003ccode\u003eex\u003c/code\u003e.\n If any other type of exception is raised than it will be propogated\n up to the next enclosing exception handler.\n\u003c/p\u003e\u003cpre\u003e  try a = catch (Right `liftM` a) (return . Left)\n\u003c/pre\u003e\u003cp\u003eNote that \u003ca\u003eSystem.IO.Error\u003c/a\u003e also exports a function called\n \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e with a similar type to \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e,\n except that it catches only the IO and user families of exceptions\n (as required by the Haskell 98 \u003ccode\u003eIO\u003c/code\u003e module).\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "try",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Either e a)",
          "type": "function"
        },
        "index": {
          "description": "Similar to catch but returns an Either result which is Right if no exception of type was raised or Left ex if an exception of type was raised and its value is ex If any other type of exception is raised than it will be propogated up to the next enclosing exception handler try catch Right liftM return Left Note that System.IO.Error also exports function called try with similar type to try except that it catches only the IO and user families of exceptions as required by the Haskell IO module",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "try",
          "normalized": "IO a-\u003eIO(Either b a)",
          "package": "uni-util",
          "signature": "IO a-\u003eIO(Either e a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:try"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "tryUntilOK",
          "package": "uni-util",
          "signature": "IO a -\u003e IO a",
          "source": "src/Util-Computation.html#tryUntilOK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "tryUntilOK",
          "normalized": "IO a-\u003eIO a",
          "package": "uni-util",
          "partial": "Until OK",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:tryUntilOK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe reverse of \u003ccode\u003e\u003ca\u003ewhen\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "unless",
          "package": "uni-util",
          "signature": "Bool -\u003e m () -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "The reverse of when",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "unless",
          "normalized": "Bool-\u003ea()-\u003ea()",
          "package": "uni-util",
          "signature": "Bool-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:unless"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConditional execution of monadic expressions. For example, \n\u003c/p\u003e\u003cpre\u003e       when debug (putStr \"Debugging\\n\")\n\u003c/pre\u003e\u003cp\u003ewill output the string \u003ccode\u003eDebugging\\n\u003c/code\u003e if the Boolean value \u003ccode\u003edebug\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e,\nand otherwise do nothing.\n\u003c/p\u003e",
          "module": "Util.Computation",
          "name": "when",
          "package": "uni-util",
          "signature": "Bool -\u003e m () -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Conditional execution of monadic expressions For example when debug putStr Debugging will output the string Debugging if the Boolean value debug is True and otherwise do nothing",
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "when",
          "normalized": "Bool-\u003ea()-\u003ea()",
          "package": "uni-util",
          "signature": "Bool-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:when"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Computation",
          "name": "while",
          "package": "uni-util",
          "signature": "m a -\u003e (a -\u003e Bool) -\u003e m a",
          "source": "src/Util-Computation.html#while",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Computation",
          "module": "Util.Computation",
          "name": "while",
          "normalized": "a b-\u003e(b-\u003eBool)-\u003ea b",
          "package": "uni-util",
          "signature": "m a-\u003e(a-\u003eBool)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Computation.html#v:while"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAUTHOR        : George Russell\n University of Bremen\n DATE          : 2000\n DESCRIPTION   : This module provides a uniform interface for debugging\n              purposes.  In final versions of this module it would\n              be best to make the debug function do nothing and\n              force it to be inlined.\n\u003c/p\u003e\u003cp\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e\u003ca name=\"\"/\u003e#\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Debug",
          "name": "Debug",
          "package": "uni-util",
          "source": "src/Util-Debug.html",
          "type": "module"
        },
        "index": {
          "description": "AUTHOR George Russell University of Bremen DATE DESCRIPTION This module provides uniform interface for debugging purposes In final versions of this module it would be best to make the debug function do nothing and force it to be inlined",
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "Debug",
          "package": "uni-util",
          "partial": "Debug",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Debug",
          "name": "(@@:)",
          "package": "uni-util",
          "signature": "String -\u003e IO a -\u003e IO a",
          "source": "src/Util-Debug.html#%40%40%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "(@@:) @@:",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:-64--64-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Debug",
          "name": "(@:)",
          "package": "uni-util",
          "signature": "String -\u003e IO a -\u003e IO a",
          "source": "src/Util-Debug.html#%40%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "(@:) @:",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:-64-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealways show something to the log file\n\u003c/p\u003e",
          "module": "Util.Debug",
          "name": "alwaysDebug",
          "package": "uni-util",
          "signature": "a -\u003e IO ()",
          "source": "src/Util-Debug.html#alwaysDebug",
          "type": "function"
        },
        "index": {
          "description": "always show something to the log file",
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "alwaysDebug",
          "normalized": "a-\u003eIO()",
          "package": "uni-util",
          "partial": "Debug",
          "signature": "a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:alwaysDebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealways print out a message if action fails.\n\u003c/p\u003e",
          "module": "Util.Debug",
          "name": "alwaysDebugAct",
          "package": "uni-util",
          "signature": "String -\u003e IO a -\u003e IO a",
          "source": "src/Util-Debug.html#alwaysDebugAct",
          "type": "function"
        },
        "index": {
          "description": "always print out message if action fails",
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "alwaysDebugAct",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "partial": "Debug Act",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:alwaysDebugAct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshow something to log file if debugging is turned on.\n\u003c/p\u003e",
          "module": "Util.Debug",
          "name": "debug",
          "package": "uni-util",
          "signature": "a -\u003e IO ()",
          "source": "src/Util-Debug.html#debug",
          "type": "function"
        },
        "index": {
          "description": "show something to log file if debugging is turned on",
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "debug",
          "normalized": "a-\u003eIO()",
          "package": "uni-util",
          "signature": "a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:debug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf an action fails print out a message before\n propagating message.\n\u003c/p\u003e",
          "module": "Util.Debug",
          "name": "debugAct",
          "package": "uni-util",
          "signature": "String -\u003e IO a -\u003e IO a",
          "source": "src/Util-Debug.html#debugAct",
          "type": "function"
        },
        "index": {
          "description": "If an action fails print out message before propagating message",
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "debugAct",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "partial": "Act",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:debugAct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend a string to the debug file.  This differs from\n debug, in that debug will Haskell-escape the string and add\n a newline, while just writes to the file with no interpretation.\n\u003c/p\u003e",
          "module": "Util.Debug",
          "name": "debugString",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Debug.html#debugString",
          "type": "function"
        },
        "index": {
          "description": "Send string to the debug file This differs from debug in that debug will Haskell-escape the string and add newline while just writes to the file with no interpretation",
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "debugString",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "String",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:debugString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Debug",
          "name": "wrapError",
          "package": "uni-util",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Util-Debug.html#wrapError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Debug",
          "module": "Util.Debug",
          "name": "wrapError",
          "normalized": "String-\u003ea-\u003ea",
          "package": "uni-util",
          "partial": "Error",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Debug.html#v:wrapError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule taken from Dean Harington's post to the Haskell mailing list\n on Fri, 17 Aug 2001.\n\u003c/p\u003e\u003cp\u003eURL is currently\n \u003ca\u003ehttp://www.haskell.org/pipermail/haskell/2001-August/007712.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThis module provides \u003ccode\u003e\u003ca\u003edeepSeq\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e$!!\u003c/a\u003e\u003c/code\u003e which correspond to \u003ccode\u003e\u003ca\u003eseq\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e$!\u003c/a\u003e\u003c/code\u003e\n except that they try to evaluate everything in the argument.  For example,\n if a list is provided, the whole list must be evaluated.\n\u003c/p\u003e\u003cp\u003eFor purposes of Haddock, empty instance declarations with \u003ccode\u003ewhere\u003c/code\u003e\n have had the \u003ccode\u003ewhere\u003c/code\u003e deleted.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.DeepSeq",
          "name": "DeepSeq",
          "package": "uni-util",
          "source": "src/Util-DeepSeq.html",
          "type": "module"
        },
        "index": {
          "description": "Module taken from Dean Harington post to the Haskell mailing list on Fri Aug URL is currently http www.haskell.org pipermail haskell August html This module provides deepSeq and which correspond to seq and except that they try to evaluate everything in the argument For example if list is provided the whole list must be evaluated For purposes of Haddock empty instance declarations with where have had the where deleted",
          "hierarchy": "Util DeepSeq",
          "module": "Util.DeepSeq",
          "name": "DeepSeq",
          "package": "uni-util",
          "partial": "Deep Seq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-DeepSeq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.DeepSeq",
          "name": "DeepSeq",
          "package": "uni-util",
          "source": "src/Util-DeepSeq.html#DeepSeq",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util DeepSeq",
          "module": "Util.DeepSeq",
          "name": "DeepSeq",
          "package": "uni-util",
          "partial": "Deep Seq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-DeepSeq.html#t:DeepSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.DeepSeq",
          "name": "($!!)",
          "package": "uni-util",
          "signature": "(a -\u003e b) -\u003e a -\u003e b",
          "source": "src/Util-DeepSeq.html#%24%21%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util DeepSeq",
          "module": "Util.DeepSeq",
          "name": "($!!) $!!",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "uni-util",
          "signature": "(a-\u003eb)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-DeepSeq.html#v:-36--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.DeepSeq",
          "name": "deepSeq",
          "package": "uni-util",
          "signature": "a -\u003e b -\u003e b",
          "source": "src/Util-DeepSeq.html#deepSeq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util DeepSeq",
          "module": "Util.DeepSeq",
          "name": "deepSeq",
          "normalized": "a-\u003eb-\u003eb",
          "package": "uni-util",
          "partial": "Seq",
          "signature": "a-\u003eb-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-DeepSeq.html#v:deepSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDelayers handle delaying of actions; the main purpose is to delay\n graph redrawing actions during complex updates.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Delayer",
          "name": "Delayer",
          "package": "uni-util",
          "source": "src/Util-Delayer.html",
          "type": "module"
        },
        "index": {
          "description": "Delayers handle delaying of actions the main purpose is to delay graph redrawing actions during complex updates",
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "Delayer",
          "package": "uni-util",
          "partial": "Delayer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "DelayedAction",
          "package": "uni-util",
          "source": "src/Util-Delayer.html#DelayedAction",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "DelayedAction",
          "package": "uni-util",
          "partial": "Delayed Action",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#t:DelayedAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "Delayer",
          "package": "uni-util",
          "source": "src/Util-Delayer.html#Delayer",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "Delayer",
          "package": "uni-util",
          "partial": "Delayer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#t:Delayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances of HasAddDelayer are event sources to which you can attach\n   a delayer, to indicate you are currently not interested in events.\n\u003c/p\u003e",
          "module": "Util.Delayer",
          "name": "HasAddDelayer",
          "package": "uni-util",
          "source": "src/Util-Delayer.html#HasAddDelayer",
          "type": "class"
        },
        "index": {
          "description": "Instances of HasAddDelayer are event sources to which you can attach delayer to indicate you are currently not interested in events",
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "HasAddDelayer",
          "package": "uni-util",
          "partial": "Has Add Delayer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#t:HasAddDelayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike HasAddDelayer, but allows an IO action.\n\u003c/p\u003e",
          "module": "Util.Delayer",
          "name": "HasAddDelayerIO",
          "package": "uni-util",
          "source": "src/Util-Delayer.html#HasAddDelayerIO",
          "type": "class"
        },
        "index": {
          "description": "Like HasAddDelayer but allows an IO action",
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "HasAddDelayerIO",
          "package": "uni-util",
          "partial": "Has Add Delayer IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#t:HasAddDelayerIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "HasDelayer",
          "package": "uni-util",
          "source": "src/Util-Delayer.html#HasDelayer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "HasDelayer",
          "package": "uni-util",
          "partial": "Has Delayer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#t:HasDelayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "addDelayer",
          "package": "uni-util",
          "signature": "Delayer -\u003e eventSource -\u003e eventSource",
          "source": "src/Util-Delayer.html#addDelayer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "addDelayer",
          "normalized": "Delayer-\u003ea-\u003ea",
          "package": "uni-util",
          "partial": "Delayer",
          "signature": "Delayer-\u003eeventSource-\u003eeventSource",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:addDelayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "addDelayerIO",
          "package": "uni-util",
          "signature": "Delayer -\u003e eventSource -\u003e IO eventSource",
          "source": "src/Util-Delayer.html#addDelayerIO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "addDelayerIO",
          "normalized": "Delayer-\u003ea-\u003eIO a",
          "package": "uni-util",
          "partial": "Delayer IO",
          "signature": "Delayer-\u003eeventSource-\u003eIO eventSource",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:addDelayerIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf this DelayedAction is queued, remove it from the queue.\n\u003c/p\u003e",
          "module": "Util.Delayer",
          "name": "cancelDelayedAct",
          "package": "uni-util",
          "signature": "Delayer -\u003e DelayedAction -\u003e IO ()",
          "source": "src/Util-Delayer.html#cancelDelayedAct",
          "type": "function"
        },
        "index": {
          "description": "If this DelayedAction is queued remove it from the queue",
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "cancelDelayedAct",
          "normalized": "Delayer-\u003eDelayedAction-\u003eIO()",
          "package": "uni-util",
          "partial": "Delayed Act",
          "signature": "Delayer-\u003eDelayedAction-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:cancelDelayedAct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecarry out the given action preventing the Delayer from doing anything.\n\u003c/p\u003e",
          "module": "Util.Delayer",
          "name": "delay",
          "package": "uni-util",
          "signature": "object -\u003e IO a -\u003e IO a",
          "source": "src/Util-Delayer.html#delay",
          "type": "function"
        },
        "index": {
          "description": "carry out the given action preventing the Delayer from doing anything",
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "delay",
          "normalized": "a-\u003eIO b-\u003eIO b",
          "package": "uni-util",
          "signature": "object-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "delayedAct",
          "package": "uni-util",
          "signature": "Delayer -\u003e DelayedAction -\u003e IO ()",
          "source": "src/Util-Delayer.html#delayedAct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "delayedAct",
          "normalized": "Delayer-\u003eDelayedAction-\u003eIO()",
          "package": "uni-util",
          "partial": "Act",
          "signature": "Delayer-\u003eDelayedAction-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:delayedAct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "newDelayedAction",
          "package": "uni-util",
          "signature": "IO () -\u003e IO DelayedAction",
          "source": "src/Util-Delayer.html#newDelayedAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "newDelayedAction",
          "normalized": "IO()-\u003eIO DelayedAction",
          "package": "uni-util",
          "partial": "Delayed Action",
          "signature": "IO()-\u003eIO DelayedAction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:newDelayedAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "newDelayer",
          "package": "uni-util",
          "signature": "IO Delayer",
          "source": "src/Util-Delayer.html#newDelayer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "newDelayer",
          "package": "uni-util",
          "partial": "Delayer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:newDelayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Delayer",
          "name": "toDelayer",
          "package": "uni-util",
          "signature": "object -\u003e Delayer",
          "source": "src/Util-Delayer.html#toDelayer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Delayer",
          "module": "Util.Delayer",
          "name": "toDelayer",
          "normalized": "a-\u003eDelayer",
          "package": "uni-util",
          "partial": "Delayer",
          "signature": "object-\u003eDelayer",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Delayer.html#v:toDelayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA wrapper for the new GHC (and Hugs) Dynamic module.\n The main improvement over the original Dynamic module is\n that we provide flavours of TypeableXXXX for kinds with\n arguments other than *, a feature used by \u003ca\u003eDisplayView\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Dynamics",
          "name": "Dynamics",
          "package": "uni-util",
          "source": "src/Util-Dynamics.html",
          "type": "module"
        },
        "index": {
          "description": "wrapper for the new GHC and Hugs Dynamic module The main improvement over the original Dynamic module is that we provide flavours of TypeableXXXX for kinds with arguments other than feature used by DisplayView",
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "Dynamics",
          "package": "uni-util",
          "partial": "Dynamics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "Dyn",
          "package": "uni-util",
          "source": "src/Util-Dynamics.html#Dyn",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "Dyn",
          "package": "uni-util",
          "partial": "Dyn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#t:Dyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA concrete representation of a (monomorphic) type.  \u003ccode\u003e\u003ca\u003eTypeRep\u003c/a\u003e\u003c/code\u003e\n supports reasonably efficient equality.\n\u003c/p\u003e",
          "module": "Util.Dynamics",
          "name": "TypeRep",
          "package": "uni-util",
          "type": "data"
        },
        "index": {
          "description": "concrete representation of monomorphic type TypeRep supports reasonably efficient equality",
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "TypeRep",
          "package": "uni-util",
          "partial": "Type Rep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#t:TypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e allows a concrete representation of a type to\n be calculated.\n\u003c/p\u003e",
          "module": "Util.Dynamics",
          "name": "Typeable",
          "package": "uni-util",
          "type": "class"
        },
        "index": {
          "description": "The class Typeable allows concrete representation of type to be calculated",
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "Typeable",
          "package": "uni-util",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#t:Typeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "coerce",
          "package": "uni-util",
          "signature": "Dyn -\u003e a",
          "source": "src/Util-Dynamics.html#coerce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "coerce",
          "normalized": "Dyn-\u003ea",
          "package": "uni-util",
          "signature": "Dyn-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:coerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "coerceIO",
          "package": "uni-util",
          "signature": "Dyn -\u003e IO a",
          "source": "src/Util-Dynamics.html#coerceIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "coerceIO",
          "normalized": "Dyn-\u003eIO a",
          "package": "uni-util",
          "partial": "IO",
          "signature": "Dyn-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:coerceIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "dynCast",
          "package": "uni-util",
          "signature": "String -\u003e a -\u003e b",
          "source": "src/Util-Dynamics.html#dynCast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "dynCast",
          "normalized": "String-\u003ea-\u003eb",
          "package": "uni-util",
          "partial": "Cast",
          "signature": "String-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:dynCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "dynCastOpt",
          "package": "uni-util",
          "signature": "a -\u003e Maybe b",
          "source": "src/Util-Dynamics.html#dynCastOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "dynCastOpt",
          "normalized": "a-\u003eMaybe b",
          "package": "uni-util",
          "partial": "Cast Opt",
          "signature": "a-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:dynCastOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "fromDynamic",
          "package": "uni-util",
          "signature": "Dyn -\u003e Maybe a",
          "source": "src/Util-Dynamics.html#fromDynamic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "fromDynamic",
          "normalized": "Dyn-\u003eMaybe a",
          "package": "uni-util",
          "partial": "Dynamic",
          "signature": "Dyn-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:fromDynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003efromDynamic\u003c/a\u003e\u003c/code\u003e but provides an error message indicating what\n types are getting confused.\n\u003c/p\u003e",
          "module": "Util.Dynamics",
          "name": "fromDynamicWE",
          "package": "uni-util",
          "signature": "Dyn -\u003e WithError a",
          "source": "src/Util-Dynamics.html#fromDynamicWE",
          "type": "function"
        },
        "index": {
          "description": "Like fromDynamic but provides an error message indicating what types are getting confused",
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "fromDynamicWE",
          "normalized": "Dyn-\u003eWithError a",
          "package": "uni-util",
          "partial": "Dynamic WE",
          "signature": "Dyn-\u003eWithError a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:fromDynamicWE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "toDyn",
          "package": "uni-util",
          "signature": "a -\u003e Dyn",
          "source": "src/Util-Dynamics.html#toDyn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "toDyn",
          "normalized": "a-\u003eDyn",
          "package": "uni-util",
          "partial": "Dyn",
          "signature": "a-\u003eDyn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:toDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Dynamics",
          "name": "typeMismatch",
          "package": "uni-util",
          "signature": "IOError",
          "source": "src/Util-Dynamics.html#typeMismatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "typeMismatch",
          "package": "uni-util",
          "partial": "Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:typeMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a value of type \u003ccode\u003ea\u003c/code\u003e and returns a concrete representation\n of that type.  The \u003cem\u003evalue\u003c/em\u003e of the argument should be ignored by\n any instance of \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e, so that it is safe to pass \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e as\n the argument.\n\u003c/p\u003e",
          "module": "Util.Dynamics",
          "name": "typeOf",
          "package": "uni-util",
          "signature": "a -\u003e TypeRep",
          "type": "method"
        },
        "index": {
          "description": "Takes value of type and returns concrete representation of that type The value of the argument should be ignored by any instance of Typeable so that it is safe to pass undefined as the argument",
          "hierarchy": "Util Dynamics",
          "module": "Util.Dynamics",
          "name": "typeOf",
          "normalized": "a-\u003eTypeRep",
          "package": "uni-util",
          "partial": "Of",
          "signature": "a-\u003eTypeRep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Dynamics.html#v:typeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic string-manipulation and other functions they forgot to put in\n the standard prelude.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "ExtendedPrelude",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html",
          "type": "module"
        },
        "index": {
          "description": "Basic string-manipulation and other functions they forgot to put in the standard prelude",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "ExtendedPrelude",
          "package": "uni-util",
          "partial": "Extended Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function indicating we want to escape from the current computation.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "BreakFn",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#BreakFn",
          "type": "type"
        },
        "index": {
          "description": "function indicating we want to escape from the current computation",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "BreakFn",
          "package": "uni-util",
          "partial": "Break Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:BreakFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "EqIO",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#EqIO",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "EqIO",
          "package": "uni-util",
          "partial": "Eq IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:EqIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindicates that an Ord or Eq instance really does need to\n take everything into account.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "Full",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#Full",
          "type": "newtype"
        },
        "index": {
          "description": "indicates that an Ord or Eq instance really does need to take everything into account",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "Full",
          "package": "uni-util",
          "partial": "Full",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:Full"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "GeneralBreakFn",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#GeneralBreakFn",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "GeneralBreakFn",
          "package": "uni-util",
          "partial": "General Break Fn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:GeneralBreakFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "GeneralCatchFn",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#GeneralCatchFn",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "GeneralCatchFn",
          "package": "uni-util",
          "partial": "General Catch Fn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:GeneralCatchFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "HasCoMapIO",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#HasCoMapIO",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "HasCoMapIO",
          "package": "uni-util",
          "partial": "Has Co Map IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:HasCoMapIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "HasMapIO",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#HasMapIO",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "HasMapIO",
          "package": "uni-util",
          "partial": "Has Map IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:HasMapIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "HasMapMonadic",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#HasMapMonadic",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "HasMapMonadic",
          "package": "uni-util",
          "partial": "Has Map Monadic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:HasMapMonadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "OrdIO",
          "package": "uni-util",
          "source": "src/Util-ExtendedPrelude.html#OrdIO",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "OrdIO",
          "package": "uni-util",
          "partial": "Ord IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#t:OrdIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "Full",
          "package": "uni-util",
          "signature": "Full a",
          "source": "src/Util-ExtendedPrelude.html#Full",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "Full",
          "package": "uni-util",
          "partial": "Full",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:Full"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "GeneralBreakFn",
          "package": "uni-util",
          "signature": "GeneralBreakFn (forall b.  a -\u003e b)",
          "source": "src/Util-ExtendedPrelude.html#GeneralBreakFn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "GeneralBreakFn",
          "normalized": "GeneralBreakFn(a b c-\u003ed)",
          "package": "uni-util",
          "partial": "General Break Fn",
          "signature": "GeneralBreakFn(forall b. a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:GeneralBreakFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "GeneralCatchFn",
          "package": "uni-util",
          "signature": "GeneralCatchFn (forall c.  IO c -\u003e IO (Either a c))",
          "source": "src/Util-ExtendedPrelude.html#GeneralCatchFn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "GeneralCatchFn",
          "normalized": "GeneralCatchFn(a b IO c-\u003eIO(Either d c))",
          "package": "uni-util",
          "partial": "General Catch Fn",
          "signature": "GeneralCatchFn(forall c. IO c-\u003eIO(Either a c))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:GeneralCatchFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntended use, EG\n    addFallOut ( break -\u003e\n       do\n          -- blah blah (normal IO a stuff) --\n          when (break condition)\n             (break \u003ca\u003eYou can't do that there ere\u003c/a\u003e)\n          -- more blah blah, not executed if there's an break --\n          return (value of type a)\n       )\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "addFallOut",
          "package": "uni-util",
          "signature": "(BreakFn -\u003e IO a) -\u003e IO (Either String a)",
          "source": "src/Util-ExtendedPrelude.html#addFallOut",
          "type": "function"
        },
        "index": {
          "description": "Intended use EG addFallOut break do blah blah normal IO stuff when break condition break You can do that there ere more blah blah not executed if there an break return value of type",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "addFallOut",
          "normalized": "(BreakFn-\u003eIO a)-\u003eIO(Either String a)",
          "package": "uni-util",
          "partial": "Fall Out",
          "signature": "(BreakFn-\u003eIO a)-\u003eIO(Either String a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:addFallOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike addFallOut, but returns a WithError object instead.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "addFallOutWE",
          "package": "uni-util",
          "signature": "(BreakFn -\u003e IO a) -\u003e IO (WithError a)",
          "source": "src/Util-ExtendedPrelude.html#addFallOutWE",
          "type": "function"
        },
        "index": {
          "description": "Like addFallOut but returns WithError object instead",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "addFallOutWE",
          "normalized": "(BreakFn-\u003eIO a)-\u003eIO(WithError a)",
          "package": "uni-util",
          "partial": "Fall Out WE",
          "signature": "(BreakFn-\u003eIO a)-\u003eIO(WithError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:addFallOutWE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "addGeneralFallOut",
          "package": "uni-util",
          "signature": "IO (GeneralBreakFn a, GeneralCatchFn a)",
          "source": "src/Util-ExtendedPrelude.html#addGeneralFallOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "addGeneralFallOut",
          "normalized": "IO(GeneralBreakFn a,GeneralCatchFn a)",
          "package": "uni-util",
          "partial": "General Fall Out",
          "signature": "IO(GeneralBreakFn a,GeneralCatchFn a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:addGeneralFallOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "addSimpleFallOut",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Either String a)",
          "source": "src/Util-ExtendedPrelude.html#addSimpleFallOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "addSimpleFallOut",
          "normalized": "IO a-\u003eIO(Either String a)",
          "package": "uni-util",
          "partial": "Simple Fall Out",
          "signature": "IO a-\u003eIO(Either String a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:addSimpleFallOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf all the elements are equal, return True\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "allEq",
          "package": "uni-util",
          "signature": "[a] -\u003e Bool",
          "source": "src/Util-ExtendedPrelude.html#allEq",
          "type": "function"
        },
        "index": {
          "description": "If all the elements are equal return True",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "allEq",
          "normalized": "[a]-\u003eBool",
          "package": "uni-util",
          "partial": "Eq",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:allEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn Just True if all the elements give True, Just False if all False,\n Nothing otherwise (or list is empty).\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "allSame",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe Bool",
          "source": "src/Util-ExtendedPrelude.html#allSame",
          "type": "function"
        },
        "index": {
          "description": "Return Just True if all the elements give True Just False if all False Nothing otherwise or list is empty",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "allSame",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe Bool",
          "package": "uni-util",
          "partial": "Same",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:allSame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "bottom",
          "package": "uni-util",
          "signature": "a",
          "source": "src/Util-ExtendedPrelude.html#bottom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "bottom",
          "package": "uni-util",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:bottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "breakOtherExceps",
          "package": "uni-util",
          "signature": "BreakFn -\u003e IO a -\u003e IO a",
          "source": "src/Util-ExtendedPrelude.html#breakOtherExceps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "breakOtherExceps",
          "normalized": "BreakFn-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "partial": "Other Exceps",
          "signature": "BreakFn-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:breakOtherExceps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "catchAllExceps",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Either String a)",
          "source": "src/Util-ExtendedPrelude.html#catchAllExceps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "catchAllExceps",
          "normalized": "IO a-\u003eIO(Either String a)",
          "package": "uni-util",
          "partial": "All Exceps",
          "signature": "IO a-\u003eIO(Either String a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:catchAllExceps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "catchOurExceps",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Either String a)",
          "source": "src/Util-ExtendedPrelude.html#catchOurExceps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "catchOurExceps",
          "normalized": "IO a-\u003eIO(Either String a)",
          "package": "uni-util",
          "partial": "Our Exceps",
          "signature": "IO a-\u003eIO(Either String a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:catchOurExceps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "chop",
          "package": "uni-util",
          "signature": "Int -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Util-ExtendedPrelude.html#chop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "chop",
          "normalized": "Int-\u003e[a]-\u003eMaybe[a]",
          "package": "uni-util",
          "signature": "Int-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:chop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "coMapIO",
          "package": "uni-util",
          "signature": "(a -\u003e IO b) -\u003e option b -\u003e option a",
          "source": "src/Util-ExtendedPrelude.html#coMapIO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "coMapIO",
          "normalized": "(a-\u003eIO b)-\u003ec b-\u003ec a",
          "package": "uni-util",
          "partial": "Map IO",
          "signature": "(a-\u003eIO b)-\u003eoption b-\u003eoption a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:coMapIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "compareIO",
          "package": "uni-util",
          "signature": "v -\u003e v -\u003e IO Ordering",
          "source": "src/Util-ExtendedPrelude.html#compareIO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "compareIO",
          "normalized": "a-\u003ea-\u003eIO Ordering",
          "package": "uni-util",
          "partial": "IO",
          "signature": "v-\u003ev-\u003eIO Ordering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:compareIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "deleteAndFindFirst",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e (a, [a])",
          "source": "src/Util-ExtendedPrelude.html#deleteAndFindFirst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "deleteAndFindFirst",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e(a,[a])",
          "package": "uni-util",
          "partial": "And Find First",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:deleteAndFindFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "deleteAndFindFirstOpt",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe (a, [a])",
          "source": "src/Util-ExtendedPrelude.html#deleteAndFindFirstOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "deleteAndFindFirstOpt",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe(a,[a])",
          "package": "uni-util",
          "partial": "And Find First Opt",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:deleteAndFindFirstOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "deleteFirst",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#deleteFirst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "deleteFirst",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "First",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:deleteFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "deleteFirstOpt",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#deleteFirstOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "deleteFirstOpt",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "First Opt",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:deleteFirstOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "divideList",
          "package": "uni-util",
          "signature": "(a -\u003e Either b c) -\u003e [a] -\u003e ([b], [c])",
          "source": "src/Util-ExtendedPrelude.html#divideList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "divideList",
          "normalized": "(a-\u003eEither b c)-\u003e[a]-\u003e([b],[c])",
          "package": "uni-util",
          "partial": "List",
          "signature": "(a-\u003eEither b c)-\u003e[a]-\u003e([b],[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:divideList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "eqIO",
          "package": "uni-util",
          "signature": "v -\u003e v -\u003e IO Bool",
          "source": "src/Util-ExtendedPrelude.html#eqIO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "eqIO",
          "normalized": "a-\u003ea-\u003eIO Bool",
          "package": "uni-util",
          "partial": "IO",
          "signature": "v-\u003ev-\u003eIO Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:eqIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "errorOurExceps",
          "package": "uni-util",
          "signature": "IO a -\u003e IO a",
          "source": "src/Util-ExtendedPrelude.html#errorOurExceps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "errorOurExceps",
          "normalized": "IO a-\u003eIO a",
          "package": "uni-util",
          "partial": "Our Exceps",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:errorOurExceps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf there are two elements of the list with the same (a), return one,\n otherwise Nothing.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "findDuplicate",
          "package": "uni-util",
          "signature": "(b -\u003e a) -\u003e [b] -\u003e Maybe b",
          "source": "src/Util-ExtendedPrelude.html#findDuplicate",
          "type": "function"
        },
        "index": {
          "description": "If there are two elements of the list with the same return one otherwise Nothing",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "findDuplicate",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003eMaybe a",
          "package": "uni-util",
          "partial": "Duplicate",
          "signature": "(b-\u003ea)-\u003e[b]-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:findDuplicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "findJust",
          "package": "uni-util",
          "signature": "(a -\u003e Maybe b) -\u003e [a] -\u003e Maybe b",
          "source": "src/Util-ExtendedPrelude.html#findJust",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "findJust",
          "normalized": "(a-\u003eMaybe b)-\u003e[a]-\u003eMaybe b",
          "package": "uni-util",
          "partial": "Just",
          "signature": "(a-\u003eMaybe b)-\u003e[a]-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:findJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA merge function for combining an input list with some new data,\n where both are pre-sorted.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "generalisedMerge",
          "package": "uni-util",
          "signature": "[a]-\u003e [b]-\u003e (a -\u003e b -\u003e Ordering)-\u003e (Maybe a -\u003e Maybe b -\u003e m (Maybe a, Maybe c))-\u003e m ([a], [c])",
          "type": "function"
        },
        "index": {
          "description": "merge function for combining an input list with some new data where both are pre-sorted",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "generalisedMerge",
          "normalized": "[a]-\u003e[b]-\u003e(a-\u003eb-\u003eOrdering)-\u003e(Maybe a-\u003eMaybe b-\u003ec(Maybe a,Maybe d))-\u003ec([a],[d])",
          "package": "uni-util",
          "partial": "Merge",
          "signature": "[a]-\u003e[b]-\u003e(a-\u003eb-\u003eOrdering)-\u003e(Maybe a-\u003eMaybe b-\u003em(Maybe a,Maybe c))-\u003em([a],[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:generalisedMerge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "insertOrd",
          "package": "uni-util",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e a -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#insertOrd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "insertOrd",
          "normalized": "(a-\u003ea-\u003eBool)-\u003ea-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord",
          "signature": "(a-\u003ea-\u003eBool)-\u003ea-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:insertOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einsertOrdAlternate is similar to insertOrd except (1) it takes an Ordering\n argument; (2) if it finds an argument that matches, it applies the\n given function to generate a new element, rather than inserting another.\n The new generated element should be EQ to the old one.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "insertOrdAlternate",
          "package": "uni-util",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e a -\u003e (a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#insertOrdAlternate",
          "type": "function"
        },
        "index": {
          "description": "insertOrdAlternate is similar to insertOrd except it takes an Ordering argument if it finds an argument that matches it applies the given function to generate new element rather than inserting another The new generated element should be EQ to the old one",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "insertOrdAlternate",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord Alternate",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:insertOrdAlternate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "insertOrdGt",
          "package": "uni-util",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#insertOrdGt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "insertOrdGt",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord Gt",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:insertOrdGt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "insertOrdLt",
          "package": "uni-util",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#insertOrdLt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "insertOrdLt",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord Lt",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:insertOrdLt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "isOurFallOut",
          "package": "uni-util",
          "signature": "ObjectID -\u003e Dyn -\u003e Maybe String",
          "source": "src/Util-ExtendedPrelude.html#isOurFallOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "isOurFallOut",
          "normalized": "ObjectID-\u003eDyn-\u003eMaybe String",
          "package": "uni-util",
          "partial": "Our Fall Out",
          "signature": "ObjectID-\u003eDyn-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:isOurFallOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns remainder if the first list is a prefix of the second one.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "isPrefix",
          "package": "uni-util",
          "signature": "[a] -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Util-ExtendedPrelude.html#isPrefix",
          "type": "function"
        },
        "index": {
          "description": "returns remainder if the first list is prefix of the second one",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "isPrefix",
          "normalized": "[a]-\u003e[a]-\u003eMaybe[a]",
          "package": "uni-util",
          "partial": "Prefix",
          "signature": "[a]-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:isPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "lastOpt",
          "package": "uni-util",
          "signature": "[a] -\u003e Maybe a",
          "source": "src/Util-ExtendedPrelude.html#lastOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "lastOpt",
          "normalized": "[a]-\u003eMaybe a",
          "package": "uni-util",
          "partial": "Opt",
          "signature": "[a]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:lastOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduce an equality function for b\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "mapEq",
          "package": "uni-util",
          "signature": "(b -\u003e a) -\u003e b -\u003e b -\u003e Bool",
          "source": "src/Util-ExtendedPrelude.html#mapEq",
          "type": "function"
        },
        "index": {
          "description": "Produce an equality function for",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "mapEq",
          "normalized": "(a-\u003eb)-\u003ea-\u003ea-\u003eBool",
          "package": "uni-util",
          "partial": "Eq",
          "signature": "(b-\u003ea)-\u003eb-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:mapEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "mapIO",
          "package": "uni-util",
          "signature": "(a -\u003e IO b) -\u003e option a -\u003e option b",
          "source": "src/Util-ExtendedPrelude.html#mapIO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "mapIO",
          "normalized": "(a-\u003eIO b)-\u003ec a-\u003ec b",
          "package": "uni-util",
          "partial": "IO",
          "signature": "(a-\u003eIO b)-\u003eoption a-\u003eoption b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:mapIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "mapMonadic",
          "package": "uni-util",
          "signature": "(a -\u003e m b) -\u003e h a -\u003e m (h b)",
          "source": "src/Util-ExtendedPrelude.html#mapMonadic",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "mapMonadic",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
          "package": "uni-util",
          "partial": "Monadic",
          "signature": "(a-\u003em b)-\u003eh a-\u003em(h b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:mapMonadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduce a compare function for b\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "mapOrd",
          "package": "uni-util",
          "signature": "(b -\u003e a) -\u003e b -\u003e b -\u003e Ordering",
          "source": "src/Util-ExtendedPrelude.html#mapOrd",
          "type": "function"
        },
        "index": {
          "description": "Produce compare function for",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "mapOrd",
          "normalized": "(a-\u003eb)-\u003ea-\u003ea-\u003eOrdering",
          "package": "uni-util",
          "partial": "Ord",
          "signature": "(b-\u003ea)-\u003eb-\u003eb-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:mapOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "mapPartialM",
          "package": "uni-util",
          "signature": "(a -\u003e m (Maybe b)) -\u003e [a] -\u003e m [b]",
          "source": "src/Util-ExtendedPrelude.html#mapPartialM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "mapPartialM",
          "normalized": "(a-\u003eb(Maybe c))-\u003e[a]-\u003eb[c]",
          "package": "uni-util",
          "partial": "Partial",
          "signature": "(a-\u003em(Maybe b))-\u003e[a]-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:mapPartialM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "mkBreakFn",
          "package": "uni-util",
          "signature": "ObjectID -\u003e BreakFn",
          "source": "src/Util-ExtendedPrelude.html#mkBreakFn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "mkBreakFn",
          "normalized": "ObjectID-\u003eBreakFn",
          "package": "uni-util",
          "partial": "Break Fn",
          "signature": "ObjectID-\u003eBreakFn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:mkBreakFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ca\u003e.\u003c/a\u003e operator lifted to monads.   So like ., the arguments\n are given in the reverse order to that in which they should\n be executed.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "monadDot",
          "package": "uni-util",
          "signature": "(b -\u003e m c) -\u003e (a -\u003e m b) -\u003e a -\u003e m c",
          "source": "src/Util-ExtendedPrelude.html#monadDot",
          "type": "function"
        },
        "index": {
          "description": "The operator lifted to monads So like the arguments are given in the reverse order to that in which they should be executed",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "monadDot",
          "normalized": "(a-\u003eb c)-\u003e(d-\u003eb a)-\u003ed-\u003eb c",
          "package": "uni-util",
          "partial": "Dot",
          "signature": "(b-\u003em c)-\u003e(a-\u003em b)-\u003ea-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:monadDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "newFallOut",
          "package": "uni-util",
          "signature": "IO (ObjectID, IO a -\u003e IO (Either String a))",
          "source": "src/Util-ExtendedPrelude.html#newFallOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "newFallOut",
          "normalized": "IO(ObjectID,IO a-\u003eIO(Either String a))",
          "package": "uni-util",
          "partial": "Fall Out",
          "signature": "IO(ObjectID,IO a-\u003eIO(Either String a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:newFallOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "ourExcepToMess",
          "package": "uni-util",
          "signature": "Dyn -\u003e Maybe String",
          "source": "src/Util-ExtendedPrelude.html#ourExcepToMess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "ourExcepToMess",
          "normalized": "Dyn-\u003eMaybe String",
          "package": "uni-util",
          "partial": "Excep To Mess",
          "signature": "Dyn-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:ourExcepToMess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePad a string if necessary to the given length with leading spaces.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "padToLength",
          "package": "uni-util",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Util-ExtendedPrelude.html#padToLength",
          "type": "function"
        },
        "index": {
          "description": "Pad string if necessary to the given length with leading spaces",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "padToLength",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "uni-util",
          "partial": "To Length",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:padToLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "pairList",
          "package": "uni-util",
          "signature": "a -\u003e [b] -\u003e [(a, b)]",
          "source": "src/Util-ExtendedPrelude.html#pairList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "pairList",
          "normalized": "a-\u003e[b]-\u003e[(a,b)]",
          "package": "uni-util",
          "partial": "List",
          "signature": "a-\u003e[b]-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:pairList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturns Just a if we can read a, and the rest is just spaces.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "readCheck",
          "package": "uni-util",
          "signature": "String -\u003e Maybe a",
          "source": "src/Util-ExtendedPrelude.html#readCheck",
          "type": "function"
        },
        "index": {
          "description": "returns Just if we can read and the rest is just spaces",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "readCheck",
          "normalized": "String-\u003eMaybe a",
          "package": "uni-util",
          "partial": "Check",
          "signature": "String-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:readCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "showException2",
          "package": "uni-util",
          "signature": "Dyn -\u003e String",
          "source": "src/Util-ExtendedPrelude.html#showException2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "showException2",
          "normalized": "Dyn-\u003eString",
          "package": "uni-util",
          "partial": "Exception",
          "signature": "Dyn-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:showException2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "simpleFallOut",
          "package": "uni-util",
          "signature": "BreakFn",
          "source": "src/Util-ExtendedPrelude.html#simpleFallOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "simpleFallOut",
          "package": "uni-util",
          "partial": "Fall Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:simpleFallOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "simpleSplit",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Util-ExtendedPrelude.html#simpleSplit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "simpleSplit",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "uni-util",
          "partial": "Split",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:simpleSplit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "splitByChar",
          "package": "uni-util",
          "signature": "Char -\u003e String -\u003e [String]",
          "source": "src/Util-ExtendedPrelude.html#splitByChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "splitByChar",
          "normalized": "Char-\u003eString-\u003e[String]",
          "package": "uni-util",
          "partial": "By Char",
          "signature": "Char-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:splitByChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe split at the first occurrence of the character, returning the\n string before and after.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "splitToChar",
          "package": "uni-util",
          "signature": "Char -\u003e String -\u003e Maybe (String, String)",
          "source": "src/Util-ExtendedPrelude.html#splitToChar",
          "type": "function"
        },
        "index": {
          "description": "We split at the first occurrence of the character returning the string before and after",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "splitToChar",
          "normalized": "Char-\u003eString-\u003eMaybe(String,String)",
          "package": "uni-util",
          "partial": "To Char",
          "signature": "Char-\u003eString-\u003eMaybe(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:splitToChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "splitToElem",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe ([a], [a])",
          "source": "src/Util-ExtendedPrelude.html#splitToElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "splitToElem",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe([a],[a])",
          "package": "uni-util",
          "partial": "To Elem",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:splitToElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "splitToElemGeneral",
          "package": "uni-util",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe ([a], a, [a])",
          "source": "src/Util-ExtendedPrelude.html#splitToElemGeneral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "splitToElemGeneral",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe([a],a,[a])",
          "package": "uni-util",
          "partial": "To Elem General",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe([a],a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:splitToElemGeneral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enode is the tree's node type.\n state is folded through every node of the tree (and is the result).\n We search the tree in depth-first order, applying visitNode at each\n   node to update the state.\n The ancestorInfo information comes from the ancestors of the node.  EG\n if we are visiting node N1 which came from N2 the ancestorInfo given to\n visitNode for N1 will be that computed from visitNode for N2.\n For the root node, it will be initialAncestor\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "treeFold",
          "package": "uni-util",
          "signature": "(ancestorInfo -\u003e state -\u003e node -\u003e (ancestorInfo, state, [node])) -\u003e ancestorInfo -\u003e state -\u003e node -\u003e state",
          "source": "src/Util-ExtendedPrelude.html#treeFold",
          "type": "function"
        },
        "index": {
          "description": "node is the tree node type state is folded through every node of the tree and is the result We search the tree in depth-first order applying visitNode at each node to update the state The ancestorInfo information comes from the ancestors of the node EG if we are visiting node N1 which came from N2 the ancestorInfo given to visitNode for N1 will be that computed from visitNode for N2 For the root node it will be initialAncestor",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "treeFold",
          "normalized": "(a-\u003eb-\u003ec-\u003e(a,b,[c]))-\u003ea-\u003eb-\u003ec-\u003eb",
          "package": "uni-util",
          "partial": "Fold",
          "signature": "(ancestorInfo-\u003estate-\u003enode-\u003e(ancestorInfo,state,[node]))-\u003eancestorInfo-\u003estate-\u003enode-\u003estate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:treeFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike treeFold, but using monads.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "treeFoldM",
          "package": "uni-util",
          "signature": "(ancestorInfo -\u003e state -\u003e node -\u003e m (ancestorInfo, state, [node])) -\u003e ancestorInfo -\u003e state -\u003e node -\u003e m state",
          "source": "src/Util-ExtendedPrelude.html#treeFoldM",
          "type": "function"
        },
        "index": {
          "description": "Like treeFold but using monads",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "treeFoldM",
          "normalized": "(a-\u003eb-\u003ec-\u003ed(a,b,[c]))-\u003ea-\u003eb-\u003ec-\u003ed b",
          "package": "uni-util",
          "partial": "Fold",
          "signature": "(ancestorInfo-\u003estate-\u003enode-\u003em(ancestorInfo,state,[node]))-\u003eancestorInfo-\u003estate-\u003enode-\u003em state",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:treeFoldM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove leading spaces\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "trimLeading",
          "package": "uni-util",
          "signature": "String -\u003e String",
          "source": "src/Util-ExtendedPrelude.html#trimLeading",
          "type": "function"
        },
        "index": {
          "description": "Remove leading spaces",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "trimLeading",
          "normalized": "String-\u003eString",
          "package": "uni-util",
          "partial": "Leading",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:trimLeading"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove trailing and leading spaces\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "trimSpaces",
          "package": "uni-util",
          "signature": "String -\u003e String",
          "source": "src/Util-ExtendedPrelude.html#trimSpaces",
          "type": "function"
        },
        "index": {
          "description": "Remove trailing and leading spaces",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "trimSpaces",
          "normalized": "String-\u003eString",
          "package": "uni-util",
          "partial": "Spaces",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:trimSpaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove trailing spaces (We try to avoid reconstructing the string,\n on the assumption that there aren't often spaces)\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "trimTrailing",
          "package": "uni-util",
          "signature": "String -\u003e String",
          "source": "src/Util-ExtendedPrelude.html#trimTrailing",
          "type": "function"
        },
        "index": {
          "description": "Remove trailing spaces We try to avoid reconstructing the string on the assumption that there aren often spaces",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "trimTrailing",
          "normalized": "String-\u003eString",
          "package": "uni-util",
          "partial": "Trailing",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:trimTrailing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove duplicate elements from a list.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrd",
          "package": "uni-util",
          "signature": "[a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#uniqOrd",
          "type": "function"
        },
        "index": {
          "description": "Remove duplicate elements from list",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrd",
          "normalized": "[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:uniqOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove duplicate elements from a list where the key function is supplied.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrdByKey",
          "package": "uni-util",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#uniqOrdByKey",
          "type": "function"
        },
        "index": {
          "description": "Remove duplicate elements from list where the key function is supplied",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrdByKey",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord By Key",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:uniqOrdByKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove duplicate elements from a list where the key function is supplied.\n The list order is preserved and of the duplicates, it is the first in the\n list which is not deleted.\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrdByKeyOrder",
          "package": "uni-util",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#uniqOrdByKeyOrder",
          "type": "function"
        },
        "index": {
          "description": "Remove duplicate elements from list where the key function is supplied The list order is preserved and of the duplicates it is the first in the list which is not deleted",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrdByKeyOrder",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord By Key Order",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:uniqOrdByKeyOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike uniqOrd, except that we specify the output order of the list.\n The resulting list is that obtained by deleting all duplicate elements\n in the list, except the first, for example [1,2,3,2,1,4] will go to\n [1,2,3,4].\n\u003c/p\u003e",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrdOrder",
          "package": "uni-util",
          "signature": "[a] -\u003e [a]",
          "source": "src/Util-ExtendedPrelude.html#uniqOrdOrder",
          "type": "function"
        },
        "index": {
          "description": "Like uniqOrd except that we specify the output order of the list The resulting list is that obtained by deleting all duplicate elements in the list except the first for example will go to",
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "uniqOrdOrder",
          "normalized": "[a]-\u003e[a]",
          "package": "uni-util",
          "partial": "Ord Order",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:uniqOrdOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "unsplitByChar",
          "package": "uni-util",
          "signature": "Char -\u003e [String] -\u003e String",
          "source": "src/Util-ExtendedPrelude.html#unsplitByChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "unsplitByChar",
          "normalized": "Char-\u003e[String]-\u003eString",
          "package": "uni-util",
          "partial": "By Char",
          "signature": "Char-\u003e[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:unsplitByChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ExtendedPrelude",
          "name": "unsplitByChar0",
          "package": "uni-util",
          "signature": "Char -\u003e [String] -\u003e String",
          "source": "src/Util-ExtendedPrelude.html#unsplitByChar0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ExtendedPrelude",
          "module": "Util.ExtendedPrelude",
          "name": "unsplitByChar0",
          "normalized": "Char-\u003e[String]-\u003eString",
          "package": "uni-util",
          "partial": "By Char",
          "signature": "Char-\u003e[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ExtendedPrelude.html#v:unsplitByChar0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFileNames contain facilities for manipulating filenames\n in a hopefully OS-independent manner.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.FileNames",
          "name": "FileNames",
          "package": "uni-util",
          "source": "src/Util-FileNames.html",
          "type": "module"
        },
        "index": {
          "description": "FileNames contain facilities for manipulating filenames in hopefully OS-independent manner",
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "FileNames",
          "package": "uni-util",
          "partial": "File Names",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "breakName",
          "package": "uni-util",
          "signature": "String -\u003e [String]",
          "source": "src/Util-FileNames.html#breakName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "breakName",
          "normalized": "String-\u003e[String]",
          "package": "uni-util",
          "partial": "Name",
          "signature": "String-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:breakName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "combineNames",
          "package": "uni-util",
          "signature": "String -\u003e String -\u003e String",
          "source": "src/Util-FileNames.html#combineNames",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "combineNames",
          "normalized": "String-\u003eString-\u003eString",
          "package": "uni-util",
          "partial": "Names",
          "signature": "String-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:combineNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "fileSep",
          "package": "uni-util",
          "signature": "Char",
          "source": "src/Util-FileNames.html#fileSep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "fileSep",
          "package": "uni-util",
          "partial": "Sep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:fileSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "recordSep",
          "package": "uni-util",
          "signature": "String",
          "source": "src/Util-FileNames.html#recordSep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "recordSep",
          "package": "uni-util",
          "partial": "Sep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:recordSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "splitExtension",
          "package": "uni-util",
          "signature": "String -\u003e Maybe (String, String)",
          "source": "src/Util-FileNames.html#splitExtension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "splitExtension",
          "normalized": "String-\u003eMaybe(String,String)",
          "package": "uni-util",
          "partial": "Extension",
          "signature": "String-\u003eMaybe(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:splitExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "splitName",
          "package": "uni-util",
          "signature": "String -\u003e (String, String)",
          "source": "src/Util-FileNames.html#splitName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "splitName",
          "normalized": "String-\u003e(String,String)",
          "package": "uni-util",
          "partial": "Name",
          "signature": "String-\u003e(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:splitName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "thisDir",
          "package": "uni-util",
          "signature": "String",
          "source": "src/Util-FileNames.html#thisDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "thisDir",
          "package": "uni-util",
          "partial": "Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:thisDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "topDir",
          "package": "uni-util",
          "signature": "String",
          "source": "src/Util-FileNames.html#topDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "topDir",
          "package": "uni-util",
          "partial": "Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:topDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "trimDir",
          "package": "uni-util",
          "signature": "String -\u003e String",
          "source": "src/Util-FileNames.html#trimDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "trimDir",
          "normalized": "String-\u003eString",
          "package": "uni-util",
          "partial": "Dir",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:trimDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "unbreakName",
          "package": "uni-util",
          "signature": "[String] -\u003e String",
          "source": "src/Util-FileNames.html#unbreakName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "unbreakName",
          "normalized": "[String]-\u003eString",
          "package": "uni-util",
          "partial": "Name",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:unbreakName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.FileNames",
          "name": "unsplitExtension",
          "package": "uni-util",
          "signature": "String -\u003e String -\u003e String",
          "source": "src/Util-FileNames.html#unsplitExtension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util FileNames",
          "module": "Util.FileNames",
          "name": "unsplitExtension",
          "normalized": "String-\u003eString-\u003eString",
          "package": "uni-util",
          "partial": "Extension",
          "signature": "String-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-FileNames.html#v:unsplitExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains code which (supposedly) extracts the full qualified\n name of the machine on which it is running.  (At least it does on the\n Linux and Solaris implementations I tested.)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.HostName",
          "name": "HostName",
          "package": "uni-util",
          "source": "src/Util-HostName.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains code which supposedly extracts the full qualified name of the machine on which it is running At least it does on the Linux and Solaris implementations tested",
          "hierarchy": "Util HostName",
          "module": "Util.HostName",
          "name": "HostName",
          "package": "uni-util",
          "partial": "Host Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-HostName.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.HostName",
          "name": "getFullHostName",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-HostName.html#getFullHostName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util HostName",
          "module": "Util.HostName",
          "name": "getFullHostName",
          "package": "uni-util",
          "partial": "Full Host Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-HostName.html#v:getFullHostName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis code does \u003ca\u003eHuffman\u003c/a\u003e coding, using the queue implementation.  This\n can be used for constructing Huffman encodings, or for computing factorials\n efficiently.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Huffman",
          "name": "Huffman",
          "package": "uni-util",
          "source": "src/Util-Huffman.html",
          "type": "module"
        },
        "index": {
          "description": "This code does Huffman coding using the queue implementation This can be used for constructing Huffman encodings or for computing factorials efficiently",
          "hierarchy": "Util Huffman",
          "module": "Util.Huffman",
          "name": "Huffman",
          "package": "uni-util",
          "partial": "Huffman",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Huffman.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehuffmanFold op l\n where op is associative, l is a nonempty monotonically increasing list,\n and op has the property that (x1\u003e=x2,y1\u003e=y2) =\u003e (op x1 y1\u003e=op x2 y2)\n computes the fold of l with op, by repeatedly folding the smallest two\n elements of the list until only one remains.\n\u003c/p\u003e",
          "module": "Util.Huffman",
          "name": "huffmanFold",
          "package": "uni-util",
          "signature": "(a -\u003e a -\u003e a) -\u003e [a] -\u003e a",
          "source": "src/Util-Huffman.html#huffmanFold",
          "type": "function"
        },
        "index": {
          "description": "huffmanFold op where op is associative is nonempty monotonically increasing list and op has the property that x1 x2 y1 y2 op x1 y1 op x2 y2 computes the fold of with op by repeatedly folding the smallest two elements of the list until only one remains",
          "hierarchy": "Util Huffman",
          "module": "Util.Huffman",
          "name": "huffmanFold",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "package": "uni-util",
          "partial": "Fold",
          "signature": "(a-\u003ea-\u003ea)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Huffman.html#v:huffmanFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides immutable CStrings, which additionally have\n the property that they are automatically freed when the garbage-collector\n forgets about them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.ICStringLen",
          "name": "ICStringLen",
          "package": "uni-util",
          "source": "src/Util-ICStringLen.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides immutable CStrings which additionally have the property that they are automatically freed when the garbage-collector forgets about them",
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "ICStringLen",
          "package": "uni-util",
          "partial": "ICString Len",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "ICStringLen",
          "package": "uni-util",
          "source": "src/Util-ICStringLen.html#ICStringLen",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "ICStringLen",
          "package": "uni-util",
          "partial": "ICString Len",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#t:ICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "UTF8",
          "package": "uni-util",
          "source": "src/Util-ICStringLen.html#UTF8",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "UTF8",
          "package": "uni-util",
          "partial": "UTF",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#t:UTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "UTF8",
          "package": "uni-util",
          "signature": "UTF8 bytes",
          "source": "src/Util-ICStringLen.html#UTF8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "UTF8",
          "package": "uni-util",
          "partial": "UTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:UTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "bytesFromICStringLen",
          "package": "uni-util",
          "signature": "ICStringLen -\u003e (Bytes, Int)",
          "source": "src/Util-ICStringLen.html#bytesFromICStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "bytesFromICStringLen",
          "normalized": "ICStringLen-\u003e(Bytes,Int)",
          "package": "uni-util",
          "partial": "From ICString Len",
          "signature": "ICStringLen-\u003e(Bytes,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:bytesFromICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "bytesToICStringLen",
          "package": "uni-util",
          "signature": "(Bytes, Int) -\u003e IO ICStringLen",
          "source": "src/Util-ICStringLen.html#bytesToICStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "bytesToICStringLen",
          "normalized": "(Bytes,Int)-\u003eIO ICStringLen",
          "package": "uni-util",
          "partial": "To ICString Len",
          "signature": "(Bytes,Int)-\u003eIO ICStringLen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:bytesToICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a UTF8 representation of a String back into the String,\n catching all possible format errors.\n\u003c/p\u003e\u003cp\u003eExample: With the Haskell module Control.Monad.Error, you can\n instance this as\n (fromUTF8WE :: String -\u003e Either String String)\n to get a conversion function which either succeeds (Right) or\n returns an error message (Left).\n\u003c/p\u003e",
          "module": "[\"Util.ICStringLen\",\"Util.UTF8\"]",
          "name": "fromUTF8WE",
          "package": "uni-util",
          "signature": "[byte] -\u003e m String",
          "source": "src/Util-UTF8.html#fromUTF8WE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:fromUTF8WE\",\"http://hackage.haskell.org/package/uni-util/docs/Util-UTF8.html#v:fromUTF8WE\"]"
        },
        "index": {
          "description": "Converts UTF8 representation of String back into the String catching all possible format errors Example With the Haskell module Control.Monad.Error you can instance this as fromUTF8WE String Either String String to get conversion function which either succeeds Right or returns an error message Left",
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "fromUTF8WE",
          "normalized": "[a]-\u003eb String",
          "package": "uni-util",
          "partial": "UTF WE",
          "signature": "[byte]-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:fromUTF8WE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "mkICStringLen",
          "package": "uni-util",
          "signature": "Int -\u003e (CString -\u003e IO ()) -\u003e IO ICStringLen",
          "source": "src/Util-ICStringLen.html#mkICStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "mkICStringLen",
          "normalized": "Int-\u003e(CString-\u003eIO())-\u003eIO ICStringLen",
          "package": "uni-util",
          "partial": "ICString Len",
          "signature": "Int-\u003e(CString-\u003eIO())-\u003eIO ICStringLen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:mkICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "mkICStringLenExtra",
          "package": "uni-util",
          "signature": "Int -\u003e (CString -\u003e IO extra) -\u003e IO (ICStringLen, extra)",
          "source": "src/Util-ICStringLen.html#mkICStringLenExtra",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "mkICStringLenExtra",
          "normalized": "Int-\u003e(CString-\u003eIO a)-\u003eIO(ICStringLen,a)",
          "package": "uni-util",
          "partial": "ICString Len Extra",
          "signature": "Int-\u003e(CString-\u003eIO extra)-\u003eIO(ICStringLen,extra)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:mkICStringLenExtra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "readICStringLen",
          "package": "uni-util",
          "signature": "ICStringLen -\u003e IO a",
          "source": "src/Util-ICStringLen.html#readICStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "readICStringLen",
          "normalized": "ICStringLen-\u003eIO a",
          "package": "uni-util",
          "partial": "ICString Len",
          "signature": "ICStringLen-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:readICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a String into its UTF8 representation.\n\u003c/p\u003e",
          "module": "[\"Util.ICStringLen\",\"Util.UTF8\"]",
          "name": "toUTF8",
          "package": "uni-util",
          "signature": "String -\u003e [byte]",
          "source": "src/Util-UTF8.html#toUTF8",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:toUTF8\",\"http://hackage.haskell.org/package/uni-util/docs/Util-UTF8.html#v:toUTF8\"]"
        },
        "index": {
          "description": "Converts String into its UTF8 representation",
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "toUTF8",
          "normalized": "String-\u003e[a]",
          "package": "uni-util",
          "partial": "UTF",
          "signature": "String-\u003e[byte]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:toUTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "touchICStringLen",
          "package": "uni-util",
          "signature": "ICStringLen -\u003e IO ()",
          "source": "src/Util-ICStringLen.html#touchICStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "touchICStringLen",
          "normalized": "ICStringLen-\u003eIO()",
          "package": "uni-util",
          "partial": "ICString Len",
          "signature": "ICStringLen-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:touchICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "withICStringLen",
          "package": "uni-util",
          "signature": "ICStringLen -\u003e (Int -\u003e CString -\u003e IO a) -\u003e IO a",
          "source": "src/Util-ICStringLen.html#withICStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "withICStringLen",
          "normalized": "ICStringLen-\u003e(Int-\u003eCString-\u003eIO a)-\u003eIO a",
          "package": "uni-util",
          "partial": "ICString Len",
          "signature": "ICStringLen-\u003e(Int-\u003eCString-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:withICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ICStringLen",
          "name": "writeToICStringLen",
          "package": "uni-util",
          "signature": "a -\u003e IO ICStringLen",
          "source": "src/Util-ICStringLen.html#writeToICStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ICStringLen",
          "module": "Util.ICStringLen",
          "name": "writeToICStringLen",
          "normalized": "a-\u003eIO ICStringLen",
          "package": "uni-util",
          "partial": "To ICString Len",
          "signature": "a-\u003eIO ICStringLen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ICStringLen.html#v:writeToICStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLittle functions connected with IO\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.IOExtras",
          "name": "IOExtras",
          "package": "uni-util",
          "source": "src/Util-IOExtras.html",
          "type": "module"
        },
        "index": {
          "description": "Little functions connected with IO",
          "hierarchy": "Util IOExtras",
          "module": "Util.IOExtras",
          "name": "IOExtras",
          "package": "uni-util",
          "partial": "IOExtras",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IOExtras.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.IOExtras",
          "name": "catchAlreadyExists",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Maybe a)",
          "source": "src/Util-IOExtras.html#catchAlreadyExists",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util IOExtras",
          "module": "Util.IOExtras",
          "name": "catchAlreadyExists",
          "normalized": "IO a-\u003eIO(Maybe a)",
          "package": "uni-util",
          "partial": "Already Exists",
          "signature": "IO a-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IOExtras.html#v:catchAlreadyExists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.IOExtras",
          "name": "catchDoesNotExist",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Maybe a)",
          "source": "src/Util-IOExtras.html#catchDoesNotExist",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util IOExtras",
          "module": "Util.IOExtras",
          "name": "catchDoesNotExist",
          "normalized": "IO a-\u003eIO(Maybe a)",
          "package": "uni-util",
          "partial": "Does Not Exist",
          "signature": "IO a-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IOExtras.html#v:catchDoesNotExist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.IOExtras",
          "name": "catchEOF",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Maybe a)",
          "source": "src/Util-IOExtras.html#catchEOF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util IOExtras",
          "module": "Util.IOExtras",
          "name": "catchEOF",
          "normalized": "IO a-\u003eIO(Maybe a)",
          "package": "uni-util",
          "partial": "EOF",
          "signature": "IO a-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IOExtras.html#v:catchEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.IOExtras",
          "name": "catchErrorCalls",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Either ErrorCall a)",
          "source": "src/Util-IOExtras.html#catchErrorCalls",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util IOExtras",
          "module": "Util.IOExtras",
          "name": "catchErrorCalls",
          "normalized": "IO a-\u003eIO(Either ErrorCall a)",
          "package": "uni-util",
          "partial": "Error Calls",
          "signature": "IO a-\u003eIO(Either ErrorCall a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IOExtras.html#v:catchErrorCalls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.IOExtras",
          "name": "hGetLineR",
          "package": "uni-util",
          "signature": "Handle -\u003e IO a",
          "source": "src/Util-IOExtras.html#hGetLineR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util IOExtras",
          "module": "Util.IOExtras",
          "name": "hGetLineR",
          "normalized": "Handle-\u003eIO a",
          "package": "uni-util",
          "partial": "Get Line",
          "signature": "Handle-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IOExtras.html#v:hGetLineR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.IOExtras",
          "name": "simpleModifyIORef",
          "package": "uni-util",
          "signature": "IORef a -\u003e (a -\u003e (a, b)) -\u003e IO b",
          "source": "src/Util-IOExtras.html#simpleModifyIORef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util IOExtras",
          "module": "Util.IOExtras",
          "name": "simpleModifyIORef",
          "normalized": "IORef a-\u003e(a-\u003e(a,b))-\u003eIO b",
          "package": "uni-util",
          "partial": "Modify IORef",
          "signature": "IORef a-\u003e(a-\u003e(a,b))-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IOExtras.html#v:simpleModifyIORef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIntegers augmented with Infinity.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.IntPlus",
          "name": "IntPlus",
          "package": "uni-util",
          "source": "src/Util-IntPlus.html",
          "type": "module"
        },
        "index": {
          "description": "Integers augmented with Infinity",
          "hierarchy": "Util IntPlus",
          "module": "Util.IntPlus",
          "name": "IntPlus",
          "package": "uni-util",
          "partial": "Int Plus",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IntPlus.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Bool is a sign, with True meaning positive infinity.\n\u003c/p\u003e",
          "module": "Util.IntPlus",
          "name": "IntPlus",
          "package": "uni-util",
          "source": "src/Util-IntPlus.html#IntPlus",
          "type": "data"
        },
        "index": {
          "description": "The Bool is sign with True meaning positive infinity",
          "hierarchy": "Util IntPlus",
          "module": "Util.IntPlus",
          "name": "IntPlus",
          "package": "uni-util",
          "partial": "Int Plus",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IntPlus.html#t:IntPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.IntPlus",
          "name": "infinity",
          "package": "uni-util",
          "signature": "IntPlus",
          "source": "src/Util-IntPlus.html#infinity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util IntPlus",
          "module": "Util.IntPlus",
          "name": "infinity",
          "package": "uni-util",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-IntPlus.html#v:infinity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis implements a SinkSource with keyed changes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.KeyedChanges",
          "name": "KeyedChanges",
          "package": "uni-util",
          "source": "src/Util-KeyedChanges.html",
          "type": "module"
        },
        "index": {
          "description": "This implements SinkSource with keyed changes",
          "hierarchy": "Util KeyedChanges",
          "module": "Util.KeyedChanges",
          "name": "KeyedChanges",
          "package": "uni-util",
          "partial": "Keyed Changes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-KeyedChanges.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.KeyedChanges",
          "name": "KeyedChanges",
          "package": "uni-util",
          "source": "src/Util-KeyedChanges.html#KeyedChanges",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util KeyedChanges",
          "module": "Util.KeyedChanges",
          "name": "KeyedChanges",
          "package": "uni-util",
          "partial": "Keyed Changes",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-KeyedChanges.html#t:KeyedChanges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.KeyedChanges",
          "name": "deleteKeyedChange",
          "package": "uni-util",
          "signature": "key -\u003e delta -\u003e KeyedChanges key delta -\u003e IO ()",
          "source": "src/Util-KeyedChanges.html#deleteKeyedChange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util KeyedChanges",
          "module": "Util.KeyedChanges",
          "name": "deleteKeyedChange",
          "normalized": "a-\u003eb-\u003eKeyedChanges a b-\u003eIO()",
          "package": "uni-util",
          "partial": "Keyed Change",
          "signature": "key-\u003edelta-\u003eKeyedChanges key delta-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-KeyedChanges.html#v:deleteKeyedChange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.KeyedChanges",
          "name": "newKeyedChanges",
          "package": "uni-util",
          "signature": "IO (KeyedChanges key delta)",
          "source": "src/Util-KeyedChanges.html#newKeyedChanges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util KeyedChanges",
          "module": "Util.KeyedChanges",
          "name": "newKeyedChanges",
          "package": "uni-util",
          "partial": "Keyed Changes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-KeyedChanges.html#v:newKeyedChanges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.KeyedChanges",
          "name": "sendKeyedChanges",
          "package": "uni-util",
          "signature": "key -\u003e delta -\u003e KeyedChanges key delta -\u003e IO ()",
          "source": "src/Util-KeyedChanges.html#sendKeyedChanges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util KeyedChanges",
          "module": "Util.KeyedChanges",
          "name": "sendKeyedChanges",
          "normalized": "a-\u003eb-\u003eKeyedChanges a b-\u003eIO()",
          "package": "uni-util",
          "partial": "Keyed Changes",
          "signature": "key-\u003edelta-\u003eKeyedChanges key delta-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-KeyedChanges.html#v:sendKeyedChanges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe LineShow type is simply a list type except that it has\n Read and Show instances which put the output line by line,\n preceded by the number of lines.  This is useful for data\n files stored by CVS and similar systems.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.LineShow",
          "name": "LineShow",
          "package": "uni-util",
          "source": "src/Util-LineShow.html",
          "type": "module"
        },
        "index": {
          "description": "The LineShow type is simply list type except that it has Read and Show instances which put the output line by line preceded by the number of lines This is useful for data files stored by CVS and similar systems",
          "hierarchy": "Util LineShow",
          "module": "Util.LineShow",
          "name": "LineShow",
          "package": "uni-util",
          "partial": "Line Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-LineShow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.LineShow",
          "name": "LineShow",
          "package": "uni-util",
          "source": "src/Util-LineShow.html#LineShow",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util LineShow",
          "module": "Util.LineShow",
          "name": "LineShow",
          "package": "uni-util",
          "partial": "Line Show",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-LineShow.html#t:LineShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.LineShow",
          "name": "LineShow",
          "package": "uni-util",
          "signature": "LineShow [a]",
          "source": "src/Util-LineShow.html#LineShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util LineShow",
          "module": "Util.LineShow",
          "name": "LineShow",
          "normalized": "LineShow[a]",
          "package": "uni-util",
          "partial": "Line Show",
          "signature": "LineShow[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-LineShow.html#v:LineShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis file differs from the Einar original (itself automatically\n produced by decommenting an obsolete GHC source file, apparently) with\n nearly all the functions removed.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Maybes",
          "name": "Maybes",
          "package": "uni-util",
          "source": "src/Util-Maybes.html",
          "type": "module"
        },
        "index": {
          "description": "This file differs from the Einar original itself automatically produced by decommenting an obsolete GHC source file apparently with nearly all the functions removed",
          "hierarchy": "Util Maybes",
          "module": "Util.Maybes",
          "name": "Maybes",
          "package": "uni-util",
          "partial": "Maybes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Maybes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Maybes",
          "name": "fromMaybes",
          "package": "uni-util",
          "signature": "[Maybe a] -\u003e Maybe [a]",
          "source": "src/Util-Maybes.html#fromMaybes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Maybes",
          "module": "Util.Maybes",
          "name": "fromMaybes",
          "normalized": "[Maybe a]-\u003eMaybe[a]",
          "package": "uni-util",
          "partial": "Maybes",
          "signature": "[Maybe a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Maybes.html#v:fromMaybes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains the hooks for displaying messages to the user\n (errors, alerts, warnings and the like) and getting yes/no responses.\n\u003c/p\u003e\u003cp\u003eThe idea is that these are by default textual, and go via\n \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003estdout\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003estderr\u003c/a\u003e\u003c/code\u003e .  However if the DialogWin function\n \u003ccode\u003euseHTk\u003c/code\u003e is invoked, windows will pop up.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Messages",
          "name": "Messages",
          "package": "uni-util",
          "source": "src/Util-Messages.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains the hooks for displaying messages to the user errors alerts warnings and the like and getting yes no responses The idea is that these are by default textual and go via stdin stdout and stderr However if the DialogWin function useHTk is invoked windows will pop up",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "Messages",
          "package": "uni-util",
          "partial": "Messages",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "MessFns",
          "package": "uni-util",
          "source": "src/Util-Messages.html#MessFns",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "MessFns",
          "package": "uni-util",
          "partial": "Mess Fns",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#t:MessFns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "MessFns",
          "package": "uni-util",
          "signature": "MessFns",
          "source": "src/Util-Messages.html#MessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "MessFns",
          "package": "uni-util",
          "partial": "Mess Fns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:MessFns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "alertFn",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#MessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "alertFn",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Fn",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:alertFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay an alert\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "alertMess",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#alertMess",
          "type": "function"
        },
        "index": {
          "description": "Display an alert",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "alertMess",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Mess",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:alertMess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "confirmFn",
          "package": "uni-util",
          "signature": "String -\u003e IO Bool",
          "source": "src/Util-Messages.html#MessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "confirmFn",
          "normalized": "String-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Fn",
          "signature": "String-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:confirmFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConfirm something with the user.\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "confirmMess",
          "package": "uni-util",
          "signature": "String -\u003e IO Bool",
          "source": "src/Util-Messages.html#confirmMess",
          "type": "function"
        },
        "index": {
          "description": "Confirm something with the user",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "confirmMess",
          "normalized": "String-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Mess",
          "signature": "String-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:confirmMess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "errorFn",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#MessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "errorFn",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Fn",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:errorFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay an error\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "errorMess",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#errorMess",
          "type": "function"
        },
        "index": {
          "description": "Display an error",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "errorMess",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Mess",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:errorMess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay a series of one-line messages, separated by newline characters,\n attempting to combine them together and eliminate duplicates as much as\n possible.  If other identical messages come in while the error message\n is being delayed, we throw them away.\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "errorMess2",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#errorMess2",
          "type": "function"
        },
        "index": {
          "description": "Display series of one-line messages separated by newline characters attempting to combine them together and eliminate duplicates as much as possible If other identical messages come in while the error message is being delayed we throw them away",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "errorMess2",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Mess",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:errorMess2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "htkPres",
          "package": "uni-util",
          "signature": "Bool",
          "source": "src/Util-Messages.html#MessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "htkPres",
          "package": "uni-util",
          "partial": "Pres",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:htkPres"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf True, indicates that the flag corresponding to a graphical mode\n has been set.  This is used occasionally for deciding whether to\n ask the user something on stdout, stdin or via a window.\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "htkPresent",
          "package": "uni-util",
          "signature": "IO Bool",
          "source": "src/Util-Messages.html#htkPresent",
          "type": "function"
        },
        "index": {
          "description": "If True indicates that the flag corresponding to graphical mode has been set This is used occasionally for deciding whether to ask the user something on stdout stdin or via window",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "htkPresent",
          "package": "uni-util",
          "partial": "Present",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:htkPresent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "messageFn",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#MessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "messageFn",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Fn",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:messageFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay some informational message.\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "messageMess",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#messageMess",
          "type": "function"
        },
        "index": {
          "description": "Display some informational message",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "messageMess",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Mess",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:messageMess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "setMessFns",
          "package": "uni-util",
          "signature": "MessFns -\u003e IO ()",
          "source": "src/Util-Messages.html#setMessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "setMessFns",
          "normalized": "MessFns-\u003eIO()",
          "package": "uni-util",
          "partial": "Mess Fns",
          "signature": "MessFns-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:setMessFns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equeries the user on stdout getting the answer from stdin.\n Leading and trailing spaces are trimmed from the result.\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "textQuery",
          "package": "uni-util",
          "signature": "String -\u003e IO String",
          "source": "src/Util-Messages.html#textQuery",
          "type": "function"
        },
        "index": {
          "description": "queries the user on stdout getting the answer from stdin Leading and trailing spaces are trimmed from the result",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "textQuery",
          "normalized": "String-\u003eIO String",
          "package": "uni-util",
          "partial": "Query",
          "signature": "String-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:textQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Messages",
          "name": "warningFn",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#MessFns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "warningFn",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Fn",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:warningFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay a warning message\n\u003c/p\u003e",
          "module": "Util.Messages",
          "name": "warningMess",
          "package": "uni-util",
          "signature": "String -\u003e IO ()",
          "source": "src/Util-Messages.html#warningMess",
          "type": "function"
        },
        "index": {
          "description": "Display warning message",
          "hierarchy": "Util Messages",
          "module": "Util.Messages",
          "name": "warningMess",
          "normalized": "String-\u003eIO()",
          "package": "uni-util",
          "partial": "Mess",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Messages.html#v:warningMess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of the Myers algorithm, from \u003ca\u003eAn O(ND) Difference Algorithm\n and Its Variations\u003c/a\u003e, by Eugene Myers page 6 (figure 2).\n\u003c/p\u003e\u003cp\u003eSpecification: if\n\u003c/p\u003e\u003cp\u003ef1 (InBoth v) = Just v\n    f1 (InFirst v) = Just v\n    f1 (InSecond v) = Nothing\n\u003c/p\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cp\u003ef2 (InBoth v) = Just v\n    f2 (InFirst v) = Nothing\n    f2 (InSecond v) = Just v\n\u003c/p\u003e\u003cp\u003ethen\n\u003c/p\u003e\u003cp\u003emapPartial f1 (diff l1 l2) == l1\n\u003c/p\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cp\u003emapPartial f2 (diff l1 l2) == l2\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Myers",
          "name": "Myers",
          "package": "uni-util",
          "source": "src/Util-Myers.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of the Myers algorithm from An ND Difference Algorithm and Its Variations by Eugene Myers page figure Specification if f1 InBoth Just f1 InFirst Just f1 InSecond Nothing and f2 InBoth Just f2 InFirst Nothing f2 InSecond Just then mapPartial f1 diff l1 l2 l1 and mapPartial f2 diff l1 l2 l2",
          "hierarchy": "Util Myers",
          "module": "Util.Myers",
          "name": "Myers",
          "package": "uni-util",
          "partial": "Myers",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Myers.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Myers",
          "name": "DiffElement",
          "package": "uni-util",
          "source": "src/Util-Myers.html#DiffElement",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Myers",
          "module": "Util.Myers",
          "name": "DiffElement",
          "package": "uni-util",
          "partial": "Diff Element",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Myers.html#t:DiffElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Myers",
          "name": "InBoth",
          "package": "uni-util",
          "signature": "InBoth [v]",
          "source": "src/Util-Myers.html#DiffElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Myers",
          "module": "Util.Myers",
          "name": "InBoth",
          "normalized": "InBoth[a]",
          "package": "uni-util",
          "partial": "In Both",
          "signature": "InBoth[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Myers.html#v:InBoth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Myers",
          "name": "InFirst",
          "package": "uni-util",
          "signature": "InFirst [v]",
          "source": "src/Util-Myers.html#DiffElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Myers",
          "module": "Util.Myers",
          "name": "InFirst",
          "normalized": "InFirst[a]",
          "package": "uni-util",
          "partial": "In First",
          "signature": "InFirst[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Myers.html#v:InFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Myers",
          "name": "InSecond",
          "package": "uni-util",
          "signature": "InSecond [v]",
          "source": "src/Util-Myers.html#DiffElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Myers",
          "module": "Util.Myers",
          "name": "InSecond",
          "normalized": "InSecond[a]",
          "package": "uni-util",
          "partial": "In Second",
          "signature": "InSecond[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Myers.html#v:InSecond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Myers",
          "name": "diff",
          "package": "uni-util",
          "signature": "[a] -\u003e [a] -\u003e [DiffElement a]",
          "source": "src/Util-Myers.html#diff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Myers",
          "module": "Util.Myers",
          "name": "diff",
          "normalized": "[a]-\u003e[a]-\u003e[DiffElement a]",
          "package": "uni-util",
          "signature": "[a]-\u003e[a]-\u003e[DiffElement a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Myers.html#v:diff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Myers",
          "name": "diff2",
          "package": "uni-util",
          "signature": "[v] -\u003e [v] -\u003e [DiffElement v]",
          "source": "src/Util-Myers.html#diff2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Myers",
          "module": "Util.Myers",
          "name": "diff2",
          "normalized": "[a]-\u003e[a]-\u003e[DiffElement a]",
          "package": "uni-util",
          "signature": "[v]-\u003e[v]-\u003e[DiffElement v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Myers.html#v:diff2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule for generating unique names which correspond to given names\n (of type ref).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.NameMangle",
          "name": "NameMangle",
          "package": "uni-util",
          "source": "src/Util-NameMangle.html",
          "type": "module"
        },
        "index": {
          "description": "Module for generating unique names which correspond to given names of type ref",
          "hierarchy": "Util NameMangle",
          "module": "Util.NameMangle",
          "name": "NameMangle",
          "package": "uni-util",
          "partial": "Name Mangle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-NameMangle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.NameMangle",
          "name": "MangledName",
          "package": "uni-util",
          "source": "src/Util-NameMangle.html#MangledName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util NameMangle",
          "module": "Util.NameMangle",
          "name": "MangledName",
          "package": "uni-util",
          "partial": "Mangled Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-NameMangle.html#t:MangledName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor now we just do this naively, with a Registry.  Since the names are\n generated sequentially a dynamic array would be more efficient, perhaps.\n\u003c/p\u003e",
          "module": "Util.NameMangle",
          "name": "NameMangler",
          "package": "uni-util",
          "source": "src/Util-NameMangle.html#NameMangler",
          "type": "data"
        },
        "index": {
          "description": "For now we just do this naively with Registry Since the names are generated sequentially dynamic array would be more efficient perhaps",
          "hierarchy": "Util NameMangle",
          "module": "Util.NameMangle",
          "name": "NameMangler",
          "package": "uni-util",
          "partial": "Name Mangler",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-NameMangle.html#t:NameMangler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.NameMangle",
          "name": "newMangledName",
          "package": "uni-util",
          "signature": "NameMangler ref -\u003e ref -\u003e IO MangledName",
          "source": "src/Util-NameMangle.html#newMangledName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util NameMangle",
          "module": "Util.NameMangle",
          "name": "newMangledName",
          "normalized": "NameMangler a-\u003ea-\u003eIO MangledName",
          "package": "uni-util",
          "partial": "Mangled Name",
          "signature": "NameMangler ref-\u003eref-\u003eIO MangledName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-NameMangle.html#v:newMangledName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.NameMangle",
          "name": "newNameMangler",
          "package": "uni-util",
          "signature": "IO (NameMangler ref)",
          "source": "src/Util-NameMangle.html#newNameMangler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util NameMangle",
          "module": "Util.NameMangle",
          "name": "newNameMangler",
          "package": "uni-util",
          "partial": "Name Mangler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-NameMangle.html#v:newNameMangler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.NameMangle",
          "name": "readMangledName",
          "package": "uni-util",
          "signature": "NameMangler ref -\u003e MangledName -\u003e IO ref",
          "source": "src/Util-NameMangle.html#readMangledName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util NameMangle",
          "module": "Util.NameMangle",
          "name": "readMangledName",
          "normalized": "NameMangler a-\u003eMangledName-\u003eIO a",
          "package": "uni-util",
          "partial": "Mangled Name",
          "signature": "NameMangler ref-\u003eMangledName-\u003eIO ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-NameMangle.html#v:readMangledName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule which generates globally unique \u003ccode\u003e\u003ca\u003eObjectID\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Object",
          "name": "Object",
          "package": "uni-util",
          "source": "src/Util-Object.html",
          "type": "module"
        },
        "index": {
          "description": "Module which generates globally unique ObjectID",
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "Object",
          "package": "uni-util",
          "partial": "Object",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Object",
          "name": "Object",
          "package": "uni-util",
          "source": "src/Util-Object.html#Object",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "Object",
          "package": "uni-util",
          "partial": "Object",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#t:Object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Object",
          "name": "ObjectID",
          "package": "uni-util",
          "source": "src/Util-Object.html#ObjectID",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "ObjectID",
          "package": "uni-util",
          "partial": "Object ID",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#t:ObjectID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Object",
          "name": "ObjectID",
          "package": "uni-util",
          "signature": "ObjectID Int",
          "source": "src/Util-Object.html#ObjectID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "ObjectID",
          "package": "uni-util",
          "partial": "Object ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#v:ObjectID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Object",
          "name": "newInt",
          "package": "uni-util",
          "signature": "IO Int",
          "source": "src/Util-Object.html#newInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "newInt",
          "package": "uni-util",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#v:newInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Object",
          "name": "newObject",
          "package": "uni-util",
          "signature": "IO ObjectID",
          "source": "src/Util-Object.html#newObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "newObject",
          "package": "uni-util",
          "partial": "Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#v:newObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Object",
          "name": "objectID",
          "package": "uni-util",
          "signature": "o -\u003e ObjectID",
          "source": "src/Util-Object.html#objectID",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "objectID",
          "normalized": "a-\u003eObjectID",
          "package": "uni-util",
          "partial": "ID",
          "signature": "o-\u003eObjectID",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#v:objectID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Object",
          "name": "staticObject",
          "package": "uni-util",
          "signature": "Int -\u003e ObjectID",
          "source": "src/Util-Object.html#staticObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Object",
          "module": "Util.Object",
          "name": "staticObject",
          "normalized": "Int-\u003eObjectID",
          "package": "uni-util",
          "partial": "Object",
          "signature": "Int-\u003eObjectID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Object.html#v:staticObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is an implementation of queues inspired by the paper in\n Software Practice & Experience, ...\n The queue is divided into two sequences. The first sequence\n holds the elements in a LIFO order, the second in a FIFO order.\n The LIFO sequence is the one where elements are added, the FIFO\n the one from which elements are removed. When the remove operation\n is called and the FIFO sequence is empty, the LIFO sequence is\n turned into a FIFO sequence by reversing the order of its elements.\n\u003c/p\u003e\u003cp\u003eNote from GER - as far as I know, we only need the values\n    emptyQ :: Queue a -- new empty queue\n    singletonQ :: a -\u003e Queue a -- new singleton queue\n    insertQ :: Queue a -\u003e a -\u003e Queue a -- add to queue\n    removeQ :: Queue a -\u003e Maybe (a,Queue a) -- pop from queue.\n    insertAtEndQ :: Queue a -\u003e a -\u003e Queue a\n    -- undo the effect of the previous removeQ.\n    isEmptyQ :: Queue a -\u003e Bool\n    queueToList :: Queue a -\u003e [a]\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Queue",
          "name": "Queue",
          "package": "uni-util",
          "source": "src/Util-Queue.html",
          "type": "module"
        },
        "index": {
          "description": "This is an implementation of queues inspired by the paper in Software Practice Experience The queue is divided into two sequences The first sequence holds the elements in LIFO order the second in FIFO order The LIFO sequence is the one where elements are added the FIFO the one from which elements are removed When the remove operation is called and the FIFO sequence is empty the LIFO sequence is turned into FIFO sequence by reversing the order of its elements Note from GER as far as know we only need the values emptyQ Queue new empty queue singletonQ Queue new singleton queue insertQ Queue Queue add to queue removeQ Queue Maybe Queue pop from queue insertAtEndQ Queue Queue undo the effect of the previous removeQ isEmptyQ Queue Bool queueToList Queue",
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "Queue",
          "package": "uni-util",
          "partial": "Queue",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Queue",
          "name": "Queue",
          "package": "uni-util",
          "source": "src/Util-Queue.html#Queue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "Queue",
          "package": "uni-util",
          "partial": "Queue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#t:Queue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Queue",
          "name": "emptyQ",
          "package": "uni-util",
          "signature": "Queue a",
          "source": "src/Util-Queue.html#emptyQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "emptyQ",
          "package": "uni-util",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:emptyQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Queue",
          "name": "insertAtEndQ",
          "package": "uni-util",
          "signature": "Queue a -\u003e a -\u003e Queue a",
          "source": "src/Util-Queue.html#insertAtEndQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "insertAtEndQ",
          "normalized": "Queue a-\u003ea-\u003eQueue a",
          "package": "uni-util",
          "partial": "At End",
          "signature": "Queue a-\u003ea-\u003eQueue a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:insertAtEndQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Queue",
          "name": "insertQ",
          "package": "uni-util",
          "signature": "Queue a -\u003e a -\u003e Queue a",
          "source": "src/Util-Queue.html#insertQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "insertQ",
          "normalized": "Queue a-\u003ea-\u003eQueue a",
          "package": "uni-util",
          "signature": "Queue a-\u003ea-\u003eQueue a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:insertQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Queue",
          "name": "isEmptyQ",
          "package": "uni-util",
          "signature": "Queue a -\u003e Bool",
          "source": "src/Util-Queue.html#isEmptyQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "isEmptyQ",
          "normalized": "Queue a-\u003eBool",
          "package": "uni-util",
          "partial": "Empty",
          "signature": "Queue a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:isEmptyQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a list to a queue with the first element of the list the\n first element of the queue.\n\u003c/p\u003e",
          "module": "Util.Queue",
          "name": "listToQueue",
          "package": "uni-util",
          "signature": "[a] -\u003e Queue a",
          "source": "src/Util-Queue.html#listToQueue",
          "type": "function"
        },
        "index": {
          "description": "Converts list to queue with the first element of the list the first element of the queue",
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "listToQueue",
          "normalized": "[a]-\u003eQueue a",
          "package": "uni-util",
          "partial": "To Queue",
          "signature": "[a]-\u003eQueue a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:listToQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverts listToQueue\n\u003c/p\u003e",
          "module": "Util.Queue",
          "name": "queueToList",
          "package": "uni-util",
          "signature": "Queue a -\u003e [a]",
          "source": "src/Util-Queue.html#queueToList",
          "type": "function"
        },
        "index": {
          "description": "Inverts listToQueue",
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "queueToList",
          "normalized": "Queue a-\u003e[a]",
          "package": "uni-util",
          "partial": "To List",
          "signature": "Queue a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:queueToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Queue",
          "name": "removeQ",
          "package": "uni-util",
          "signature": "Queue a -\u003e Maybe (a, Queue a)",
          "source": "src/Util-Queue.html#removeQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "removeQ",
          "normalized": "Queue a-\u003eMaybe(a,Queue a)",
          "package": "uni-util",
          "signature": "Queue a-\u003eMaybe(a,Queue a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:removeQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Queue",
          "name": "singletonQ",
          "package": "uni-util",
          "signature": "a -\u003e Queue a",
          "source": "src/Util-Queue.html#singletonQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Queue",
          "module": "Util.Queue",
          "name": "singletonQ",
          "normalized": "a-\u003eQueue a",
          "package": "uni-util",
          "signature": "a-\u003eQueue a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Queue.html#v:singletonQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eQuickReadShow is designed for the rapid manufacture of read/show\n instances.  To create such an instance you need to (a) instance\n quickRead; (b) instance Read/Show using a particular template.\n (Before April 2004 (b) was not part of the code; it now has to\n be added to deal with tougher GHC restrictions on overlapping instances.)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.QuickReadShow",
          "name": "QuickReadShow",
          "package": "uni-util",
          "source": "src/Util-QuickReadShow.html",
          "type": "module"
        },
        "index": {
          "description": "QuickReadShow is designed for the rapid manufacture of read show instances To create such an instance you need to instance quickRead instance Read Show using particular template Before April was not part of the code it now has to be added to deal with tougher GHC restrictions on overlapping instances",
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "QuickReadShow",
          "package": "uni-util",
          "partial": "Quick Read Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "QuickRead",
          "package": "uni-util",
          "source": "src/Util-QuickReadShow.html#QuickRead",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "QuickRead",
          "package": "uni-util",
          "partial": "Quick Read",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#t:QuickRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "QuickShow",
          "package": "uni-util",
          "source": "src/Util-QuickReadShow.html#QuickShow",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "QuickShow",
          "package": "uni-util",
          "partial": "Quick Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#t:QuickShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "WrapRead",
          "package": "uni-util",
          "source": "src/Util-QuickReadShow.html#WrapRead",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "WrapRead",
          "package": "uni-util",
          "partial": "Wrap Read",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#t:WrapRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "WrapShow",
          "package": "uni-util",
          "source": "src/Util-QuickReadShow.html#WrapShow",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "WrapShow",
          "package": "uni-util",
          "partial": "Wrap Show",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#t:WrapShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "WrapRead",
          "package": "uni-util",
          "signature": "WrapRead (read -\u003e toRead)",
          "source": "src/Util-QuickReadShow.html#WrapRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "WrapRead",
          "normalized": "WrapRead(a-\u003eb)",
          "package": "uni-util",
          "partial": "Wrap Read",
          "signature": "WrapRead(read-\u003etoRead)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#v:WrapRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "WrapShow",
          "package": "uni-util",
          "signature": "WrapShow (toShow -\u003e show)",
          "source": "src/Util-QuickReadShow.html#WrapShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "WrapShow",
          "normalized": "WrapShow(a-\u003eb)",
          "package": "uni-util",
          "partial": "Wrap Show",
          "signature": "WrapShow(toShow-\u003eshow)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#v:WrapShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "qRead",
          "package": "uni-util",
          "signature": "Int -\u003e String -\u003e [(toRead, String)]",
          "source": "src/Util-QuickReadShow.html#qRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "qRead",
          "normalized": "Int-\u003eString-\u003e[(a,String)]",
          "package": "uni-util",
          "partial": "Read",
          "signature": "Int-\u003eString-\u003e[(toRead,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#v:qRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "qShow",
          "package": "uni-util",
          "signature": "Int -\u003e toShow -\u003e String -\u003e String",
          "source": "src/Util-QuickReadShow.html#qShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "qShow",
          "normalized": "Int-\u003ea-\u003eString-\u003eString",
          "package": "uni-util",
          "partial": "Show",
          "signature": "Int-\u003etoShow-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#v:qShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "quickRead",
          "package": "uni-util",
          "signature": "WrapRead toRead",
          "source": "src/Util-QuickReadShow.html#quickRead",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "quickRead",
          "package": "uni-util",
          "partial": "Read",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#v:quickRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.QuickReadShow",
          "name": "quickShow",
          "package": "uni-util",
          "signature": "WrapShow toShow",
          "source": "src/Util-QuickReadShow.html#quickShow",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util QuickReadShow",
          "module": "Util.QuickReadShow",
          "name": "quickShow",
          "package": "uni-util",
          "partial": "Show",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-QuickReadShow.html#v:quickShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple reference counter\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.ReferenceCount",
          "name": "ReferenceCount",
          "package": "uni-util",
          "source": "src/Util-ReferenceCount.html",
          "type": "module"
        },
        "index": {
          "description": "simple reference counter",
          "hierarchy": "Util ReferenceCount",
          "module": "Util.ReferenceCount",
          "name": "ReferenceCount",
          "package": "uni-util",
          "partial": "Reference Count",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ReferenceCount.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ReferenceCount",
          "name": "RefCount",
          "package": "uni-util",
          "source": "src/Util-ReferenceCount.html#RefCount",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util ReferenceCount",
          "module": "Util.ReferenceCount",
          "name": "RefCount",
          "package": "uni-util",
          "partial": "Ref Count",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ReferenceCount.html#t:RefCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ReferenceCount",
          "name": "addRef",
          "package": "uni-util",
          "signature": "RefCount -\u003e IO ()",
          "source": "src/Util-ReferenceCount.html#addRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ReferenceCount",
          "module": "Util.ReferenceCount",
          "name": "addRef",
          "normalized": "RefCount-\u003eIO()",
          "package": "uni-util",
          "partial": "Ref",
          "signature": "RefCount-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ReferenceCount.html#v:addRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ReferenceCount",
          "name": "newLinkedRefCount",
          "package": "uni-util",
          "signature": "IO RefCount",
          "source": "src/Util-ReferenceCount.html#newLinkedRefCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ReferenceCount",
          "module": "Util.ReferenceCount",
          "name": "newLinkedRefCount",
          "package": "uni-util",
          "partial": "Linked Ref Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ReferenceCount.html#v:newLinkedRefCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ReferenceCount",
          "name": "newRefCount",
          "package": "uni-util",
          "signature": "IO RefCount",
          "source": "src/Util-ReferenceCount.html#newRefCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ReferenceCount",
          "module": "Util.ReferenceCount",
          "name": "newRefCount",
          "package": "uni-util",
          "partial": "Ref Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ReferenceCount.html#v:newRefCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ReferenceCount",
          "name": "remRef",
          "package": "uni-util",
          "signature": "RefCount -\u003e IO Bool",
          "source": "src/Util-ReferenceCount.html#remRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ReferenceCount",
          "module": "Util.ReferenceCount",
          "name": "remRef",
          "normalized": "RefCount-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Ref",
          "signature": "RefCount-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ReferenceCount.html#v:remRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Registry is a mapping from ordered values.  For the Registry\n type itself, all target values have the same type.  For the\n UntypedRegistry type, the values\n can have any Typeable type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Registry",
          "name": "Registry",
          "package": "uni-util",
          "source": "src/Util-Registry.html",
          "type": "module"
        },
        "index": {
          "description": "Registry is mapping from ordered values For the Registry type itself all target values have the same type For the UntypedRegistry type the values can have any Typeable type",
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "Registry",
          "package": "uni-util",
          "partial": "Registry",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "GetSetRegistry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#GetSetRegistry",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "GetSetRegistry",
          "package": "uni-util",
          "partial": "Get Set Registry",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:GetSetRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "GetSetRegistryDyn",
          "package": "uni-util",
          "source": "src/Util-Registry.html#GetSetRegistryDyn",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "GetSetRegistryDyn",
          "package": "uni-util",
          "partial": "Get Set Registry Dyn",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:GetSetRegistryDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "KeyOpsRegistry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#KeyOpsRegistry",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "KeyOpsRegistry",
          "package": "uni-util",
          "partial": "Key Ops Registry",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:KeyOpsRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eListRegistryContents will not be implemented for the untyped registries.\n\u003c/p\u003e",
          "module": "Util.Registry",
          "name": "ListRegistryContents",
          "package": "uni-util",
          "source": "src/Util-Registry.html#ListRegistryContents",
          "type": "class"
        },
        "index": {
          "description": "ListRegistryContents will not be implemented for the untyped registries",
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "ListRegistryContents",
          "package": "uni-util",
          "partial": "List Registry Contents",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:ListRegistryContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "LockedRegistry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#LockedRegistry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "LockedRegistry",
          "package": "uni-util",
          "partial": "Locked Registry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:LockedRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "NewRegistry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#NewRegistry",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "NewRegistry",
          "package": "uni-util",
          "partial": "New Registry",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:NewRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "Registry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#Registry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "Registry",
          "package": "uni-util",
          "partial": "Registry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:Registry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "Unsafe",
          "package": "uni-util",
          "source": "src/Util-Registry.html#Unsafe",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "Unsafe",
          "package": "uni-util",
          "partial": "Unsafe",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:Unsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "UnsafeRegistry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#UnsafeRegistry",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "UnsafeRegistry",
          "package": "uni-util",
          "partial": "Unsafe Registry",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:UnsafeRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "Untyped",
          "package": "uni-util",
          "source": "src/Util-Registry.html#Untyped",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "Untyped",
          "package": "uni-util",
          "partial": "Untyped",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:Untyped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "UntypedLockedRegistry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#UntypedLockedRegistry",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "UntypedLockedRegistry",
          "package": "uni-util",
          "partial": "Untyped Locked Registry",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:UntypedLockedRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "UntypedRegistry",
          "package": "uni-util",
          "source": "src/Util-Registry.html#UntypedRegistry",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "UntypedRegistry",
          "package": "uni-util",
          "partial": "Untyped Registry",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#t:UntypedRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elook up the element given by the first key, and if it exists\n delete it, replacing it with the element given by the second key.\n\u003c/p\u003e",
          "module": "Util.Registry",
          "name": "changeKey",
          "package": "uni-util",
          "signature": "Registry from to -\u003e from -\u003e from -\u003e IO ()",
          "source": "src/Util-Registry.html#changeKey",
          "type": "function"
        },
        "index": {
          "description": "look up the element given by the first key and if it exists delete it replacing it with the element given by the second key",
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "changeKey",
          "normalized": "Registry a b-\u003ea-\u003ea-\u003eIO()",
          "package": "uni-util",
          "partial": "Key",
          "signature": "Registry from to-\u003efrom-\u003efrom-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:changeKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "deleteFromRegistry",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e IO ()",
          "source": "src/Util-Registry.html#deleteFromRegistry",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "deleteFromRegistry",
          "normalized": "a-\u003eb-\u003eIO()",
          "package": "uni-util",
          "partial": "From Registry",
          "signature": "registry-\u003efrom-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:deleteFromRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "deleteFromRegistryBool",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e IO Bool",
          "source": "src/Util-Registry.html#deleteFromRegistryBool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "deleteFromRegistryBool",
          "normalized": "a-\u003eb-\u003eIO Bool",
          "package": "uni-util",
          "partial": "From Registry Bool",
          "signature": "registry-\u003efrom-\u003eIO Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:deleteFromRegistryBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "emptyRegistry",
          "package": "uni-util",
          "signature": "registry -\u003e IO ()",
          "source": "src/Util-Registry.html#emptyRegistry",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "emptyRegistry",
          "normalized": "a-\u003eIO()",
          "package": "uni-util",
          "partial": "Registry",
          "signature": "registry-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:emptyRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getRegistryValue",
          "package": "uni-util",
          "signature": "Registry from to -\u003e from -\u003e IO to",
          "source": "src/Util-Registry.html#getRegistryValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getRegistryValue",
          "normalized": "Registry a b-\u003ea-\u003eIO b",
          "package": "uni-util",
          "partial": "Registry Value",
          "signature": "Registry from to-\u003efrom-\u003eIO to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getRegistryValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getRegistryValueSafe",
          "package": "uni-util",
          "signature": "String -\u003e Registry from to -\u003e from -\u003e IO to",
          "source": "src/Util-Registry.html#getRegistryValueSafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getRegistryValueSafe",
          "normalized": "String-\u003eRegistry a b-\u003ea-\u003eIO b",
          "package": "uni-util",
          "partial": "Registry Value Safe",
          "signature": "String-\u003eRegistry from to-\u003efrom-\u003eIO to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getRegistryValueSafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getValue",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e IO to",
          "source": "src/Util-Registry.html#getValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getValue",
          "normalized": "a-\u003eb-\u003eIO c",
          "package": "uni-util",
          "partial": "Value",
          "signature": "registry-\u003efrom-\u003eIO to",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getValue'",
          "package": "uni-util",
          "signature": "String -\u003e registry -\u003e from -\u003e IO to",
          "source": "src/Util-Registry.html#getValue%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getValue'",
          "normalized": "String-\u003ea-\u003eb-\u003eIO c",
          "package": "uni-util",
          "partial": "Value'",
          "signature": "String-\u003eregistry-\u003efrom-\u003eIO to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getValue-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getValueAsDyn",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e IO Dyn",
          "source": "src/Util-Registry.html#getValueAsDyn",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getValueAsDyn",
          "normalized": "a-\u003eb-\u003eIO Dyn",
          "package": "uni-util",
          "partial": "Value As Dyn",
          "signature": "registry-\u003efrom-\u003eIO Dyn",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getValueAsDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getValueDefault",
          "package": "uni-util",
          "signature": "to -\u003e registry -\u003e from -\u003e IO to",
          "source": "src/Util-Registry.html#getValueDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getValueDefault",
          "normalized": "a-\u003eb-\u003ec-\u003eIO a",
          "package": "uni-util",
          "partial": "Value Default",
          "signature": "to-\u003eregistry-\u003efrom-\u003eIO to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getValueDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getValueOpt",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e IO (Maybe to)",
          "source": "src/Util-Registry.html#getValueOpt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getValueOpt",
          "normalized": "a-\u003eb-\u003eIO(Maybe c)",
          "package": "uni-util",
          "partial": "Value Opt",
          "signature": "registry-\u003efrom-\u003eIO(Maybe to)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getValueOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "getValueSafe",
          "package": "uni-util",
          "signature": "String -\u003e registry -\u003e from -\u003e IO to",
          "source": "src/Util-Registry.html#getValueSafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "getValueSafe",
          "normalized": "String-\u003ea-\u003eb-\u003eIO c",
          "package": "uni-util",
          "partial": "Value Safe",
          "signature": "String-\u003eregistry-\u003efrom-\u003eIO to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:getValueSafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "listKeys",
          "package": "uni-util",
          "signature": "registry -\u003e IO [from]",
          "source": "src/Util-Registry.html#listKeys",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "listKeys",
          "normalized": "a-\u003eIO[b]",
          "package": "uni-util",
          "partial": "Keys",
          "signature": "registry-\u003eIO[from]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:listKeys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "listRegistryContents",
          "package": "uni-util",
          "signature": "registry from to -\u003e IO [(from, to)]",
          "source": "src/Util-Registry.html#listRegistryContents",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "listRegistryContents",
          "normalized": "a b c-\u003eIO[(b,c)]",
          "package": "uni-util",
          "partial": "Registry Contents",
          "signature": "registry from to-\u003eIO[(from,to)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:listRegistryContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "listRegistryContentsAndEmptyRegistry",
          "package": "uni-util",
          "signature": "listRegistryContentsAndEmptyRegistry",
          "source": "src/Util-Registry.html#listRegistryContentsAndEmptyRegistry",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "listRegistryContentsAndEmptyRegistry",
          "package": "uni-util",
          "partial": "Registry Contents And Empty Registry",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:listRegistryContentsAndEmptyRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "listToNewRegistry",
          "package": "uni-util",
          "signature": "[(from, to)] -\u003e IO (registry from to)",
          "source": "src/Util-Registry.html#listToNewRegistry",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "listToNewRegistry",
          "normalized": "[(a,b)]-\u003eIO(c a b)",
          "package": "uni-util",
          "partial": "To New Registry",
          "signature": "[(from,to)]-\u003eIO(registry from to)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:listToNewRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "lockedRegistryCheck",
          "package": "uni-util",
          "signature": "IO a -\u003e IO (Either String a)",
          "source": "src/Util-Registry.html#lockedRegistryCheck",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "lockedRegistryCheck",
          "normalized": "IO a-\u003eIO(Either String a)",
          "package": "uni-util",
          "partial": "Registry Check",
          "signature": "IO a-\u003eIO(Either String a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:lockedRegistryCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "newRegistry",
          "package": "uni-util",
          "signature": "IO registry",
          "source": "src/Util-Registry.html#newRegistry",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "newRegistry",
          "package": "uni-util",
          "partial": "Registry",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:newRegistry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "setValue",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e to -\u003e IO ()",
          "source": "src/Util-Registry.html#setValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "setValue",
          "normalized": "a-\u003eb-\u003ec-\u003eIO()",
          "package": "uni-util",
          "partial": "Value",
          "signature": "registry-\u003efrom-\u003eto-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:setValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "setValueAsDyn",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e Dyn -\u003e IO ()",
          "source": "src/Util-Registry.html#setValueAsDyn",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "setValueAsDyn",
          "normalized": "a-\u003eb-\u003eDyn-\u003eIO()",
          "package": "uni-util",
          "partial": "Value As Dyn",
          "signature": "registry-\u003efrom-\u003eDyn-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:setValueAsDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Registry",
          "name": "transformValue",
          "package": "uni-util",
          "signature": "registry -\u003e from -\u003e (Maybe to -\u003e IO (Maybe to, extra)) -\u003e IO extra",
          "source": "src/Util-Registry.html#transformValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Registry",
          "module": "Util.Registry",
          "name": "transformValue",
          "normalized": "a-\u003eb-\u003e(Maybe c-\u003eIO(Maybe c,d))-\u003eIO d",
          "package": "uni-util",
          "partial": "Value",
          "signature": "registry-\u003efrom-\u003e(Maybe to-\u003eIO(Maybe to,extra))-\u003eIO extra",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Registry.html#v:transformValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVery primitive concurrency, this implements a sink, which passes messages\n along until the receiver is no longer interested.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Sink",
          "name": "Sink",
          "package": "uni-util",
          "source": "src/Util-Sink.html",
          "type": "module"
        },
        "index": {
          "description": "Very primitive concurrency this implements sink which passes messages along until the receiver is no longer interested",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "Sink",
          "package": "uni-util",
          "partial": "Sink",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class for things (in particular Source and SimpleSource) that can\n output via sinks.  Each sink source is supposed to have a unique\n x, containing a representation of the current value, and delta,\n containing the (incremental) updates which are put in the sink.\n Only the addOrdSink function must be defined by instances.\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "CanAddSinks",
          "package": "uni-util",
          "source": "src/Util-Sink.html#CanAddSinks",
          "type": "class"
        },
        "index": {
          "description": "class for things in particular Source and SimpleSource that can output via sinks Each sink source is supposed to have unique containing representation of the current value and delta containing the incremental updates which are put in the sink Only the addOrdSink function must be defined by instances",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "CanAddSinks",
          "package": "uni-util",
          "partial": "Can Add Sinks",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#t:CanAddSinks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe HasInvalidate class represents information sources which can be told\n \"No more, I'm not interested.\"\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "HasInvalidate",
          "package": "uni-util",
          "source": "src/Util-Sink.html#HasInvalidate",
          "type": "class"
        },
        "index": {
          "description": "The HasInvalidate class represents information sources which can be told No more not interested",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "HasInvalidate",
          "package": "uni-util",
          "partial": "Has Invalidate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#t:HasInvalidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "ParallelExec",
          "package": "uni-util",
          "source": "src/Util-Sink.html#ParallelExec",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "ParallelExec",
          "package": "uni-util",
          "partial": "Parallel Exec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#t:ParallelExec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "Sink",
          "package": "uni-util",
          "source": "src/Util-Sink.html#Sink",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "Sink",
          "package": "uni-util",
          "partial": "Sink",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#t:Sink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "SinkID",
          "package": "uni-util",
          "source": "src/Util-Sink.html#SinkID",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "SinkID",
          "package": "uni-util",
          "partial": "Sink ID",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#t:SinkID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an action to a sinkSource which is performed until the action returns\n False.\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "addNewAction",
          "package": "uni-util",
          "signature": "sinkSource -\u003e (delta -\u003e IO Bool) -\u003e IO x",
          "source": "src/Util-Sink.html#addNewAction",
          "type": "function"
        },
        "index": {
          "description": "Add an action to sinkSource which is performed until the action returns False",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addNewAction",
          "normalized": "a-\u003e(b-\u003eIO Bool)-\u003eIO c",
          "package": "uni-util",
          "partial": "New Action",
          "signature": "sinkSource-\u003e(delta-\u003eIO Bool)-\u003eIO x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addNewAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "addNewQuickSink",
          "package": "uni-util",
          "signature": "sinkSource -\u003e (delta -\u003e IO ()) -\u003e IO (x, Sink delta)",
          "source": "src/Util-Sink.html#addNewQuickSink",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addNewQuickSink",
          "normalized": "a-\u003e(b-\u003eIO())-\u003eIO(c,Sink b)",
          "package": "uni-util",
          "partial": "New Quick Sink",
          "signature": "sinkSource-\u003e(delta-\u003eIO())-\u003eIO(x,Sink delta)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addNewQuickSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "addNewQuickSinkGeneral",
          "package": "uni-util",
          "signature": "sinkSource -\u003e (delta -\u003e IO ()) -\u003e SinkID -\u003e IO (x, Sink delta)",
          "source": "src/Util-Sink.html#addNewQuickSinkGeneral",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addNewQuickSinkGeneral",
          "normalized": "a-\u003e(b-\u003eIO())-\u003eSinkID-\u003eIO(c,Sink b)",
          "package": "uni-util",
          "partial": "New Quick Sink General",
          "signature": "sinkSource-\u003e(delta-\u003eIO())-\u003eSinkID-\u003eIO(x,Sink delta)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addNewQuickSinkGeneral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "addNewSink",
          "package": "uni-util",
          "signature": "sinkSource -\u003e (delta -\u003e IO ()) -\u003e IO (x, Sink delta)",
          "source": "src/Util-Sink.html#addNewSink",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addNewSink",
          "normalized": "a-\u003e(b-\u003eIO())-\u003eIO(c,Sink b)",
          "package": "uni-util",
          "partial": "New Sink",
          "signature": "sinkSource-\u003e(delta-\u003eIO())-\u003eIO(x,Sink delta)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addNewSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "addNewSinkGeneral",
          "package": "uni-util",
          "signature": "sinkSource -\u003e (delta -\u003e IO ()) -\u003e SinkID -\u003e IO (x, Sink delta)",
          "source": "src/Util-Sink.html#addNewSinkGeneral",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addNewSinkGeneral",
          "normalized": "a-\u003e(b-\u003eIO())-\u003eSinkID-\u003eIO(c,Sink b)",
          "package": "uni-util",
          "partial": "New Sink General",
          "signature": "sinkSource-\u003e(delta-\u003eIO())-\u003eSinkID-\u003eIO(x,Sink delta)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addNewSinkGeneral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "addNewSinkVeryGeneral",
          "package": "uni-util",
          "signature": "sinkSource -\u003e (delta -\u003e IO ()) -\u003e SinkID -\u003e ParallelExec -\u003e IO (x, Sink delta)",
          "source": "src/Util-Sink.html#addNewSinkVeryGeneral",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addNewSinkVeryGeneral",
          "normalized": "a-\u003e(b-\u003eIO())-\u003eSinkID-\u003eParallelExec-\u003eIO(c,Sink b)",
          "package": "uni-util",
          "partial": "New Sink Very General",
          "signature": "sinkSource-\u003e(delta-\u003eIO())-\u003eSinkID-\u003eParallelExec-\u003eIO(x,Sink delta)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addNewSinkVeryGeneral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "addNewSinkWithInitial",
          "package": "uni-util",
          "signature": "sinkSource -\u003e (x -\u003e IO ()) -\u003e (delta -\u003e IO ()) -\u003e SinkID -\u003e ParallelExec -\u003e IO (x, Sink delta)",
          "source": "src/Util-Sink.html#addNewSinkWithInitial",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addNewSinkWithInitial",
          "normalized": "a-\u003e(b-\u003eIO())-\u003e(c-\u003eIO())-\u003eSinkID-\u003eParallelExec-\u003eIO(b,Sink c)",
          "package": "uni-util",
          "partial": "New Sink With Initial",
          "signature": "sinkSource-\u003e(x-\u003eIO())-\u003e(delta-\u003eIO())-\u003eSinkID-\u003eParallelExec-\u003eIO(x,Sink delta)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addNewSinkWithInitial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "addOldSink",
          "package": "uni-util",
          "signature": "sinkSource -\u003e Sink delta -\u003e IO x",
          "source": "src/Util-Sink.html#addOldSink",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "addOldSink",
          "normalized": "a-\u003eSink b-\u003eIO c",
          "package": "uni-util",
          "partial": "Old Sink",
          "signature": "sinkSource-\u003eSink delta-\u003eIO x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:addOldSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version which allows an IO action, which had better not take too long.\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "coMapIOSink'",
          "package": "uni-util",
          "signature": "(y -\u003e IO (Maybe x)) -\u003e Sink x -\u003e Sink y",
          "source": "src/Util-Sink.html#coMapIOSink%27",
          "type": "function"
        },
        "index": {
          "description": "version which allows an IO action which had better not take too long",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "coMapIOSink'",
          "normalized": "(a-\u003eIO(Maybe b))-\u003eSink b-\u003eSink a",
          "package": "uni-util",
          "partial": "Map IOSink'",
          "signature": "(y-\u003eIO(Maybe x))-\u003eSink x-\u003eSink y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:coMapIOSink-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a sink from one type to another\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "coMapSink",
          "package": "uni-util",
          "signature": "(y -\u003e x) -\u003e Sink x -\u003e Sink y",
          "source": "src/Util-Sink.html#coMapSink",
          "type": "function"
        },
        "index": {
          "description": "Convert sink from one type to another",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "coMapSink",
          "normalized": "(a-\u003eb)-\u003eSink b-\u003eSink a",
          "package": "uni-util",
          "partial": "Map Sink",
          "signature": "(y-\u003ex)-\u003eSink x-\u003eSink y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:coMapSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnother version which allows a transformation function to filter\n certain elements\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "coMapSink'",
          "package": "uni-util",
          "signature": "(y -\u003e Maybe x) -\u003e Sink x -\u003e Sink y",
          "source": "src/Util-Sink.html#coMapSink%27",
          "type": "function"
        },
        "index": {
          "description": "Another version which allows transformation function to filter certain elements",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "coMapSink'",
          "normalized": "(a-\u003eMaybe b)-\u003eSink b-\u003eSink a",
          "package": "uni-util",
          "partial": "Map Sink'",
          "signature": "(y-\u003eMaybe x)-\u003eSink x-\u003eSink y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:coMapSink-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "invalidate",
          "package": "uni-util",
          "signature": "source -\u003e IO ()",
          "source": "src/Util-Sink.html#invalidate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "invalidate",
          "normalized": "a-\u003eIO()",
          "package": "uni-util",
          "signature": "source-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:invalidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new sink which executes actions in a parallelExec thread,\n but allow the function generating these actions to be specified later,\n via the returned command.\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "newParallelDelayedSink",
          "package": "uni-util",
          "signature": "IO (Sink x, (x -\u003e IO ()) -\u003e IO ())",
          "source": "src/Util-Sink.html#newParallelDelayedSink",
          "type": "function"
        },
        "index": {
          "description": "Creates new sink which executes actions in parallelExec thread but allow the function generating these actions to be specified later via the returned command",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "newParallelDelayedSink",
          "normalized": "IO(Sink a,(a-\u003eIO())-\u003eIO())",
          "package": "uni-util",
          "partial": "Parallel Delayed Sink",
          "signature": "IO(Sink x,(x-\u003eIO())-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:newParallelDelayedSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "newParallelExec",
          "package": "uni-util",
          "signature": "IO ParallelExec",
          "source": "src/Util-Sink.html#newParallelExec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "newParallelExec",
          "package": "uni-util",
          "partial": "Parallel Exec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:newParallelExec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new sink which executes actions in a parallelExec thread.\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "newParallelSink",
          "package": "uni-util",
          "signature": "(x -\u003e IO ()) -\u003e IO (Sink x)",
          "source": "src/Util-Sink.html#newParallelSink",
          "type": "function"
        },
        "index": {
          "description": "Creates new sink which executes actions in parallelExec thread",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "newParallelSink",
          "normalized": "(a-\u003eIO())-\u003eIO(Sink a)",
          "package": "uni-util",
          "partial": "Parallel Sink",
          "signature": "(x-\u003eIO())-\u003eIO(Sink x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:newParallelSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new sink with its own SinkID\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "newSink",
          "package": "uni-util",
          "signature": "(x -\u003e IO ()) -\u003e IO (Sink x)",
          "source": "src/Util-Sink.html#newSink",
          "type": "function"
        },
        "index": {
          "description": "Creates new sink with its own SinkID",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "newSink",
          "normalized": "(a-\u003eIO())-\u003eIO(Sink a)",
          "package": "uni-util",
          "partial": "Sink",
          "signature": "(x-\u003eIO())-\u003eIO(Sink x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:newSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new sink with a given SinkID.  This allows us to\n invalidate lots of sinks just by invalidating one sinkID.\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "newSinkGeneral",
          "package": "uni-util",
          "signature": "SinkID -\u003e (x -\u003e IO ()) -\u003e IO (Sink x)",
          "source": "src/Util-Sink.html#newSinkGeneral",
          "type": "function"
        },
        "index": {
          "description": "Creates new sink with given SinkID This allows us to invalidate lots of sinks just by invalidating one sinkID",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "newSinkGeneral",
          "normalized": "SinkID-\u003e(a-\u003eIO())-\u003eIO(Sink a)",
          "package": "uni-util",
          "partial": "Sink General",
          "signature": "SinkID-\u003e(x-\u003eIO())-\u003eIO(Sink x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:newSinkGeneral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "newSinkID",
          "package": "uni-util",
          "signature": "IO SinkID",
          "source": "src/Util-Sink.html#newSinkID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "newSinkID",
          "package": "uni-util",
          "partial": "Sink ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:newSinkID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "parallelExec",
          "package": "uni-util",
          "signature": "ParallelExec -\u003e IO () -\u003e IO ()",
          "source": "src/Util-Sink.html#parallelExec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "parallelExec",
          "normalized": "ParallelExec-\u003eIO()-\u003eIO()",
          "package": "uni-util",
          "partial": "Exec",
          "signature": "ParallelExec-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:parallelExec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sink",
          "name": "parallelExecVSem",
          "package": "uni-util",
          "signature": "VSem",
          "source": "src/Util-Sink.html#parallelExecVSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "parallelExecVSem",
          "package": "uni-util",
          "partial": "Exec VSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:parallelExecVSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut a value into the sink, returning False if the sink id has been\n invalidated.\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "putSink",
          "package": "uni-util",
          "signature": "Sink x -\u003e x -\u003e IO Bool",
          "source": "src/Util-Sink.html#putSink",
          "type": "function"
        },
        "index": {
          "description": "Put value into the sink returning False if the sink id has been invalidated",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "putSink",
          "normalized": "Sink a-\u003ea-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Sink",
          "signature": "Sink x-\u003ex-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:putSink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut a list of values into the sink, returning False if the sink id has been\n invalidated\n\u003c/p\u003e",
          "module": "Util.Sink",
          "name": "putSinkMultiple",
          "package": "uni-util",
          "signature": "Sink x -\u003e [x] -\u003e IO Bool",
          "source": "src/Util-Sink.html#putSinkMultiple",
          "type": "function"
        },
        "index": {
          "description": "Put list of values into the sink returning False if the sink id has been invalidated",
          "hierarchy": "Util Sink",
          "module": "Util.Sink",
          "name": "putSinkMultiple",
          "normalized": "Sink a-\u003e[a]-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Sink Multiple",
          "signature": "Sink x-\u003e[x]-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sink.html#v:putSinkMultiple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWe implement the Source type and combinators for it.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Sources",
          "name": "Sources",
          "package": "uni-util",
          "source": "src/Util-Sources.html",
          "type": "module"
        },
        "index": {
          "description": "We implement the Source type and combinators for it",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "Sources",
          "package": "uni-util",
          "partial": "Sources",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "Client",
          "package": "uni-util",
          "source": "src/Util-Sources.html#Client",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "Client",
          "package": "uni-util",
          "partial": "Client",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#t:Client"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "HasSimpleSource",
          "package": "uni-util",
          "source": "src/Util-Sources.html#HasSimpleSource",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "HasSimpleSource",
          "package": "uni-util",
          "partial": "Has Simple Source",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#t:HasSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "HasSource",
          "package": "uni-util",
          "source": "src/Util-Sources.html#HasSource",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "HasSource",
          "package": "uni-util",
          "partial": "Has Source",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#t:HasSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "SimpleSource",
          "package": "uni-util",
          "source": "src/Util-Sources.html#SimpleSource",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "SimpleSource",
          "package": "uni-util",
          "partial": "Simple Source",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#t:SimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "Source",
          "package": "uni-util",
          "source": "src/Util-Sources.html#Source",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "Source",
          "package": "uni-util",
          "partial": "Source",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#t:Source"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "Updater",
          "package": "uni-util",
          "source": "src/Util-Sources.html#Updater",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "Updater",
          "package": "uni-util",
          "partial": "Updater",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#t:Updater"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "SimpleSource",
          "package": "uni-util",
          "signature": "SimpleSource (Source x x)",
          "source": "src/Util-Sources.html#SimpleSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "SimpleSource",
          "package": "uni-util",
          "partial": "Simple Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:SimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the specified actions for the source, using the given SinkID and\n in the ParallelExec thread.\n The x -\u003e IO () action is guaranteed to be performed before any of the\n d -\u003e IO () actions.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "addNewSourceActions",
          "package": "uni-util",
          "signature": "Source x d -\u003e (x -\u003e IO ()) -\u003e (d -\u003e IO ()) -\u003e SinkID -\u003e ParallelExec -\u003e IO x",
          "source": "src/Util-Sources.html#addNewSourceActions",
          "type": "function"
        },
        "index": {
          "description": "Run the specified actions for the source using the given SinkID and in the ParallelExec thread The IO action is guaranteed to be performed before any of the IO actions",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "addNewSourceActions",
          "normalized": "Source a b-\u003e(a-\u003eIO())-\u003e(b-\u003eIO())-\u003eSinkID-\u003eParallelExec-\u003eIO a",
          "package": "uni-util",
          "partial": "New Source Actions",
          "signature": "Source x d-\u003e(x-\u003eIO())-\u003e(d-\u003eIO())-\u003eSinkID-\u003eParallelExec-\u003eIO x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:addNewSourceActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "applyToUpdater",
          "package": "uni-util",
          "signature": "Updater x d -\u003e (x -\u003e (x, [d], extra)) -\u003e IO extra",
          "source": "src/Util-Sources.html#applyToUpdater",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "applyToUpdater",
          "normalized": "Updater a b-\u003e(a-\u003e(a,[b],c))-\u003eIO c",
          "package": "uni-util",
          "partial": "To Updater",
          "signature": "Updater x d-\u003e(x-\u003e(x,[d],extra))-\u003eIO extra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:applyToUpdater"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "attachClient",
          "package": "uni-util",
          "signature": "Client d -\u003e Source x d -\u003e IO x",
          "source": "src/Util-Sources.html#attachClient",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "attachClient",
          "normalized": "Client a-\u003eSource b a-\u003eIO b",
          "package": "uni-util",
          "partial": "Client",
          "signature": "Client d-\u003eSource x d-\u003eIO x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:attachClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplaces the first value of the SimpleSource.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "change1",
          "package": "uni-util",
          "signature": "SimpleSource x -\u003e x -\u003e SimpleSource x",
          "source": "src/Util-Sources.html#change1",
          "type": "function"
        },
        "index": {
          "description": "replaces the first value of the SimpleSource",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "change1",
          "normalized": "SimpleSource a-\u003ea-\u003eSimpleSource a",
          "package": "uni-util",
          "signature": "SimpleSource x-\u003ex-\u003eSimpleSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:change1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "choose",
          "package": "uni-util",
          "signature": "Source x1 d1 -\u003e Source x2 d2 -\u003e Source (x1, x2) (Either d1 d2)",
          "source": "src/Util-Sources.html#choose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "choose",
          "normalized": "Source a b-\u003eSource a b-\u003eSource(a,a)(Either b b)",
          "package": "uni-util",
          "signature": "Source x d-\u003eSource x d-\u003eSource(x,x)(Either d d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "filter2",
          "package": "uni-util",
          "signature": "(d1 -\u003e Maybe d2) -\u003e Source x d1 -\u003e Source x d2",
          "source": "src/Util-Sources.html#filter2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "filter2",
          "normalized": "(a-\u003eMaybe a)-\u003eSource b a-\u003eSource b a",
          "package": "uni-util",
          "signature": "(d-\u003eMaybe d)-\u003eSource x d-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:filter2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "filter2IO",
          "package": "uni-util",
          "signature": "(d1 -\u003e IO (Maybe d2)) -\u003e Source x d1 -\u003e Source x d2",
          "source": "src/Util-Sources.html#filter2IO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "filter2IO",
          "normalized": "(a-\u003eIO(Maybe a))-\u003eSource b a-\u003eSource b a",
          "package": "uni-util",
          "partial": "IO",
          "signature": "(d-\u003eIO(Maybe d))-\u003eSource x d-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:filter2IO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Source combinator which \"flattens\" lists of updates.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "flattenSource",
          "package": "uni-util",
          "signature": "Source x [d] -\u003e Source x d",
          "source": "src/Util-Sources.html#flattenSource",
          "type": "function"
        },
        "index": {
          "description": "Source combinator which flattens lists of updates",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "flattenSource",
          "normalized": "Source a[b]-\u003eSource a b",
          "package": "uni-util",
          "partial": "Source",
          "signature": "Source x[d]-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:flattenSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold a Simple Source, so that it carries state.\n The state is recomputed for each client.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "foldSimpleSourceIO",
          "package": "uni-util",
          "signature": "(x1 -\u003e IO (state, x2)) -\u003e (state -\u003e x1 -\u003e IO (state, x2)) -\u003e SimpleSource x1 -\u003e SimpleSource x2",
          "source": "src/Util-Sources.html#foldSimpleSourceIO",
          "type": "function"
        },
        "index": {
          "description": "Fold Simple Source so that it carries state The state is recomputed for each client",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "foldSimpleSourceIO",
          "normalized": "(a-\u003eIO(b,a))-\u003e(b-\u003ea-\u003eIO(b,a))-\u003eSimpleSource a-\u003eSimpleSource a",
          "package": "uni-util",
          "partial": "Simple Source IO",
          "signature": "(x-\u003eIO(state,x))-\u003e(state-\u003ex-\u003eIO(state,x))-\u003eSimpleSource x-\u003eSimpleSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:foldSimpleSourceIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "foldSource",
          "package": "uni-util",
          "signature": "(x -\u003e state) -\u003e (state -\u003e d1 -\u003e (state, d2)) -\u003e Source x d1 -\u003e Source (state, x) d2",
          "source": "src/Util-Sources.html#foldSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "foldSource",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ec-\u003e(b,c))-\u003eSource a c-\u003eSource(b,a)c",
          "package": "uni-util",
          "partial": "Source",
          "signature": "(x-\u003estate)-\u003e(state-\u003ed-\u003e(state,d))-\u003eSource x d-\u003eSource(state,x)d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:foldSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold a Source so that it can carry state around.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "foldSourceIO",
          "package": "uni-util",
          "signature": "(x1 -\u003e IO (state, x2)) -\u003e (state -\u003e d1 -\u003e IO (state, d2)) -\u003e Source x1 d1 -\u003e Source (state, x2) d2",
          "source": "src/Util-Sources.html#foldSourceIO",
          "type": "function"
        },
        "index": {
          "description": "Fold Source so that it can carry state around",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "foldSourceIO",
          "normalized": "(a-\u003eIO(b,a))-\u003e(b-\u003ec-\u003eIO(b,c))-\u003eSource a c-\u003eSource(b,a)c",
          "package": "uni-util",
          "partial": "Source IO",
          "signature": "(x-\u003eIO(state,x))-\u003e(state-\u003ed-\u003eIO(state,d))-\u003eSource x d-\u003eSource(state,x)d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:foldSourceIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "map1",
          "package": "uni-util",
          "signature": "(x1 -\u003e x2) -\u003e Source x1 d -\u003e Source x2 d",
          "source": "src/Util-Sources.html#map1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "map1",
          "normalized": "(a-\u003ea)-\u003eSource a b-\u003eSource a b",
          "package": "uni-util",
          "signature": "(x-\u003ex)-\u003eSource x d-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:map1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "map1IO",
          "package": "uni-util",
          "signature": "(x1 -\u003e IO x2) -\u003e Source x1 d -\u003e Source x2 d",
          "source": "src/Util-Sources.html#map1IO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "map1IO",
          "normalized": "(a-\u003eIO a)-\u003eSource a b-\u003eSource a b",
          "package": "uni-util",
          "partial": "IO",
          "signature": "(x-\u003eIO x)-\u003eSource x d-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:map1IO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "map2",
          "package": "uni-util",
          "signature": "(d1 -\u003e d2) -\u003e Source x d1 -\u003e Source x d2",
          "source": "src/Util-Sources.html#map2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "map2",
          "normalized": "(a-\u003ea)-\u003eSource b a-\u003eSource b a",
          "package": "uni-util",
          "signature": "(d-\u003ed)-\u003eSource x d-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:map2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "mapIOSeq",
          "package": "uni-util",
          "signature": "SimpleSource a -\u003e (a -\u003e IO (SimpleSource b)) -\u003e SimpleSource b",
          "source": "src/Util-Sources.html#mapIOSeq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "mapIOSeq",
          "normalized": "SimpleSource a-\u003e(a-\u003eIO(SimpleSource b))-\u003eSimpleSource b",
          "package": "uni-util",
          "partial": "IOSeq",
          "signature": "SimpleSource a-\u003e(a-\u003eIO(SimpleSource b))-\u003eSimpleSource b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:mapIOSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike mkHistorySource but for SimpleSource's; the x returns the initial\n value to compare with.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "mkHistorySimpleSource",
          "package": "uni-util",
          "signature": "x -\u003e SimpleSource x -\u003e SimpleSource (x, x)",
          "source": "src/Util-Sources.html#mkHistorySimpleSource",
          "type": "function"
        },
        "index": {
          "description": "Like mkHistorySource but for SimpleSource the returns the initial value to compare with",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "mkHistorySimpleSource",
          "normalized": "a-\u003eSimpleSource a-\u003eSimpleSource(a,a)",
          "package": "uni-util",
          "partial": "History Simple Source",
          "signature": "x-\u003eSimpleSource x-\u003eSimpleSource(x,x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:mkHistorySimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor each update d, pairs it with its predecessor (given first).\n For the very first update, a value is given based on the initial x,\n mapped by the given function.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "mkHistorySource",
          "package": "uni-util",
          "signature": "(x -\u003e d) -\u003e Source x d -\u003e Source x (d, d)",
          "source": "src/Util-Sources.html#mkHistorySource",
          "type": "function"
        },
        "index": {
          "description": "For each update pairs it with its predecessor given first For the very first update value is given based on the initial mapped by the given function",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "mkHistorySource",
          "normalized": "(a-\u003eb)-\u003eSource a b-\u003eSource a(b,b)",
          "package": "uni-util",
          "partial": "History Source",
          "signature": "(x-\u003ed)-\u003eSource x d-\u003eSource x(d,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:mkHistorySource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "mkIOSimpleSource",
          "package": "uni-util",
          "signature": "IO (SimpleSource a) -\u003e SimpleSource a",
          "source": "src/Util-Sources.html#mkIOSimpleSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "mkIOSimpleSource",
          "normalized": "IO(SimpleSource a)-\u003eSimpleSource a",
          "package": "uni-util",
          "partial": "IOSimple Source",
          "signature": "IO(SimpleSource a)-\u003eSimpleSource a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:mkIOSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed when we are worried that a SimpleSource recursively constructed\n by mapIOSeq, \u003e\u003e= and friends may actually try to call itself, and\n so loop forever.   The Strings identify the SimpleSource,\n and so the [String] is effectively a backtrace of the TSems, revealing what\n chain of simple sources might have caused the loop.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "noLoopSimpleSource",
          "package": "uni-util",
          "signature": "TSem -\u003e ([String] -\u003e a) -\u003e SimpleSource a -\u003e SimpleSource a",
          "source": "src/Util-Sources.html#noLoopSimpleSource",
          "type": "function"
        },
        "index": {
          "description": "Used when we are worried that SimpleSource recursively constructed by mapIOSeq and friends may actually try to call itself and so loop forever The Strings identify the SimpleSource and so the String is effectively backtrace of the TSems revealing what chain of simple sources might have caused the loop",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "noLoopSimpleSource",
          "normalized": "TSem-\u003e([String]-\u003ea)-\u003eSimpleSource a-\u003eSimpleSource a",
          "package": "uni-util",
          "partial": "Loop Simple Source",
          "signature": "TSem-\u003e([String]-\u003ea)-\u003eSimpleSource a-\u003eSimpleSource a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:noLoopSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair two SimpleSource's.  This is probably better than using \u003e\u003e=, since it\n does not require reregistering with the second SimpleSource\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "pairSimpleSources",
          "package": "uni-util",
          "signature": "SimpleSource x1 -\u003e SimpleSource x2 -\u003e SimpleSource (x1, x2)",
          "source": "src/Util-Sources.html#pairSimpleSources",
          "type": "function"
        },
        "index": {
          "description": "Pair two SimpleSource This is probably better than using since it does not require reregistering with the second SimpleSource",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "pairSimpleSources",
          "normalized": "SimpleSource a-\u003eSimpleSource a-\u003eSimpleSource(a,a)",
          "package": "uni-util",
          "partial": "Simple Sources",
          "signature": "SimpleSource x-\u003eSimpleSource x-\u003eSimpleSource(x,x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:pairSimpleSources"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current contents of the source, but don't specify any other\n action.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "readContents",
          "package": "uni-util",
          "signature": "source -\u003e IO x",
          "source": "src/Util-Sources.html#readContents",
          "type": "function"
        },
        "index": {
          "description": "Get the current contents of the source but don specify any other action",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "readContents",
          "normalized": "a-\u003eIO b",
          "package": "uni-util",
          "partial": "Contents",
          "signature": "source-\u003eIO x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:readContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "seqSource",
          "package": "uni-util",
          "signature": "Source x1 x1 -\u003e (x1 -\u003e Source x2 x2) -\u003e Source x2 x2",
          "source": "src/Util-Sources.html#seqSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "seqSource",
          "normalized": "Source a a-\u003e(a-\u003eSource a a)-\u003eSource a a",
          "package": "uni-util",
          "partial": "Source",
          "signature": "Source x x-\u003e(x-\u003eSource x x)-\u003eSource x x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:seqSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes a similar job to pairSimpleSources, so that the sources run\n parallel.\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "sequenceSimpleSource",
          "package": "uni-util",
          "signature": "[SimpleSource x] -\u003e SimpleSource [x]",
          "source": "src/Util-Sources.html#sequenceSimpleSource",
          "type": "function"
        },
        "index": {
          "description": "Does similar job to pairSimpleSources so that the sources run parallel",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "sequenceSimpleSource",
          "normalized": "[SimpleSource a]-\u003eSimpleSource[a]",
          "package": "uni-util",
          "partial": "Simple Source",
          "signature": "[SimpleSource x]-\u003eSimpleSource[x]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:sequenceSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "staticSimpleSource",
          "package": "uni-util",
          "signature": "x -\u003e SimpleSource x",
          "source": "src/Util-Sources.html#staticSimpleSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "staticSimpleSource",
          "normalized": "a-\u003eSimpleSource a",
          "package": "uni-util",
          "partial": "Simple Source",
          "signature": "x-\u003eSimpleSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:staticSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "staticSimpleSourceIO",
          "package": "uni-util",
          "signature": "IO x -\u003e SimpleSource x",
          "source": "src/Util-Sources.html#staticSimpleSourceIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "staticSimpleSourceIO",
          "normalized": "IO a-\u003eSimpleSource a",
          "package": "uni-util",
          "partial": "Simple Source IO",
          "signature": "IO x-\u003eSimpleSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:staticSimpleSourceIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "staticSource",
          "package": "uni-util",
          "signature": "x -\u003e Source x d",
          "source": "src/Util-Sources.html#staticSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "staticSource",
          "normalized": "a-\u003eSource a b",
          "package": "uni-util",
          "partial": "Source",
          "signature": "x-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:staticSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "staticSourceIO",
          "package": "uni-util",
          "signature": "IO x -\u003e Source x d",
          "source": "src/Util-Sources.html#staticSourceIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "staticSourceIO",
          "normalized": "IO a-\u003eSource a b",
          "package": "uni-util",
          "partial": "Source IO",
          "signature": "IO x-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:staticSourceIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "stepSource",
          "package": "uni-util",
          "signature": "(x -\u003e d2) -\u003e (d1 -\u003e d2) -\u003e Source x d1 -\u003e Source x d2",
          "source": "src/Util-Sources.html#stepSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "stepSource",
          "normalized": "(a-\u003eb)-\u003e(b-\u003eb)-\u003eSource a b-\u003eSource a b",
          "package": "uni-util",
          "partial": "Source",
          "signature": "(x-\u003ed)-\u003e(d-\u003ed)-\u003eSource x d-\u003eSource x d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:stepSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "toSimpleSource",
          "package": "uni-util",
          "signature": "hasSource -\u003e SimpleSource x",
          "source": "src/Util-Sources.html#toSimpleSource",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "toSimpleSource",
          "normalized": "a-\u003eSimpleSource b",
          "package": "uni-util",
          "partial": "Simple Source",
          "signature": "hasSource-\u003eSimpleSource x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:toSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "toSource",
          "package": "uni-util",
          "signature": "hasSource -\u003e Source x d",
          "source": "src/Util-Sources.html#toSource",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "toSource",
          "normalized": "a-\u003eSource b c",
          "package": "uni-util",
          "partial": "Source",
          "signature": "hasSource-\u003eSource x d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:toSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutputs information about what comes through the source, turning\n it into a String with the supplied function.  (This is done once\n for each active client.)\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "traceSimpleSource",
          "package": "uni-util",
          "signature": "(a -\u003e String) -\u003e SimpleSource a -\u003e SimpleSource a",
          "source": "src/Util-Sources.html#traceSimpleSource",
          "type": "function"
        },
        "index": {
          "description": "Outputs information about what comes through the source turning it into String with the supplied function This is done once for each active client",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "traceSimpleSource",
          "normalized": "(a-\u003eString)-\u003eSimpleSource a-\u003eSimpleSource a",
          "package": "uni-util",
          "partial": "Simple Source",
          "signature": "(a-\u003eString)-\u003eSimpleSource a-\u003eSimpleSource a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:traceSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutputs information about what comes through the source, turning\n it into a String with the supplied function.  (This is done once\n for each active client.)\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "traceSource",
          "package": "uni-util",
          "signature": "(a -\u003e String) -\u003e (d -\u003e String) -\u003e Source a d -\u003e Source a d",
          "source": "src/Util-Sources.html#traceSource",
          "type": "function"
        },
        "index": {
          "description": "Outputs information about what comes through the source turning it into String with the supplied function This is done once for each active client",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "traceSource",
          "normalized": "(a-\u003eString)-\u003e(b-\u003eString)-\u003eSource a b-\u003eSource a b",
          "package": "uni-util",
          "partial": "Source",
          "signature": "(a-\u003eString)-\u003e(d-\u003eString)-\u003eSource a d-\u003eSource a d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:traceSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efilter out consecutive duplicates\n\u003c/p\u003e",
          "module": "Util.Sources",
          "name": "uniqSimpleSource",
          "package": "uni-util",
          "signature": "SimpleSource x -\u003e SimpleSource x",
          "source": "src/Util-Sources.html#uniqSimpleSource",
          "type": "function"
        },
        "index": {
          "description": "filter out consecutive duplicates",
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "uniqSimpleSource",
          "normalized": "SimpleSource a-\u003eSimpleSource a",
          "package": "uni-util",
          "partial": "Simple Source",
          "signature": "SimpleSource x-\u003eSimpleSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:uniqSimpleSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "variableGeneralSource",
          "package": "uni-util",
          "signature": "x -\u003e IO (Source x d, Updater x d)",
          "source": "src/Util-Sources.html#variableGeneralSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "variableGeneralSource",
          "normalized": "a-\u003eIO(Source a b,Updater a b)",
          "package": "uni-util",
          "partial": "General Source",
          "signature": "x-\u003eIO(Source x d,Updater x d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:variableGeneralSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Sources",
          "name": "variableSource",
          "package": "uni-util",
          "signature": "x -\u003e IO (Source x d, (x -\u003e (x, [d])) -\u003e IO ())",
          "source": "src/Util-Sources.html#variableSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Sources",
          "module": "Util.Sources",
          "name": "variableSource",
          "normalized": "a-\u003eIO(Source a b,(a-\u003e(a,[b]))-\u003eIO())",
          "package": "uni-util",
          "partial": "Source",
          "signature": "x-\u003eIO(Source x d,(x-\u003e(x,[d]))-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Sources.html#v:variableSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Store a contains an (a) value which is only to be computed once,\n when it is first needed.\n\u003c/p\u003e\u003cp\u003ePerhaps we should use laziness and unsafePerformIO?\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Store",
          "name": "Store",
          "package": "uni-util",
          "source": "src/Util-Store.html",
          "type": "module"
        },
        "index": {
          "description": "Store contains an value which is only to be computed once when it is first needed Perhaps we should use laziness and unsafePerformIO",
          "hierarchy": "Util Store",
          "module": "Util.Store",
          "name": "Store",
          "package": "uni-util",
          "partial": "Store",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Store.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Store",
          "name": "Store",
          "package": "uni-util",
          "source": "src/Util-Store.html#Store",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util Store",
          "module": "Util.Store",
          "name": "Store",
          "package": "uni-util",
          "partial": "Store",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Store.html#t:Store"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Store",
          "name": "newStore",
          "package": "uni-util",
          "signature": "IO (Store a)",
          "source": "src/Util-Store.html#newStore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Store",
          "module": "Util.Store",
          "name": "newStore",
          "package": "uni-util",
          "partial": "Store",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Store.html#v:newStore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Store",
          "name": "takeStore",
          "package": "uni-util",
          "signature": "IO a -\u003e Store a -\u003e IO a",
          "source": "src/Util-Store.html#takeStore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Store",
          "module": "Util.Store",
          "name": "takeStore",
          "normalized": "IO a-\u003eStore a-\u003eIO a",
          "package": "uni-util",
          "partial": "Store",
          "signature": "IO a-\u003eStore a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Store.html#v:takeStore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA TSem is an unusual sort of lock in that it only protects the same thread\n from acquiring it twice.  Different threads may acquire the same TSem\n without problems.\n\u003c/p\u003e\u003cp\u003eThe purpose of this is to allow computations which potentially would\n loop forever by calling themselves to instead fail gracefully.  To\n aid in this process, we also include in each TSem a String.  When we\n attempt to acquire a TSem which is already acquired, we instead return\n the String for this TSem and the TSems acquired within this one.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.TSem",
          "name": "TSem",
          "package": "uni-util",
          "source": "src/Util-TSem.html",
          "type": "module"
        },
        "index": {
          "description": "TSem is an unusual sort of lock in that it only protects the same thread from acquiring it twice Different threads may acquire the same TSem without problems The purpose of this is to allow computations which potentially would loop forever by calling themselves to instead fail gracefully To aid in this process we also include in each TSem String When we attempt to acquire TSem which is already acquired we instead return the String for this TSem and the TSems acquired within this one",
          "hierarchy": "Util TSem",
          "module": "Util.TSem",
          "name": "TSem",
          "package": "uni-util",
          "partial": "TSem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-TSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.TSem",
          "name": "TSem",
          "package": "uni-util",
          "source": "src/Util-TSem.html#TSem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util TSem",
          "module": "Util.TSem",
          "name": "TSem",
          "package": "uni-util",
          "partial": "TSem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-TSem.html#t:TSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.TSem",
          "name": "newTSem",
          "package": "uni-util",
          "signature": "IO String -\u003e IO TSem",
          "source": "src/Util-TSem.html#newTSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util TSem",
          "module": "Util.TSem",
          "name": "newTSem",
          "normalized": "IO String-\u003eIO TSem",
          "package": "uni-util",
          "partial": "TSem",
          "signature": "IO String-\u003eIO TSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-TSem.html#v:newTSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.TSem",
          "name": "synchronizeTSem",
          "package": "uni-util",
          "signature": "TSem -\u003e IO a -\u003e IO (Either [String] a)",
          "source": "src/Util-TSem.html#synchronizeTSem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util TSem",
          "module": "Util.TSem",
          "name": "synchronizeTSem",
          "normalized": "TSem-\u003eIO a-\u003eIO(Either[String]a)",
          "package": "uni-util",
          "partial": "TSem",
          "signature": "TSem-\u003eIO a-\u003eIO(Either[String]a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-TSem.html#v:synchronizeTSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe TempFile module allocates temporary files\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.TempFile",
          "name": "TempFile",
          "package": "uni-util",
          "source": "src/Util-TempFile.html",
          "type": "module"
        },
        "index": {
          "description": "The TempFile module allocates temporary files",
          "hierarchy": "Util TempFile",
          "module": "Util.TempFile",
          "name": "TempFile",
          "package": "uni-util",
          "partial": "Temp File",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-TempFile.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.TempFile",
          "name": "newTempFile",
          "package": "uni-util",
          "signature": "IO FilePath",
          "source": "src/Util-TempFile.html#newTempFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util TempFile",
          "module": "Util.TempFile",
          "name": "newTempFile",
          "package": "uni-util",
          "partial": "Temp File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-TempFile.html#v:newTempFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic Thread operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.Thread",
          "name": "Thread",
          "package": "uni-util",
          "source": "src/Util-Thread.html",
          "type": "module"
        },
        "index": {
          "description": "Basic Thread operations",
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "Thread",
          "package": "uni-util",
          "partial": "Thread",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "Duration",
          "package": "uni-util",
          "source": "src/Util-Thread.html#Duration",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "Duration",
          "package": "uni-util",
          "partial": "Duration",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#t:Duration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an abstract type representing a handle to a thread.\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e, where\nthe \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instance implements an arbitrary total ordering over\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003es. The \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance lets you convert an arbitrary-valued\n\u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e to string form; showing a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e value is occasionally\nuseful when debugging or diagnosing the behaviour of a concurrent\nprogram.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: in GHC, if you have a \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e, you essentially have\na pointer to the thread itself.  This means the thread itself can't be\ngarbage collected until you drop the \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e.\nThis misfeature will hopefully be corrected at a later date.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: Hugs does not provide any operations on other threads;\nit defines \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e as a synonym for ().\n\u003c/p\u003e",
          "module": "Util.Thread",
          "name": "ThreadId",
          "package": "uni-util",
          "type": "data"
        },
        "index": {
          "description": "ThreadId is an abstract type representing handle to thread ThreadId is an instance of Eq Ord and Show where the Ord instance implements an arbitrary total ordering over ThreadId The Show instance lets you convert an arbitrary-valued ThreadId to string form showing ThreadId value is occasionally useful when debugging or diagnosing the behaviour of concurrent program Note in GHC if you have ThreadId you essentially have pointer to the thread itself This means the thread itself can be garbage collected until you drop the ThreadId This misfeature will hopefully be corrected at later date Note Hugs does not provide any operations on other threads it defines ThreadId as synonym for",
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "ThreadId",
          "package": "uni-util",
          "partial": "Thread Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#t:ThreadId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "after",
          "package": "uni-util",
          "signature": "Duration -\u003e IO a -\u003e IO a",
          "source": "src/Util-Thread.html#after",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "after",
          "normalized": "Duration-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "signature": "Duration-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:after"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "delay",
          "package": "uni-util",
          "signature": "Duration -\u003e IO ()",
          "source": "src/Util-Thread.html#delay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "delay",
          "normalized": "Duration-\u003eIO()",
          "package": "uni-util",
          "signature": "Duration-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:delay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "every",
          "package": "uni-util",
          "signature": "Duration -\u003e IO a -\u003e IO ()",
          "source": "src/Util-Thread.html#every",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "every",
          "normalized": "Duration-\u003eIO a-\u003eIO()",
          "package": "uni-util",
          "signature": "Duration-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:every"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "forkIODebug",
          "package": "uni-util",
          "signature": "IO () -\u003e IO ThreadId",
          "source": "src/Util-Thread.html#forkIODebug",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "forkIODebug",
          "normalized": "IO()-\u003eIO ThreadId",
          "package": "uni-util",
          "partial": "IODebug",
          "signature": "IO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:forkIODebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "forkIOquiet",
          "package": "uni-util",
          "signature": "String -\u003e IO () -\u003e IO ThreadId",
          "source": "src/Util-Thread.html#forkIOquiet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "forkIOquiet",
          "normalized": "String-\u003eIO()-\u003eIO ThreadId",
          "package": "uni-util",
          "partial": "IOquiet",
          "signature": "String-\u003eIO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:forkIOquiet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "goesQuietly",
          "package": "uni-util",
          "signature": "IO () -\u003e IO ()",
          "source": "src/Util-Thread.html#goesQuietly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "goesQuietly",
          "normalized": "IO()-\u003eIO()",
          "package": "uni-util",
          "partial": "Quietly",
          "signature": "IO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:goesQuietly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "mapMConcurrent",
          "package": "uni-util",
          "signature": "(a -\u003e IO b) -\u003e [a] -\u003e IO [b]",
          "source": "src/Util-Thread.html#mapMConcurrent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "mapMConcurrent",
          "normalized": "(a-\u003eIO b)-\u003e[a]-\u003eIO[b]",
          "package": "uni-util",
          "partial": "MConcurrent",
          "signature": "(a-\u003eIO b)-\u003e[a]-\u003eIO[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:mapMConcurrent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "mapMConcurrentExcep",
          "package": "uni-util",
          "signature": "forall a b.  (a -\u003e IO b) -\u003e [a] -\u003e IO [b]",
          "source": "src/Util-Thread.html#mapMConcurrentExcep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "mapMConcurrentExcep",
          "normalized": "a b c(b-\u003eIO d)-\u003e[b]-\u003eIO[d]",
          "package": "uni-util",
          "partial": "MConcurrent Excep",
          "signature": "forall a b.(a-\u003eIO b)-\u003e[a]-\u003eIO[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:mapMConcurrentExcep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "mapMConcurrent_",
          "package": "uni-util",
          "signature": "(a -\u003e IO ()) -\u003e [a] -\u003e IO ()",
          "source": "src/Util-Thread.html#mapMConcurrent_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "mapMConcurrent_",
          "normalized": "(a-\u003eIO())-\u003e[a]-\u003eIO()",
          "package": "uni-util",
          "partial": "MConcurrent",
          "signature": "(a-\u003eIO())-\u003e[a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:mapMConcurrent_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "mins",
          "package": "uni-util",
          "signature": "Double -\u003e Duration",
          "source": "src/Util-Thread.html#mins",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "mins",
          "normalized": "Double-\u003eDuration",
          "package": "uni-util",
          "signature": "Double-\u003eDuration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:mins"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "msecs",
          "package": "uni-util",
          "signature": "Double -\u003e Duration",
          "source": "src/Util-Thread.html#msecs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "msecs",
          "normalized": "Double-\u003eDuration",
          "package": "uni-util",
          "signature": "Double-\u003eDuration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:msecs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "secs",
          "package": "uni-util",
          "signature": "Double -\u003e Duration",
          "source": "src/Util-Thread.html#secs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "secs",
          "normalized": "Double-\u003eDuration",
          "package": "uni-util",
          "signature": "Double-\u003eDuration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:secs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.Thread",
          "name": "usecs",
          "package": "uni-util",
          "signature": "Double -\u003e Duration",
          "source": "src/Util-Thread.html#usecs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util Thread",
          "module": "Util.Thread",
          "name": "usecs",
          "normalized": "Double-\u003eDuration",
          "package": "uni-util",
          "signature": "Double-\u003eDuration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-Thread.html#v:usecs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements per-thread variables\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.ThreadDict",
          "name": "ThreadDict",
          "package": "uni-util",
          "source": "src/Util-ThreadDict.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements per-thread variables",
          "hierarchy": "Util ThreadDict",
          "module": "Util.ThreadDict",
          "name": "ThreadDict",
          "package": "uni-util",
          "partial": "Thread Dict",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ThreadDict.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ThreadDict",
          "name": "ThreadDict",
          "package": "uni-util",
          "source": "src/Util-ThreadDict.html#ThreadDict",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util ThreadDict",
          "module": "Util.ThreadDict",
          "name": "ThreadDict",
          "package": "uni-util",
          "partial": "Thread Dict",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ThreadDict.html#t:ThreadDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ThreadDict",
          "name": "modifyThreadDict",
          "package": "uni-util",
          "signature": "ThreadDict a -\u003e (Maybe a -\u003e IO (Maybe a, b)) -\u003e IO b",
          "source": "src/Util-ThreadDict.html#modifyThreadDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ThreadDict",
          "module": "Util.ThreadDict",
          "name": "modifyThreadDict",
          "normalized": "ThreadDict a-\u003e(Maybe a-\u003eIO(Maybe a,b))-\u003eIO b",
          "package": "uni-util",
          "partial": "Thread Dict",
          "signature": "ThreadDict a-\u003e(Maybe a-\u003eIO(Maybe a,b))-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ThreadDict.html#v:modifyThreadDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ThreadDict",
          "name": "newThreadDict",
          "package": "uni-util",
          "signature": "IO (ThreadDict a)",
          "source": "src/Util-ThreadDict.html#newThreadDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ThreadDict",
          "module": "Util.ThreadDict",
          "name": "newThreadDict",
          "package": "uni-util",
          "partial": "Thread Dict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ThreadDict.html#v:newThreadDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ThreadDict",
          "name": "readThreadDict",
          "package": "uni-util",
          "signature": "ThreadDict a -\u003e IO (Maybe a)",
          "source": "src/Util-ThreadDict.html#readThreadDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ThreadDict",
          "module": "Util.ThreadDict",
          "name": "readThreadDict",
          "normalized": "ThreadDict a-\u003eIO(Maybe a)",
          "package": "uni-util",
          "partial": "Thread Dict",
          "signature": "ThreadDict a-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ThreadDict.html#v:readThreadDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.ThreadDict",
          "name": "writeThreadDict",
          "package": "uni-util",
          "signature": "ThreadDict a -\u003e a -\u003e IO ()",
          "source": "src/Util-ThreadDict.html#writeThreadDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util ThreadDict",
          "module": "Util.ThreadDict",
          "name": "writeThreadDict",
          "normalized": "ThreadDict a-\u003ea-\u003eIO()",
          "package": "uni-util",
          "partial": "Thread Dict",
          "signature": "ThreadDict a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-ThreadDict.html#v:writeThreadDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains functions for converting to and from the UTF8\n representations for Strings.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.UTF8",
          "name": "UTF8",
          "package": "uni-util",
          "source": "src/Util-UTF8.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains functions for converting to and from the UTF8 representations for Strings",
          "hierarchy": "Util UTF8",
          "module": "Util.UTF8",
          "name": "UTF8",
          "package": "uni-util",
          "partial": "UTF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UTF8.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnion-Find algorithm.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.UnionFind",
          "name": "UnionFind",
          "package": "uni-util",
          "source": "src/Util-UnionFind.html",
          "type": "module"
        },
        "index": {
          "description": "Union-Find algorithm",
          "hierarchy": "Util UnionFind",
          "module": "Util.UnionFind",
          "name": "UnionFind",
          "package": "uni-util",
          "partial": "Union Find",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UnionFind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UnionFind",
          "name": "UnionFind",
          "package": "uni-util",
          "source": "src/Util-UnionFind.html#UnionFind",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util UnionFind",
          "module": "Util.UnionFind",
          "name": "UnionFind",
          "package": "uni-util",
          "partial": "Union Find",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UnionFind.html#t:UnionFind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UnionFind",
          "name": "isSame",
          "package": "uni-util",
          "signature": "UnionFind a -\u003e UnionFind a -\u003e IO Bool",
          "source": "src/Util-UnionFind.html#isSame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UnionFind",
          "module": "Util.UnionFind",
          "name": "isSame",
          "normalized": "UnionFind a-\u003eUnionFind a-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Same",
          "signature": "UnionFind a-\u003eUnionFind a-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UnionFind.html#v:isSame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UnionFind",
          "name": "newElement",
          "package": "uni-util",
          "signature": "a -\u003e IO (UnionFind a)",
          "source": "src/Util-UnionFind.html#newElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UnionFind",
          "module": "Util.UnionFind",
          "name": "newElement",
          "normalized": "a-\u003eIO(UnionFind a)",
          "package": "uni-util",
          "partial": "Element",
          "signature": "a-\u003eIO(UnionFind a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UnionFind.html#v:newElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UnionFind",
          "name": "sameElements",
          "package": "uni-util",
          "signature": "UnionFind a -\u003e IO [UnionFind a]",
          "source": "src/Util-UnionFind.html#sameElements",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UnionFind",
          "module": "Util.UnionFind",
          "name": "sameElements",
          "normalized": "UnionFind a-\u003eIO[UnionFind a]",
          "package": "uni-util",
          "partial": "Elements",
          "signature": "UnionFind a-\u003eIO[UnionFind a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UnionFind.html#v:sameElements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UnionFind",
          "name": "toValue",
          "package": "uni-util",
          "signature": "UnionFind a -\u003e a",
          "source": "src/Util-UnionFind.html#toValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UnionFind",
          "module": "Util.UnionFind",
          "name": "toValue",
          "normalized": "UnionFind a-\u003ea",
          "package": "uni-util",
          "partial": "Value",
          "signature": "UnionFind a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UnionFind.html#v:toValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UnionFind",
          "name": "union",
          "package": "uni-util",
          "signature": "UnionFind a -\u003e UnionFind a -\u003e IO ()",
          "source": "src/Util-UnionFind.html#union",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UnionFind",
          "module": "Util.UnionFind",
          "name": "union",
          "normalized": "UnionFind a-\u003eUnionFind a-\u003eIO()",
          "package": "uni-util",
          "signature": "UnionFind a-\u003eUnionFind a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UnionFind.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUniqueFile is used for allocating names for temporary files in a directory.\n To avoid large numbers of files in the same directory, we create sub-\n directories where necessary.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.UniqueFile",
          "name": "UniqueFile",
          "package": "uni-util",
          "source": "src/Util-UniqueFile.html",
          "type": "module"
        },
        "index": {
          "description": "UniqueFile is used for allocating names for temporary files in directory To avoid large numbers of files in the same directory we create sub directories where necessary",
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "UniqueFile",
          "package": "uni-util",
          "partial": "Unique File",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueFile",
          "name": "UniqueFileCounter",
          "package": "uni-util",
          "source": "src/Util-UniqueFile.html#UniqueFileCounter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "UniqueFileCounter",
          "package": "uni-util",
          "partial": "Unique File Counter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#t:UniqueFileCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueFile",
          "name": "UniqueFileStore",
          "package": "uni-util",
          "source": "src/Util-UniqueFile.html#UniqueFileStore",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "UniqueFileStore",
          "package": "uni-util",
          "partial": "Unique File Store",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#t:UniqueFileStore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueFile",
          "name": "ensureDirectories",
          "package": "uni-util",
          "signature": "UniqueFileStore -\u003e String -\u003e IO ()",
          "source": "src/Util-UniqueFile.html#ensureDirectories",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "ensureDirectories",
          "normalized": "UniqueFileStore-\u003eString-\u003eIO()",
          "package": "uni-util",
          "partial": "Directories",
          "signature": "UniqueFileStore-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#v:ensureDirectories"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueFile",
          "name": "getFilePath",
          "package": "uni-util",
          "signature": "UniqueFileStore -\u003e String -\u003e FilePath",
          "source": "src/Util-UniqueFile.html#getFilePath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "getFilePath",
          "normalized": "UniqueFileStore-\u003eString-\u003eFilePath",
          "package": "uni-util",
          "partial": "File Path",
          "signature": "UniqueFileStore-\u003eString-\u003eFilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#v:getFilePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueFile",
          "name": "initialUniqueFileCounter",
          "package": "uni-util",
          "signature": "UniqueFileCounter",
          "source": "src/Util-UniqueFile.html#initialUniqueFileCounter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "initialUniqueFileCounter",
          "package": "uni-util",
          "partial": "Unique File Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#v:initialUniqueFileCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueFile",
          "name": "newUniqueFileStore",
          "package": "uni-util",
          "signature": "FilePath -\u003e (FilePath -\u003e IO ()) -\u003e IO UniqueFileStore",
          "source": "src/Util-UniqueFile.html#newUniqueFileStore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "newUniqueFileStore",
          "normalized": "FilePath-\u003e(FilePath-\u003eIO())-\u003eIO UniqueFileStore",
          "package": "uni-util",
          "partial": "Unique File Store",
          "signature": "FilePath-\u003e(FilePath-\u003eIO())-\u003eIO UniqueFileStore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#v:newUniqueFileStore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueFile",
          "name": "stepUniqueFileCounter",
          "package": "uni-util",
          "signature": "UniqueFileCounter -\u003e (String, UniqueFileCounter)",
          "source": "src/Util-UniqueFile.html#stepUniqueFileCounter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueFile",
          "module": "Util.UniqueFile",
          "name": "stepUniqueFileCounter",
          "normalized": "UniqueFileCounter-\u003e(String,UniqueFileCounter)",
          "package": "uni-util",
          "partial": "Unique File Counter",
          "signature": "UniqueFileCounter-\u003e(String,UniqueFileCounter)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueFile.html#v:stepUniqueFileCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module generates short non-empty unique printable strings (IE without\n funny characters).  Quotes and backslashes are not included, so printing\n should not be too hard.  Periods are also not included, for the\n benefit of NewNames.hs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.UniqueString",
          "name": "UniqueString",
          "package": "uni-util",
          "source": "src/Util-UniqueString.html",
          "type": "module"
        },
        "index": {
          "description": "This module generates short non-empty unique printable strings IE without funny characters Quotes and backslashes are not included so printing should not be too hard Periods are also not included for the benefit of NewNames.hs",
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "UniqueString",
          "package": "uni-util",
          "partial": "Unique String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "UniqueStringCounter",
          "package": "uni-util",
          "source": "src/Util-UniqueString.html#UniqueStringCounter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "UniqueStringCounter",
          "package": "uni-util",
          "partial": "Unique String Counter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#t:UniqueStringCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "UniqueStringSource",
          "package": "uni-util",
          "source": "src/Util-UniqueString.html#UniqueStringSource",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "UniqueStringSource",
          "package": "uni-util",
          "partial": "Unique String Source",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#t:UniqueStringSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreateUniqueStringSource is the inverse of readUniqueStringSource.\n\u003c/p\u003e",
          "module": "Util.UniqueString",
          "name": "createUniqueStringSource",
          "package": "uni-util",
          "signature": "[Int] -\u003e IO UniqueStringSource",
          "source": "src/Util-UniqueString.html#createUniqueStringSource",
          "type": "function"
        },
        "index": {
          "description": "createUniqueStringSource is the inverse of readUniqueStringSource",
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "createUniqueStringSource",
          "normalized": "[Int]-\u003eIO UniqueStringSource",
          "package": "uni-util",
          "partial": "Unique String Source",
          "signature": "[Int]-\u003eIO UniqueStringSource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:createUniqueStringSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "firstUniqueString",
          "package": "uni-util",
          "signature": "String",
          "source": "src/Util-UniqueString.html#firstUniqueString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "firstUniqueString",
          "package": "uni-util",
          "partial": "Unique String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:firstUniqueString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "firstUniqueStringCounter",
          "package": "uni-util",
          "signature": "UniqueStringCounter",
          "source": "src/Util-UniqueString.html#firstUniqueStringCounter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "firstUniqueStringCounter",
          "package": "uni-util",
          "partial": "Unique String Counter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:firstUniqueStringCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "maxUniqueStringSources",
          "package": "uni-util",
          "signature": "[UniqueStringSource] -\u003e IO UniqueStringSource",
          "source": "src/Util-UniqueString.html#maxUniqueStringSources",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "maxUniqueStringSources",
          "normalized": "[UniqueStringSource]-\u003eIO UniqueStringSource",
          "package": "uni-util",
          "partial": "Unique String Sources",
          "signature": "[UniqueStringSource]-\u003eIO UniqueStringSource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:maxUniqueStringSources"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate non-conflicting string which cannot be produced by\n newUniqueString.  This is useful for exceptional cases.\n We add this by adding a character with integer value 0 at the end.\n\u003c/p\u003e",
          "module": "Util.UniqueString",
          "name": "newNonUnique",
          "package": "uni-util",
          "signature": "String -\u003e String",
          "source": "src/Util-UniqueString.html#newNonUnique",
          "type": "function"
        },
        "index": {
          "description": "Create non-conflicting string which cannot be produced by newUniqueString This is useful for exceptional cases We add this by adding character with integer value at the end",
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "newNonUnique",
          "normalized": "String-\u003eString",
          "package": "uni-util",
          "partial": "Non Unique",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:newNonUnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "newUniqueString",
          "package": "uni-util",
          "signature": "UniqueStringSource -\u003e IO String",
          "source": "src/Util-UniqueString.html#newUniqueString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "newUniqueString",
          "normalized": "UniqueStringSource-\u003eIO String",
          "package": "uni-util",
          "partial": "Unique String",
          "signature": "UniqueStringSource-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:newUniqueString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "newUniqueStringSource",
          "package": "uni-util",
          "signature": "IO UniqueStringSource",
          "source": "src/Util-UniqueString.html#newUniqueStringSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "newUniqueStringSource",
          "package": "uni-util",
          "partial": "Unique String Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:newUniqueStringSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereadUniqueStringSource is used by types/CodedValue.hs to export values.\n\u003c/p\u003e",
          "module": "Util.UniqueString",
          "name": "readUniqueStringSource",
          "package": "uni-util",
          "signature": "UniqueStringSource -\u003e IO [Int]",
          "source": "src/Util-UniqueString.html#readUniqueStringSource",
          "type": "function"
        },
        "index": {
          "description": "readUniqueStringSource is used by types CodedValue.hs to export values",
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "readUniqueStringSource",
          "normalized": "UniqueStringSource-\u003eIO[Int]",
          "package": "uni-util",
          "partial": "Unique String Source",
          "signature": "UniqueStringSource-\u003eIO[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:readUniqueStringSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.UniqueString",
          "name": "stepUniqueStringCounter",
          "package": "uni-util",
          "signature": "UniqueStringCounter -\u003e (String, UniqueStringCounter)",
          "source": "src/Util-UniqueString.html#stepUniqueStringCounter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util UniqueString",
          "module": "Util.UniqueString",
          "name": "stepUniqueStringCounter",
          "normalized": "UniqueStringCounter-\u003e(String,UniqueStringCounter)",
          "package": "uni-util",
          "partial": "Unique String Counter",
          "signature": "UniqueStringCounter-\u003e(String,UniqueStringCounter)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-UniqueString.html#v:stepUniqueStringCounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e| Implements locks which can be locked \u003ca\u003eglobally\u003c/a\u003e or \u003ca\u003elocally\u003c/a\u003e.\n   A global lock prevents any other lock; a local lock allows other local\n   locks.\n\u003c/p\u003e\u003cp\u003eThere are some subtle decisions to be made about when to give preference\n   to local, and when to global, locks.  There are two important cases:\n   (1) When we free a global lock, and there is another queued global lock,\n       we take that global lock (or the earliest for which someone is\n       waiting, if there's a choice), irrespective of whether anyone is\n       waiting for a local lock.\n   (2) When at least one local lock is held, we allow people to acquire\n       further local locks, even if there are queued global locks.\n\u003c/p\u003e\u003cp\u003eA bad consequence of (2) is that a global lock can be indefinitely not\n   satisfied by a carefully-timed sequence of finite local locks:\n\u003c/p\u003e\u003cp\u003elocal locks : --- --- --- --- . . .\n                   --- --- ---   . . .\n   no global lock can be acquired at all.\n\u003c/p\u003e\u003cp\u003eHowever the alternative, of not permitting any fresh local locks when\n   a global lock is queued, is worse (in my opinion), since if a thread\n   attempts to acquire two local locks, one inside the other, and another\n   attempts to acquire a global lock, the whole thing can deadlock.\n\u003c/p\u003e\u003cp\u003eThread 1  : acquire local lock                    attempt to acquire second local lock =\u003e DEADLOCK.\n   Thread 2  :                   wait for global lock\n\u003c/p\u003e\u003cp\u003eWe could deal with this partially by allowing local locks for free\n   to a thread which already holds one, but this is more complicated and\n   I suspect theoretically dodgy.\n\u003c/p\u003e\u003cp\u003eA consequence of this decision is that threads should avoid creating\n   automated repeated sequences of local locks on the same VSem.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.VSem",
          "name": "VSem",
          "package": "uni-util",
          "source": "src/Util-VSem.html",
          "type": "module"
        },
        "index": {
          "description": "Implements locks which can be locked globally or locally global lock prevents any other lock local lock allows other local locks There are some subtle decisions to be made about when to give preference to local and when to global locks There are two important cases When we free global lock and there is another queued global lock we take that global lock or the earliest for which someone is waiting if there choice irrespective of whether anyone is waiting for local lock When at least one local lock is held we allow people to acquire further local locks even if there are queued global locks bad consequence of is that global lock can be indefinitely not satisfied by carefully-timed sequence of finite local locks local locks no global lock can be acquired at all However the alternative of not permitting any fresh local locks when global lock is queued is worse in my opinion since if thread attempts to acquire two local locks one inside the other and another attempts to acquire global lock the whole thing can deadlock Thread acquire local lock attempt to acquire second local lock DEADLOCK Thread wait for global lock We could deal with this partially by allowing local locks for free to thread which already holds one but this is more complicated and suspect theoretically dodgy consequence of this decision is that threads should avoid creating automated repeated sequences of local locks on the same VSem",
          "hierarchy": "Util VSem",
          "module": "Util.VSem",
          "name": "VSem",
          "package": "uni-util",
          "partial": "VSem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA lock which can be globally or locally locked.\n At any time, a \u003ccode\u003eVSem\u003c/code\u003e is either globally locked once, or locally locked\n zero or more times.  Global locks always take priority over local locks.\n\u003c/p\u003e",
          "module": "Util.VSem",
          "name": "VSem",
          "package": "uni-util",
          "source": "src/Util-VSem.html#VSem",
          "type": "data"
        },
        "index": {
          "description": "lock which can be globally or locally locked At any time VSem is either globally locked once or locally locked zero or more times Global locks always take priority over local locks",
          "hierarchy": "Util VSem",
          "module": "Util.VSem",
          "name": "VSem",
          "package": "uni-util",
          "partial": "VSem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VSem.html#t:VSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAcquire a local lock on a \u003ccode\u003e\u003ca\u003eVSem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.VSem",
          "name": "acquireLocal",
          "package": "uni-util",
          "signature": "VSem -\u003e IO ()",
          "source": "src/Util-VSem.html#acquireLocal",
          "type": "function"
        },
        "index": {
          "description": "Acquire local lock on VSem",
          "hierarchy": "Util VSem",
          "module": "Util.VSem",
          "name": "acquireLocal",
          "normalized": "VSem-\u003eIO()",
          "package": "uni-util",
          "partial": "Local",
          "signature": "VSem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VSem.html#v:acquireLocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a \u003ccode\u003e\u003ca\u003eVSem\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Util.VSem",
          "name": "newVSem",
          "package": "uni-util",
          "signature": "IO VSem",
          "source": "src/Util-VSem.html#newVSem",
          "type": "function"
        },
        "index": {
          "description": "Creates VSem",
          "hierarchy": "Util VSem",
          "module": "Util.VSem",
          "name": "newVSem",
          "package": "uni-util",
          "partial": "VSem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VSem.html#v:newVSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelease a local lock on a \u003ccode\u003e\u003ca\u003eVSem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Util.VSem",
          "name": "releaseLocal",
          "package": "uni-util",
          "signature": "VSem -\u003e IO ()",
          "source": "src/Util-VSem.html#releaseLocal",
          "type": "function"
        },
        "index": {
          "description": "Release local lock on VSem",
          "hierarchy": "Util VSem",
          "module": "Util.VSem",
          "name": "releaseLocal",
          "normalized": "VSem-\u003eIO()",
          "package": "uni-util",
          "partial": "Local",
          "signature": "VSem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VSem.html#v:releaseLocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an action while locking a \u003ccode\u003e\u003ca\u003eVSem\u003c/a\u003e\u003c/code\u003e globally.\n\u003c/p\u003e",
          "module": "Util.VSem",
          "name": "synchronizeGlobal",
          "package": "uni-util",
          "signature": "VSem -\u003e IO b -\u003e IO b",
          "source": "src/Util-VSem.html#synchronizeGlobal",
          "type": "function"
        },
        "index": {
          "description": "Perform an action while locking VSem globally",
          "hierarchy": "Util VSem",
          "module": "Util.VSem",
          "name": "synchronizeGlobal",
          "normalized": "VSem-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "partial": "Global",
          "signature": "VSem-\u003eIO b-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VSem.html#v:synchronizeGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an action while locking a \u003ccode\u003e\u003ca\u003eVSem\u003c/a\u003e\u003c/code\u003e locally.\n\u003c/p\u003e",
          "module": "Util.VSem",
          "name": "synchronizeLocal",
          "package": "uni-util",
          "signature": "VSem -\u003e IO b -\u003e IO b",
          "source": "src/Util-VSem.html#synchronizeLocal",
          "type": "function"
        },
        "index": {
          "description": "Perform an action while locking VSem locally",
          "hierarchy": "Util VSem",
          "module": "Util.VSem",
          "name": "synchronizeLocal",
          "normalized": "VSem-\u003eIO a-\u003eIO a",
          "package": "uni-util",
          "partial": "Local",
          "signature": "VSem-\u003eIO b-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VSem.html#v:synchronizeLocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "VariableList",
          "package": "uni-util",
          "source": "src/Util-VariableList.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "VariableList",
          "package": "uni-util",
          "partial": "Variable List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "ListDrawer",
          "package": "uni-util",
          "source": "src/Util-VariableList.html#ListDrawer",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "ListDrawer",
          "package": "uni-util",
          "partial": "List Drawer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#t:ListDrawer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the close action.\n attachListOp :: ParallelExec -\u003e VariableList a -\u003e ListDrawer a -\u003e IO (IO ())\n\u003c/p\u003e",
          "module": "Util.VariableList",
          "name": "VariableList",
          "package": "uni-util",
          "source": "src/Util-VariableList.html#VariableList",
          "type": "data"
        },
        "index": {
          "description": "Return the close action attachListOp ParallelExec VariableList ListDrawer IO IO",
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "VariableList",
          "package": "uni-util",
          "partial": "Variable List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#t:VariableList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "ListDrawer",
          "package": "uni-util",
          "signature": "ListDrawer",
          "source": "src/Util-VariableList.html#ListDrawer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "ListDrawer",
          "package": "uni-util",
          "partial": "List Drawer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:ListDrawer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "attachListOp",
          "package": "uni-util",
          "signature": "VariableList a -\u003e forall pos.  ParallelExec -\u003e ListDrawer a pos -\u003e IO (IO ())",
          "source": "src/Util-VariableList.html#attachListOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "attachListOp",
          "normalized": "VariableList a-\u003eb c ParallelExec-\u003eListDrawer a d-\u003eIO(IO())",
          "package": "uni-util",
          "partial": "List Op",
          "signature": "VariableList a-\u003eforall pos. ParallelExec-\u003eListDrawer a pos-\u003eIO(IO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:attachListOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "catVariableLists",
          "package": "uni-util",
          "signature": "VariableList a -\u003e VariableList a -\u003e VariableList a",
          "source": "src/Util-VariableList.html#catVariableLists",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "catVariableLists",
          "normalized": "VariableList a-\u003eVariableList a-\u003eVariableList a",
          "package": "uni-util",
          "partial": "Variable Lists",
          "signature": "VariableList a-\u003eVariableList a-\u003eVariableList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:catVariableLists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "coMapListDrawer",
          "package": "uni-util",
          "signature": "(a -\u003e b) -\u003e ListDrawer b pos -\u003e ListDrawer a pos",
          "source": "src/Util-VariableList.html#coMapListDrawer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "coMapListDrawer",
          "normalized": "(a-\u003eb)-\u003eListDrawer b c-\u003eListDrawer a c",
          "package": "uni-util",
          "partial": "Map List Drawer",
          "signature": "(a-\u003eb)-\u003eListDrawer b pos-\u003eListDrawer a pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:coMapListDrawer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "delPos",
          "package": "uni-util",
          "signature": "pos -\u003e IO ()",
          "source": "src/Util-VariableList.html#ListDrawer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "delPos",
          "normalized": "a-\u003eIO()",
          "package": "uni-util",
          "partial": "Pos",
          "signature": "pos-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:delPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "emptyVariableList",
          "package": "uni-util",
          "signature": "VariableList a",
          "source": "src/Util-VariableList.html#emptyVariableList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "emptyVariableList",
          "package": "uni-util",
          "partial": "Variable List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:emptyVariableList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "map2ListDrawer",
          "package": "uni-util",
          "signature": "(pos1 -\u003e pos2) -\u003e (pos2 -\u003e pos1) -\u003e ListDrawer b pos1 -\u003e ListDrawer b pos2",
          "source": "src/Util-VariableList.html#map2ListDrawer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "map2ListDrawer",
          "normalized": "(a-\u003ea)-\u003e(a-\u003ea)-\u003eListDrawer b a-\u003eListDrawer b a",
          "package": "uni-util",
          "partial": "List Drawer",
          "signature": "(pos-\u003epos)-\u003e(pos-\u003epos)-\u003eListDrawer b pos-\u003eListDrawer b pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:map2ListDrawer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "newPos",
          "package": "uni-util",
          "signature": "Maybe pos -\u003e Maybe a -\u003e IO pos",
          "source": "src/Util-VariableList.html#ListDrawer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "newPos",
          "normalized": "Maybe a-\u003eMaybe b-\u003eIO a",
          "package": "uni-util",
          "partial": "Pos",
          "signature": "Maybe pos-\u003eMaybe a-\u003eIO pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:newPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "newVariableListFromList",
          "package": "uni-util",
          "signature": "SimpleSource [a] -\u003e VariableList a",
          "source": "src/Util-VariableList.html#newVariableListFromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "newVariableListFromList",
          "normalized": "SimpleSource[a]-\u003eVariableList a",
          "package": "uni-util",
          "partial": "Variable List From List",
          "signature": "SimpleSource[a]-\u003eVariableList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:newVariableListFromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "newVariableListFromSet",
          "package": "uni-util",
          "signature": "VariableSetSource a -\u003e VariableList a",
          "source": "src/Util-VariableList.html#newVariableListFromSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "newVariableListFromSet",
          "normalized": "VariableSetSource a-\u003eVariableList a",
          "package": "uni-util",
          "partial": "Variable List From Set",
          "signature": "VariableSetSource a-\u003eVariableList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:newVariableListFromSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "redraw",
          "package": "uni-util",
          "signature": "IO ()",
          "source": "src/Util-VariableList.html#ListDrawer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "redraw",
          "normalized": "IO()",
          "package": "uni-util",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:redraw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "setPos",
          "package": "uni-util",
          "signature": "pos -\u003e Maybe a -\u003e IO ()",
          "source": "src/Util-VariableList.html#ListDrawer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "setPos",
          "normalized": "a-\u003eMaybe b-\u003eIO()",
          "package": "uni-util",
          "partial": "Pos",
          "signature": "pos-\u003eMaybe a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:setPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableList",
          "name": "singletonList",
          "package": "uni-util",
          "signature": "forall a.  a -\u003e VariableList a",
          "source": "src/Util-VariableList.html#singletonList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableList",
          "module": "Util.VariableList",
          "name": "singletonList",
          "normalized": "a b c-\u003eVariableList c",
          "package": "uni-util",
          "partial": "List",
          "signature": "forall a. a-\u003eVariableList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableList.html#v:singletonList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVariableMap is analagous to VariableSet and provides a mutable map ordered\n by key whose changes can be tracked.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.VariableMap",
          "name": "VariableMap",
          "package": "uni-util",
          "source": "src/Util-VariableMap.html",
          "type": "module"
        },
        "index": {
          "description": "VariableMap is analagous to VariableSet and provides mutable map ordered by key whose changes can be tracked",
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "VariableMap",
          "package": "uni-util",
          "partial": "Variable Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "VariableMap",
          "package": "uni-util",
          "source": "src/Util-VariableMap.html#VariableMap",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "VariableMap",
          "package": "uni-util",
          "partial": "Variable Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#t:VariableMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes a map update.  For DelUpdate, the second parameter (the one\n of type elt) is irrelevant and may be undefined.\n\u003c/p\u003e",
          "module": "Util.VariableMap",
          "name": "VariableMapData",
          "package": "uni-util",
          "source": "src/Util-VariableMap.html#VariableMapData",
          "type": "data"
        },
        "index": {
          "description": "Describes map update For DelUpdate the second parameter the one of type elt is irrelevant and may be undefined",
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "VariableMapData",
          "package": "uni-util",
          "partial": "Variable Map Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#t:VariableMapData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe recycle the VariableSetUpdate type for this.\n\u003c/p\u003e",
          "module": "Util.VariableMap",
          "name": "VariableMapUpdate",
          "package": "uni-util",
          "source": "src/Util-VariableMap.html#VariableMapUpdate",
          "type": "newtype"
        },
        "index": {
          "description": "We recycle the VariableSetUpdate type for this",
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "VariableMapUpdate",
          "package": "uni-util",
          "partial": "Variable Map Update",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#t:VariableMapUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "VariableMapUpdate",
          "package": "uni-util",
          "signature": "VariableMapUpdate (VariableSetUpdate (key, elt))",
          "source": "src/Util-VariableMap.html#VariableMapUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "VariableMapUpdate",
          "normalized": "VariableMapUpdate(VariableSetUpdate(a,b))",
          "package": "uni-util",
          "partial": "Variable Map Update",
          "signature": "VariableMapUpdate(VariableSetUpdate(key,elt))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:VariableMapUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "addToVariableMap",
          "package": "uni-util",
          "signature": "VariableMap key elt -\u003e key -\u003e elt -\u003e IO Bool",
          "source": "src/Util-VariableMap.html#addToVariableMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "addToVariableMap",
          "normalized": "VariableMap a b-\u003ea-\u003eb-\u003eIO Bool",
          "package": "uni-util",
          "partial": "To Variable Map",
          "signature": "VariableMap key elt-\u003ekey-\u003eelt-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:addToVariableMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "delFromVariableMap",
          "package": "uni-util",
          "signature": "VariableMap key elt -\u003e key -\u003e IO Bool",
          "source": "src/Util-VariableMap.html#delFromVariableMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "delFromVariableMap",
          "normalized": "VariableMap a b-\u003ea-\u003eIO Bool",
          "package": "uni-util",
          "partial": "From Variable Map",
          "signature": "VariableMap key elt-\u003ekey-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:delFromVariableMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "getVariableMapByKey",
          "package": "uni-util",
          "signature": "VariableMap key elt -\u003e key -\u003e SimpleSource (Maybe elt)",
          "source": "src/Util-VariableMap.html#getVariableMapByKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "getVariableMapByKey",
          "normalized": "VariableMap a b-\u003ea-\u003eSimpleSource(Maybe b)",
          "package": "uni-util",
          "partial": "Variable Map By Key",
          "signature": "VariableMap key elt-\u003ekey-\u003eSimpleSource(Maybe elt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:getVariableMapByKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "lookupMap",
          "package": "uni-util",
          "signature": "VariableMapData key elt -\u003e key -\u003e Maybe elt",
          "source": "src/Util-VariableMap.html#lookupMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "lookupMap",
          "normalized": "VariableMapData a b-\u003ea-\u003eMaybe b",
          "package": "uni-util",
          "partial": "Map",
          "signature": "VariableMapData key elt-\u003ekey-\u003eMaybe elt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:lookupMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "lookupVariableMap",
          "package": "uni-util",
          "signature": "VariableMap key elt -\u003e key -\u003e IO (Maybe elt)",
          "source": "src/Util-VariableMap.html#lookupVariableMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "lookupVariableMap",
          "normalized": "VariableMap a b-\u003ea-\u003eIO(Maybe b)",
          "package": "uni-util",
          "partial": "Variable Map",
          "signature": "VariableMap key elt-\u003ekey-\u003eIO(Maybe elt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:lookupVariableMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "lookupWithDefaultMap",
          "package": "uni-util",
          "signature": "VariableMapData key elt -\u003e elt -\u003e key -\u003e elt",
          "source": "src/Util-VariableMap.html#lookupWithDefaultMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "lookupWithDefaultMap",
          "normalized": "VariableMapData a b-\u003eb-\u003ea-\u003eb",
          "package": "uni-util",
          "partial": "With Default Map",
          "signature": "VariableMapData key elt-\u003eelt-\u003ekey-\u003eelt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:lookupWithDefaultMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "mapToFM",
          "package": "uni-util",
          "signature": "VariableMapData key elt -\u003e Map key elt",
          "source": "src/Util-VariableMap.html#mapToFM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "mapToFM",
          "normalized": "VariableMapData a b-\u003eMap a b",
          "package": "uni-util",
          "partial": "To FM",
          "signature": "VariableMapData key elt-\u003eMap key elt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:mapToFM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "mapToList",
          "package": "uni-util",
          "signature": "VariableMapData key elt -\u003e [(key, elt)]",
          "source": "src/Util-VariableMap.html#mapToList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "mapToList",
          "normalized": "VariableMapData a b-\u003e[(a,b)]",
          "package": "uni-util",
          "partial": "To List",
          "signature": "VariableMapData key elt-\u003e[(key,elt)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:mapToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a variable map and conversion function, produce a VariableSetSource\n\u003c/p\u003e",
          "module": "Util.VariableMap",
          "name": "mapToVariableSetSource",
          "package": "uni-util",
          "signature": "(key -\u003e elt -\u003e element) -\u003e VariableMap key elt -\u003e VariableSetSource element",
          "source": "src/Util-VariableMap.html#mapToVariableSetSource",
          "type": "function"
        },
        "index": {
          "description": "Given variable map and conversion function produce VariableSetSource",
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "mapToVariableSetSource",
          "normalized": "(a-\u003eb-\u003ec)-\u003eVariableMap a b-\u003eVariableSetSource c",
          "package": "uni-util",
          "partial": "To Variable Set Source",
          "signature": "(key-\u003eelt-\u003eelement)-\u003eVariableMap key elt-\u003eVariableSetSource element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:mapToVariableSetSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new empty variable map.\n\u003c/p\u003e",
          "module": "Util.VariableMap",
          "name": "newEmptyVariableMap",
          "package": "uni-util",
          "signature": "IO (VariableMap key elt)",
          "source": "src/Util-VariableMap.html#newEmptyVariableMap",
          "type": "function"
        },
        "index": {
          "description": "Create new empty variable map",
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "newEmptyVariableMap",
          "package": "uni-util",
          "partial": "Empty Variable Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:newEmptyVariableMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new variable map with given contents\n\u003c/p\u003e",
          "module": "Util.VariableMap",
          "name": "newVariableMap",
          "package": "uni-util",
          "signature": "[(key, elt)] -\u003e IO (VariableMap key elt)",
          "source": "src/Util-VariableMap.html#newVariableMap",
          "type": "function"
        },
        "index": {
          "description": "Create new variable map with given contents",
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "newVariableMap",
          "normalized": "[(a,b)]-\u003eIO(VariableMap a b)",
          "package": "uni-util",
          "partial": "Variable Map",
          "signature": "[(key,elt)]-\u003eIO(VariableMap key elt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:newVariableMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "newVariableMapFromFM",
          "package": "uni-util",
          "signature": "Map key elt -\u003e IO (VariableMap key elt)",
          "source": "src/Util-VariableMap.html#newVariableMapFromFM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "newVariableMapFromFM",
          "normalized": "Map a b-\u003eIO(VariableMap a b)",
          "package": "uni-util",
          "partial": "Variable Map From FM",
          "signature": "Map key elt-\u003eIO(VariableMap key elt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:newVariableMapFromFM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate a variable map in some way.  Returns True if the update was\n sucessful (so for insertions, the object is not already there; for\n deletions the object is not there).\n\u003c/p\u003e",
          "module": "Util.VariableMap",
          "name": "updateMap",
          "package": "uni-util",
          "signature": "VariableMap key elt -\u003e VariableMapUpdate key elt -\u003e IO Bool",
          "source": "src/Util-VariableMap.html#updateMap",
          "type": "function"
        },
        "index": {
          "description": "Update variable map in some way Returns True if the update was sucessful so for insertions the object is not already there for deletions the object is not there",
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "updateMap",
          "normalized": "VariableMap a b-\u003eVariableMapUpdate a b-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Map",
          "signature": "VariableMap key elt-\u003eVariableMapUpdate key elt-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:updateMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableMap",
          "name": "variableMapToList",
          "package": "uni-util",
          "signature": "VariableMap key elt -\u003e IO [(key, elt)]",
          "source": "src/Util-VariableMap.html#variableMapToList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableMap",
          "module": "Util.VariableMap",
          "name": "variableMapToList",
          "normalized": "VariableMap a b-\u003eIO[(a,b)]",
          "package": "uni-util",
          "partial": "Map To List",
          "signature": "VariableMap key elt-\u003eIO[(key,elt)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableMap.html#v:variableMapToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVariableSet allow us to track changes to an unordered mutable set.\n The elements of the set are keyed by instancing HasKey with some Ord\n instance; this allows us to set up a special HasKey instance for this\n module without committing us to that Ord instance everywhere.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.VariableSet",
          "name": "VariableSet",
          "package": "uni-util",
          "source": "src/Util-VariableSet.html",
          "type": "module"
        },
        "index": {
          "description": "VariableSet allow us to track changes to an unordered mutable set The elements of the set are keyed by instancing HasKey with some Ord instance this allows us to set up special HasKey instance for this module without committing us to that Ord instance everywhere",
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "VariableSet",
          "package": "uni-util",
          "partial": "Variable Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "HasKey",
          "package": "uni-util",
          "source": "src/Util-VariableSet.html#HasKey",
          "type": "class"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "HasKey",
          "package": "uni-util",
          "partial": "Has Key",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#t:HasKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "Keyed",
          "package": "uni-util",
          "source": "src/Util-VariableSet.html#Keyed",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "Keyed",
          "package": "uni-util",
          "partial": "Keyed",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#t:Keyed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "VariableSet",
          "package": "uni-util",
          "source": "src/Util-VariableSet.html#VariableSet",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "VariableSet",
          "package": "uni-util",
          "partial": "Variable Set",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#t:VariableSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "VariableSetSource",
          "package": "uni-util",
          "source": "src/Util-VariableSet.html#VariableSetSource",
          "type": "type"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "VariableSetSource",
          "package": "uni-util",
          "partial": "Variable Set Source",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#t:VariableSetSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncodes the updates to a variable set.\n BeginGroup does not actually alter the set itself, but\n indicate that a group of updates is about to begin, terminated by EndGroup.\n This prevents the client from trying to recalculate the state after every single\n update.\n\u003c/p\u003e\u003cp\u003eBeginGroup/EndGroup may be nested (though I don't have any application for that\n yet).\n\u003c/p\u003e",
          "module": "Util.VariableSet",
          "name": "VariableSetUpdate",
          "package": "uni-util",
          "source": "src/Util-VariableSet.html#VariableSetUpdate",
          "type": "data"
        },
        "index": {
          "description": "Encodes the updates to variable set BeginGroup does not actually alter the set itself but indicate that group of updates is about to begin terminated by EndGroup This prevents the client from trying to recalculate the state after every single update BeginGroup EndGroup may be nested though don have any application for that yet",
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "VariableSetUpdate",
          "package": "uni-util",
          "partial": "Variable Set Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#t:VariableSetUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "AddElement",
          "package": "uni-util",
          "signature": "AddElement x",
          "source": "src/Util-VariableSet.html#VariableSetUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "AddElement",
          "package": "uni-util",
          "partial": "Add Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:AddElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "BeginGroup",
          "package": "uni-util",
          "signature": "BeginGroup",
          "source": "src/Util-VariableSet.html#VariableSetUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "BeginGroup",
          "package": "uni-util",
          "partial": "Begin Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:BeginGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "DelElement",
          "package": "uni-util",
          "signature": "DelElement x",
          "source": "src/Util-VariableSet.html#VariableSetUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "DelElement",
          "package": "uni-util",
          "partial": "Del Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:DelElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "EndGroup",
          "package": "uni-util",
          "signature": "EndGroup",
          "source": "src/Util-VariableSet.html#VariableSetUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "EndGroup",
          "package": "uni-util",
          "partial": "End Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:EndGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "Keyed",
          "package": "uni-util",
          "signature": "Keyed x",
          "source": "src/Util-VariableSet.html#Keyed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "Keyed",
          "package": "uni-util",
          "partial": "Keyed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:Keyed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "VariableSet",
          "package": "uni-util",
          "signature": "VariableSet (Broadcaster (VariableSetData x) (VariableSetUpdate x))",
          "source": "src/Util-VariableSet.html#VariableSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "VariableSet",
          "package": "uni-util",
          "partial": "Variable Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:VariableSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "concatVariableSetSource",
          "package": "uni-util",
          "signature": "VariableSetSource x -\u003e VariableSetSource x -\u003e VariableSetSource x",
          "source": "src/Util-VariableSet.html#concatVariableSetSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "concatVariableSetSource",
          "normalized": "VariableSetSource a-\u003eVariableSetSource a-\u003eVariableSetSource a",
          "package": "uni-util",
          "partial": "Variable Set Source",
          "signature": "VariableSetSource x-\u003eVariableSetSource x-\u003eVariableSetSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:concatVariableSetSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "emptyVariableSetSource",
          "package": "uni-util",
          "signature": "VariableSetSource x",
          "source": "src/Util-VariableSet.html#emptyVariableSetSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "emptyVariableSetSource",
          "package": "uni-util",
          "partial": "Variable Set Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:emptyVariableSetSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a VariableSetSource whose elements are the same as those of the\n corresponding list.\n\u003c/p\u003e",
          "module": "Util.VariableSet",
          "name": "listToSetSource",
          "package": "uni-util",
          "signature": "SimpleSource [x] -\u003e VariableSetSource x",
          "source": "src/Util-VariableSet.html#listToSetSource",
          "type": "function"
        },
        "index": {
          "description": "Creates VariableSetSource whose elements are the same as those of the corresponding list",
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "listToSetSource",
          "normalized": "SimpleSource[a]-\u003eVariableSetSource a",
          "package": "uni-util",
          "partial": "To Set Source",
          "signature": "SimpleSource[x]-\u003eVariableSetSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:listToSetSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "mapVariableSetSource",
          "package": "uni-util",
          "signature": "(x -\u003e y) -\u003e VariableSetSource x -\u003e VariableSetSource y",
          "source": "src/Util-VariableSet.html#mapVariableSetSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "mapVariableSetSource",
          "normalized": "(a-\u003eb)-\u003eVariableSetSource a-\u003eVariableSetSource b",
          "package": "uni-util",
          "partial": "Variable Set Source",
          "signature": "(x-\u003ey)-\u003eVariableSetSource x-\u003eVariableSetSource y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:mapVariableSetSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "mapVariableSetSourceIO'",
          "package": "uni-util",
          "signature": "(x -\u003e IO (Maybe y)) -\u003e VariableSetSource x -\u003e VariableSetSource y",
          "source": "src/Util-VariableSet.html#mapVariableSetSourceIO%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "mapVariableSetSourceIO'",
          "normalized": "(a-\u003eIO(Maybe b))-\u003eVariableSetSource a-\u003eVariableSetSource b",
          "package": "uni-util",
          "partial": "Variable Set Source IO'",
          "signature": "(x-\u003eIO(Maybe y))-\u003eVariableSetSource x-\u003eVariableSetSource y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:mapVariableSetSourceIO-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new empty variable set.\n\u003c/p\u003e",
          "module": "Util.VariableSet",
          "name": "newEmptyVariableSet",
          "package": "uni-util",
          "signature": "IO (VariableSet x)",
          "source": "src/Util-VariableSet.html#newEmptyVariableSet",
          "type": "function"
        },
        "index": {
          "description": "Create new empty variable set",
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "newEmptyVariableSet",
          "package": "uni-util",
          "partial": "Empty Variable Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:newEmptyVariableSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new variable set with given contents\n\u003c/p\u003e",
          "module": "Util.VariableSet",
          "name": "newVariableSet",
          "package": "uni-util",
          "signature": "[x] -\u003e IO (VariableSet x)",
          "source": "src/Util-VariableSet.html#newVariableSet",
          "type": "function"
        },
        "index": {
          "description": "Create new variable set with given contents",
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "newVariableSet",
          "normalized": "[a]-\u003eIO(VariableSet a)",
          "package": "uni-util",
          "partial": "Variable Set",
          "signature": "[x]-\u003eIO(VariableSet x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:newVariableSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the elements of the variable set.\n\u003c/p\u003e",
          "module": "Util.VariableSet",
          "name": "setVariableSet",
          "package": "uni-util",
          "signature": "VariableSet x -\u003e [x] -\u003e IO ()",
          "source": "src/Util-VariableSet.html#setVariableSet",
          "type": "function"
        },
        "index": {
          "description": "Set the elements of the variable set",
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "setVariableSet",
          "normalized": "VariableSet a-\u003e[a]-\u003eIO()",
          "package": "uni-util",
          "partial": "Variable Set",
          "signature": "VariableSet x-\u003e[x]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:setVariableSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "singletonSetSource",
          "package": "uni-util",
          "signature": "SimpleSource x -\u003e VariableSetSource x",
          "source": "src/Util-VariableSet.html#singletonSetSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "singletonSetSource",
          "normalized": "SimpleSource a-\u003eVariableSetSource a",
          "package": "uni-util",
          "partial": "Set Source",
          "signature": "SimpleSource x-\u003eVariableSetSource x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:singletonSetSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSet",
          "name": "toKey",
          "package": "uni-util",
          "signature": "x -\u003e key",
          "source": "src/Util-VariableSet.html#toKey",
          "type": "method"
        },
        "index": {
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "toKey",
          "normalized": "a-\u003eb",
          "package": "uni-util",
          "partial": "Key",
          "signature": "x-\u003ekey",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:toKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate a variable set in some way.\n\u003c/p\u003e",
          "module": "Util.VariableSet",
          "name": "updateSet",
          "package": "uni-util",
          "signature": "VariableSet x -\u003e VariableSetUpdate x -\u003e IO ()",
          "source": "src/Util-VariableSet.html#updateSet",
          "type": "function"
        },
        "index": {
          "description": "Update variable set in some way",
          "hierarchy": "Util VariableSet",
          "module": "Util.VariableSet",
          "name": "updateSet",
          "normalized": "VariableSet a-\u003eVariableSetUpdate a-\u003eIO()",
          "package": "uni-util",
          "partial": "Set",
          "signature": "VariableSet x-\u003eVariableSetUpdate x-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSet.html#v:updateSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBlockers are used to implement variable set sources which can be\n turned on and off.  They are indexed by a BlockID.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.VariableSetBlocker",
          "name": "VariableSetBlocker",
          "package": "uni-util",
          "source": "src/Util-VariableSetBlocker.html",
          "type": "module"
        },
        "index": {
          "description": "Blockers are used to implement variable set sources which can be turned on and off They are indexed by BlockID",
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "VariableSetBlocker",
          "package": "uni-util",
          "partial": "Variable Set Blocker",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "BlockID",
          "package": "uni-util",
          "source": "src/Util-VariableSetBlocker.html#BlockID",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "BlockID",
          "package": "uni-util",
          "partial": "Block ID",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#t:BlockID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "Blocker",
          "package": "uni-util",
          "source": "src/Util-VariableSetBlocker.html#Blocker",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "Blocker",
          "package": "uni-util",
          "partial": "Blocker",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#t:Blocker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "blockVariableSet",
          "package": "uni-util",
          "signature": "Blocker a -\u003e BlockID -\u003e IO (VariableSetSource a)",
          "source": "src/Util-VariableSetBlocker.html#blockVariableSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "blockVariableSet",
          "normalized": "Blocker a-\u003eBlockID-\u003eIO(VariableSetSource a)",
          "package": "uni-util",
          "partial": "Variable Set",
          "signature": "Blocker a-\u003eBlockID-\u003eIO(VariableSetSource a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#v:blockVariableSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "closeBlocker",
          "package": "uni-util",
          "signature": "Blocker a -\u003e BlockID -\u003e IO ()",
          "source": "src/Util-VariableSetBlocker.html#closeBlocker",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "closeBlocker",
          "normalized": "Blocker a-\u003eBlockID-\u003eIO()",
          "package": "uni-util",
          "partial": "Blocker",
          "signature": "Blocker a-\u003eBlockID-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#v:closeBlocker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "newBlockID",
          "package": "uni-util",
          "signature": "IO BlockID",
          "source": "src/Util-VariableSetBlocker.html#newBlockID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "newBlockID",
          "package": "uni-util",
          "partial": "Block ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#v:newBlockID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "newBlocker",
          "package": "uni-util",
          "signature": "VariableSetSource a -\u003e IO (Blocker a)",
          "source": "src/Util-VariableSetBlocker.html#newBlocker",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "newBlocker",
          "normalized": "VariableSetSource a-\u003eIO(Blocker a)",
          "package": "uni-util",
          "partial": "Blocker",
          "signature": "VariableSetSource a-\u003eIO(Blocker a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#v:newBlocker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "newBlockerWithPreAction",
          "package": "uni-util",
          "signature": "VariableSetSource a -\u003e ([a] -\u003e IO ()) -\u003e IO (Blocker a)",
          "source": "src/Util-VariableSetBlocker.html#newBlockerWithPreAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "newBlockerWithPreAction",
          "normalized": "VariableSetSource a-\u003e([a]-\u003eIO())-\u003eIO(Blocker a)",
          "package": "uni-util",
          "partial": "Blocker With Pre Action",
          "signature": "VariableSetSource a-\u003e([a]-\u003eIO())-\u003eIO(Blocker a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#v:newBlockerWithPreAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VariableSetBlocker",
          "name": "openBlocker",
          "package": "uni-util",
          "signature": "Blocker a -\u003e BlockID -\u003e IO ()",
          "source": "src/Util-VariableSetBlocker.html#openBlocker",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VariableSetBlocker",
          "module": "Util.VariableSetBlocker",
          "name": "openBlocker",
          "normalized": "Blocker a-\u003eBlockID-\u003eIO()",
          "package": "uni-util",
          "partial": "Blocker",
          "signature": "Blocker a-\u003eBlockID-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VariableSetBlocker.html#v:openBlocker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VisitedSet",
          "name": "VisitedSet",
          "package": "uni-util",
          "source": "src/Util-VisitedSet.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Util VisitedSet",
          "module": "Util.VisitedSet",
          "name": "VisitedSet",
          "package": "uni-util",
          "partial": "Visited Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VisitedSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VisitedSet",
          "name": "VisitedSet",
          "package": "uni-util",
          "source": "src/Util-VisitedSet.html#VisitedSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util VisitedSet",
          "module": "Util.VisitedSet",
          "name": "VisitedSet",
          "package": "uni-util",
          "partial": "Visited Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VisitedSet.html#t:VisitedSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VisitedSet",
          "name": "isVisited",
          "package": "uni-util",
          "signature": "VisitedSet key -\u003e key -\u003e IO Bool",
          "source": "src/Util-VisitedSet.html#isVisited",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VisitedSet",
          "module": "Util.VisitedSet",
          "name": "isVisited",
          "normalized": "VisitedSet a-\u003ea-\u003eIO Bool",
          "package": "uni-util",
          "partial": "Visited",
          "signature": "VisitedSet key-\u003ekey-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VisitedSet.html#v:isVisited"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.VisitedSet",
          "name": "newVisitedSet",
          "package": "uni-util",
          "signature": "IO (VisitedSet key)",
          "source": "src/Util-VisitedSet.html#newVisitedSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util VisitedSet",
          "module": "Util.VisitedSet",
          "name": "newVisitedSet",
          "package": "uni-util",
          "partial": "Visited Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-VisitedSet.html#v:newVisitedSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe WBFiles module is in charge of decoding information from the command\n line and making it available to the rest of the UniForM workbench.\n\u003c/p\u003e\u003cp\u003eAll UniForM options have names beginning with \u003ca\u003e--uni\u003c/a\u003e.  It is hoped\n that this won't be a problem for programs that use the UniForM workbench.\n However, if it is, the function\n    setAlternateArgs\n should be called before any of the functions in the UniForM workbench,\n as this will prevent the program arguments being read by UniForM.\n\u003c/p\u003e\u003cp\u003eThe\n \u003ccode\u003e\n    --uni\n \u003c/code\u003e\n option prints a help message, as do other options beginning with\n --uni which are not understood.\n\u003c/p\u003e\u003cp\u003eThe\n \u003ccode\u003e\n    --uni-parameters\n \u003c/code\u003e\n option prints the parameters at the given position on the command\n line.\n\u003c/p\u003e\u003cp\u003eThe\n \u003ccode\u003e\n    --uni-version\n \u003c/code\u003e\n option prints the current version of uni.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\n --uni-\u003ca\u003eoption-name\u003c/a\u003e:\u003ca\u003eoption-value\u003c/a\u003e\n \u003c/code\u003e\n or equivalently\n \u003ccode\u003e\n --uni-\u003ca\u003eoption-name\u003c/a\u003e=\u003ca\u003eoption-value\u003c/a\u003e\n \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eAll options can also be overridden by environment variables.\n The environment variable corresponding to \u003ca\u003eoption-name\u003c/a\u003e has the\n name \u003ccode\u003eUNI\u003ca\u003eOPTION-NAME\u003c/a\u003e\u003c/code\u003e\n where \u003ccode\u003e\u003ca\u003eOPTION-NAME\u003c/a\u003e\u003c/code\u003e is the capitalised name of the option.\n\u003c/p\u003e\u003cp\u003eThe default set of options are as follows:\n\u003c/p\u003e\u003cp\u003eoption-name   explanation\n\u003c/p\u003e\u003cp\u003ewish          The filename of the wish program\n daVinci       The filename of daVinci\n gnuclient     The filename of gnuclient\n editor        A command to execute the text editor.\n               This uses the CommandStringSub format, with defined\n               substitutions %F =\u003e where the file is to be found and\n               %N =\u003e what the user-visible name (for example, of the\n               buffer) should be.\n top           The directory in which UniForM is installed\n\u003c/p\u003e\u003cp\u003edaVinciIcons  The directory containing daVinci icons\n\u003c/p\u003e\u003cp\u003eworkingDir    The directory used for temporary files.\n\u003c/p\u003e\u003cp\u003eserver        The host name of the server\n user          The user-id to use connecting to the server\n password      The password to use connecting to the server\n port          The port on the server to connect to\n xmlPort       The port for the XML server (which has a different default)\n\u003c/p\u003e\u003cp\u003edebug         Where Debug.debug messages should go\n\u003c/p\u003e\u003cp\u003eserverDir     Where Server stores its files\n serverId      The unique identifier of the server.\n               Since this really does have to be globally unique,\n               it is by default constructed from a combination\n               of the machine's hostname and the server port.\n               You had better not change it unless you know what\n               you are doing.\n\u003c/p\u003e\u003cp\u003eMMiSSDTD      Location of DTD file for MMiSS.\n\u003c/p\u003e\u003cp\u003ehosts         Location of hosts file.\n\u003c/p\u003e\u003cp\u003etoolTimeOut   Time-out waiting for responses from a tool when\n               it starts up and we are doing challenge-response\n               verification.\n windowsTick   (Windows only) time in microseconds we wait between\n               polling Wish.\n\u003c/p\u003e\u003cp\u003eThe options wish, daVinci, daVinciIcons, top\n should all be set automatically by the configure procedure.\n The configure procedure constructs a variable DEFAULTOPTIONS\n and writes it into the file default_options.c.\n\u003c/p\u003e\u003cp\u003ereturns a string with exactly the same syntax as the command line\n so a typical one might be\n    \u003ccode\u003e\n    --uni-wish:\u003cem\u003eusr\u003c/em\u003ebin\u003cem\u003ewish --uni-daVinci:\u003c/em\u003eusr\u003cem\u003ebin\u003c/em\u003edaVinci\n    \u003c/code\u003e\n    ... (and so on)\n\u003c/p\u003e\u003cp\u003eHowever one difference is that options which are not understood\n in the default_options string are simply ignored.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Util.WBFiles",
          "name": "WBFiles",
          "package": "uni-util",
          "source": "src/Util-WBFiles.html",
          "type": "module"
        },
        "index": {
          "description": "The WBFiles module is in charge of decoding information from the command line and making it available to the rest of the UniForM workbench All UniForM options have names beginning with uni It is hoped that this won be problem for programs that use the UniForM workbench However if it is the function setAlternateArgs should be called before any of the functions in the UniForM workbench as this will prevent the program arguments being read by UniForM The uni option prints help message as do other options beginning with uni which are not understood The uni-parameters option prints the parameters at the given position on the command line The uni-version option prints the current version of uni uni option-name option-value or equivalently uni option-name option-value All options can also be overridden by environment variables The environment variable corresponding to option-name has the name UNI OPTION-NAME where OPTION-NAME is the capitalised name of the option The default set of options are as follows option-name explanation wish The filename of the wish program daVinci The filename of daVinci gnuclient The filename of gnuclient editor command to execute the text editor This uses the CommandStringSub format with defined substitutions where the file is to be found and what the user-visible name for example of the buffer should be top The directory in which UniForM is installed daVinciIcons The directory containing daVinci icons workingDir The directory used for temporary files server The host name of the server user The user-id to use connecting to the server password The password to use connecting to the server port The port on the server to connect to xmlPort The port for the XML server which has different default debug Where Debug.debug messages should go serverDir Where Server stores its files serverId The unique identifier of the server Since this really does have to be globally unique it is by default constructed from combination of the machine hostname and the server port You had better not change it unless you know what you are doing MMiSSDTD Location of DTD file for MMiSS hosts Location of hosts file toolTimeOut Time-out waiting for responses from tool when it starts up and we are doing challenge-response verification windowsTick Windows only time in microseconds we wait between polling Wish The options wish daVinci daVinciIcons top should all be set automatically by the configure procedure The configure procedure constructs variable DEFAULTOPTIONS and writes it into the file default options.c returns string with exactly the same syntax as the command line so typical one might be uni-wish usr bin wish uni-daVinci usr bin daVinci and so on However one difference is that options which are not understood in the default options string are simply ignored",
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "WBFiles",
          "package": "uni-util",
          "partial": "WBFiles",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "ArgType",
          "package": "uni-util",
          "source": "src/Util-WBFiles.html#ArgType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "ArgType",
          "package": "uni-util",
          "partial": "Arg Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#t:ArgType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "ArgValue",
          "package": "uni-util",
          "source": "src/Util-WBFiles.html#ArgValue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "ArgValue",
          "package": "uni-util",
          "partial": "Arg Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#t:ArgValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "ProgramArgument",
          "package": "uni-util",
          "source": "src/Util-WBFiles.html#ProgramArgument",
          "type": "data"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "ProgramArgument",
          "package": "uni-util",
          "partial": "Program Argument",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#t:ProgramArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "BOOL",
          "package": "uni-util",
          "signature": "BOOL",
          "source": "src/Util-WBFiles.html#ArgType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "BOOL",
          "package": "uni-util",
          "partial": "BOOL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:BOOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "BoolValue",
          "package": "uni-util",
          "signature": "BoolValue Bool",
          "source": "src/Util-WBFiles.html#ArgValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "BoolValue",
          "package": "uni-util",
          "partial": "Bool Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:BoolValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "INT",
          "package": "uni-util",
          "signature": "INT",
          "source": "src/Util-WBFiles.html#ArgType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "INT",
          "package": "uni-util",
          "partial": "INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:INT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "IntValue",
          "package": "uni-util",
          "signature": "IntValue Int",
          "source": "src/Util-WBFiles.html#ArgValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "IntValue",
          "package": "uni-util",
          "partial": "Int Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:IntValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "ProgramArgument",
          "package": "uni-util",
          "signature": "ProgramArgument",
          "source": "src/Util-WBFiles.html#ProgramArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "ProgramArgument",
          "package": "uni-util",
          "partial": "Program Argument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:ProgramArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "STRING",
          "package": "uni-util",
          "signature": "STRING",
          "source": "src/Util-WBFiles.html#ArgType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "STRING",
          "package": "uni-util",
          "partial": "STRING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:STRING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "StringValue",
          "package": "uni-util",
          "signature": "StringValue String",
          "source": "src/Util-WBFiles.html#ArgValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "StringValue",
          "package": "uni-util",
          "partial": "String Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:StringValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "argType",
          "package": "uni-util",
          "signature": "ArgType",
          "source": "src/Util-WBFiles.html#ProgramArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "argType",
          "package": "uni-util",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:argType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "defaultVal",
          "package": "uni-util",
          "signature": "Maybe ArgValue",
          "source": "src/Util-WBFiles.html#ProgramArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "defaultVal",
          "package": "uni-util",
          "partial": "Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:defaultVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getArgBool",
          "package": "uni-util",
          "signature": "String -\u003e IO (Maybe Bool)",
          "source": "src/Util-WBFiles.html#getArgBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getArgBool",
          "normalized": "String-\u003eIO(Maybe Bool)",
          "package": "uni-util",
          "partial": "Arg Bool",
          "signature": "String-\u003eIO(Maybe Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getArgBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getArgInt",
          "package": "uni-util",
          "signature": "String -\u003e IO (Maybe Int)",
          "source": "src/Util-WBFiles.html#getArgInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getArgInt",
          "normalized": "String-\u003eIO(Maybe Int)",
          "package": "uni-util",
          "partial": "Arg Int",
          "signature": "String-\u003eIO(Maybe Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getArgInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getArgString",
          "package": "uni-util",
          "signature": "String -\u003e IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getArgString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getArgString",
          "normalized": "String-\u003eIO(Maybe String)",
          "package": "uni-util",
          "partial": "Arg String",
          "signature": "String-\u003eIO(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getArgString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getCouplingDir",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getCouplingDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getCouplingDir",
          "package": "uni-util",
          "partial": "Coupling Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getCouplingDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getCouplingPort",
          "package": "uni-util",
          "signature": "IO Int",
          "source": "src/Util-WBFiles.html#getCouplingPort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getCouplingPort",
          "package": "uni-util",
          "partial": "Coupling Port",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getCouplingPort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getDaVinciIcons",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getDaVinciIcons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getDaVinciIcons",
          "package": "uni-util",
          "partial": "Da Vinci Icons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getDaVinciIcons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getDaVinciPath",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getDaVinciPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getDaVinciPath",
          "package": "uni-util",
          "partial": "Da Vinci Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getDaVinciPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getDebugFileName",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getDebugFileName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getDebugFileName",
          "package": "uni-util",
          "partial": "Debug File Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getDebugFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getEditorString",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getEditorString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getEditorString",
          "package": "uni-util",
          "partial": "Editor String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getEditorString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getGnuClientPath",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getGnuClientPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getGnuClientPath",
          "package": "uni-util",
          "partial": "Gnu Client Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getGnuClientPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getHosts",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getHosts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getHosts",
          "package": "uni-util",
          "partial": "Hosts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getHosts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getMMiSSAPIDTD",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getMMiSSAPIDTD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getMMiSSAPIDTD",
          "package": "uni-util",
          "partial": "MMi SSAPIDTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getMMiSSAPIDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getMMiSSDTD",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getMMiSSDTD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getMMiSSDTD",
          "package": "uni-util",
          "partial": "MMi SSDTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getMMiSSDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getPassword",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getPassword",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getPassword",
          "package": "uni-util",
          "partial": "Password",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getPassword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getPort",
          "package": "uni-util",
          "signature": "IO Int",
          "source": "src/Util-WBFiles.html#getPort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getPort",
          "package": "uni-util",
          "partial": "Port",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getPort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getServer",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getServer",
          "package": "uni-util",
          "partial": "Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getServerDir",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getServerDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getServerDir",
          "package": "uni-util",
          "partial": "Server Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getServerDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getServerFile",
          "package": "uni-util",
          "signature": "String -\u003e IO String",
          "source": "src/Util-WBFiles.html#getServerFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getServerFile",
          "normalized": "String-\u003eIO String",
          "package": "uni-util",
          "partial": "Server File",
          "signature": "String-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getServerFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getServerId",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getServerId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getServerId",
          "package": "uni-util",
          "partial": "Server Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getServerId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getTOP",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getTOP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getTOP",
          "package": "uni-util",
          "partial": "TOP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getTOP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a path within the top directory.\n\u003c/p\u003e",
          "module": "Util.WBFiles",
          "name": "getTOPPath",
          "package": "uni-util",
          "signature": "[String] -\u003e IO String",
          "source": "src/Util-WBFiles.html#getTOPPath",
          "type": "function"
        },
        "index": {
          "description": "Get path within the top directory",
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getTOPPath",
          "normalized": "[String]-\u003eIO String",
          "package": "uni-util",
          "partial": "TOPPath",
          "signature": "[String]-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getTOPPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getToolTimeOut",
          "package": "uni-util",
          "signature": "IO Int",
          "source": "src/Util-WBFiles.html#getToolTimeOut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getToolTimeOut",
          "package": "uni-util",
          "partial": "Tool Time Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getToolTimeOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getUser",
          "package": "uni-util",
          "signature": "IO (Maybe String)",
          "source": "src/Util-WBFiles.html#getUser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getUser",
          "package": "uni-util",
          "partial": "User",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getUser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getWishPath",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getWishPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getWishPath",
          "package": "uni-util",
          "partial": "Wish Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getWishPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getWorkingDir",
          "package": "uni-util",
          "signature": "IO String",
          "source": "src/Util-WBFiles.html#getWorkingDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getWorkingDir",
          "package": "uni-util",
          "partial": "Working Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getWorkingDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "getXMLPort",
          "package": "uni-util",
          "signature": "IO Int",
          "source": "src/Util-WBFiles.html#getXMLPort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "getXMLPort",
          "package": "uni-util",
          "partial": "XMLPort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:getXMLPort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "optionHelp",
          "package": "uni-util",
          "signature": "String",
          "source": "src/Util-WBFiles.html#ProgramArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "optionHelp",
          "package": "uni-util",
          "partial": "Help",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:optionHelp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "optionName",
          "package": "uni-util",
          "signature": "String",
          "source": "src/Util-WBFiles.html#ProgramArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "optionName",
          "package": "uni-util",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:optionName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "parseArguments",
          "package": "uni-util",
          "signature": "IO ()",
          "source": "src/Util-WBFiles.html#parseArguments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "parseArguments",
          "normalized": "IO()",
          "package": "uni-util",
          "partial": "Arguments",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:parseArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "parseArgumentsRequiring",
          "package": "uni-util",
          "signature": "[String] -\u003e IO ()",
          "source": "src/Util-WBFiles.html#parseArgumentsRequiring",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "parseArgumentsRequiring",
          "normalized": "[String]-\u003eIO()",
          "package": "uni-util",
          "partial": "Arguments Requiring",
          "signature": "[String]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:parseArgumentsRequiring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "parseTheseArguments",
          "package": "uni-util",
          "signature": "[ProgramArgument] -\u003e IO ()",
          "source": "src/Util-WBFiles.html#parseTheseArguments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "parseTheseArguments",
          "normalized": "[ProgramArgument]-\u003eIO()",
          "package": "uni-util",
          "partial": "These Arguments",
          "signature": "[ProgramArgument]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:parseTheseArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "parseTheseArgumentsRequiring",
          "package": "uni-util",
          "signature": "[ProgramArgument] -\u003e [String] -\u003e IO ()",
          "source": "src/Util-WBFiles.html#parseTheseArgumentsRequiring",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "parseTheseArgumentsRequiring",
          "normalized": "[ProgramArgument]-\u003e[String]-\u003eIO()",
          "package": "uni-util",
          "partial": "These Arguments Requiring",
          "signature": "[ProgramArgument]-\u003e[String]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:parseTheseArgumentsRequiring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "setAlternateArgs",
          "package": "uni-util",
          "signature": "[String] -\u003e IO ()",
          "source": "src/Util-WBFiles.html#setAlternateArgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "setAlternateArgs",
          "normalized": "[String]-\u003eIO()",
          "package": "uni-util",
          "partial": "Alternate Args",
          "signature": "[String]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:setAlternateArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Util.WBFiles",
          "name": "usualProgramArguments",
          "package": "uni-util",
          "signature": "[ProgramArgument]",
          "source": "src/Util-WBFiles.html#usualProgramArguments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Util WBFiles",
          "module": "Util.WBFiles",
          "name": "usualProgramArguments",
          "normalized": "[ProgramArgument]",
          "package": "uni-util",
          "partial": "Program Arguments",
          "signature": "[ProgramArgument]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uni-util/docs/Util-WBFiles.html#v:usualProgramArguments"
      }
    }
  ]
]