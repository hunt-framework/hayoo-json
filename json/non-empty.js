[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "non-empty"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Empty",
          "name": "Empty",
          "package": "non-empty",
          "source": "src/Data-Empty.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Empty",
          "module": "Data.Empty",
          "name": "Empty",
          "package": "non-empty",
          "partial": "Empty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Empty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Empty",
          "name": "T",
          "package": "non-empty",
          "source": "src/Data-Empty.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Empty",
          "module": "Data.Empty",
          "name": "T",
          "package": "non-empty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Empty.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Empty",
          "name": "Cons",
          "package": "non-empty",
          "signature": "Cons",
          "source": "src/Data-Empty.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Empty",
          "module": "Data.Empty",
          "name": "Cons",
          "package": "non-empty",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Empty.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Class",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Class",
          "package": "non-empty",
          "partial": "Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Append",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Append",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Append",
          "package": "non-empty",
          "partial": "Append",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Arbitrary",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Arbitrary",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Arbitrary",
          "package": "non-empty",
          "partial": "Arbitrary",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Arbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Cons",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Cons",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Cons",
          "package": "non-empty",
          "partial": "Cons",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Empty",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Empty",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Empty",
          "package": "non-empty",
          "partial": "Empty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Repeat",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Repeat",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Repeat",
          "package": "non-empty",
          "partial": "Repeat",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Reverse",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Reverse",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Reverse",
          "package": "non-empty",
          "partial": "Reverse",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Show",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Show",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Show",
          "package": "non-empty",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Show"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Singleton",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Singleton",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Singleton",
          "package": "non-empty",
          "partial": "Singleton",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "Sort",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Sort",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Sort",
          "package": "non-empty",
          "partial": "Sort",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "View",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#View",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "View",
          "package": "non-empty",
          "partial": "View",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:View"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt must hold:\n\u003c/p\u003e\u003cpre\u003e fmap f xs\n    = zipWith (\\x _ -\u003e f x) xs xs\n    = zipWith (\\_ x -\u003e f x) xs xs\n\u003c/pre\u003e",
          "module": "Data.NonEmpty.Class",
          "name": "Zip",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Class.html#Zip",
          "type": "class"
        },
        "index": {
          "description": "It must hold fmap xs zipWith xs xs zipWith xs xs",
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "Zip",
          "package": "non-empty",
          "partial": "Zip",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#t:Zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "append",
          "package": "non-empty",
          "signature": "f a -\u003e f a -\u003e f a",
          "source": "src/Data-NonEmpty-Class.html#append",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "append",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "non-empty",
          "signature": "f a-\u003ef a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "arbitrary",
          "package": "non-empty",
          "signature": "Gen (f a)",
          "source": "src/Data-NonEmpty-Class.html#arbitrary",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "arbitrary",
          "package": "non-empty",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:arbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "cons",
          "package": "non-empty",
          "signature": "a -\u003e f a -\u003e f a",
          "source": "src/Data-NonEmpty-Class.html#cons",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "cons",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "non-empty",
          "signature": "a-\u003ef a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "empty",
          "package": "non-empty",
          "signature": "f a",
          "source": "src/Data-NonEmpty-Class.html#empty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "empty",
          "package": "non-empty",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a container with as many copies as possible of a given value.\n   That is, for a container with fixed size \u003ccode\u003en\u003c/code\u003e,\n   the call \u003ccode\u003erepeat x\u003c/code\u003e will generate a container with \u003ccode\u003en\u003c/code\u003e copies of \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.NonEmpty.Class",
          "name": "repeat",
          "package": "non-empty",
          "signature": "a -\u003e f a",
          "source": "src/Data-NonEmpty-Class.html#repeat",
          "type": "method"
        },
        "index": {
          "description": "Create container with as many copies as possible of given value That is for container with fixed size the call repeat will generate container with copies of",
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "repeat",
          "normalized": "a-\u003eb a",
          "package": "non-empty",
          "signature": "a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "reverse",
          "package": "non-empty",
          "signature": "f a -\u003e f a",
          "source": "src/Data-NonEmpty-Class.html#reverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "reverse",
          "normalized": "a b-\u003ea b",
          "package": "non-empty",
          "signature": "f a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "showsPrec",
          "package": "non-empty",
          "signature": "Int -\u003e f a -\u003e ShowS",
          "source": "src/Data-NonEmpty-Class.html#showsPrec",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "showsPrec",
          "normalized": "Int-\u003ea b-\u003eShowS",
          "package": "non-empty",
          "partial": "Prec",
          "signature": "Int-\u003ef a-\u003eShowS",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:showsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "shrink",
          "package": "non-empty",
          "signature": "f a -\u003e [f a]",
          "source": "src/Data-NonEmpty-Class.html#shrink",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "shrink",
          "normalized": "a b-\u003e[a b]",
          "package": "non-empty",
          "signature": "f a-\u003e[f a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:shrink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "singleton",
          "package": "non-empty",
          "signature": "a -\u003e f a",
          "source": "src/Data-NonEmpty-Class.html#singleton",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "singleton",
          "normalized": "a-\u003eb a",
          "package": "non-empty",
          "signature": "a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "sort",
          "package": "non-empty",
          "signature": "f a -\u003e f a",
          "source": "src/Data-NonEmpty-Class.html#sort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "sort",
          "normalized": "a b-\u003ea b",
          "package": "non-empty",
          "signature": "f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "sortBy",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e f a -\u003e f a",
          "source": "src/Data-NonEmpty-Class.html#sortBy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "sortBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eb a",
          "package": "non-empty",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ef a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:sortBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "viewL",
          "package": "non-empty",
          "signature": "f a -\u003e Maybe (a, f a)",
          "source": "src/Data-NonEmpty-Class.html#viewL",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "viewL",
          "normalized": "a b-\u003eMaybe(b,a b)",
          "package": "non-empty",
          "signature": "f a-\u003eMaybe(a,f a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:viewL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "zip",
          "package": "non-empty",
          "signature": "f a -\u003e f b -\u003e f (a, b)",
          "source": "src/Data-NonEmpty-Class.html#zip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "zip",
          "normalized": "a b-\u003ea c-\u003ea(b,c)",
          "package": "non-empty",
          "signature": "f a-\u003ef b-\u003ef(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Class",
          "name": "zipWith",
          "package": "non-empty",
          "signature": "(a -\u003e b -\u003e c) -\u003e f a -\u003e f b -\u003e f c",
          "source": "src/Data-NonEmpty-Class.html#zipWith",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty Class",
          "module": "Data.NonEmpty.Class",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "non-empty",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003ef a-\u003ef b-\u003ef c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Class.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions that cope both with plain and non-empty structures.\n\u003c/p\u003e\u003cp\u003eIf there are two versions of a function,\nwhere one works on fixed-length lists,\nthe place the fixed-length list variant to NonEmpty\nand the other one here.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.NonEmpty.Mixed",
          "name": "Mixed",
          "package": "non-empty",
          "source": "src/Data-NonEmpty-Mixed.html",
          "type": "module"
        },
        "index": {
          "description": "Functions that cope both with plain and non-empty structures If there are two versions of function where one works on fixed-length lists the place the fixed-length list variant to NonEmpty and the other one here",
          "hierarchy": "Data NonEmpty Mixed",
          "module": "Data.NonEmpty.Mixed",
          "name": "Mixed",
          "package": "non-empty",
          "partial": "Mixed",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Mixed",
          "name": "appendLeft",
          "package": "non-empty",
          "signature": "[a] -\u003e f a -\u003e f a",
          "source": "src/Data-NonEmpty-Mixed.html#appendLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Mixed",
          "module": "Data.NonEmpty.Mixed",
          "name": "appendLeft",
          "normalized": "[a]-\u003eb a-\u003eb a",
          "package": "non-empty",
          "partial": "Left",
          "signature": "[a]-\u003ef a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:appendLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Mixed",
          "name": "groupBy",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e f a -\u003e [T [] a]",
          "source": "src/Data-NonEmpty-Mixed.html#groupBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Mixed",
          "module": "Data.NonEmpty.Mixed",
          "name": "groupBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eb a-\u003e[T[]a]",
          "package": "non-empty",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003ef a-\u003e[T[]a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:groupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Mixed",
          "name": "inits",
          "package": "non-empty",
          "signature": "f a -\u003e T [] (f a)",
          "source": "src/Data-NonEmpty-Mixed.html#inits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Mixed",
          "module": "Data.NonEmpty.Mixed",
          "name": "inits",
          "normalized": "a b-\u003eT[](a b)",
          "package": "non-empty",
          "signature": "f a-\u003eT[](f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:inits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Mixed",
          "name": "mapAdjacent",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e b) -\u003e T f a -\u003e f b",
          "source": "src/Data-NonEmpty-Mixed.html#mapAdjacent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Mixed",
          "module": "Data.NonEmpty.Mixed",
          "name": "mapAdjacent",
          "normalized": "(a-\u003ea-\u003eb)-\u003eT c a-\u003ec b",
          "package": "non-empty",
          "partial": "Adjacent",
          "signature": "(a-\u003ea-\u003eb)-\u003eT f a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:mapAdjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Mixed",
          "name": "segmentBefore",
          "package": "non-empty",
          "signature": "(a -\u003e Bool) -\u003e f a -\u003e ([a], [T [] a])",
          "source": "src/Data-NonEmpty-Mixed.html#segmentBefore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Mixed",
          "module": "Data.NonEmpty.Mixed",
          "name": "segmentBefore",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003e([a],[T[]a])",
          "package": "non-empty",
          "partial": "Before",
          "signature": "(a-\u003eBool)-\u003ef a-\u003e([a],[T[]a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:segmentBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty.Mixed",
          "name": "tails",
          "package": "non-empty",
          "signature": "f a -\u003e T [] (f a)",
          "source": "src/Data-NonEmpty-Mixed.html#tails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty Mixed",
          "module": "Data.NonEmpty.Mixed",
          "name": "tails",
          "normalized": "a b-\u003eT[](a b)",
          "package": "non-empty",
          "signature": "f a-\u003eT[](f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Mixed.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "NonEmpty",
          "package": "non-empty",
          "source": "src/Data-NonEmpty.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "NonEmpty",
          "package": "non-empty",
          "partial": "Non Empty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "Insert",
          "package": "non-empty",
          "source": "src/Data-NonEmptyPrivate.html#Insert",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "Insert",
          "package": "non-empty",
          "partial": "Insert",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:Insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "RemoveEach",
          "package": "non-empty",
          "source": "src/Data-NonEmptyPrivate.html#RemoveEach",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "RemoveEach",
          "package": "non-empty",
          "partial": "Remove Each",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:RemoveEach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e can be used for many kinds of list-like structures\nwith restrictions on the size.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eT [] a\u003c/code\u003e is a lazy list containing at least one element.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT (T []) a\u003c/code\u003e is a lazy list containing at least two elements.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT Vector a\u003c/code\u003e is a vector with at least one element.\n  You may also use unboxed vectors but the first element will be stored in a box\n  and you will not be able to use many functions from this module.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT Maybe a\u003c/code\u003e is a list that contains one or two elements.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eMaybe\u003c/code\u003e is isomorphic to \u003ccode\u003eOptional Empty\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT Empty a\u003c/code\u003e is a list that contains exactly one element.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eT (T Empty) a\u003c/code\u003e is a list that contains exactly two elements.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eOptional (T Empty) a\u003c/code\u003e is a list that contains zero or two elements.\n\u003c/li\u003e\u003cli\u003e You can create a list type for every finite set of allowed list length\n  by nesting Optional and NonEmpty constructors.\n  If list length \u003ccode\u003en\u003c/code\u003e is allowed, then place \u003ccode\u003eOptional\u003c/code\u003e at depth \u003ccode\u003en\u003c/code\u003e,\n  if it is disallowed then place \u003ccode\u003eNonEmpty\u003c/code\u003e.\n  The maximm length is marked by \u003ccode\u003eEmpty\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Data.NonEmpty",
          "name": "T",
          "package": "non-empty",
          "source": "src/Data-NonEmptyPrivate.html#T",
          "type": "data"
        },
        "index": {
          "description": "The type can be used for many kinds of list-like structures with restrictions on the size is lazy list containing at least one element is lazy list containing at least two elements Vector is vector with at least one element You may also use unboxed vectors but the first element will be stored in box and you will not be able to use many functions from this module Maybe is list that contains one or two elements Maybe is isomorphic to Optional Empty Empty is list that contains exactly one element Empty is list that contains exactly two elements Optional Empty is list that contains zero or two elements You can create list type for every finite set of allowed list length by nesting Optional and NonEmpty constructors If list length is allowed then place Optional at depth if it is disallowed then place NonEmpty The maximm length is marked by Empty",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "T",
          "package": "non-empty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "Tails",
          "package": "non-empty",
          "source": "src/Data-NonEmptyPrivate.html#Tails",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "Tails",
          "package": "non-empty",
          "partial": "Tails",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#t:Tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "(!:)",
          "package": "non-empty",
          "signature": "a -\u003e f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#%21%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "(!:) !:",
          "normalized": "a-\u003eb a-\u003eT b a",
          "package": "non-empty",
          "signature": "a-\u003ef a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:-33-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "Cons",
          "package": "non-empty",
          "signature": "Cons",
          "source": "src/Data-NonEmptyPrivate.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "Cons",
          "package": "non-empty",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "append",
          "package": "non-empty",
          "signature": "T f a -\u003e T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "append",
          "normalized": "T a b-\u003eT a b-\u003eT a b",
          "package": "non-empty",
          "signature": "T f a-\u003eT f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "appendLeft",
          "package": "non-empty",
          "signature": "f a -\u003e T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#appendLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "appendLeft",
          "normalized": "a b-\u003eT a b-\u003eT a b",
          "package": "non-empty",
          "partial": "Left",
          "signature": "f a-\u003eT f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:appendLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "appendRight",
          "package": "non-empty",
          "signature": "T f a -\u003e f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#appendRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "appendRight",
          "normalized": "T a b-\u003ea b-\u003eT a b",
          "package": "non-empty",
          "partial": "Right",
          "signature": "T f a-\u003ef a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:appendRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e without the \u003ccode\u003e\u003ca\u003eEmpty\u003c/a\u003e\u003c/code\u003e constraint\nthat is needed for \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "apply",
          "package": "non-empty",
          "signature": "T f (a -\u003e b) -\u003e T f a -\u003e T f b",
          "source": "src/Data-NonEmptyPrivate.html#apply",
          "type": "function"
        },
        "index": {
          "description": "Implementation of without the Empty constraint that is needed for pure",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "apply",
          "normalized": "T a(b-\u003ec)-\u003eT a b-\u003eT a c",
          "package": "non-empty",
          "signature": "T f(a-\u003eb)-\u003eT f a-\u003eT f b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e without the \u003ccode\u003e\u003ca\u003eEmpty\u003c/a\u003e\u003c/code\u003e constraint\nthat is needed for \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "bind",
          "package": "non-empty",
          "signature": "T f a -\u003e (a -\u003e T f b) -\u003e T f b",
          "source": "src/Data-NonEmptyPrivate.html#bind",
          "type": "function"
        },
        "index": {
          "description": "Implementation of without the Empty constraint that is needed for return",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "bind",
          "normalized": "T a b-\u003e(b-\u003eT a c)-\u003eT a c",
          "package": "non-empty",
          "signature": "T f a-\u003e(a-\u003eT f b)-\u003eT f b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "cons",
          "package": "non-empty",
          "signature": "a -\u003e T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "cons",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "non-empty",
          "signature": "a-\u003eT f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneric variants:\n\u003ccode\u003e\u003ca\u003ecycle\u003c/a\u003e\u003c/code\u003e or better \u003ccode\u003eSemigroup.cycle\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "cycle",
          "package": "non-empty",
          "signature": "T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#cycle",
          "type": "function"
        },
        "index": {
          "description": "generic variants cycle or better Semigroup.cycle",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "cycle",
          "normalized": "T a b-\u003eT a b",
          "package": "non-empty",
          "signature": "T f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "fetch",
          "package": "non-empty",
          "signature": "f a -\u003e Maybe (T f a)",
          "source": "src/Data-NonEmptyPrivate.html#fetch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "fetch",
          "normalized": "a b-\u003eMaybe(T a b)",
          "package": "non-empty",
          "signature": "f a-\u003eMaybe(T f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:fetch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "flatten",
          "package": "non-empty",
          "signature": "T f a -\u003e f a",
          "source": "src/Data-NonEmptyPrivate.html#flatten",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "flatten",
          "normalized": "T a b-\u003ea b",
          "package": "non-empty",
          "signature": "T f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:flatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "foldl1",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e a) -\u003e T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#foldl1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "foldl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT b a-\u003ea",
          "package": "non-empty",
          "signature": "(a-\u003ea-\u003ea)-\u003eT f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:foldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForce immediate generation of Cons.\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "force",
          "package": "non-empty",
          "signature": "T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#force",
          "type": "function"
        },
        "index": {
          "description": "Force immediate generation of Cons",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "force",
          "normalized": "T a b-\u003eT a b",
          "package": "non-empty",
          "signature": "T f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:force"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "head",
          "package": "non-empty",
          "signature": "a",
          "source": "src/Data-NonEmptyPrivate.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "head",
          "package": "non-empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "init",
          "package": "non-empty",
          "signature": "T f a -\u003e f a",
          "source": "src/Data-NonEmptyPrivate.html#init",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "init",
          "normalized": "T a b-\u003ea b",
          "package": "non-empty",
          "signature": "T f a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert an element into an ordered list while preserving the order.\nThe first element of the resulting list is returned individually.\nWe need this for construction of a non-empty list.\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "insert",
          "package": "non-empty",
          "signature": "a -\u003e f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#insert",
          "type": "function"
        },
        "index": {
          "description": "Insert an element into an ordered list while preserving the order The first element of the resulting list is returned individually We need this for construction of non-empty list",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "insert",
          "normalized": "a-\u003eb a-\u003eT b a",
          "package": "non-empty",
          "signature": "a-\u003ef a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "insertBy",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e a -\u003e f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#insertBy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "insertBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003eb a-\u003eT b a",
          "package": "non-empty",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003ef a-\u003eT f a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:insertBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "last",
          "package": "non-empty",
          "signature": "T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#last",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "last",
          "normalized": "T a b-\u003eb",
          "package": "non-empty",
          "signature": "T f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "mapAdjacent",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e b) -\u003e T f a -\u003e f b",
          "source": "src/Data-NonEmptyPrivate.html#mapAdjacent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "mapAdjacent",
          "normalized": "(a-\u003ea-\u003eb)-\u003eT c a-\u003ec b",
          "package": "non-empty",
          "partial": "Adjacent",
          "signature": "(a-\u003ea-\u003eb)-\u003eT f a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:mapAdjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "mapHead",
          "package": "non-empty",
          "signature": "(a -\u003e a) -\u003e T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#mapHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "mapHead",
          "normalized": "(a-\u003ea)-\u003eT b a-\u003eT b a",
          "package": "non-empty",
          "partial": "Head",
          "signature": "(a-\u003ea)-\u003eT f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:mapHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "mapTail",
          "package": "non-empty",
          "signature": "(f a -\u003e g a) -\u003e T f a -\u003e T g a",
          "source": "src/Data-NonEmptyPrivate.html#mapTail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "mapTail",
          "normalized": "(a b-\u003ec b)-\u003eT a b-\u003eT c b",
          "package": "non-empty",
          "partial": "Tail",
          "signature": "(f a-\u003eg a)-\u003eT f a-\u003eT g a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:mapTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaximum is a total function\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "maximum",
          "package": "non-empty",
          "signature": "T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#maximum",
          "type": "function"
        },
        "index": {
          "description": "maximum is total function",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "maximum",
          "normalized": "T a b-\u003eb",
          "package": "non-empty",
          "signature": "T f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:maximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaximumBy is a total function\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "maximumBy",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#maximumBy",
          "type": "function"
        },
        "index": {
          "description": "maximumBy is total function",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "maximumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eT b a-\u003ea",
          "package": "non-empty",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003eT f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:maximumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaximumKey is a total function\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "maximumKey",
          "package": "non-empty",
          "signature": "(a -\u003e b) -\u003e T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#maximumKey",
          "type": "function"
        },
        "index": {
          "description": "maximumKey is total function",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "maximumKey",
          "normalized": "(a-\u003eb)-\u003eT c a-\u003ea",
          "package": "non-empty",
          "partial": "Key",
          "signature": "(a-\u003eb)-\u003eT f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:maximumKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eminimum is a total function\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "minimum",
          "package": "non-empty",
          "signature": "T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#minimum",
          "type": "function"
        },
        "index": {
          "description": "minimum is total function",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "minimum",
          "normalized": "T a b-\u003eb",
          "package": "non-empty",
          "signature": "T f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:minimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eminimumBy is a total function\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "minimumBy",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#minimumBy",
          "type": "function"
        },
        "index": {
          "description": "minimumBy is total function",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "minimumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eT b a-\u003ea",
          "package": "non-empty",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003eT f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:minimumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eminimumKey is a total function\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "minimumKey",
          "package": "non-empty",
          "signature": "(a -\u003e b) -\u003e T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#minimumKey",
          "type": "function"
        },
        "index": {
          "description": "minimumKey is total function",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "minimumKey",
          "normalized": "(a-\u003eb)-\u003eT c a-\u003ea",
          "package": "non-empty",
          "partial": "Key",
          "signature": "(a-\u003eb)-\u003eT f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:minimumKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eproduct does not need a one for initialization\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "product",
          "package": "non-empty",
          "signature": "T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#product",
          "type": "function"
        },
        "index": {
          "description": "product does not need one for initialization",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "product",
          "normalized": "T a b-\u003eb",
          "package": "non-empty",
          "signature": "T f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "removeEach",
          "package": "non-empty",
          "signature": "T f a -\u003e T f (a, f a)",
          "source": "src/Data-NonEmptyPrivate.html#removeEach",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "removeEach",
          "normalized": "T a b-\u003eT a(b,a b)",
          "package": "non-empty",
          "partial": "Each",
          "signature": "T f a-\u003eT f(a,f a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:removeEach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "reverse",
          "package": "non-empty",
          "signature": "T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#reverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "reverse",
          "normalized": "T a b-\u003eT a b",
          "package": "non-empty",
          "signature": "T f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "scanl",
          "package": "non-empty",
          "signature": "(b -\u003e a -\u003e b) -\u003e b -\u003e f a -\u003e T f b",
          "source": "src/Data-NonEmptyPrivate.html#scanl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "scanl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003eT c a",
          "package": "non-empty",
          "signature": "(b-\u003ea-\u003eb)-\u003eb-\u003ef a-\u003eT f b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:scanl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "scanr",
          "package": "non-empty",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e f a -\u003e T f b",
          "source": "src/Data-NonEmptyPrivate.html#scanr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "scanr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eT c b",
          "package": "non-empty",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ef a-\u003eT f b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:scanr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "singleton",
          "package": "non-empty",
          "signature": "a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "singleton",
          "normalized": "a-\u003eT b a",
          "package": "non-empty",
          "signature": "a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "sort",
          "package": "non-empty",
          "signature": "T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#sort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "sort",
          "normalized": "T a b-\u003eT a b",
          "package": "non-empty",
          "signature": "T f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf you nest too many non-empty lists\nthen the efficient merge-sort (linear-logarithmic runtime)\nwill degenerate to an inefficient insert-sort (quadratic runtime).\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "sortBy",
          "package": "non-empty",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e T f a -\u003e T f a",
          "source": "src/Data-NonEmptyPrivate.html#sortBy",
          "type": "function"
        },
        "index": {
          "description": "If you nest too many non-empty lists then the efficient merge-sort linear-logarithmic runtime will degenerate to an inefficient insert-sort quadratic runtime",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "sortBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eT b a-\u003eT b a",
          "package": "non-empty",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003eT f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:sortBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esum does not need a zero for initialization\n\u003c/p\u003e",
          "module": "Data.NonEmpty",
          "name": "sum",
          "package": "non-empty",
          "signature": "T f a -\u003e a",
          "source": "src/Data-NonEmptyPrivate.html#sum",
          "type": "function"
        },
        "index": {
          "description": "sum does not need zero for initialization",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "sum",
          "normalized": "T a b-\u003eb",
          "package": "non-empty",
          "signature": "T f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "tail",
          "package": "non-empty",
          "signature": "f a",
          "source": "src/Data-NonEmptyPrivate.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "tail",
          "package": "non-empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "tails",
          "package": "non-empty",
          "signature": "f a -\u003e T f (g a)",
          "source": "src/Data-NonEmptyPrivate.html#tails",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "tails",
          "normalized": "a b-\u003eT a(c b)",
          "package": "non-empty",
          "signature": "f a-\u003eT f(g a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "toList",
          "package": "non-empty",
          "signature": "T f a -\u003e [a]",
          "source": "src/Data-NonEmptyPrivate.html#toList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "toList",
          "normalized": "T a b-\u003e[b]",
          "package": "non-empty",
          "partial": "List",
          "signature": "T f a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlways returns a rectangular list\nby clipping all dimensions to the shortest slice.\nBe aware that \u003ccode\u003etranspose [] == repeat []\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.NonEmpty\",\"Data.Zip\"]",
          "name": "transposeClip",
          "package": "non-empty",
          "signature": "f (g a) -\u003e g (f a)",
          "source": "src/Data-Zip.html#transposeClip",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:transposeClip\",\"http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#v:transposeClip\"]"
        },
        "index": {
          "description": "Always returns rectangular list by clipping all dimensions to the shortest slice Be aware that transpose repeat",
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "transposeClip",
          "normalized": "a(b c)-\u003eb(a c)",
          "package": "non-empty",
          "partial": "Clip",
          "signature": "f(g a)-\u003eg(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:transposeClip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.NonEmpty",
          "name": "zipWith",
          "package": "non-empty",
          "signature": "(a -\u003e b -\u003e c) -\u003e T f a -\u003e T f b -\u003e T f c",
          "source": "src/Data-NonEmptyPrivate.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data NonEmpty",
          "module": "Data.NonEmpty",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT d a-\u003eT d b-\u003eT d c",
          "package": "non-empty",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eT f a-\u003eT f b-\u003eT f c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Optional",
          "name": "Optional",
          "package": "non-empty",
          "source": "src/Data-Optional.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Optional",
          "module": "Data.Optional",
          "name": "Optional",
          "package": "non-empty",
          "partial": "Optional",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Optional",
          "name": "T",
          "package": "non-empty",
          "source": "src/Data-Optional.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Optional",
          "module": "Data.Optional",
          "name": "T",
          "package": "non-empty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Optional",
          "name": "(?:)",
          "package": "non-empty",
          "signature": "a -\u003e f a -\u003e T f a",
          "source": "src/Data-Optional.html#%3F%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Optional",
          "module": "Data.Optional",
          "name": "(?:) ?:",
          "normalized": "a-\u003eb a-\u003eT b a",
          "package": "non-empty",
          "signature": "a-\u003ef a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:-63-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Optional",
          "name": "Cons",
          "package": "non-empty",
          "signature": "Cons a (f a)",
          "source": "src/Data-Optional.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Optional",
          "module": "Data.Optional",
          "name": "Cons",
          "package": "non-empty",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Optional",
          "name": "Nil",
          "package": "non-empty",
          "signature": "Nil",
          "source": "src/Data-Optional.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Optional",
          "module": "Data.Optional",
          "name": "Nil",
          "package": "non-empty",
          "partial": "Nil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:Nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Optional",
          "name": "fromEmpty",
          "package": "non-empty",
          "signature": "T a -\u003e T f a",
          "source": "src/Data-Optional.html#fromEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Optional",
          "module": "Data.Optional",
          "name": "fromEmpty",
          "normalized": "T a-\u003eT b a",
          "package": "non-empty",
          "partial": "Empty",
          "signature": "T a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:fromEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Optional",
          "name": "fromNonEmpty",
          "package": "non-empty",
          "signature": "T f a -\u003e T f a",
          "source": "src/Data-Optional.html#fromNonEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Optional",
          "module": "Data.Optional",
          "name": "fromNonEmpty",
          "normalized": "T a b-\u003eT a b",
          "package": "non-empty",
          "partial": "Non Empty",
          "signature": "T f a-\u003eT f a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Optional.html#v:fromNonEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Zip",
          "name": "Zip",
          "package": "non-empty",
          "source": "src/Data-Zip.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Zip",
          "module": "Data.Zip",
          "name": "Zip",
          "package": "non-empty",
          "partial": "Zip",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap a container such that its Applicative instance is based on zip.\n\u003c/p\u003e",
          "module": "Data.Zip",
          "name": "T",
          "package": "non-empty",
          "source": "src/Data-Zip.html#T",
          "type": "newtype"
        },
        "index": {
          "description": "Wrap container such that its Applicative instance is based on zip",
          "hierarchy": "Data Zip",
          "module": "Data.Zip",
          "name": "T",
          "package": "non-empty",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Zip",
          "name": "Cons",
          "package": "non-empty",
          "signature": "Cons",
          "source": "src/Data-Zip.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Zip",
          "module": "Data.Zip",
          "name": "Cons",
          "package": "non-empty",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Zip",
          "name": "decons",
          "package": "non-empty",
          "signature": "f a",
          "source": "src/Data-Zip.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Zip",
          "module": "Data.Zip",
          "name": "decons",
          "package": "non-empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/non-empty/docs/Data-Zip.html#v:decons"
      }
    }
  ]
]