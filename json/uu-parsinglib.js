[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "uu-parsinglib"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains basic instances for the class interface described in the \u003ca\u003eText.ParserCombinators.UU.Core\u003c/a\u003e module.\n   It demonstates how to construct and maintain a state during parsing. In the state we store error messages, \n   positional information and the actual input that is being parsed.\n   Unless you have very specific wishes the module can be used as such. \n   Since we make use of the \u003ca\u003eData.ListLike\u003c/a\u003e interface a wide variety of input structures can be handled.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "BasicInstances",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains basic instances for the class interface described in the Text.ParserCombinators.UU.Core module It demonstates how to construct and maintain state during parsing In the state we store error messages positional information and the actual input that is being parsed Unless you have very specific wishes the module can be used as such Since we make use of the Data.ListLike interface wide variety of input structures can be handled",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "BasicInstances",
          "package": "uu-parsinglib",
          "partial": "Basic Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data type \u003ccode\u003e\u003ca\u003eError\u003c/a\u003e\u003c/code\u003e describes the various kinds of errors which can be generated by the instances in this module\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Error",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Error",
          "type": "data"
        },
        "index": {
          "description": "The data type Error describes the various kinds of errors which can be generated by the instances in this module",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Error",
          "package": "uu-parsinglib",
          "partial": "Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe \u003ccode\u003eString\u003c/code\u003e describes what is being inserted, the \u003ccode\u003ea\u003c/code\u003e parameter the value which is to be inserted and the \u003ccode\u003ecost\u003c/code\u003e the prices to be paid.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Insertion",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Insertion",
          "type": "data"
        },
        "index": {
          "description": "the String describes what is being inserted the parameter the value which is to be inserted and the cost the prices to be paid",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Insertion",
          "package": "uu-parsinglib",
          "partial": "Insertion",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:Insertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe input state may maintain a location which can be used in generating error messages. \n   Since we do not want to fix our input to be just a \u003ccode\u003eString\u003c/code\u003e we provide an interface\n   which can be used to advance this location by passing  information about the part recognised. This function is typically\n   called in the \u003ccode\u003esplitState\u003c/code\u003e functions.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "IsLocationUpdatedBy",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#IsLocationUpdatedBy",
          "type": "class"
        },
        "index": {
          "description": "The input state may maintain location which can be used in generating error messages Since we do not want to fix our input to be just String we provide an interface which can be used to advance this location by passing information about the part recognised This function is typically called in the splitState functions",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "IsLocationUpdatedBy",
          "package": "uu-parsinglib",
          "partial": "Is Location Updated By",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:IsLocationUpdatedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineCol",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#LineCol",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineCol",
          "package": "uu-parsinglib",
          "partial": "Line Col",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:LineCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineColPos",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#LineColPos",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineColPos",
          "package": "uu-parsinglib",
          "partial": "Line Col Pos",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:LineColPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e is a parser that is prepared to accept \u003ca\u003eData.Listlike\u003c/a\u003e input; hence we can deal with \u003ccode\u003eString\u003c/code\u003e's, \u003ccode\u003eByteString\u003c/code\u003e's, etc.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Parser",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Parser",
          "type": "type"
        },
        "index": {
          "description": "Parser is parser that is prepared to accept Data.Listlike input hence we can deal with String ByteString etc",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Parser",
          "package": "uu-parsinglib",
          "partial": "Parser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eParserTrafo\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e maps a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e onto a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eParser\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "ParserTrafo",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#ParserTrafo",
          "type": "type"
        },
        "index": {
          "description": "ParserTrafo maps Parser onto Parser",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "ParserTrafo",
          "package": "uu-parsinglib",
          "partial": "Parser Trafo",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:ParserTrafo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data type \u003ccode\u003e\u003ca\u003eStr\u003c/a\u003e\u003c/code\u003e holds the input data to be parsed, the current location, the error messages generated \n   and whether it is ok to delete elements from the input. Since an insert/delete action is \n   the same as a delete/insert action we try to avoid the first one. \n   So: no deletes after an insert.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Str",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Str",
          "type": "data"
        },
        "index": {
          "description": "The data type Str holds the input data to be parsed the current location the error messages generated and whether it is ok to delete elements from the input Since an insert delete action is the same as delete insert action we try to avoid the first one So no deletes after an insert",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Str",
          "package": "uu-parsinglib",
          "partial": "Str",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#t:Str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e was deleted at \u003ccode\u003epos\u003c/code\u003e-ition, where we expected  \u003ccode\u003eStrings\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Deleted",
          "package": "uu-parsinglib",
          "signature": "Deleted String pos Strings",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Error",
          "type": "function"
        },
        "index": {
          "description": "String was deleted at pos ition where we expected Strings",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Deleted",
          "package": "uu-parsinglib",
          "partial": "Deleted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:Deleted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe unconsumed part of the input was deleted\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "DeletedAtEnd",
          "package": "uu-parsinglib",
          "signature": "DeletedAtEnd String",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Error",
          "type": "function"
        },
        "index": {
          "description": "the unconsumed part of the input was deleted",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "DeletedAtEnd",
          "package": "uu-parsinglib",
          "partial": "Deleted At End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:DeletedAtEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e was inserted at \u003ccode\u003epos\u003c/code\u003e-ition, where we expected  \u003ccode\u003eStrings\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Inserted",
          "package": "uu-parsinglib",
          "signature": "Inserted String pos Strings",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Error",
          "type": "function"
        },
        "index": {
          "description": "String was inserted at pos ition where we expected Strings",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Inserted",
          "package": "uu-parsinglib",
          "partial": "Inserted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:Inserted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Insertion",
          "package": "uu-parsinglib",
          "signature": "Insertion String a Cost",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Insertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Insertion",
          "package": "uu-parsinglib",
          "partial": "Insertion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:Insertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineCol",
          "package": "uu-parsinglib",
          "signature": "LineCol !Int !Int",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#LineCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineCol",
          "package": "uu-parsinglib",
          "partial": "Line Col",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:LineCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineColPos",
          "package": "uu-parsinglib",
          "signature": "LineColPos !Int !Int !Int",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#LineColPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "LineColPos",
          "package": "uu-parsinglib",
          "partial": "Line Col Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:LineColPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor future use\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Replaced",
          "package": "uu-parsinglib",
          "signature": "Replaced String String pos Strings",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Error",
          "type": "function"
        },
        "index": {
          "description": "for future use",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Replaced",
          "package": "uu-parsinglib",
          "partial": "Replaced",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:Replaced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Str",
          "package": "uu-parsinglib",
          "signature": "Str",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Str",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "Str",
          "package": "uu-parsinglib",
          "partial": "Str",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:Str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecreateStr\u003c/a\u003e\u003c/code\u003e initialises the input stream with the input data and the initial position. There are no error messages yet.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "createStr",
          "package": "uu-parsinglib",
          "signature": "loc -\u003e s -\u003e Str a s loc",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#createStr",
          "type": "function"
        },
        "index": {
          "description": "createStr initialises the input stream with the input data and the initial position There are no error messages yet",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "createStr",
          "normalized": "a-\u003eb-\u003eStr c b a",
          "package": "uu-parsinglib",
          "partial": "Str",
          "signature": "loc-\u003es-\u003eStr a s loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:createStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewe want to avoid deletions after insertions\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "deleteOk",
          "package": "uu-parsinglib",
          "signature": "Bool",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Str",
          "type": "function"
        },
        "index": {
          "description": "we want to avoid deletions after insertions",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "deleteOk",
          "package": "uu-parsinglib",
          "partial": "Ok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:deleteOk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe unconsumed part of the input\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "input",
          "package": "uu-parsinglib",
          "signature": "s",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Str",
          "type": "function"
        },
        "index": {
          "description": "the unconsumed part of the input",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "input",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe accumulated error messages\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "msgs",
          "package": "uu-parsinglib",
          "signature": "[Error loc]",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Str",
          "type": "function"
        },
        "index": {
          "description": "the accumulated error messages",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "msgs",
          "normalized": "[Error a]",
          "package": "uu-parsinglib",
          "signature": "[Error loc]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:msgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epMunch\u003c/a\u003e\u003c/code\u003e recognises the longest prefix of the input for which the passed predicate holds.  \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pMunch",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e Bool) -\u003e P (Str a state loc) [a]",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pMunch",
          "type": "function"
        },
        "index": {
          "description": "pMunch recognises the longest prefix of the input for which the passed predicate holds",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pMunch",
          "normalized": "(a-\u003eBool)-\u003eP(Str a b c)[a]",
          "package": "uu-parsinglib",
          "partial": "Munch",
          "signature": "(a-\u003eBool)-\u003eP(Str a state loc)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pMunch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epMunchL\u003c/a\u003e\u003c/code\u003e recognises the longest prefix of the input for which the passed predicate holds. The message parameter is used when tracing has been switched on. \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pMunchL",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e Bool) -\u003e String -\u003e P (Str a state loc) [a]",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pMunchL",
          "type": "function"
        },
        "index": {
          "description": "pMunchL recognises the longest prefix of the input for which the passed predicate holds The message parameter is used when tracing has been switched on",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pMunchL",
          "normalized": "(a-\u003eBool)-\u003eString-\u003eP(Str a b c)[a]",
          "package": "uu-parsinglib",
          "partial": "Munch",
          "signature": "(a-\u003eBool)-\u003eString-\u003eP(Str a state loc)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pMunchL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epRange\u003c/a\u003e\u003c/code\u003e uses the information from the bounds to compute the \u003ccode\u003e\u003ca\u003eInsertion\u003c/a\u003e\u003c/code\u003e information.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pRange",
          "package": "uu-parsinglib",
          "signature": "(a, a) -\u003e P (Str a state loc) a",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pRange",
          "type": "function"
        },
        "index": {
          "description": "pRange uses the information from the bounds to compute the Insertion information",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pRange",
          "normalized": "(a,a)-\u003eP(Str a b c)a",
          "package": "uu-parsinglib",
          "partial": "Range",
          "signature": "(a,a)-\u003eP(Str a state loc)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epRangeInsert\u003c/a\u003e\u003c/code\u003e recognises an element between a lower and an upper bound. Furthermore it can be specified what element \n   is to be inserted in case such an element is not at the head of the input.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pRangeInsert",
          "package": "uu-parsinglib",
          "signature": "(a, a) -\u003e Insertion a -\u003e P (Str a state loc) a",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pRangeInsert",
          "type": "function"
        },
        "index": {
          "description": "pRangeInsert recognises an element between lower and an upper bound Furthermore it can be specified what element is to be inserted in case such an element is not at the head of the input",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pRangeInsert",
          "normalized": "(a,a)-\u003eInsertion a-\u003eP(Str a b c)a",
          "package": "uu-parsinglib",
          "partial": "Range Insert",
          "signature": "(a,a)-\u003eInsertion a-\u003eP(Str a state loc)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pRangeInsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epSatisfy\u003c/a\u003e\u003c/code\u003e  describes and elementary parsing step. Its first parameter check whether the head element of the input can be recognised, \n    and the second parameter how to proceed in case an element recognised by this parser is absent, \n    and parsing may proceed by pretending such an element was present in the input anayway.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pSatisfy",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e Bool) -\u003e Insertion a -\u003e P (Str a state loc) a",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pSatisfy",
          "type": "function"
        },
        "index": {
          "description": "pSatisfy describes and elementary parsing step Its first parameter check whether the head element of the input can be recognised and the second parameter how to proceed in case an element recognised by this parser is absent and parsing may proceed by pretending such an element was present in the input anayway",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pSatisfy",
          "normalized": "(a-\u003eBool)-\u003eInsertion a-\u003eP(Str a b c)a",
          "package": "uu-parsinglib",
          "partial": "Satisfy",
          "signature": "(a-\u003eBool)-\u003eInsertion a-\u003eP(Str a state loc)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pSatisfy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epSym\u003c/a\u003e\u003c/code\u003e recognises a specific element. Furthermore it can be specified what element. Information about \u003ccode\u003e\u003ca\u003eInsertion\u003c/a\u003e\u003c/code\u003e is derived from the parameter.\n   is to be inserted in case such an element is not at the head of the input.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pSym",
          "package": "uu-parsinglib",
          "signature": "a -\u003e P (Str a state loc) a",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pSym",
          "type": "function"
        },
        "index": {
          "description": "pSym recognises specific element Furthermore it can be specified what element Information about Insertion is derived from the parameter is to be inserted in case such an element is not at the head of the input",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pSym",
          "normalized": "a-\u003eP(Str a b c)a",
          "package": "uu-parsinglib",
          "partial": "Sym",
          "signature": "a-\u003eP(Str a state loc)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epSymInsert\u003c/a\u003e\u003c/code\u003e recognises a specific element. Furthermore it can be specified what element \n   is to be inserted in case such an element is not at the head of the input.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pSymInsert",
          "package": "uu-parsinglib",
          "signature": "a -\u003e Insertion a -\u003e P (Str a state loc) a",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pSymInsert",
          "type": "function"
        },
        "index": {
          "description": "pSymInsert recognises specific element Furthermore it can be specified what element is to be inserted in case such an element is not at the head of the input",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pSymInsert",
          "normalized": "a-\u003eInsertion a-\u003eP(Str a b c)a",
          "package": "uu-parsinglib",
          "partial": "Sym Insert",
          "signature": "a-\u003eInsertion a-\u003eP(Str a state loc)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pSymInsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pToken",
          "package": "uu-parsinglib",
          "signature": "[a] -\u003e P (Str a state loc) [a]",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pToken",
          "normalized": "[a]-\u003eP(Str a b c)[a]",
          "package": "uu-parsinglib",
          "partial": "Token",
          "signature": "[a]-\u003eP(Str a state loc)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epTokenCost\u003c/a\u003e\u003c/code\u003e succeeds if its parameter is a prefix of the input. \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pTokenCost",
          "package": "uu-parsinglib",
          "signature": "[a] -\u003e Int -\u003e P (Str a state loc) [a]",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#pTokenCost",
          "type": "function"
        },
        "index": {
          "description": "pTokenCost succeeds if its parameter is prefix of the input",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pTokenCost",
          "normalized": "[a]-\u003eInt-\u003eP(Str a b c)[a]",
          "package": "uu-parsinglib",
          "partial": "Token Cost",
          "signature": "[a]-\u003eInt-\u003eP(Str a state loc)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pTokenCost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe current input position  \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pos",
          "package": "uu-parsinglib",
          "signature": "loc",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#Str",
          "type": "function"
        },
        "index": {
          "description": "the current input position",
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "pos",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:pos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "show_expecting",
          "package": "uu-parsinglib",
          "signature": "pos -\u003e [String] -\u003e String",
          "source": "src/Text-ParserCombinators-UU-BasicInstances.html#show_expecting",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU BasicInstances",
          "module": "Text.ParserCombinators.UU.BasicInstances",
          "name": "show_expecting",
          "normalized": "a-\u003e[String]-\u003eString",
          "package": "uu-parsinglib",
          "signature": "pos-\u003e[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-BasicInstances.html#v:show_expecting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module just contains the CHANGELOG\n\u003c/p\u003e\u003cp\u003eVersion 2.7.4.1\n\u003c/p\u003e\u003cp\u003eexport of constructors of LineCol and LineColPos \n export of pState from Core.hs\n\u003c/p\u003e\u003cp\u003eVersion 2.7.4\n\u003c/p\u003e\u003cp\u003eMade some abstract interpretation a bit simpler, and made comparing lengths less trict. Some times the abstrcat interpretation would \u003cimg src=\"loop\"/\u003e\n\u003c/p\u003e\u003cp\u003eVersion 2.7.3.3\n\u003c/p\u003e\u003cp\u003ecured a problem with loosing priority information when applying semantic actions, final cure is probably to intrduce a real priority mechanism\n replace pSpaces with more efficient version using pMunch\n\u003c/p\u003e\u003cp\u003eVersion 2.7.3.2\n\u003c/p\u003e\u003cp\u003emade TypeOperators explicit as required by GHC 7.4\n\u003c/p\u003e\u003cp\u003eVersion 2.7.3.1\n\u003c/p\u003e\u003cp\u003efixed corner case when combining to failing parsers during grammar analysis; probably useful error message is now gone\n\u003c/p\u003e\u003cp\u003eVersion 2.7.3\n\u003c/p\u003e\u003cp\u003ebetter behaviour when inserting at end of input\n\u003c/p\u003e\u003cp\u003eVersion 2.7.2.2\n\u003c/p\u003e\u003cp\u003efixed the case where the left hand operand of  \u003ca\u003e\u003c||\u003c/a\u003e starts with a monadic bind\n\u003c/p\u003e\u003cp\u003eVersion 2.7.2.1\n\u003c/p\u003e\u003cp\u003eremoved a left-over from debugging\n\u003c/p\u003e\u003cp\u003eVersion 2.7.2\n\u003c/p\u003e\u003cp\u003efixed a subtle bug in the merging parsers caused by name shielding ;-{{\n\u003c/p\u003e\u003cp\u003eVersion 2.7.1.1\n\u003c/p\u003e\u003cp\u003eadded \u003ccode\u003epDoubleStr\u003c/code\u003e to the export list of the Utils module\n\u003c/p\u003e\u003cp\u003eVersion 2.7.1\n\u003c/p\u003e\u003cp\u003efixed a subtle black hole which prevented computation of lengths!! You should upgrade.\n\u003c/p\u003e\u003cp\u003eVersion 2.7.0.2\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Some types were reformulated to compile correctly with ghc 6.12.3\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.7.0.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Typos fixed in Haddock documentation\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.7.0\n\u003c/p\u003e\u003cp\u003eImprovement: change of error correction at end of \u003ccode\u003eamb\u003c/code\u003e combinator, so lookahead is better taken into account\n\u003c/p\u003e\u003cp\u003eRelatively large change:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Change to \u003ca\u003eData.ListLike\u003c/a\u003e inputs, so a general stream input structure is possible; hence we can now parse all instances of \u003ccode\u003eListLike\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e Simplified and generalised implementation of merging\u003cem\u003epermuting parsers; any kind of parsers can now be merged\u003c/em\u003epermuted\n\u003c/li\u003e\u003cli\u003e New class \u003ccode\u003eIsParser\u003c/code\u003e was introduced which captures the basic properties of our parsers\n\u003c/li\u003e\u003cli\u003e Inclusion of a module \u003ca\u003eText.ParserCombinators.UU.Utils\u003c/a\u003e containing common \u003ccode\u003eChar\u003c/code\u003e based parsers\n\u003c/li\u003e\u003cli\u003e Removal of the class \u003ccode\u003eProvides\u003c/code\u003e, and replaced by separate \u003ccode\u003epSym\u003c/code\u003e, \u003ccode\u003epSatisfy\u003c/code\u003e and \u003ccode\u003epRange\u003c/code\u003e; \n        this may require some rwriting of  existing parsers. Readbaility is supposed to improve from that. \n        Types become simpler. For an example see the module \u003ca\u003eText.ParserCombinators.UU.Utils\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e Included a Demo directory, with a modules for demonstrating normal parsers and one aimed at merging parsers\n\u003c/li\u003e\u003cli\u003e Added the module \u003ca\u003eText.ParserCombinaors.UU.Idioms\u003c/a\u003e, which contains specialised version for the idiomatic notation; it infers the\n        sequental composition operators from the types of the operands; \u003ccode\u003eString\u003c/code\u003e-s and \u003ccode\u003eChar\u003c/code\u003e-s are not supposed to contribute to the result,\n        function parameters are lifted using \u003ccode\u003epure\u003c/code\u003e, and normal parsers are composed with \u003ccode\u003e\u003c*\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e Many other small changes, mostly upwards compatible or invisible (code cleanup)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.6.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Changed the input to a \u003ccode\u003eStream\u003c/code\u003e interface to handle different kind of inputs like \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eData.Text\u003c/code\u003e and \u003ccode\u003eData.ByteString\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e To update old code to the new interface you should add\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e import Text.ParserCombinators.UU.BasicInstances.String\n\u003c/pre\u003e\u003cp\u003ein the file header and change\n\u003c/p\u003e\u003cpre\u003e listToStr inp (0,0)\n\u003c/pre\u003e\u003cp\u003eto\n\u003c/p\u003e\u003cpre\u003e createStr inp\n\u003c/pre\u003e\u003cul\u003e\u003cli\u003e To work with other inputs, import \u003ca\u003eText.ParserCombinators.UU.BasicInstances.List\u003c/a\u003e, \u003ca\u003eText.ParserCombinators.UU.BasicInstances.Text\u003c/a\u003e, \n        \u003ca\u003eText.ParserCombinators.UU.BasicInstances.ByteString\u003c/a\u003e or \u003ca\u003eText.ParserCombinators.UU.BasicInstances.ByteString.Lazy\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.6.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  replaced references to modules with references in the new library scheme\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.6\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  added a special version of \u003c|\u003e (called \u003ccode\u003e\u003c-|-\u003e\u003c/code\u003e) in \u003ccode\u003eExtAlternative\u003c/code\u003e which does not compare the \n          length of the parsers; to be used in permutations\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.5.2\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  type signatures were added to make Haddock happy\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.5.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  type signatures were added to make the library GHC 7 ready.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.5\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  preference is given to earlier accept steps in order to avoid infinite insertions in case of otherwise equivalent repair strategies\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.4.2\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e fixed small problem in \u003ca\u003e?\u003c/a\u003e so it gets its chance to do its work\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.4.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e added a \u003ccode\u003epSem\u003c/code\u003e which makes it possible to tell how certain components of merged structures\n        are to be combined before exposing all elements to the outer sem: \n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e  run ( (,)  `pMerge` ( ((++) `pSem` (pMany pa \u003c||\u003e pMany pb)) \u003c||\u003e pOne pc))  \"abcaaab\"\n\n  Result: ([\"a\",\"a\",\"a\",\"a\",\"b\",\"b\"],\"c\")\n\u003c/pre\u003e\u003cul\u003e\u003cli\u003e added a \u003ccode\u003epMergedSep\u003c/code\u003e, which allows you to specify a separator between two merged elements\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e  run ((((,), pc) `pMergeSep` (pMany pa \u003c||\u003e pMany pb))) \"acbcacbc\"\n\n Result: ([\"a\",\"a\",\"a\"],[\"b\",\"b\"])\n Correcting steps: \n    Inserted 'a' at position (0,8) expecting one of ['b', 'a']\n\u003c/pre\u003e\u003cp\u003eVersion 2.5.4\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e made the merging combinators more general introducing  \u003ccode\u003epAtMost\u003c/code\u003e, \u003ccode\u003epBetween\u003c/code\u003e and  \u003ccode\u003epAtLeast\u003c/code\u003e; examples are extended; see \u003ccode\u003e\u003ccode\u003edemo_merge\u003c/code\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e used CPP in order to generate demo's easily\n\u003c/li\u003e\u003cli\u003e fixed a bug which made \u003ccode\u003epPos\u003c/code\u003e ambiguous\n\u003c/li\u003e\u003cli\u003e modified haddock stuff\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.3\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e fixed a bug in the implementation; some functions were too strict, due to introduction of nice abstractions!!\n\u003c/li\u003e\u003cli\u003e added a generalisation of \u003ccode\u003e\u003ccode\u003epMerged\u003c/code\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003epPerms\u003c/code\u003e\u003c/code\u003e to the module \u003ca\u003eText.ParserCombinators.UU.Derived\u003c/a\u003e;  the old modules have been marked as deprecated\n\u003c/li\u003e\u003cli\u003e removed the old module Text.ParserCombinators.UU.Parsing, which was already marged as deprecated\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.2\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e fixed a bug in sequential composition with a pure as left hand side\n\u003c/li\u003e\u003cli\u003e added an experimental \u003ccode\u003epMerge\u003c/code\u003e, which combines the featurs of \u003ccode\u003epPerms\u003c/code\u003e and \u003ccode\u003epMerged\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.1.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Now with the correct Changelog\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.1 \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e added the permutation parsers from the old uulib\n\u003c/li\u003e\u003cli\u003e extended the abstract interpretation so more soundness checks can be done statically\n\u003c/li\u003e\u003cli\u003e everything seems to work; in case of problems please report and go back to 2.5.0\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.5.0\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e generalised over the position in the input; now it is easy to maintain e.g. (line,column) info as shown in the \u003ca\u003eExamples.hs\u003c/a\u003e file\n\u003c/li\u003e\u003cli\u003e added needed instances for \u003ccode\u003eString\u003c/code\u003e s as input in \u003ca\u003eBasicInstances.hs\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e fixed a bug in pMunch where a Step was inserted with 0 progress, leading to infinite insertions \n\u003c/li\u003e\u003cli\u003e added Haddock beautifications\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.4.5\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e added the function \u003ccode\u003e\u003ccode\u003epPos\u003c/code\u003e\u003c/code\u003e for retreiving the current input position\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.4.4\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e solved a mistake which had crept in in the greedy choice\n\u003c/li\u003e\u003cli\u003e added priority for \u003ccode\u003e\u003ccode\u003e\u003c\u003c|\u003e\u003c/code\u003e\u003c/code\u003e which had disappeared\n\u003c/li\u003e\u003cli\u003e added an example how to achieve the effect of manytill from parsec\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.4.3\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e removed the classes IsParser and Symbol, which made the code shorter and more H98-alike\n         last version with dynamic error message computation\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.4.2\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e fixed dependency in cabal file to base \u003e=4.2\n\u003c/li\u003e\u003cli\u003e moved definition of \u003c$ to the class Functor and removed the class ExtApplicative \n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.4.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e added the module Text.ParserCombinators.Merge for recognizing alternating sequences\n\u003c/li\u003e\u003cli\u003e made \u003ccode\u003eP st\u003c/code\u003e an instance of \u003ccode\u003e\u003ccode\u003eMonadPlus\u003c/code\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e beautified Haddock documentation\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.4.0\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e contains abstract interpretation for minimal lenth, in order to avoid recursive correction process\n\u003c/li\u003e\u003cli\u003e idem for checking that no repeating combinators like pList are parameterised with possibly empty parsers\n\u003c/li\u003e\u003cli\u003e lots of Haddcock doumentation in \u003ca\u003eText.ParserCombinators.UU.Examples\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.3.4\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e removed dependecies on impredictaive types, preparing for next GHC version\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.3.3\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e added \u003ccode\u003epMunch\u003c/code\u003e which takes a Boolean function, and recognises the longest prefix for which the symbols match the predicate\n\u003c/li\u003e\u003cli\u003e added the infix operator with piority 2 \u003ccode\u003e\u003c?\u003e :: P state a -\u003e String -\u003e P state a\u003c/code\u003e which replaces the list of expected symbols\n         in error message by its right argument String\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.3.2\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e added microsteps, which can be used to disambiguate\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersion 2.3.1\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e fix for GHC 6.12, because of change in GADT definition handling\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersions above 2.2:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e  make use of type families\n\u003c/li\u003e\u003cli\u003e  contain a module with many list-based derived combinators\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eVersions above 2.1: \n       * based on Control.Applicative\n\u003c/p\u003e\u003cp\u003eNote that the basic parser interface will probably not change much when we add more features, but the calling conventions\n    of the outer parser and the class structure upon which the parametrisation is based may change slightly\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.CHANGELOG",
          "name": "CHANGELOG",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-CHANGELOG.html",
          "type": "module"
        },
        "index": {
          "description": "This module just contains the CHANGELOG Version export of constructors of LineCol and LineColPos export of pState from Core.hs Version Made some abstract interpretation bit simpler and made comparing lengths less trict Some times the abstrcat interpretation would Version cured problem with loosing priority information when applying semantic actions final cure is probably to intrduce real priority mechanism replace pSpaces with more efficient version using pMunch Version made TypeOperators explicit as required by GHC Version fixed corner case when combining to failing parsers during grammar analysis probably useful error message is now gone Version better behaviour when inserting at end of input Version fixed the case where the left hand operand of starts with monadic bind Version removed left-over from debugging Version fixed subtle bug in the merging parsers caused by name shielding Version added pDoubleStr to the export list of the Utils module Version fixed subtle black hole which prevented computation of lengths You should upgrade Version Some types were reformulated to compile correctly with ghc Version Typos fixed in Haddock documentation Version Improvement change of error correction at end of amb combinator so lookahead is better taken into account Relatively large change Change to Data.ListLike inputs so general stream input structure is possible hence we can now parse all instances of ListLike Simplified and generalised implementation of merging permuting parsers any kind of parsers can now be merged permuted New class IsParser was introduced which captures the basic properties of our parsers Inclusion of module Text.ParserCombinators.UU.Utils containing common Char based parsers Removal of the class Provides and replaced by separate pSym pSatisfy and pRange this may require some rwriting of existing parsers Readbaility is supposed to improve from that Types become simpler For an example see the module Text.ParserCombinators.UU.Utils Included Demo directory with modules for demonstrating normal parsers and one aimed at merging parsers Added the module Text.ParserCombinaors.UU.Idioms which contains specialised version for the idiomatic notation it infers the sequental composition operators from the types of the operands String and Char are not supposed to contribute to the result function parameters are lifted using pure and normal parsers are composed with Many other small changes mostly upwards compatible or invisible code cleanup Version Changed the input to Stream interface to handle different kind of inputs like String Data.Text and Data.ByteString To update old code to the new interface you should add import Text.ParserCombinators.UU.BasicInstances.String in the file header and change listToStr inp to createStr inp To work with other inputs import Text.ParserCombinators.UU.BasicInstances.List Text.ParserCombinators.UU.BasicInstances.Text Text.ParserCombinators.UU.BasicInstances.ByteString or Text.ParserCombinators.UU.BasicInstances.ByteString.Lazy Version replaced references to modules with references in the new library scheme Version added special version of called in ExtAlternative which does not compare the length of the parsers to be used in permutations Version type signatures were added to make Haddock happy Version type signatures were added to make the library GHC ready Version preference is given to earlier accept steps in order to avoid infinite insertions in case of otherwise equivalent repair strategies Version fixed small problem in so it gets its chance to do its work Version added pSem which makes it possible to tell how certain components of merged structures are to be combined before exposing all elements to the outer sem run pMerge pSem pMany pa pMany pb pOne pc abcaaab Result added pMergedSep which allows you to specify separator between two merged elements run pc pMergeSep pMany pa pMany pb acbcacbc Result Correcting steps Inserted at position expecting one of Version made the merging combinators more general introducing pAtMost pBetween and pAtLeast examples are extended see demo merge used CPP in order to generate demo easily fixed bug which made pPos ambiguous modified haddock stuff Version fixed bug in the implementation some functions were too strict due to introduction of nice abstractions added generalisation of pMerged and pPerms to the module Text.ParserCombinators.UU.Derived the old modules have been marked as deprecated removed the old module Text.ParserCombinators.UU.Parsing which was already marged as deprecated Version fixed bug in sequential composition with pure as left hand side added an experimental pMerge which combines the featurs of pPerms and pMerged Version Now with the correct Changelog Version added the permutation parsers from the old uulib extended the abstract interpretation so more soundness checks can be done statically everything seems to work in case of problems please report and go back to Version generalised over the position in the input now it is easy to maintain e.g line column info as shown in the Examples.hs file added needed instances for String as input in BasicInstances.hs fixed bug in pMunch where Step was inserted with progress leading to infinite insertions added Haddock beautifications Version added the function pPos for retreiving the current input position Version solved mistake which had crept in in the greedy choice added priority for which had disappeared added an example how to achieve the effect of manytill from parsec Version removed the classes IsParser and Symbol which made the code shorter and more H98-alike last version with dynamic error message computation Version fixed dependency in cabal file to base moved definition of to the class Functor and removed the class ExtApplicative Version added the module Text.ParserCombinators.Merge for recognizing alternating sequences made st an instance of MonadPlus beautified Haddock documentation Version contains abstract interpretation for minimal lenth in order to avoid recursive correction process idem for checking that no repeating combinators like pList are parameterised with possibly empty parsers lots of Haddcock doumentation in Text.ParserCombinators.UU.Examples Version removed dependecies on impredictaive types preparing for next GHC version Version added pMunch which takes Boolean function and recognises the longest prefix for which the symbols match the predicate added the infix operator with piority state String state which replaces the list of expected symbols in error message by its right argument String Version added microsteps which can be used to disambiguate Version fix for GHC because of change in GADT definition handling Versions above make use of type families contain module with many list-based derived combinators Versions above based on Control.Applicative Note that the basic parser interface will probably not change much when we add more features but the calling conventions of the outer parser and the class structure upon which the parametrisation is based may change slightly",
          "hierarchy": "Text ParserCombinators UU CHANGELOG",
          "module": "Text.ParserCombinators.UU.CHANGELOG",
          "name": "CHANGELOG",
          "package": "uu-parsinglib",
          "partial": "CHANGELOG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-CHANGELOG.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe module \u003ccode\u003eCore\u003c/code\u003e contains the basic functionality of the parser library.\n   It defines the types and implementations of the elementary  parsers and  recognisers involved.  \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Core",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html",
          "type": "module"
        },
        "index": {
          "description": "The module Core contains the basic functionality of the parser library It defines the types and implementations of the elementary parsers and recognisers involved",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Core",
          "package": "uu-parsinglib",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Cost",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#Cost",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Cost",
          "package": "uu-parsinglib",
          "partial": "Cost",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:Cost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eEof\u003c/a\u003e\u003c/code\u003e contains a function \u003ccode\u003e\u003ca\u003eeof\u003c/a\u003e\u003c/code\u003e which is used to check whether we have reached the end of the input and \u003ccode\u003edeletAtEnd\u003c/code\u003e \n   should discard any unconsumed input at the end of a successful parse.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Eof",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#Eof",
          "type": "class"
        },
        "index": {
          "description": "The class Eof contains function eof which is used to check whether we have reached the end of the input and deletAtEnd should discard any unconsumed input at the end of successful parse",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Eof",
          "package": "uu-parsinglib",
          "partial": "Eof",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:Eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "ExtAlternative",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#ExtAlternative",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "ExtAlternative",
          "package": "uu-parsinglib",
          "partial": "Ext Alternative",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:ExtAlternative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "HasPosition",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#HasPosition",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "HasPosition",
          "package": "uu-parsinglib",
          "partial": "Has Position",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:HasPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe input state may maintain a location which can be used in generating error messages. \n   Since we do not want to fix our input to be just a \u003ccode\u003eString\u003c/code\u003e we provide an interface\n   which can be used to advance this location by passing  information about the part recognised. This function is typically\n   called in the \u003ccode\u003esplitState\u003c/code\u003e functions.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "IsLocationUpdatedBy",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#IsLocationUpdatedBy",
          "type": "class"
        },
        "index": {
          "description": "The input state may maintain location which can be used in generating error messages Since we do not want to fix our input to be just String we provide an interface which can be used to advance this location by passing information about the part recognised This function is typically called in the splitState functions",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "IsLocationUpdatedBy",
          "package": "uu-parsinglib",
          "partial": "Is Location Updated By",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:IsLocationUpdatedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn the class \u003ccode\u003e\u003ca\u003eIsParser\u003c/a\u003e\u003c/code\u003e we assemble the basic properties we expect parsers to have. The class itself does not have any methods. \n   Most properties  come directly from the standard \n   \u003ca\u003eControl.Applicative\u003c/a\u003e module. The class \u003ccode\u003e\u003ca\u003eExtAlternative\u003c/a\u003e\u003c/code\u003e contains some extra methods we expect our parsers to have.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "IsParser",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#IsParser",
          "type": "class"
        },
        "index": {
          "description": "In the class IsParser we assemble the basic properties we expect parsers to have The class itself does not have any methods Most properties come directly from the standard Control.Applicative module The class ExtAlternative contains some extra methods we expect our parsers to have",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "IsParser",
          "package": "uu-parsinglib",
          "partial": "Is Parser",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:IsParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eNat\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is used to represent the minimal length of a parser.\n   Care should be taken in order to not evaluate the right hand side of the binary function \u003ccode\u003e`nat-add`\u003c/code\u003e more than necesssary.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Nat",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#Nat",
          "type": "data"
        },
        "index": {
          "description": "The data type Nat is used to represent the minimal length of parser Care should be taken in order to not evaluate the right hand side of the binary function nat-add more than necesssary",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Nat",
          "package": "uu-parsinglib",
          "partial": "Nat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:Nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "P",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#P",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "P",
          "package": "uu-parsinglib",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Progress",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#Progress",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Progress",
          "package": "uu-parsinglib",
          "partial": "Progress",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:Progress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data type \u003ccode\u003e\u003ca\u003eSteps\u003c/a\u003e\u003c/code\u003e is the core data type around which the parsers are constructed.\n   It describes a tree structure of streams containing (in an interleaved way) both the online result of the parsing process,\n   and progress information. Recognising an input token should correspond to a certain amount of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eProgress\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, \n   which tells how much of the input state was consumed. \n   The \u003ccode\u003e\u003ccode\u003e\u003ca\u003eProgress\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is used to implement the breadth-first search process, in which alternatives are\n   examined in a more-or-less synchronised way. The meaning of the various \u003ccode\u003e\u003ccode\u003e\u003ca\u003eStep\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e constructors is as follows:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eStep\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e A token was succesfully recognised, and as a result the input was \u003ccode\u003eadvanced\u003c/code\u003e by the distance  \u003ccode\u003e\u003ccode\u003e\u003ca\u003eProgress\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eApply\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The type of value represented by the \u003ccode\u003e\u003ca\u003eSteps\u003c/a\u003e\u003c/code\u003e changes by applying the function parameter.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eFail\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e A correcting step has to be made to the input; the first parameter contains information about what was expected in the input, \n   and the second parameter describes the various corrected alternatives, each with an associated \u003ccode\u003e\u003ca\u003eCost\u003c/a\u003e\u003c/code\u003e\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eMicro\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e A small cost is inserted in the sequence, which is used to disambiguate. Use with care!\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThe last two alternatives play a role in recognising ambigous non-terminals. For a full description see the technical report referred to from \n   \u003ca\u003eText.ParserCombinators.UU.README\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Steps",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#Steps",
          "type": "data"
        },
        "index": {
          "description": "The data type Steps is the core data type around which the parsers are constructed It describes tree structure of streams containing in an interleaved way both the online result of the parsing process and progress information Recognising an input token should correspond to certain amount of Progress which tells how much of the input state was consumed The Progress is used to implement the breadth-first search process in which alternatives are examined in more-or-less synchronised way The meaning of the various Step constructors is as follows Step token was succesfully recognised and as result the input was advanced by the distance Progress Apply The type of value represented by the Steps changes by applying the function parameter Fail correcting step has to be made to the input the first parameter contains information about what was expected in the input and the second parameter describes the various corrected alternatives each with an associated Cost Micro small cost is inserted in the sequence which is used to disambiguate Use with care The last two alternatives play role in recognising ambigous non-terminals For full description see the technical report referred to from Text.ParserCombinators.UU.README",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Steps",
          "package": "uu-parsinglib",
          "partial": "Steps",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:Steps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eStoresErrors\u003c/a\u003e\u003c/code\u003e is used by the function \u003ccode\u003e\u003ca\u003epErrors\u003c/a\u003e\u003c/code\u003e which retrieves the generated \n  correction steps since the last time it was called.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "StoresErrors",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#StoresErrors",
          "type": "class"
        },
        "index": {
          "description": "The class StoresErrors is used by the function pErrors which retrieves the generated correction steps since the last time it was called",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "StoresErrors",
          "package": "uu-parsinglib",
          "partial": "Stores Errors",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:StoresErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Strings",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Core.html#Strings",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Strings",
          "package": "uu-parsinglib",
          "partial": "Strings",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#t:Strings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003c\u003c|\u003e\u003c/a\u003e\u003c/code\u003e is the greedy version of \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e. If its left hand side parser can\n   make any progress then it commits to that alternative. Can be used to make\n   parsers faster, and even get a complete Parsec equivalent behaviour, with\n   all its (dis)advantages. Intended use \u003ccode\u003ep \u003c\u003c|\u003e q \u003c\u003c|\u003e r \u003c|\u003e x \u003c|\u003e y \u003c?\u003e \"string\"\u003c/code\u003e. Use with care!   \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "(\u003c\u003c|\u003e)",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p a -\u003e p a",
          "source": "src/Text-ParserCombinators-UU-Core.html#%3C%3C%7C%3E",
          "type": "method"
        },
        "index": {
          "description": "is the greedy version of If its left hand side parser can make any progress then it commits to that alternative Can be used to make parsers faster and even get complete Parsec equivalent behaviour with all its dis advantages Intended use string Use with care",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "(\u003c\u003c|\u003e) \u003c\u003c|\u003e",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "uu-parsinglib",
          "signature": "p a-\u003ep a-\u003ep a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:-60--60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parsers build a list of symbols which are expected at a specific point. \n   This list is used to report errors.\n   Quite often it is more informative to get e.g. the name of the non-terminal . \n   The \u003ccode\u003e\u003ca\u003e\u003c?\u003e\u003c/a\u003e\u003c/code\u003e combinator replaces this list of symbols by the string argument.   \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "(\u003c?\u003e)",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e String -\u003e p a",
          "source": "src/Text-ParserCombinators-UU-Core.html#%3C%3F%3E",
          "type": "method"
        },
        "index": {
          "description": "The parsers build list of symbols which are expected at specific point This list is used to report errors Quite often it is more informative to get e.g the name of the non-terminal The combinator replaces this list of symbols by the string argument",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "(\u003c?\u003e) \u003c?\u003e",
          "normalized": "a b-\u003eString-\u003ea b",
          "package": "uu-parsinglib",
          "signature": "p a-\u003eString-\u003ep a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:-60--63--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Apply",
          "package": "uu-parsinglib",
          "signature": "forall a b.  (b -\u003e a) -\u003e Steps b -\u003e Steps a",
          "source": "src/Text-ParserCombinators-UU-Core.html#Steps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Apply",
          "normalized": "a b c(d-\u003eb)-\u003eSteps d-\u003eSteps b",
          "package": "uu-parsinglib",
          "partial": "Apply",
          "signature": "forall a b.(b-\u003ea)-\u003eSteps b-\u003eSteps a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "End_f",
          "package": "uu-parsinglib",
          "signature": "[Steps a] -\u003e Steps a -\u003e Steps a",
          "source": "src/Text-ParserCombinators-UU-Core.html#Steps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "End_f",
          "normalized": "[Steps a]-\u003eSteps a-\u003eSteps a",
          "package": "uu-parsinglib",
          "partial": "End",
          "signature": "[Steps a]-\u003eSteps a-\u003eSteps a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:End_f"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "End_h",
          "package": "uu-parsinglib",
          "signature": "([a], [a] -\u003e Steps r) -\u003e Steps (a, r) -\u003e Steps (a, r)",
          "source": "src/Text-ParserCombinators-UU-Core.html#Steps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "End_h",
          "normalized": "([a],[a]-\u003eSteps b)-\u003eSteps(a,b)-\u003eSteps(a,b)",
          "package": "uu-parsinglib",
          "partial": "End",
          "signature": "([a],[a]-\u003eSteps r)-\u003eSteps(a,r)-\u003eSteps(a,r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:End_h"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Fail",
          "package": "uu-parsinglib",
          "signature": "Strings -\u003e [Strings -\u003e (Cost, Steps a)] -\u003e Steps a",
          "source": "src/Text-ParserCombinators-UU-Core.html#Steps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Fail",
          "normalized": "Strings-\u003e[Strings-\u003e(Cost,Steps a)]-\u003eSteps a",
          "package": "uu-parsinglib",
          "partial": "Fail",
          "signature": "Strings-\u003e[Strings-\u003e(Cost,Steps a)]-\u003eSteps a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Hole",
          "package": "uu-parsinglib",
          "signature": "Hole",
          "source": "src/Text-ParserCombinators-UU-Core.html#Nat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Hole",
          "package": "uu-parsinglib",
          "partial": "Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Infinite",
          "package": "uu-parsinglib",
          "signature": "Infinite",
          "source": "src/Text-ParserCombinators-UU-Core.html#Nat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Infinite",
          "package": "uu-parsinglib",
          "partial": "Infinite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Infinite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Micro",
          "package": "uu-parsinglib",
          "signature": "Int -\u003e Steps a -\u003e Steps a",
          "source": "src/Text-ParserCombinators-UU-Core.html#Steps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Micro",
          "normalized": "Int-\u003eSteps a-\u003eSteps a",
          "package": "uu-parsinglib",
          "partial": "Micro",
          "signature": "Int-\u003eSteps a-\u003eSteps a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Micro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "P",
          "package": "uu-parsinglib",
          "signature": "P (T st a) (Maybe (T st a)) (Maybe a) Nat",
          "source": "src/Text-ParserCombinators-UU-Core.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "P",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Step",
          "package": "uu-parsinglib",
          "signature": "Progress -\u003e Steps a -\u003e Steps a",
          "source": "src/Text-ParserCombinators-UU-Core.html#Steps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Step",
          "normalized": "Progress-\u003eSteps a-\u003eSteps a",
          "package": "uu-parsinglib",
          "partial": "Step",
          "signature": "Progress-\u003eSteps a-\u003eSteps a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Succ",
          "package": "uu-parsinglib",
          "signature": "Succ Nat",
          "source": "src/Text-ParserCombinators-UU-Core.html#Nat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Succ",
          "package": "uu-parsinglib",
          "partial": "Succ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Unspecified",
          "package": "uu-parsinglib",
          "signature": "Unspecified",
          "source": "src/Text-ParserCombinators-UU-Core.html#Nat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Unspecified",
          "package": "uu-parsinglib",
          "partial": "Unspecified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Unspecified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Zero",
          "package": "uu-parsinglib",
          "signature": "Zero Nat",
          "source": "src/Text-ParserCombinators-UU-Core.html#Nat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "Zero",
          "package": "uu-parsinglib",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "addLength",
          "package": "uu-parsinglib",
          "signature": "Int -\u003e P st a -\u003e P st a",
          "source": "src/Text-ParserCombinators-UU-Core.html#addLength",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "addLength",
          "normalized": "Int-\u003eP a b-\u003eP a b",
          "package": "uu-parsinglib",
          "partial": "Length",
          "signature": "Int-\u003eP st a-\u003eP st a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:addLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "advance",
          "package": "uu-parsinglib",
          "signature": "advance",
          "source": "src/Text-ParserCombinators-UU-Core.html#advance",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "advance",
          "package": "uu-parsinglib",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:advance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor the precise functioning of the \u003ccode\u003e\u003ca\u003eamb\u003c/a\u003e\u003c/code\u003e combinators see the paper cited in the \u003ca\u003eText.ParserCombinators.UU.README\u003c/a\u003e;\n    it converts an ambiguous parser into a parser which returns a list of all possible recognitions,\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "amb",
          "package": "uu-parsinglib",
          "signature": "P st a -\u003e P st [a]",
          "source": "src/Text-ParserCombinators-UU-Core.html#amb",
          "type": "function"
        },
        "index": {
          "description": "For the precise functioning of the amb combinators see the paper cited in the Text.ParserCombinators.UU.README it converts an ambiguous parser into parser which returns list of all possible recognitions",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "amb",
          "normalized": "P a b-\u003eP a[b]",
          "package": "uu-parsinglib",
          "signature": "P st a-\u003eP st[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:amb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "deleteAtEnd",
          "package": "uu-parsinglib",
          "signature": "state -\u003e Maybe (Cost, state)",
          "source": "src/Text-ParserCombinators-UU-Core.html#deleteAtEnd",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "deleteAtEnd",
          "normalized": "a-\u003eMaybe(Cost,a)",
          "package": "uu-parsinglib",
          "partial": "At End",
          "signature": "state-\u003eMaybe(Cost,state)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:deleteAtEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Core",
          "name": "eof",
          "package": "uu-parsinglib",
          "signature": "state -\u003e Bool",
          "source": "src/Text-ParserCombinators-UU-Core.html#eof",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "eof",
          "normalized": "a-\u003eBool",
          "package": "uu-parsinglib",
          "signature": "state-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eeval\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e removes the progress information from a sequence of steps, \n   and constructs the value embedded in it.\n   If you are really desparate to see how your parsers are making progress\n   (e.g. when you have written an ambiguous parser, and you cannot find \n   the cause of the exponential blow-up of your parsing process), \n   you may switch on the trace in the function \u003ccode\u003e\u003ccode\u003e\u003ca\u003eeval\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e (you will need to edit the library source code).\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "eval",
          "package": "uu-parsinglib",
          "signature": "Steps a -\u003e a",
          "source": "src/Text-ParserCombinators-UU-Core.html#eval",
          "type": "function"
        },
        "index": {
          "description": "eval removes the progress information from sequence of steps and constructs the value embedded in it If you are really desparate to see how your parsers are making progress e.g when you have written an ambiguous parser and you cannot find the cause of the exponential blow-up of your parsing process you may switch on the trace in the function eval you will need to edit the library source code",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "eval",
          "normalized": "Steps a-\u003ea",
          "package": "uu-parsinglib",
          "signature": "Steps a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egetErrors\u003c/a\u003e\u003c/code\u003e retrieves the correcting steps made since the last time the function was called. The result can, \n    by using it in a monad, be used to control how to proceed with the parsing process.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getErrors",
          "package": "uu-parsinglib",
          "signature": "state -\u003e ([error], state)",
          "source": "src/Text-ParserCombinators-UU-Core.html#getErrors",
          "type": "method"
        },
        "index": {
          "description": "getErrors retrieves the correcting steps made since the last time the function was called The result can by using it in monad be used to control how to proceed with the parsing process",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getErrors",
          "normalized": "a-\u003e([b],a)",
          "package": "uu-parsinglib",
          "partial": "Errors",
          "signature": "state-\u003e([error],state)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:getErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egetOneP\u003c/a\u003e\u003c/code\u003e retrieves the non-zero part from a descriptor.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getOneP",
          "package": "uu-parsinglib",
          "signature": "P a b -\u003e Maybe (P a b)",
          "source": "src/Text-ParserCombinators-UU-Core.html#getOneP",
          "type": "function"
        },
        "index": {
          "description": "getOneP retrieves the non-zero part from descriptor",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getOneP",
          "normalized": "P a b-\u003eMaybe(P a b)",
          "package": "uu-parsinglib",
          "partial": "One",
          "signature": "P a b-\u003eMaybe(P a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:getOneP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egetPos\u003c/a\u003e\u003c/code\u003e retrieves the correcting steps made since the last time the function was called. The result can, \n   by using it as the left hand side of a monadic bind, be used to control how to proceed with the parsing process.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getPos",
          "package": "uu-parsinglib",
          "signature": "state -\u003e pos",
          "source": "src/Text-ParserCombinators-UU-Core.html#getPos",
          "type": "method"
        },
        "index": {
          "description": "getPos retrieves the correcting steps made since the last time the function was called The result can by using it as the left hand side of monadic bind be used to control how to proceed with the parsing process",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getPos",
          "normalized": "a-\u003eb",
          "package": "uu-parsinglib",
          "partial": "Pos",
          "signature": "state-\u003epos",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:getPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egetZeroP\u003c/a\u003e\u003c/code\u003e retrieves the possibly empty part from a descriptor.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getZeroP",
          "package": "uu-parsinglib",
          "signature": "P t a -\u003e Maybe a",
          "source": "src/Text-ParserCombinators-UU-Core.html#getZeroP",
          "type": "function"
        },
        "index": {
          "description": "getZeroP retrieves the possibly empty part from descriptor",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "getZeroP",
          "normalized": "P a b-\u003eMaybe b",
          "package": "uu-parsinglib",
          "partial": "Zero",
          "signature": "P t a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:getZeroP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emicro\u003c/a\u003e\u003c/code\u003e inserts a \u003ccode\u003e\u003ca\u003eCost\u003c/a\u003e\u003c/code\u003e step into the sequence representing the progress the parser is making; \n   for its use see `\u003ca\u003eText.ParserCombinators.UU.Demos.Examples\u003c/a\u003e`\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "micro",
          "package": "uu-parsinglib",
          "signature": "P state a -\u003e Int -\u003e P state a",
          "source": "src/Text-ParserCombinators-UU-Core.html#micro",
          "type": "function"
        },
        "index": {
          "description": "micro inserts Cost step into the sequence representing the progress the parser is making for its use see Text.ParserCombinators.UU.Demos.Examples",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "micro",
          "normalized": "P a b-\u003eInt-\u003eP a b",
          "package": "uu-parsinglib",
          "signature": "P state a-\u003eInt-\u003eP state a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:micro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emust_be_non_empties\u003c/a\u003e\u003c/code\u003e is similar to \u003ccode\u003e\u003ca\u003emust_be_non_empty\u003c/a\u003e\u003c/code\u003e, but can be \n    used in situations where we recognise a sequence of elements separated by \n    other elements. This does not make sense if both parsers can recognise the \n    empty string. Your grammar is then highly ambiguous.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "must_be_non_empties",
          "package": "uu-parsinglib",
          "signature": "String -\u003e p a -\u003e p b -\u003e c -\u003e c",
          "source": "src/Text-ParserCombinators-UU-Core.html#must_be_non_empties",
          "type": "method"
        },
        "index": {
          "description": "must be non empties is similar to must be non empty but can be used in situations where we recognise sequence of elements separated by other elements This does not make sense if both parsers can recognise the empty string Your grammar is then highly ambiguous",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "must_be_non_empties",
          "normalized": "String-\u003ea b-\u003ea c-\u003ed-\u003ed",
          "package": "uu-parsinglib",
          "signature": "String-\u003ep a-\u003ep b-\u003ec-\u003ec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:must_be_non_empties"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emust_be_non_empty\u003c/a\u003e\u003c/code\u003e checks whether its second argument\n    is a parser which can recognise the empty input. If so, an error message is\n    given using the  String parameter. If not, then the third argument is\n    returned. This is useful in testing for illogical combinations. For its use see\n    the module \u003ca\u003eText.ParserCombinators.UU.Derived\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "must_be_non_empty",
          "package": "uu-parsinglib",
          "signature": "String -\u003e p a -\u003e c -\u003e c",
          "source": "src/Text-ParserCombinators-UU-Core.html#must_be_non_empty",
          "type": "method"
        },
        "index": {
          "description": "must be non empty checks whether its second argument is parser which can recognise the empty input If so an error message is given using the String parameter If not then the third argument is returned This is useful in testing for illogical combinations For its use see the module Text.ParserCombinators.UU.Derived",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "must_be_non_empty",
          "normalized": "String-\u003ea b-\u003ec-\u003ec",
          "package": "uu-parsinglib",
          "signature": "String-\u003ep a-\u003ec-\u003ec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:must_be_non_empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003ep\u003c/code\u003e can be recognized, the return value of \u003ccode\u003ep\u003c/code\u003e is used. Otherwise,\n   the value \u003ccode\u003ev\u003c/code\u003e is used. Note that \u003ccode\u003e\u003ca\u003eopt\u003c/a\u003e\u003c/code\u003e by default is greedy. If you do not want\n   this use \u003ccode\u003e...\u003c|\u003e pure v\u003c/code\u003e  instead. Furthermore, \u003ccode\u003ep\u003c/code\u003e should not\n   recognise the empty string, since this would make the parser ambiguous!!\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "opt",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e a -\u003e p a",
          "source": "src/Text-ParserCombinators-UU-Core.html#opt",
          "type": "method"
        },
        "index": {
          "description": "If can be recognized the return value of is used Otherwise the value is used Note that opt by default is greedy If you do not want this use pure instead Furthermore should not recognise the empty string since this would make the parser ambiguous",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "opt",
          "normalized": "a b-\u003eb-\u003ea b",
          "package": "uu-parsinglib",
          "signature": "p a-\u003ea-\u003ep a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:opt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003epEnd\u003c/a\u003e\u003c/code\u003e should be called at the end of the parsing process. It deletes any unconsumed input, turning it into error messages.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pEnd",
          "package": "uu-parsinglib",
          "signature": "P st [error]",
          "source": "src/Text-ParserCombinators-UU-Core.html#pEnd",
          "type": "function"
        },
        "index": {
          "description": "The function pEnd should be called at the end of the parsing process It deletes any unconsumed input turning it into error messages",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pEnd",
          "normalized": "P a[b]",
          "package": "uu-parsinglib",
          "partial": "End",
          "signature": "P st[error]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:pEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epErrors\u003c/a\u003e\u003c/code\u003e returns the error messages that were generated since its last call.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pErrors",
          "package": "uu-parsinglib",
          "signature": "P st [error]",
          "source": "src/Text-ParserCombinators-UU-Core.html#pErrors",
          "type": "function"
        },
        "index": {
          "description": "pErrors returns the error messages that were generated since its last call",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pErrors",
          "normalized": "P a[b]",
          "package": "uu-parsinglib",
          "partial": "Errors",
          "signature": "P st[error]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:pErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epPos\u003c/a\u003e\u003c/code\u003e returns the current input position.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pPos",
          "package": "uu-parsinglib",
          "signature": "P st pos",
          "source": "src/Text-ParserCombinators-UU-Core.html#pPos",
          "type": "function"
        },
        "index": {
          "description": "pPos returns the current input position",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pPos",
          "package": "uu-parsinglib",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:pPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epState\u003c/a\u003e\u003c/code\u003e returns the current input state\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pState",
          "package": "uu-parsinglib",
          "signature": "P st st",
          "source": "src/Text-ParserCombinators-UU-Core.html#pState",
          "type": "function"
        },
        "index": {
          "description": "pState returns the current input state",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pState",
          "package": "uu-parsinglib",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:pState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003epSwitch\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e takes the current state and modifies it to a different type of state to which its argument parser is applied. \n   The second component of the result is a function which  converts the remaining state of this parser back into a value of the original type.\n   For the second argument to \u003ccode\u003e\u003ccode\u003e\u003ca\u003epSwitch\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e  (say split) we expect the following to hold:\n\u003c/p\u003e\u003cpre\u003e  let (n,f) = split st in f n == st\n\u003c/pre\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pSwitch",
          "package": "uu-parsinglib",
          "signature": "(st1 -\u003e (st2, st2 -\u003e st1)) -\u003e P st2 a -\u003e P st1 a",
          "source": "src/Text-ParserCombinators-UU-Core.html#pSwitch",
          "type": "function"
        },
        "index": {
          "description": "pSwitch takes the current state and modifies it to different type of state to which its argument parser is applied The second component of the result is function which converts the remaining state of this parser back into value of the original type For the second argument to pSwitch say split we expect the following to hold let split st in st",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pSwitch",
          "normalized": "(a-\u003e(a,a-\u003ea))-\u003eP a b-\u003eP a b",
          "package": "uu-parsinglib",
          "partial": "Switch",
          "signature": "(st-\u003e(st,st-\u003est))-\u003eP st a-\u003eP st a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:pSwitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe basic recognisers are written elsewhere (e.g. in our module \u003ca\u003eText.ParserCombinataors.UU.BasicInstances\u003c/a\u003e; \n    they (i.e. the parameter \u003ccode\u003esplitState\u003c/code\u003e) are lifted to our\u003ccode\u003e\u003ca\u003eP\u003c/a\u003e\u003c/code\u003e  descriptors by the function \u003ccode\u003e\u003ca\u003epSymExt\u003c/a\u003e\u003c/code\u003e which also takes\n    the minimal number of tokens recognised by the parameter \u003ccode\u003esplitState\u003c/code\u003e  and an  \u003ccode\u003eMaybe\u003c/code\u003e value describing the possibly empty value.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pSymExt",
          "package": "uu-parsinglib",
          "signature": "(forall a.  (token -\u003e state -\u003e Steps a) -\u003e state -\u003e Steps a) -\u003e Nat -\u003e Maybe token -\u003e P state token",
          "source": "src/Text-ParserCombinators-UU-Core.html#pSymExt",
          "type": "function"
        },
        "index": {
          "description": "The basic recognisers are written elsewhere e.g in our module Text.ParserCombinataors.UU.BasicInstances they i.e the parameter splitState are lifted to our descriptors by the function pSymExt which also takes the minimal number of tokens recognised by the parameter splitState and an Maybe value describing the possibly empty value",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "pSymExt",
          "normalized": "(a b(c-\u003ed-\u003eSteps e)-\u003ed-\u003eSteps e)-\u003eNat-\u003eMaybe c-\u003eP d c",
          "package": "uu-parsinglib",
          "partial": "Sym Ext",
          "signature": "(forall a.(token-\u003estate-\u003eSteps a)-\u003estate-\u003eSteps a)-\u003eNat-\u003eMaybe token-\u003eP state token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:pSymExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ccode\u003e\u003ca\u003eparse\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e shows the prototypical way of running a parser on\n some specific input.\n By default we use the future parser, since this gives us access to partal\n result; future parsers are expected to run in less space.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "parse",
          "package": "uu-parsinglib",
          "signature": "P t a -\u003e t -\u003e a",
          "source": "src/Text-ParserCombinators-UU-Core.html#parse",
          "type": "function"
        },
        "index": {
          "description": "The function parse shows the prototypical way of running parser on some specific input By default we use the future parser since this gives us access to partal result future parsers are expected to run in less space",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "parse",
          "normalized": "P a b-\u003ea-\u003eb",
          "package": "uu-parsinglib",
          "signature": "P t a-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ccode\u003e\u003ca\u003eparse_h\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e behaves like \u003ccode\u003e\u003ccode\u003e\u003ca\u003eparse\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e but using the history\n parser. This parser does not give online results, but might run faster.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "parse_h",
          "package": "uu-parsinglib",
          "signature": "P t a -\u003e t -\u003e a",
          "source": "src/Text-ParserCombinators-UU-Core.html#parse_h",
          "type": "function"
        },
        "index": {
          "description": "The function parse behaves like parse but using the history parser This parser does not give online results but might run faster",
          "hierarchy": "Text ParserCombinators UU Core",
          "module": "Text.ParserCombinators.UU.Core",
          "name": "parse_h",
          "normalized": "P a b-\u003ea-\u003eb",
          "package": "uu-parsinglib",
          "signature": "P t a-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Core.html#v:parse_h"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a lot of examples of the typical use of our parser combinator library. \n   We strongly encourage you to take a look at the source code.\n   At the end you find a \u003ccode\u003e\u003ccode\u003emain\u003c/code\u003e\u003c/code\u003e function which demonstrates the main characteristics. \n   Only the \u003ccode\u003e\u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e function is exported since it may come in handy elsewhere.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "Examples",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains lot of examples of the typical use of our parser combinator library We strongly encourage you to take look at the source code At the end you find main function which demonstrates the main characteristics Only the run function is exported since it may come in handy elsewhere",
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "Examples",
          "package": "uu-parsinglib",
          "partial": "Examples",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "Parser",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#Parser",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "Parser",
          "package": "uu-parsinglib",
          "partial": "Parser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "(\u003c++\u003e)",
          "package": "uu-parsinglib",
          "signature": "Parser String -\u003e Parser String -\u003e Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#%3C%2B%2B%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "(\u003c++\u003e) \u003c++\u003e",
          "normalized": "Parser String-\u003eParser String-\u003eParser String",
          "package": "uu-parsinglib",
          "signature": "Parser String-\u003eParser String-\u003eParser String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:-60--43--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "demo",
          "package": "uu-parsinglib",
          "signature": "String -\u003e String -\u003e P (Str Char String LineColPos) r -\u003e IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#demo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "demo",
          "normalized": "String-\u003eString-\u003eP(Str Char String LineColPos)a-\u003eIO()",
          "package": "uu-parsinglib",
          "signature": "String-\u003eString-\u003eP(Str Char String LineColPos)r-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:demo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "expr",
          "package": "uu-parsinglib",
          "signature": "Parser Int",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "expr",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "ident",
          "package": "uu-parsinglib",
          "signature": "P (Str Char String LineColPos) [Char]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#ident",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "ident",
          "normalized": "P(Str Char String LineColPos)[Char]",
          "package": "uu-parsinglib",
          "signature": "P(Str Char String LineColPos)[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:ident"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "idents",
          "package": "uu-parsinglib",
          "signature": "P (Str Char String LineColPos) [[Char]]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#idents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "idents",
          "normalized": "P(Str Char String LineColPos)[[Char]]",
          "package": "uu-parsinglib",
          "signature": "P(Str Char String LineColPos)[[Char]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:idents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "justamessage",
          "package": "uu-parsinglib",
          "signature": "[Char]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#justamessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "justamessage",
          "normalized": "[Char]",
          "package": "uu-parsinglib",
          "signature": "[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:justamessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "lift",
          "package": "uu-parsinglib",
          "signature": "t -\u003e [t]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#lift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "lift",
          "normalized": "a-\u003e[a]",
          "package": "uu-parsinglib",
          "signature": "t-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "operators",
          "package": "uu-parsinglib",
          "signature": "[[(Char, a -\u003e a -\u003e a)]]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#operators",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "operators",
          "normalized": "[[(Char,a-\u003ea-\u003ea)]]",
          "package": "uu-parsinglib",
          "signature": "[[(Char,a-\u003ea-\u003ea)]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:operators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pAnyToken",
          "package": "uu-parsinglib",
          "signature": "[String] -\u003e P (Str Char state loc) String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pAnyToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pAnyToken",
          "normalized": "[String]-\u003eP(Str Char a b)String",
          "package": "uu-parsinglib",
          "partial": "Any Token",
          "signature": "[String]-\u003eP(Str Char state loc)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pAnyToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pConId",
          "package": "uu-parsinglib",
          "signature": "P (Str Char state loc) [Char]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pConId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pConId",
          "normalized": "P(Str Char a b)[Char]",
          "package": "uu-parsinglib",
          "partial": "Con Id",
          "signature": "P(Str Char state loc)[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pConId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pIdChar",
          "package": "uu-parsinglib",
          "signature": "P (Str Char state loc) Char",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pIdChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pIdChar",
          "package": "uu-parsinglib",
          "partial": "Id Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pIdChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pIntList",
          "package": "uu-parsinglib",
          "signature": "Parser [Int]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pIntList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pIntList",
          "normalized": "Parser[Int]",
          "package": "uu-parsinglib",
          "partial": "Int List",
          "signature": "Parser[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pIntList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pKey",
          "package": "uu-parsinglib",
          "signature": "[Char] -\u003e P (Str Char String LineColPos) [Char]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pKey",
          "normalized": "[Char]-\u003eP(Str Char String LineColPos)[Char]",
          "package": "uu-parsinglib",
          "partial": "Key",
          "signature": "[Char]-\u003eP(Str Char String LineColPos)[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pManyTill",
          "package": "uu-parsinglib",
          "signature": "P st a -\u003e P st b -\u003e P st [a]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pManyTill",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pManyTill",
          "normalized": "P a b-\u003eP a c-\u003eP a[b]",
          "package": "uu-parsinglib",
          "partial": "Many Till",
          "signature": "P st a-\u003eP st b-\u003eP st[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pManyTill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pVarId",
          "package": "uu-parsinglib",
          "signature": "P (Str Char state loc) [Char]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pVarId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pVarId",
          "normalized": "P(Str Char a b)[Char]",
          "package": "uu-parsinglib",
          "partial": "Var Id",
          "signature": "P(Str Char state loc)[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pVarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOur first two parsers are simple; one recognises a single \u003ccode\u003ea\u003c/code\u003e character and the other one a single \u003ccode\u003eb\u003c/code\u003e. Since we will use them later we \n   convert the recognised character into \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e so they can be easily combined.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pa",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pa",
          "type": "function"
        },
        "index": {
          "description": "Our first two parsers are simple one recognises single character and the other one single Since we will use them later we convert the recognised character into String so they can be easily combined",
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pa",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pa2",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pa2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pa2",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pa2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pa3",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pa3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pa3",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pa3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "parseIntString",
          "package": "uu-parsinglib",
          "signature": "Parser [String]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#parseIntString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "parseIntString",
          "normalized": "Parser[String]",
          "package": "uu-parsinglib",
          "partial": "Int String",
          "signature": "Parser[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:parseIntString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "paz",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#paz",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "paz",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:paz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pb",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pb",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pc",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#pc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "pc",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:pc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fuction \u003ccode\u003e\u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e runs the parser and shows both the result, and the correcting steps which were taken during the parsing process.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "run",
          "package": "uu-parsinglib",
          "signature": "Parser t -\u003e String -\u003e IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#run",
          "type": "function"
        },
        "index": {
          "description": "The fuction run runs the parser and shows both the result and the correcting steps which were taken during the parsing process",
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "run",
          "normalized": "Parser a-\u003eString-\u003eIO()",
          "package": "uu-parsinglib",
          "signature": "Parser t-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "run'",
          "package": "uu-parsinglib",
          "signature": "P (Str a s LineColPos) a1 -\u003e s -\u003e IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#run%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "run'",
          "normalized": "P(Str a b LineColPos)a-\u003eb-\u003eIO()",
          "package": "uu-parsinglib",
          "signature": "P(Str a s LineColPos)a-\u003es-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:run-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "same_prio",
          "package": "uu-parsinglib",
          "signature": "[(b, a)] -\u003e P (Str b state loc) a",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#same_prio",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "same_prio",
          "normalized": "[(a,b)]-\u003eP(Str a c d)b",
          "package": "uu-parsinglib",
          "signature": "[(b,a)]-\u003eP(Str b state loc)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:same_prio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRunning the function \u003ccode\u003e\u003ca\u003eshow_demos\u003c/a\u003e\u003c/code\u003e should give the following output:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun pa  \"a\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"a\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun pa  \"\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"a\"\n Correcting steps: \n   Inserted  'a' at position LineColPos 0 0 0 expecting 'a'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun pa  \"b\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"a\"\n Correcting steps: \n   Deleted   'b' at position LineColPos 0 0 0 expecting 'a'\n   Inserted  'a' at position LineColPos 0 1 1 expecting 'a'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun ((++) \u003c$\u003e pa \u003c*\u003e pa)  \"bbab\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"aa\"\n Correcting steps: \n   Deleted   'b' at position LineColPos 0 0 0 expecting 'a'\n   Deleted   'b' at position LineColPos 0 1 1 expecting 'a'\n   Deleted   'b' at position LineColPos 0 3 3 expecting 'a'\n   Inserted  'a' at position LineColPos 0 4 4 expecting 'a'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun pa  \"ba\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"a\"\n Correcting steps: \n   Deleted   'b' at position LineColPos 0 0 0 expecting 'a'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun pa  \"aa\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"a\"\n Correcting steps: \n   The token 'a' was not consumed by the parsing process.\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (pCount pa :: Parser Int)  \"aaa\"\n\u003c/code\u003e\u003c/strong\u003e Result: 3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (do  {l \u003c- pCount pa; pExact l pb})  \"aaacabbbbb\"\n\u003c/code\u003e\u003c/strong\u003e Result: [\"b\",\"b\",\"b\",\"b\"]\n Correcting steps: \n   Deleted   'c' at position LineColPos 0 3 3 expecting one of ['b', 'a']\n   The token 'b' was not consumed by the parsing process.\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (amb ( (++) \u003c$\u003e pa2 \u003c*\u003e pa3 \u003c|\u003e (++) \u003c$\u003e pa3 \u003c*\u003e pa2))  \"aaaaa\"\n\u003c/code\u003e\u003c/strong\u003e Result: [\"aaaaa\",\"aaaaa\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (pList pLower)  \"doaitse\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"doaitse\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun paz  \"abc2ez\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"abcez\"\n Correcting steps: \n   Deleted   '2' at position LineColPos 0 3 3 expecting 'a'..'z'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (max \u003c$\u003e pParens ((+1) \u003c$\u003e wfp) \u003c*\u003e wfp `opt` 0)  \"((()))()(())\"\n\u003c/code\u003e\u003c/strong\u003e Result: 3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (pa \u003c|\u003e pb \u003c?\u003e justamessage)  \"c\"\n\u003c/code\u003e\u003c/strong\u003e Result: \"b\"\n Correcting steps: \n   Deleted   'c' at position LineColPos 0 0 0 expecting justamessage\n   Inserted  'b' at position LineColPos 0 1 1 expecting 'b'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (amb (pEither  parseIntString  pIntList))  \"(123;456;789)\"\n\u003c/code\u003e\u003c/strong\u003e Result: [Left [\"123\",\"456\",\"789\"],Right [123,456,789]]\n\u003c/pre\u003e",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "show_demos",
          "package": "uu-parsinglib",
          "signature": "IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#show_demos",
          "type": "function"
        },
        "index": {
          "description": "Running the function show demos should give the following output run pa Result run pa Result Correcting steps Inserted at position LineColPos expecting run pa Result Correcting steps Deleted at position LineColPos expecting Inserted at position LineColPos expecting run pa pa bbab Result aa Correcting steps Deleted at position LineColPos expecting Deleted at position LineColPos expecting Deleted at position LineColPos expecting Inserted at position LineColPos expecting run pa ba Result Correcting steps Deleted at position LineColPos expecting run pa aa Result Correcting steps The token was not consumed by the parsing process run pCount pa Parser Int aaa Result run do pCount pa pExact pb aaacabbbbb Result Correcting steps Deleted at position LineColPos expecting one of The token was not consumed by the parsing process run amb pa2 pa3 pa3 pa2 aaaaa Result aaaaa aaaaa run pList pLower doaitse Result doaitse run paz abc2ez Result abcez Correcting steps Deleted at position LineColPos expecting run max pParens wfp wfp opt Result run pa pb justamessage Result Correcting steps Deleted at position LineColPos expecting justamessage Inserted at position LineColPos expecting run amb pEither parseIntString pIntList Result Left Right",
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "show_demos",
          "normalized": "IO()",
          "package": "uu-parsinglib",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:show_demos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "simpleComment",
          "package": "uu-parsinglib",
          "signature": "P (Str Char state loc) [Char]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#simpleComment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "simpleComment",
          "normalized": "P(Str Char a b)[Char]",
          "package": "uu-parsinglib",
          "partial": "Comment",
          "signature": "P(Str Char state loc)[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:simpleComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "spaces",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#spaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "spaces",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:spaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "string",
          "package": "uu-parsinglib",
          "signature": "String -\u003e P (Str Char state loc) String",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#string",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "string",
          "normalized": "String-\u003eP(Str Char a b)String",
          "package": "uu-parsinglib",
          "signature": "String-\u003eP(Str Char state loc)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "takes_second_alt",
          "package": "uu-parsinglib",
          "signature": "P (Str Char String LineColPos) [[Char]]",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#takes_second_alt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "takes_second_alt",
          "normalized": "P(Str Char String LineColPos)[[Char]]",
          "package": "uu-parsinglib",
          "signature": "P(Str Char String LineColPos)[[Char]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:takes_second_alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is very easy to recognise infix expressions with any number of priorities and operators:\n\u003c/p\u003e\u003cpre\u003e operators       = [[('+', (+)), ('-', (-))],  [('*' , (*))], [('^', (^))]]\n same_prio  ops  = msum [ op \u003c$ pSym c | (c, op) \u003c- ops]\n expr            = foldr pChainl ( pNatural \u003c|\u003e pParens expr) (map same_prio operators) -- \n\u003c/pre\u003e\u003cp\u003ewhich we can call:  \n\u003c/p\u003e\u003cpre\u003e run expr \"15-3*5+2^5\"\n\u003c/pre\u003e\u003cpre\u003e Result: 32\n\u003c/pre\u003e\u003cp\u003eNote that also here correction takes place: \n\u003c/p\u003e\u003cpre\u003e run expr \"2 + + 3 5\"\n\u003c/pre\u003e\u003cpre\u003e Result: 37\n Correcting steps: \n    Deleted  ' ' at position 1 expecting one of ['0'..'9', '^', '*', '-', '+']\n    Deleted  ' ' at position 3 expecting one of ['(', '0'..'9']\n    Inserted '0' at position 4 expecting '0'..'9'\n    Deleted  ' ' at position 5 expecting one of ['(', '0'..'9']\n    Deleted  ' ' at position 7 expecting one of ['0'..'9', '^', '*', '-', '+']\n\u003c/pre\u003e",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test11",
          "package": "uu-parsinglib",
          "signature": "IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#test11",
          "type": "function"
        },
        "index": {
          "description": "It is very easy to recognise infix expressions with any number of priorities and operators operators same prio ops msum op pSym op ops expr foldr pChainl pNatural pParens expr map same prio operators which we can call run expr Result Note that also here correction takes place run expr Result Correcting steps Deleted at position expecting one of Deleted at position expecting one of Inserted at position expecting Deleted at position expecting one of Deleted at position expecting one of",
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test11",
          "normalized": "IO()",
          "package": "uu-parsinglib",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:test11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test13",
          "package": "uu-parsinglib",
          "signature": "IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#test13",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test13",
          "normalized": "IO()",
          "package": "uu-parsinglib",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:test13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test14",
          "package": "uu-parsinglib",
          "signature": "IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#test14",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test14",
          "normalized": "IO()",
          "package": "uu-parsinglib",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:test14"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA common case where ambiguity arises is when we e.g. want to recognise identifiers, \n   but only those which are not keywords. \n   The combinator \u003ccode\u003e\u003ca\u003emicro\u003c/a\u003e\u003c/code\u003e inserts steps with a specfied cost in the result \n   of the parser which can be used to disambiguate:\n\u003c/p\u003e\u003cpre\u003e \n ident ::  Parser String\n ident = ((:) \u003c$\u003e pSym ('a','z') \u003c*\u003e pMunch (\\x -\u003e 'a' \u003c= x && x \u003c= 'z') `micro` 2) \u003c* spaces\n idents = pList1 ident\n pKey keyw = pToken keyw `micro` 1 \u003c* spaces\n spaces :: Parser String\n spaces = pMunch (==' ')\n takes_second_alt =   pList ident \n                \\\u003c|\u003e (\\ c t e -\u003e [\"IfThenElse\"] ++  c   ++  t  ++  e) \n                    \\\u003c$ pKey \"if\"   \u003c*\u003e pList_ng ident \n                    \\\u003c* pKey \"then\" \u003c*\u003e pList_ng ident\n                    \\\u003c* pKey \"else\" \u003c*\u003e pList_ng ident  \n\u003c/pre\u003e\u003cp\u003eA keyword is followed by a small cost \u003ccode\u003e1\u003c/code\u003e, which makes sure that \n  identifiers which have a keyword as a prefix win over the keyword. Identifiers are however\n   followed by a cost \u003ccode\u003e2\u003c/code\u003e, with as result that in this case the keyword wins. \n   Note that a limitation of this approach is that keywords are only recognised as such when expected!\n\u003c/p\u003e\u003cpre\u003e test13 = run takes_second_alt \"if a then if else c\"\n test14 = run takes_second_alt \"ifx a then if else c\"\n\u003c/pre\u003e\u003cp\u003ewith results for \u003ccode\u003etest13\u003c/code\u003e and \u003ccode\u003etest14\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e Result: [\"IfThenElse\",\"a\",\"if\",\"c\"]\n Result: [\"ifx\",\"a\",\"then\",\"if\", \"else\",\"c\"]\n\u003c/pre\u003e\u003cp\u003eA mistake which is made quite often is to construct  a parser which can recognise a sequence of elements using one of the \n  derived combinators (say \u003ccode\u003e\u003ccode\u003e\u003ca\u003epList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e), but where the argument parser can recognise the empty string. \n  The derived combinators check whether this is the case and terminate the parsing process with an error message:\n\u003c/p\u003e\u003cpre\u003e run (pList spaces) \"\"\n Result: *** Exception: The combinator pList\n  requires that it's argument cannot recognise the empty string\n\u003c/pre\u003e\u003cpre\u003e run (pMaybe spaces) \" \"\n Result: *** Exception: The combinator pMaybe\n requires that it's argument cannot recognise the empty string\n\u003c/pre\u003e",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test16",
          "package": "uu-parsinglib",
          "signature": "IO ()",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#test16",
          "type": "function"
        },
        "index": {
          "description": "common case where ambiguity arises is when we e.g want to recognise identifiers but only those which are not keywords The combinator micro inserts steps with specfied cost in the result of the parser which can be used to disambiguate ident Parser String ident pSym pMunch micro spaces idents pList1 ident pKey keyw pToken keyw micro spaces spaces Parser String spaces pMunch takes second alt pList ident IfThenElse pKey if pList ng ident pKey then pList ng ident pKey else pList ng ident keyword is followed by small cost which makes sure that identifiers which have keyword as prefix win over the keyword Identifiers are however followed by cost with as result that in this case the keyword wins Note that limitation of this approach is that keywords are only recognised as such when expected test13 run takes second alt if then if else test14 run takes second alt ifx then if else with results for test13 and test14 Result IfThenElse if Result ifx then if else mistake which is made quite often is to construct parser which can recognise sequence of elements using one of the derived combinators say pList but where the argument parser can recognise the empty string The derived combinators check whether this is the case and terminate the parsing process with an error message run pList spaces Result Exception The combinator pList requires that it argument cannot recognise the empty string run pMaybe spaces Result Exception The combinator pMaybe requires that it argument cannot recognise the empty string",
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "test16",
          "normalized": "IO()",
          "package": "uu-parsinglib",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:test16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe applicative style makes it very easy to merge recogition and computing a result. \n   As an example we parse a sequence of nested well formed parentheses pairs and\n   compute the maximum nesting depth with \u003ccode\u003e\u003ccode\u003e\u003ca\u003ewfp\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e: \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "wfp",
          "package": "uu-parsinglib",
          "signature": "Parser Int",
          "source": "src/Text-ParserCombinators-UU-Demo-Examples.html#wfp",
          "type": "function"
        },
        "index": {
          "description": "The applicative style makes it very easy to merge recogition and computing result As an example we parse sequence of nested well formed parentheses pairs and compute the maximum nesting depth with wfp",
          "hierarchy": "Text ParserCombinators UU Demo Examples",
          "module": "Text.ParserCombinators.UU.Demo.Examples",
          "name": "wfp",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Demo-Examples.html#v:wfp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains a large variety of combinators for list-like structures. the extension \u003ccode\u003e_ng\u003c/code\u003e indicates that \n   that variant is the non-greedy variant.\n   See the \u003ca\u003eText.ParserCombinators.UU.Demo.Examples\u003c/a\u003e module for some examples of their use.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "Derived",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Derived.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains large variety of combinators for list-like structures the extension ng indicates that that variant is the non-greedy variant See the Text.ParserCombinators.UU.Demo.Examples module for some examples of their use",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "Derived",
          "package": "uu-parsinglib",
          "partial": "Derived",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003c$$\u003e\u003c/a\u003e\u003c/code\u003e is the version of \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e which flips the function argument \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "(\u003c$$\u003e)",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e b -\u003e c) -\u003e p b -\u003e p (a -\u003e c)",
          "source": "src/Text-ParserCombinators-UU-Derived.html#%3C%24%24%3E",
          "type": "function"
        },
        "index": {
          "description": "is the version of which flips the function argument",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "(\u003c$$\u003e) \u003c$$\u003e",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed b-\u003ed(a-\u003ec)",
          "package": "uu-parsinglib",
          "signature": "(a-\u003eb-\u003ec)-\u003ep b-\u003ep(a-\u003ec)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:-60--36--36--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003e\u003c??\u003e\u003c/a\u003e\u003c/code\u003e parses an optional postfix element and applies its result to its left hand result\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "(\u003c??\u003e)",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p (a -\u003e a) -\u003e p a",
          "source": "src/Text-ParserCombinators-UU-Derived.html#%3C%3F%3F%3E",
          "type": "function"
        },
        "index": {
          "description": "parses an optional postfix element and applies its result to its left hand result",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "(\u003c??\u003e) \u003c??\u003e",
          "normalized": "a b-\u003ea(b-\u003eb)-\u003ea b",
          "package": "uu-parsinglib",
          "signature": "p a-\u003ep(a-\u003ea)-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:-60--63--63--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "list_alg",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e [a] -\u003e [a], [a1])",
          "source": "src/Text-ParserCombinators-UU-Derived.html#list_alg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "list_alg",
          "normalized": "(a-\u003e[a]-\u003e[a],[a])",
          "package": "uu-parsinglib",
          "signature": "(a-\u003e[a]-\u003e[a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:list_alg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a parser for each element in the argument list and try them all.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pAny",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e p a1) -\u003e [a] -\u003e p a1",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pAny",
          "type": "function"
        },
        "index": {
          "description": "Build parser for each element in the argument list and try them all",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pAny",
          "normalized": "(a-\u003eb a)-\u003e[a]-\u003eb a",
          "package": "uu-parsinglib",
          "partial": "Any",
          "signature": "(a-\u003ep a)-\u003e[a]-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pAny"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pAtLeast",
          "package": "uu-parsinglib",
          "signature": "Int -\u003e f a -\u003e f [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pAtLeast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pAtLeast",
          "normalized": "Int-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "At Least",
          "signature": "Int-\u003ef a-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pAtMost",
          "package": "uu-parsinglib",
          "signature": "Int -\u003e f a -\u003e f [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pAtMost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pAtMost",
          "normalized": "Int-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "At Most",
          "signature": "Int-\u003ef a-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pAtMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pBetween",
          "package": "uu-parsinglib",
          "signature": "Int -\u003e Int -\u003e f a -\u003e f [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pBetween",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pBetween",
          "normalized": "Int-\u003eInt-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "Between",
          "signature": "Int-\u003eInt-\u003ef a-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainl",
          "package": "uu-parsinglib",
          "signature": "p (c -\u003e c -\u003e c) -\u003e p c -\u003e p c",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pChainl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainl",
          "normalized": "a(b-\u003eb-\u003eb)-\u003ea b-\u003ea b",
          "package": "uu-parsinglib",
          "partial": "Chainl",
          "signature": "p(c-\u003ec-\u003ec)-\u003ep c-\u003ep c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pChainl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainl_ng",
          "package": "uu-parsinglib",
          "signature": "p (c -\u003e c -\u003e c) -\u003e p c -\u003e p c",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pChainl_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainl_ng",
          "normalized": "a(b-\u003eb-\u003eb)-\u003ea b-\u003ea b",
          "package": "uu-parsinglib",
          "partial": "Chainl",
          "signature": "p(c-\u003ec-\u003ec)-\u003ep c-\u003ep c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pChainl_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainr",
          "package": "uu-parsinglib",
          "signature": "p (c -\u003e c -\u003e c) -\u003e p c -\u003e p c",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pChainr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainr",
          "normalized": "a(b-\u003eb-\u003eb)-\u003ea b-\u003ea b",
          "package": "uu-parsinglib",
          "partial": "Chainr",
          "signature": "p(c-\u003ec-\u003ec)-\u003ep c-\u003ep c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pChainr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainr_ng",
          "package": "uu-parsinglib",
          "signature": "p (c -\u003e c -\u003e c) -\u003e p c -\u003e p c",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pChainr_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pChainr_ng",
          "normalized": "a(b-\u003eb-\u003eb)-\u003ea b-\u003ea b",
          "package": "uu-parsinglib",
          "partial": "Chainr",
          "signature": "p(c-\u003ec-\u003ec)-\u003ep c-\u003ep c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pChainr_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount the number of times \u003ccode\u003ep\u003c/code\u003e has succeeded\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pCount",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p b",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pCount",
          "type": "function"
        },
        "index": {
          "description": "Count the number of times has succeeded",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pCount",
          "normalized": "a b-\u003ea c",
          "package": "uu-parsinglib",
          "partial": "Count",
          "signature": "p a-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epEither\u003c/a\u003e\u003c/code\u003e recognises either one of its arguments.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pEither",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p b -\u003e p (Either a b)",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pEither",
          "type": "function"
        },
        "index": {
          "description": "pEither recognises either one of its arguments",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pEither",
          "normalized": "a b-\u003ea c-\u003ea(Either b c)",
          "package": "uu-parsinglib",
          "partial": "Either",
          "signature": "p a-\u003ep b-\u003ep(Either a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epExact\u003c/a\u003e\u003c/code\u003e recognises a specified number of elements\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pExact",
          "package": "uu-parsinglib",
          "signature": "Int -\u003e f a -\u003e f [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pExact",
          "type": "function"
        },
        "index": {
          "description": "pExact recognises specified number of elements",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pExact",
          "normalized": "Int-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "Exact",
          "signature": "Int-\u003ef a-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pExact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003epFail\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is defined for upwards compatibility, and is the unit for \u003ccode\u003e\u003ca\u003e|\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFail",
          "package": "uu-parsinglib",
          "signature": "p a",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFail",
          "type": "function"
        },
        "index": {
          "description": "pFail is defined for upwards compatibility and is the unit for",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFail",
          "package": "uu-parsinglib",
          "partial": "Fail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e a1 -\u003e a1, a1) -\u003e p a -\u003e p a1",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr",
          "normalized": "(a-\u003ea-\u003ea,a)-\u003eb a-\u003eb a",
          "package": "uu-parsinglib",
          "partial": "Foldr",
          "signature": "(a-\u003ea-\u003ea,a)-\u003ep a-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1",
          "package": "uu-parsinglib",
          "signature": "(v -\u003e b -\u003e b, b) -\u003e p v -\u003e p b",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldr1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1",
          "normalized": "(a-\u003eb-\u003eb,b)-\u003ec a-\u003ec b",
          "package": "uu-parsinglib",
          "partial": "Foldr",
          "signature": "(v-\u003eb-\u003eb,b)-\u003ep v-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1Sep",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e b -\u003e b, b) -\u003e p a1 -\u003e p a -\u003e p b",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldr1Sep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1Sep",
          "normalized": "(a-\u003eb-\u003eb,b)-\u003ec a-\u003ec a-\u003ec b",
          "package": "uu-parsinglib",
          "partial": "Foldr Sep",
          "signature": "(a-\u003eb-\u003eb,b)-\u003ep a-\u003ep a-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldr1Sep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1Sep_ng",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e b -\u003e b, b) -\u003e p a1 -\u003e p a -\u003e p b",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldr1Sep_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1Sep_ng",
          "normalized": "(a-\u003eb-\u003eb,b)-\u003ec a-\u003ec a-\u003ec b",
          "package": "uu-parsinglib",
          "partial": "Foldr Sep",
          "signature": "(a-\u003eb-\u003eb,b)-\u003ep a-\u003ep a-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldr1Sep_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1_ng",
          "package": "uu-parsinglib",
          "signature": "(v -\u003e b -\u003e b, b) -\u003e p v -\u003e p b",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldr1_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr1_ng",
          "normalized": "(a-\u003eb-\u003eb,b)-\u003ec a-\u003ec b",
          "package": "uu-parsinglib",
          "partial": "Foldr",
          "signature": "(v-\u003eb-\u003eb,b)-\u003ep v-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldr1_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldrSep",
          "package": "uu-parsinglib",
          "signature": "(v -\u003e b -\u003e b, b) -\u003e p a -\u003e p v -\u003e p b",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldrSep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldrSep",
          "normalized": "(a-\u003eb-\u003eb,b)-\u003ec d-\u003ec a-\u003ec b",
          "package": "uu-parsinglib",
          "partial": "Foldr Sep",
          "signature": "(v-\u003eb-\u003eb,b)-\u003ep a-\u003ep v-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldrSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldrSep_ng",
          "package": "uu-parsinglib",
          "signature": "(v -\u003e b -\u003e b, b) -\u003e p a -\u003e p v -\u003e p b",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldrSep_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldrSep_ng",
          "normalized": "(a-\u003eb-\u003eb,b)-\u003ec d-\u003ec a-\u003ec b",
          "package": "uu-parsinglib",
          "partial": "Foldr Sep",
          "signature": "(v-\u003eb-\u003eb,b)-\u003ep a-\u003ep v-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldrSep_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr_ng",
          "package": "uu-parsinglib",
          "signature": "(a -\u003e a1 -\u003e a1, a1) -\u003e p a -\u003e p a1",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pFoldr_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pFoldr_ng",
          "normalized": "(a-\u003ea-\u003ea,a)-\u003eb a-\u003eb a",
          "package": "uu-parsinglib",
          "partial": "Foldr",
          "signature": "(a-\u003ea-\u003ea,a)-\u003ep a-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pFoldr_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList",
          "normalized": "a b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List",
          "signature": "p a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pList1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1",
          "normalized": "a b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List",
          "signature": "p a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pList1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1Sep",
          "package": "uu-parsinglib",
          "signature": "p a1 -\u003e p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pList1Sep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1Sep",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List Sep",
          "signature": "p a-\u003ep a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pList1Sep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1Sep_ng",
          "package": "uu-parsinglib",
          "signature": "p a1 -\u003e p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pList1Sep_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1Sep_ng",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List Sep",
          "signature": "p a-\u003ep a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pList1Sep_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1_ng",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pList1_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList1_ng",
          "normalized": "a b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List",
          "signature": "p a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pList1_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pListSep",
          "package": "uu-parsinglib",
          "signature": "p a1 -\u003e p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pListSep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pListSep",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List Sep",
          "signature": "p a-\u003ep a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pListSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pListSep_ng",
          "package": "uu-parsinglib",
          "signature": "p a1 -\u003e p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pListSep_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pListSep_ng",
          "normalized": "a b-\u003ea b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List Sep",
          "signature": "p a-\u003ep a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pListSep_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList_ng",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pList_ng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pList_ng",
          "normalized": "a b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "List",
          "signature": "p a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pList_ng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epMany\u003c/a\u003e\u003c/code\u003e is equivalent to the \u003ccode\u003e\u003ca\u003emany\u003c/a\u003e\u003c/code\u003e from \u003ca\u003eControl.Applicative\u003c/a\u003e. We want however all our parsers to start with a lower case \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pMany",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pMany",
          "type": "function"
        },
        "index": {
          "description": "pMany is equivalent to the many from Control.Applicative We want however all our parsers to start with lower case",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pMany",
          "normalized": "a b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "Many",
          "signature": "p a-\u003ep[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epMaybe\u003c/a\u003e\u003c/code\u003e greedily recognises its argument. If not \u003ccode\u003eNothing\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pMaybe",
          "package": "uu-parsinglib",
          "signature": "p a -\u003e p (Maybe a)",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pMaybe",
          "type": "function"
        },
        "index": {
          "description": "pMaybe greedily recognises its argument If not Nothing is returned",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pMaybe",
          "normalized": "a b-\u003ea(Maybe b)",
          "package": "uu-parsinglib",
          "partial": "Maybe",
          "signature": "p a-\u003ep(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003epPacked\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e surrounds its third parser with the first and the second one, returning only the middle result\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pPacked",
          "package": "uu-parsinglib",
          "signature": "p b1 -\u003e p b2 -\u003e p a -\u003e p a",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pPacked",
          "type": "function"
        },
        "index": {
          "description": "pPacked surrounds its third parser with the first and the second one returning only the middle result",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pPacked",
          "normalized": "a b-\u003ea b-\u003ea c-\u003ea c",
          "package": "uu-parsinglib",
          "partial": "Packed",
          "signature": "p b-\u003ep b-\u003ep a-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pPacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003epReturn\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is defined for upwards compatibility\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pReturn",
          "package": "uu-parsinglib",
          "signature": "a -\u003e p a",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pReturn",
          "type": "function"
        },
        "index": {
          "description": "pReturn is defined for upwards compatibility",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pReturn",
          "normalized": "a-\u003eb a",
          "package": "uu-parsinglib",
          "partial": "Return",
          "signature": "a-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pReturn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epSome\u003c/a\u003e\u003c/code\u003e is equivalent to the \u003ccode\u003e\u003ca\u003esome\u003c/a\u003e\u003c/code\u003e from \u003ca\u003eControl.Applicative\u003c/a\u003e. We want however all our parsers to start with a lower case \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pSome",
          "package": "uu-parsinglib",
          "signature": "f a -\u003e f [a]",
          "source": "src/Text-ParserCombinators-UU-Derived.html#pSome",
          "type": "function"
        },
        "index": {
          "description": "pSome is equivalent to the some from Control.Applicative We want however all our parsers to start with lower case",
          "hierarchy": "Text ParserCombinators UU Derived",
          "module": "Text.ParserCombinators.UU.Derived",
          "name": "pSome",
          "normalized": "a b-\u003ea[b]",
          "package": "uu-parsinglib",
          "partial": "Some",
          "signature": "f a-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Derived.html#v:pSome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Idioms",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Idioms",
          "package": "uu-parsinglib",
          "partial": "Idioms",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "ELSE",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#ELSE",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "ELSE",
          "package": "uu-parsinglib",
          "partial": "ELSE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:ELSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "FI",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#FI",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "FI",
          "package": "uu-parsinglib",
          "partial": "FI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:FI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "IF",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#IF",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "IF",
          "package": "uu-parsinglib",
          "partial": "IF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:IF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Idiomatic",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#Idiomatic",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Idiomatic",
          "package": "uu-parsinglib",
          "partial": "Idiomatic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:Idiomatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe  \u003ccode\u003e\u003ca\u003eIi\u003c/a\u003e\u003c/code\u003e is to be pronounced as \u003ccode\u003estop\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Ii",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#Ii",
          "type": "data"
        },
        "index": {
          "description": "The Ii is to be pronounced as stop",
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Ii",
          "package": "uu-parsinglib",
          "partial": "Ii",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:Ii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "OR",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#OR",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "OR",
          "package": "uu-parsinglib",
          "partial": "OR",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:OR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "String'",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#String%27",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "String'",
          "package": "uu-parsinglib",
          "partial": "String'",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:String-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "THEN",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#THEN",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "THEN",
          "package": "uu-parsinglib",
          "partial": "THEN",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#t:THEN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "ELSE",
          "package": "uu-parsinglib",
          "signature": "ELSE",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#ELSE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "ELSE",
          "package": "uu-parsinglib",
          "partial": "ELSE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:ELSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "FI",
          "package": "uu-parsinglib",
          "signature": "FI",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#FI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "FI",
          "package": "uu-parsinglib",
          "partial": "FI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:FI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "IF",
          "package": "uu-parsinglib",
          "signature": "IF",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#IF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "IF",
          "package": "uu-parsinglib",
          "partial": "IF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:IF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Ii",
          "package": "uu-parsinglib",
          "signature": "Ii",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#Ii",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "Ii",
          "package": "uu-parsinglib",
          "partial": "Ii",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:Ii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "OR",
          "package": "uu-parsinglib",
          "signature": "OR",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#OR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "OR",
          "package": "uu-parsinglib",
          "partial": "OR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:OR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "String'",
          "package": "uu-parsinglib",
          "signature": "String'",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#String%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "String'",
          "package": "uu-parsinglib",
          "partial": "String'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:String-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "THEN",
          "package": "uu-parsinglib",
          "signature": "THEN",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#THEN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "THEN",
          "package": "uu-parsinglib",
          "partial": "THEN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:THEN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "fromStr",
          "package": "uu-parsinglib",
          "signature": "String",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#String%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "fromStr",
          "package": "uu-parsinglib",
          "partial": "Str",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:fromStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eiI\u003c/a\u003e\u003c/code\u003e is to be pronounced as \u003ccode\u003estart\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "iI",
          "package": "uu-parsinglib",
          "signature": "g",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#iI",
          "type": "function"
        },
        "index": {
          "description": "The function iI is to be pronounced as start",
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "iI",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:iI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "idiomatic",
          "package": "uu-parsinglib",
          "signature": "P st f -\u003e g",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#idiomatic",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "idiomatic",
          "normalized": "P a b-\u003ec",
          "package": "uu-parsinglib",
          "signature": "P st f-\u003eg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:idiomatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe idea of the Idiom concept is that  sequential composition operators can be inferred from the type \n   of the various operands\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erun (iI (+) '(' pNatural \"plus\"  pNatural ')' Ii) \"(2 plus 3\"\n\u003c/code\u003e\u003c/strong\u003e  Result: 5\n   Correcting steps: \n     Inserted  ')' at position LineColPos 0 4 4 expecting one of [')', Whitespace, '0'..'9']\n\u003c/pre\u003e",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "pNat",
          "package": "uu-parsinglib",
          "signature": "Parser Int",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#pNat",
          "type": "function"
        },
        "index": {
          "description": "The idea of the Idiom concept is that sequential composition operators can be inferred from the type of the various operands run iI pNatural plus pNatural Ii plus Result Correcting steps Inserted at position LineColPos expecting one of Whitespace",
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "pNat",
          "package": "uu-parsinglib",
          "partial": "Nat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:pNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "show_demos",
          "package": "uu-parsinglib",
          "signature": "IO ()",
          "source": "src/Text-ParserCombinators-UU-Idioms.html#show_demos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Idioms",
          "module": "Text.ParserCombinators.UU.Idioms",
          "name": "show_demos",
          "normalized": "IO()",
          "package": "uu-parsinglib",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Idioms.html#v:show_demos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains the additional data types, instance definitions and functions to run parsers in an interleaved way.\n   If all the interleaved parsers recognise a single connected piece of the input text this incorporates the permutation parsers.\n   For some examples see the module \u003ca\u003eText.ParserCombinators.UU.Demo.MergeAndPermute\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.Interleaved",
          "name": "Interleaved",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Interleaved.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains the additional data types instance definitions and functions to run parsers in an interleaved way If all the interleaved parsers recognise single connected piece of the input text this incorporates the permutation parsers For some examples see the module Text.ParserCombinators.UU.Demo.MergeAndPermute",
          "hierarchy": "Text ParserCombinators UU Interleaved",
          "module": "Text.ParserCombinators.UU.Interleaved",
          "name": "Interleaved",
          "package": "uu-parsinglib",
          "partial": "Interleaved",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Interleaved.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edoNotInterpret\u003c/a\u003e\u003c/code\u003e forgets the computed minimal number of tokens recognised by this parser\n    which  makes a parser opaque for abstract interpretation; used when interleaving parsers\n    where we do not want to compare lengths.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Interleaved",
          "name": "doNotInterpret",
          "package": "uu-parsinglib",
          "signature": "P st a -\u003e P st a",
          "source": "src/Text-ParserCombinators-UU-Interleaved.html#doNotInterpret",
          "type": "function"
        },
        "index": {
          "description": "doNotInterpret forgets the computed minimal number of tokens recognised by this parser which makes parser opaque for abstract interpretation used when interleaving parsers where we do not want to compare lengths",
          "hierarchy": "Text ParserCombinators UU Interleaved",
          "module": "Text.ParserCombinators.UU.Interleaved",
          "name": "doNotInterpret",
          "normalized": "P a b-\u003eP a b",
          "package": "uu-parsinglib",
          "partial": "Not Interpret",
          "signature": "P st a-\u003eP st a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Interleaved.html#v:doNotInterpret"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Interleaved",
          "name": "mkP",
          "package": "uu-parsinglib",
          "signature": "Gram (P st) a -\u003e P st a",
          "source": "src/Text-ParserCombinators-UU-Interleaved.html#mkP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Interleaved",
          "module": "Text.ParserCombinators.UU.Interleaved",
          "name": "mkP",
          "normalized": "Gram(P a)b-\u003eP a b",
          "package": "uu-parsinglib",
          "signature": "Gram(P st)a-\u003eP st a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Interleaved.html#v:mkP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains some background information about a completely new version of the Utrecht parser combinator library.\n\u003c/p\u003e\u003cp\u003eBackground material\n\u003c/p\u003e\u003cp\u003eThe library is based on ideas described in the paper:\n\u003c/p\u003e\u003cp\u003e@inproceedings{uuparsing:piriapolis, Author = {Swierstra, S.~Doaitse},  Booktitle = {Language Engineering and Rigorous Software Development}, Editor = {Bove, A. and Barbosa, L. and Pardo, A. and and Sousa Pinto, J.}, Pages = {252-300}, Place = {Piriapolis},  Publisher = {Spinger}, Series = {LNCS}, Title = {Combinator Parsers: a short tutorial},  Volume = {5520}, Year = {2009}}\n\u003c/p\u003e\u003cp\u003ewhich is also available as a technical report from \u003ca\u003ehttp://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe first part of this report is a general introduction to parser combinators, whereas the second part contains the \n   motivation for and documentation of the current package.\n\u003c/p\u003e\u003cp\u003eWe appreciate if you include a reference to the above documentation in any publication describing software in which you have used the library succesfully.\n\u003c/p\u003e\u003cp\u003eAny feedback on particular use of the library, and suggestions for extensions, are welcome at \u003ca\u003emailto:doaitse@swierstra.net\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.README",
          "name": "README",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-README.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains some background information about completely new version of the Utrecht parser combinator library Background material The library is based on ideas described in the paper inproceedings uuparsing piriapolis Author Swierstra Doaitse Booktitle Language Engineering and Rigorous Software Development Editor Bove and Barbosa and Pardo and and Sousa Pinto Pages Place Piriapolis Publisher Spinger Series LNCS Title Combinator Parsers short tutorial Volume Year which is also available as technical report from http www.cs.uu.nl research techreps repo CS-2008 pdf The first part of this report is general introduction to parser combinators whereas the second part contains the motivation for and documentation of the current package We appreciate if you include reference to the above documentation in any publication describing software in which you have used the library succesfully Any feedback on particular use of the library and suggestions for extensions are welcome at mailto doaitse@swierstra.net",
          "hierarchy": "Text ParserCombinators UU README",
          "module": "Text.ParserCombinators.UU.README",
          "name": "README",
          "package": "uu-parsinglib",
          "partial": "README",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-README.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides some higher-level types and infrastructure to  make it easier to use.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "Utils",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides some higher-level types and infrastructure to make it easier to use",
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "Utils",
          "package": "uu-parsinglib",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lower-level interface. Returns all errors. \n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "execParser",
          "package": "uu-parsinglib",
          "signature": "Parser a -\u003e String -\u003e (a, [Error LineColPos])",
          "source": "src/Text-ParserCombinators-UU-Utils.html#execParser",
          "type": "function"
        },
        "index": {
          "description": "The lower-level interface Returns all errors",
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "execParser",
          "normalized": "Parser a-\u003eString-\u003e(a,[Error LineColPos])",
          "package": "uu-parsinglib",
          "partial": "Parser",
          "signature": "Parser a-\u003eString-\u003e(a,[Error LineColPos])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:execParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexeme Parsers skip trailing whitespace (this terminology comes from Parsec)\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "lexeme",
          "package": "uu-parsinglib",
          "signature": "ParserTrafo a a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#lexeme",
          "type": "function"
        },
        "index": {
          "description": "Lexeme Parsers skip trailing whitespace this terminology comes from Parsec",
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "lexeme",
          "package": "uu-parsinglib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:lexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeg [1,2,3]\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "listParser",
          "package": "uu-parsinglib",
          "signature": "ParserTrafo a [a]",
          "source": "src/Text-ParserCombinators-UU-Utils.html#listParser",
          "type": "function"
        },
        "index": {
          "description": "eg",
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "listParser",
          "normalized": "ParserTrafo a[a]",
          "package": "uu-parsinglib",
          "partial": "Parser",
          "signature": "ParserTrafo a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:listParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pAnySym",
          "package": "uu-parsinglib",
          "signature": "String -\u003e P (Str Char state loc) Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pAnySym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pAnySym",
          "normalized": "String-\u003eP(Str Char a b)Char",
          "package": "uu-parsinglib",
          "partial": "Any Sym",
          "signature": "String-\u003eP(Str Char state loc)Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pAnySym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pAscii",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pAscii",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pAscii",
          "package": "uu-parsinglib",
          "partial": "Ascii",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pAscii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pBraces",
          "package": "uu-parsinglib",
          "signature": "ParserTrafo a a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pBraces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pBraces",
          "package": "uu-parsinglib",
          "partial": "Braces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pBraces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pBrackets",
          "package": "uu-parsinglib",
          "signature": "ParserTrafo a a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pBrackets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pBrackets",
          "package": "uu-parsinglib",
          "partial": "Brackets",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pBrackets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pCR",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pCR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pCR",
          "package": "uu-parsinglib",
          "partial": "CR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pCR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pComma",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pComma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pComma",
          "package": "uu-parsinglib",
          "partial": "Comma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pComma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDQuote",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDQuote",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDQuote",
          "package": "uu-parsinglib",
          "partial": "DQuote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDay",
          "package": "uu-parsinglib",
          "signature": "Parser Day",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDay",
          "package": "uu-parsinglib",
          "partial": "Day",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDayMonthYear",
          "package": "uu-parsinglib",
          "signature": "Parser (d, Int, y)",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDayMonthYear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDayMonthYear",
          "normalized": "Parser(a,Int,b)",
          "package": "uu-parsinglib",
          "partial": "Day Month Year",
          "signature": "Parser(d,Int,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDayMonthYear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDigit",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDigit",
          "package": "uu-parsinglib",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDigitAsNum",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDigitAsNum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDigitAsNum",
          "package": "uu-parsinglib",
          "partial": "Digit As Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDigitAsNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDot",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDot",
          "package": "uu-parsinglib",
          "partial": "Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDouble",
          "package": "uu-parsinglib",
          "signature": "Parser Double",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDouble",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDouble",
          "package": "uu-parsinglib",
          "partial": "Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDoubleRaw",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDoubleRaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDoubleRaw",
          "package": "uu-parsinglib",
          "partial": "Double Raw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDoubleRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDoubleStr",
          "package": "uu-parsinglib",
          "signature": "Parser [Char]",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pDoubleStr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pDoubleStr",
          "normalized": "Parser[Char]",
          "package": "uu-parsinglib",
          "partial": "Double Str",
          "signature": "Parser[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pDoubleStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pEnum",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pEnum",
          "package": "uu-parsinglib",
          "partial": "Enum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pEnumRaw",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pEnumRaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pEnumRaw",
          "package": "uu-parsinglib",
          "partial": "Enum Raw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pEnumRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pEnumStrs",
          "package": "uu-parsinglib",
          "signature": "[String] -\u003e Parser String",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pEnumStrs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pEnumStrs",
          "normalized": "[String]-\u003eParser String",
          "package": "uu-parsinglib",
          "partial": "Enum Strs",
          "signature": "[String]-\u003eParser String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pEnumStrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pInteger",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pInteger",
          "package": "uu-parsinglib",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pIntegerRaw",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pIntegerRaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pIntegerRaw",
          "package": "uu-parsinglib",
          "partial": "Integer Raw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pIntegerRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLBrace",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pLBrace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLBrace",
          "package": "uu-parsinglib",
          "partial": "LBrace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pLBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLBracket",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pLBracket",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLBracket",
          "package": "uu-parsinglib",
          "partial": "LBracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pLBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLF",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pLF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLF",
          "package": "uu-parsinglib",
          "partial": "LF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pLF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLParen",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pLParen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLParen",
          "package": "uu-parsinglib",
          "partial": "LParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pLParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLetter",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pLetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLetter",
          "package": "uu-parsinglib",
          "partial": "Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLower",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pLower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pLower",
          "package": "uu-parsinglib",
          "partial": "Lower",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pNatural",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pNatural",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pNatural",
          "package": "uu-parsinglib",
          "partial": "Natural",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pNatural"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pNaturalRaw",
          "package": "uu-parsinglib",
          "signature": "Parser a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pNaturalRaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pNaturalRaw",
          "package": "uu-parsinglib",
          "partial": "Natural Raw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pNaturalRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pParens",
          "package": "uu-parsinglib",
          "signature": "ParserTrafo a a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pParens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pParens",
          "package": "uu-parsinglib",
          "partial": "Parens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pParens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pParentheticalString",
          "package": "uu-parsinglib",
          "signature": "Char -\u003e Parser String",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pParentheticalString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pParentheticalString",
          "normalized": "Char-\u003eParser String",
          "package": "uu-parsinglib",
          "partial": "Parenthetical String",
          "signature": "Char-\u003eParser String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pParentheticalString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pPercent",
          "package": "uu-parsinglib",
          "signature": "Parser Double",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pPercent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pPercent",
          "package": "uu-parsinglib",
          "partial": "Percent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pPercent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pQuotedString",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pQuotedString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pQuotedString",
          "package": "uu-parsinglib",
          "partial": "Quoted String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pQuotedString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pRBrace",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pRBrace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pRBrace",
          "package": "uu-parsinglib",
          "partial": "RBrace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pRBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pRBracket",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pRBracket",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pRBracket",
          "package": "uu-parsinglib",
          "partial": "RBracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pRBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pRParen",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pRParen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pRParen",
          "package": "uu-parsinglib",
          "partial": "RParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pRParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pSpaces",
          "package": "uu-parsinglib",
          "signature": "Parser String",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pSpaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pSpaces",
          "package": "uu-parsinglib",
          "partial": "Spaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pSpaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pSymbol",
          "package": "uu-parsinglib",
          "signature": "String -\u003e P (Str Char state loc) String",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pSymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pSymbol",
          "normalized": "String-\u003eP(Str Char a b)String",
          "package": "uu-parsinglib",
          "partial": "Symbol",
          "signature": "String-\u003eP(Str Char state loc)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pTuple",
          "package": "uu-parsinglib",
          "signature": "[P (Str Char state loc) a] -\u003e P (Str Char state loc) [a]",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pTuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pTuple",
          "normalized": "[P(Str Char a b)c]-\u003eP(Str Char a b)[c]",
          "package": "uu-parsinglib",
          "partial": "Tuple",
          "signature": "[P(Str Char state loc)a]-\u003eP(Str Char state loc)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pUpper",
          "package": "uu-parsinglib",
          "signature": "Parser Char",
          "source": "src/Text-ParserCombinators-UU-Utils.html#pUpper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "pUpper",
          "package": "uu-parsinglib",
          "partial": "Upper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:pUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts a UU Parser into a read-style one.\n\u003c/p\u003e\u003cp\u003eThis is intended to facilitate migration from read-style\n parsers to UU-based ones.\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "parserReadsPrec",
          "package": "uu-parsinglib",
          "signature": "Parser a -\u003e Int -\u003e ReadS a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#parserReadsPrec",
          "type": "function"
        },
        "index": {
          "description": "Converts UU Parser into read-style one This is intended to facilitate migration from read-style parsers to UU-based ones",
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "parserReadsPrec",
          "normalized": "Parser a-\u003eInt-\u003eReadS a",
          "package": "uu-parsinglib",
          "partial": "Reads Prec",
          "signature": "Parser a-\u003eInt-\u003eReadS a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:parserReadsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe higher-level interface. (Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e with a simplified error).  \n   Runs the parser; if the complete input is accepted without problems  return the\n   result else fail with reporting unconsumed tokens\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "runParser",
          "package": "uu-parsinglib",
          "signature": "String -\u003e Parser a -\u003e String -\u003e a",
          "source": "src/Text-ParserCombinators-UU-Utils.html#runParser",
          "type": "function"
        },
        "index": {
          "description": "The higher-level interface Calls error with simplified error Runs the parser if the complete input is accepted without problems return the result else fail with reporting unconsumed tokens",
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "runParser",
          "normalized": "String-\u003eParser a-\u003eString-\u003ea",
          "package": "uu-parsinglib",
          "partial": "Parser",
          "signature": "String-\u003eParser a-\u003eString-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:runParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeg (1,2,3)\n\u003c/p\u003e",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "tupleParser",
          "package": "uu-parsinglib",
          "signature": "ParserTrafo a [a]",
          "source": "src/Text-ParserCombinators-UU-Utils.html#tupleParser",
          "type": "function"
        },
        "index": {
          "description": "eg",
          "hierarchy": "Text ParserCombinators UU Utils",
          "module": "Text.ParserCombinators.UU.Utils",
          "name": "tupleParser",
          "normalized": "ParserTrafo a[a]",
          "package": "uu-parsinglib",
          "partial": "Parser",
          "signature": "ParserTrafo a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU-Utils.html#v:tupleParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe non-exported modules in \u003ca\u003eText.ParserCombinators.UU.Demo\u003c/a\u003e contain a list of examples of how to use the main functionality of this library which demonstrates:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e how to write basic parsers\n\u003c/li\u003e\u003cli\u003e how to to write ambiguous parsers\n\u003c/li\u003e\u003cli\u003e how  error correction works\n\u003c/li\u003e\u003cli\u003e how to fine-tune your parsers to get rid of ambiguities\n\u003c/li\u003e\u003cli\u003e how to use the monadic interface\n\u003c/li\u003e\u003cli\u003e what kind of error messages you can expect if you write erroneous parsers\n\u003c/li\u003e\u003cli\u003e how to use the permutating/merging parsers\n\u003c/li\u003e\u003cli\u003e to see the parsers in action load the module \u003ca\u003eText.ParserCombinators.UU.Demo.Examples\u003c/a\u003e or \u003ca\u003eText.ParserCombinators.UU.Demo.MergeAndPermute\u003c/a\u003e in \u003ccode\u003eghci\u003c/code\u003e and type \u003ccode\u003eshow_demos\u003c/code\u003e, while looking at the corresponding code\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.ParserCombinators.UU",
          "name": "UU",
          "package": "uu-parsinglib",
          "source": "src/Text-ParserCombinators-UU.html",
          "type": "module"
        },
        "index": {
          "description": "The non-exported modules in Text.ParserCombinators.UU.Demo contain list of examples of how to use the main functionality of this library which demonstrates how to write basic parsers how to to write ambiguous parsers how error correction works how to fine-tune your parsers to get rid of ambiguities how to use the monadic interface what kind of error messages you can expect if you write erroneous parsers how to use the permutating merging parsers to see the parsers in action load the module Text.ParserCombinators.UU.Demo.Examples or Text.ParserCombinators.UU.Demo.MergeAndPermute in ghci and type show demos while looking at the corresponding code",
          "hierarchy": "Text ParserCombinators UU",
          "module": "Text.ParserCombinators.UU",
          "name": "UU",
          "package": "uu-parsinglib",
          "partial": "UU",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/uu-parsinglib/docs/Text-ParserCombinators-UU.html#"
      }
    }
  ]
]