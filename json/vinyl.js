[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "vinyl"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Classes",
          "name": "Classes",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Classes.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "Classes",
          "package": "vinyl",
          "partial": "Classes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e'(~\u003e)' is a morphism between functors.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Classes",
          "name": "(~\u003e)",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Classes.html#~%3E",
          "type": "newtype"
        },
        "index": {
          "description": "is morphism between functors",
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "(~\u003e) ~\u003e",
          "package": "vinyl",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#t:-126--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is a generalized, but non-pointed version of \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e. This\n is useful for types which range over functors rather than sets.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Classes",
          "name": "Apply",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Classes.html#Apply",
          "type": "class"
        },
        "index": {
          "description": "This class is generalized but non-pointed version of Applicative This is useful for types which range over functors rather than sets",
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "Apply",
          "package": "vinyl",
          "partial": "Apply",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#t:Apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTo accumulate effects distributed over a data type, you \u003ccode\u003e\u003ca\u003edist\u003c/a\u003e\u003c/code\u003e it.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Classes",
          "name": "Dist",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Classes.html#Dist",
          "type": "class"
        },
        "index": {
          "description": "To accumulate effects distributed over data type you dist it",
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "Dist",
          "package": "vinyl",
          "partial": "Dist",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#t:Dist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf a record is homogenous, you can fold over it.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Classes",
          "name": "FoldRec",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Classes.html#FoldRec",
          "type": "class"
        },
        "index": {
          "description": "If record is homogenous you can fold over it",
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "FoldRec",
          "package": "vinyl",
          "partial": "Fold Rec",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#t:FoldRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Classes",
          "name": "(\u003c\u003c*\u003e\u003e)",
          "package": "vinyl",
          "signature": "f (arr a b) -\u003e f a -\u003e f b",
          "source": "src/Data-Vinyl-Classes.html#%3C%3C%2A%3E%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "(\u003c\u003c*\u003e\u003e) \u003c\u003c*\u003e\u003e",
          "normalized": "a(b c d)-\u003ea c-\u003ea d",
          "package": "vinyl",
          "signature": "f(arr a b)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#v:-60--60--42--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Classes",
          "name": "NT",
          "package": "vinyl",
          "signature": "NT",
          "source": "src/Data-Vinyl-Classes.html#~%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "NT",
          "package": "vinyl",
          "partial": "NT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#v:NT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Classes",
          "name": "dist",
          "package": "vinyl",
          "signature": "t f -\u003e f (t Identity)",
          "source": "src/Data-Vinyl-Classes.html#dist",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "dist",
          "normalized": "a b-\u003eb(a Identity)",
          "package": "vinyl",
          "signature": "t f-\u003ef(t Identity)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#v:dist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Classes",
          "name": "foldRec",
          "package": "vinyl",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e r -\u003e b",
          "source": "src/Data-Vinyl-Classes.html#foldRec",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "foldRec",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec-\u003eb",
          "package": "vinyl",
          "partial": "Rec",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003er-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#v:foldRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Classes",
          "name": "runNT",
          "package": "vinyl",
          "signature": "f x -\u003e g x",
          "source": "src/Data-Vinyl-Classes.html#~%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Classes",
          "module": "Data.Vinyl.Classes",
          "name": "runNT",
          "normalized": "a b-\u003ec b",
          "package": "vinyl",
          "partial": "NT",
          "signature": "f x-\u003eg x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Classes.html#v:runNT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Field",
          "name": "Field",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Field.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl Field",
          "module": "Data.Vinyl.Field",
          "name": "Field",
          "package": "vinyl",
          "partial": "Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Field.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA field contains a key and a type.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Field",
          "name": ":::",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Field.html#%3A%3A%3A",
          "type": "data"
        },
        "index": {
          "description": "field contains key and type",
          "hierarchy": "Data Vinyl Field",
          "module": "Data.Vinyl.Field",
          "name": ":::",
          "package": "vinyl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Field.html#t::::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Field",
          "name": "Field",
          "package": "vinyl",
          "signature": "t",
          "source": "src/Data-Vinyl-Field.html#%3A%3A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Field",
          "module": "Data.Vinyl.Field",
          "name": "Field",
          "package": "vinyl",
          "partial": "Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Field.html#v:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA small, \u003cem\u003een passant\u003c/em\u003e lens implementation to provide accessors\n for record fields. Lenses produced with \u003ccode\u003e\u003ca\u003erLens\u003c/a\u003e\u003c/code\u003e are fully\n compatible with the \u003ccode\u003elens\u003c/code\u003e package.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "Lens",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "small en passant lens implementation to provide accessors for record fields Lenses produced with rLens are fully compatible with the lens package",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "Lens",
          "package": "vinyl",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject a field from a \u003ccode\u003e\u003ca\u003ePlainRec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "rGet",
          "package": "vinyl",
          "signature": "t) -\u003e PlainRec rs -\u003e t",
          "source": "src/Data-Vinyl-Lens.html#rGet",
          "type": "function"
        },
        "index": {
          "description": "Project field from PlainRec",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "rGet",
          "normalized": "a)-\u003ePlainRec b-\u003ea",
          "package": "vinyl",
          "partial": "Get",
          "signature": "t)-\u003ePlainRec rs-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#v:rGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProject a field from a \u003ccode\u003e\u003ca\u003eRec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "rGet'",
          "package": "vinyl",
          "signature": "t) -\u003e Rec rs f -\u003e f t",
          "source": "src/Data-Vinyl-Lens.html#rGet%27",
          "type": "function"
        },
        "index": {
          "description": "Project field from Rec",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "rGet'",
          "normalized": "a)-\u003eRec b c-\u003ec a",
          "package": "vinyl",
          "partial": "Get'",
          "signature": "t)-\u003eRec rs f-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#v:rGet-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA lens into a \u003ccode\u003e\u003ca\u003ePlainRec\u003c/a\u003e\u003c/code\u003e that smoothly interoperates with lenses\n from the \u003ccode\u003elens\u003c/code\u003e package. Note that polymorphic update is not\n supported. In the parlance of the \u003ccode\u003elens\u003c/code\u003e package,\n\u003c/p\u003e\u003cpre\u003e rLens :: IElem (sy:::t) rs =\u003e (sy:::t) -\u003e Lens' (PlainRec rs) t\n\u003c/pre\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "rLens",
          "package": "vinyl",
          "signature": "r -\u003e (t -\u003e g t) -\u003e PlainRec rs -\u003e g (PlainRec rs)",
          "source": "src/Data-Vinyl-Lens.html#rLens",
          "type": "function"
        },
        "index": {
          "description": "lens into PlainRec that smoothly interoperates with lenses from the lens package Note that polymorphic update is not supported In the parlance of the lens package rLens IElem sy rs sy Lens PlainRec rs",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "rLens",
          "normalized": "a-\u003e(b-\u003ec b)-\u003ePlainRec d-\u003ec(PlainRec d)",
          "package": "vinyl",
          "partial": "Lens",
          "signature": "r-\u003e(t-\u003eg t)-\u003ePlainRec rs-\u003eg(PlainRec rs)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#v:rLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvide a lens to a record field. Note that this implementation\n does not support polymorphic update. In the parlance of the \u003ccode\u003elens\u003c/code\u003e\n package,\n\u003c/p\u003e\u003cpre\u003e rLens' :: IElem (sy:::t) rs =\u003e (sy:::t) -\u003e Lens' (Rec rs f) (f t)\n\u003c/pre\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "rLens'",
          "package": "vinyl",
          "signature": "r -\u003e (f t -\u003e g (f t)) -\u003e Rec rs f -\u003e g (Rec rs f)",
          "source": "src/Data-Vinyl-Lens.html#rLens%27",
          "type": "function"
        },
        "index": {
          "description": "Provide lens to record field Note that this implementation does not support polymorphic update In the parlance of the lens package rLens IElem sy rs sy Lens Rec rs",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "rLens'",
          "normalized": "a-\u003e(b c-\u003ed(b c))-\u003eRec e b-\u003ed(Rec e b)",
          "package": "vinyl",
          "partial": "Lens'",
          "signature": "r-\u003e(f t-\u003eg(f t))-\u003eRec rs f-\u003eg(Rec rs f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#v:rLens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify a field.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "rMod",
          "package": "vinyl",
          "signature": "t) -\u003e (t -\u003e t) -\u003e Rec rs f -\u003e Rec rs f",
          "source": "src/Data-Vinyl-Lens.html#rMod",
          "type": "function"
        },
        "index": {
          "description": "Modify field",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "rMod",
          "normalized": "a)-\u003e(a-\u003ea)-\u003eRec b c-\u003eRec b c",
          "package": "vinyl",
          "partial": "Mod",
          "signature": "t)-\u003e(t-\u003et)-\u003eRec rs f-\u003eRec rs f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#v:rMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet a field in a \u003ccode\u003e\u003ca\u003ePlainRec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "rPut",
          "package": "vinyl",
          "signature": "t) -\u003e t -\u003e PlainRec rs -\u003e PlainRec rs",
          "source": "src/Data-Vinyl-Lens.html#rPut",
          "type": "function"
        },
        "index": {
          "description": "Set field in PlainRec",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "rPut",
          "normalized": "a)-\u003ea-\u003ePlainRec b-\u003ePlainRec b",
          "package": "vinyl",
          "partial": "Put",
          "signature": "t)-\u003et-\u003ePlainRec rs-\u003ePlainRec rs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#v:rPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet a field in a \u003ccode\u003e\u003ca\u003eRec\u003c/a\u003e\u003c/code\u003e over an arbitrary functor.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Lens",
          "name": "rPut'",
          "package": "vinyl",
          "signature": "t) -\u003e f t -\u003e Rec rs f -\u003e Rec rs f",
          "source": "src/Data-Vinyl-Lens.html#rPut%27",
          "type": "function"
        },
        "index": {
          "description": "Set field in Rec over an arbitrary functor",
          "hierarchy": "Data Vinyl Lens",
          "module": "Data.Vinyl.Lens",
          "name": "rPut'",
          "normalized": "a)-\u003eb a-\u003eRec c b-\u003eRec c b",
          "package": "vinyl",
          "partial": "Put'",
          "signature": "t)-\u003ef t-\u003eRec rs f-\u003eRec rs f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Lens.html#v:rPut-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Rec",
          "name": "Rec",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Rec.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "Rec",
          "package": "vinyl",
          "partial": "Rec",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend for type-level lists.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Rec",
          "name": "(++)",
          "package": "vinyl",
          "signature": "(++)",
          "type": "function"
        },
        "index": {
          "description": "Append for type-level lists",
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "(++) ++",
          "normalized": "()",
          "package": "vinyl",
          "signature": "()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#t:-43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFields of plain records are in the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e functor.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Rec",
          "name": "PlainRec",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Rec.html#PlainRec",
          "type": "type"
        },
        "index": {
          "description": "Fields of plain records are in the Identity functor",
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "PlainRec",
          "package": "vinyl",
          "partial": "Plain Rec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#t:PlainRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record is parameterized by a list of fields and a functor\n to be applied to each of those fields.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Rec",
          "name": "Rec",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Rec.html#Rec",
          "type": "data"
        },
        "index": {
          "description": "record is parameterized by list of fields and functor to be applied to each of those fields",
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "Rec",
          "package": "vinyl",
          "partial": "Rec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#t:Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend for records.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Rec",
          "name": "(\u003c+\u003e)",
          "package": "vinyl",
          "signature": "Rec as f -\u003e Rec bs f -\u003e Rec (as ++ bs) f",
          "source": "src/Data-Vinyl-Rec.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Append for records",
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "Rec a b-\u003eRec c b-\u003eRec(a c)b",
          "package": "vinyl",
          "signature": "Rec as f-\u003eRec bs f-\u003eRec(as bs)f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShorthand for a record with a single field of an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e\n type. This is useful for \u003ccode\u003eApplicative\u003c/code\u003e or \u003ccode\u003eMonad\u003c/code\u003eic intialization\n of records as in the idiom:\n\u003c/p\u003e\u003cpre\u003e dist $ myField \u003c-: someIO \u003c+\u003e yourField \u003c-: otherIO\n\u003c/pre\u003e",
          "module": "Data.Vinyl.Rec",
          "name": "(\u003c-:)",
          "package": "vinyl",
          "signature": "t]` f",
          "source": "src/Data-Vinyl-Rec.html#%3C-%3A",
          "type": "function"
        },
        "index": {
          "description": "Shorthand for record with single field of an Applicative type This is useful for Applicative or Monad ic intialization of records as in the idiom dist myField someIO yourField otherIO",
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "(\u003c-:) \u003c-:",
          "package": "vinyl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#v:-60--45-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShorthand for a record with a single field. Lifts the field's\n value into the chosen functor automatically.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Rec",
          "name": "(=:)",
          "package": "vinyl",
          "signature": "t]` f",
          "source": "src/Data-Vinyl-Rec.html#%3D%3A",
          "type": "function"
        },
        "index": {
          "description": "Shorthand for record with single field Lifts the field value into the chosen functor automatically",
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "(=:) =:",
          "package": "vinyl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#v:-61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Rec",
          "name": ":&",
          "package": "vinyl",
          "signature": "t) : rs) f",
          "source": "src/Data-Vinyl-Rec.html#Rec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": ":&",
          "package": "vinyl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#v::-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Rec",
          "name": "RNil",
          "package": "vinyl",
          "signature": "Rec `[]` f",
          "source": "src/Data-Vinyl-Rec.html#Rec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "RNil",
          "normalized": "Rec[]a",
          "package": "vinyl",
          "partial": "RNil",
          "signature": "Rec[]f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#v:RNil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFixes a polymorphic record into the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e functor.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Rec",
          "name": "fixRecord",
          "package": "vinyl",
          "signature": "Rec rs f) -\u003e PlainRec rs",
          "source": "src/Data-Vinyl-Rec.html#fixRecord",
          "type": "function"
        },
        "index": {
          "description": "Fixes polymorphic record into the Identity functor",
          "hierarchy": "Data Vinyl Rec",
          "module": "Data.Vinyl.Rec",
          "name": "fixRecord",
          "normalized": "Rec a b)-\u003ePlainRec a",
          "package": "vinyl",
          "partial": "Record",
          "signature": "Rec rs f)-\u003ePlainRec rs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Rec.html#v:fixRecord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Relation",
          "name": "Relation",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Relation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl Relation",
          "module": "Data.Vinyl.Relation",
          "name": "Relation",
          "package": "vinyl",
          "partial": "Relation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Relation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA subtyping relation.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Relation",
          "name": "(\u003c:)",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Relation.html#%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "subtyping relation",
          "hierarchy": "Data Vinyl Relation",
          "module": "Data.Vinyl.Relation",
          "name": "(\u003c:) \u003c:",
          "package": "vinyl",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Relation.html#t:-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf two records types are subtypes of each other, that means that they\n differ only in order of fields.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Relation",
          "name": ":~:",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Relation.html#%3A~%3A",
          "type": "type"
        },
        "index": {
          "description": "If two records types are subtypes of each other that means that they differ only in order of fields",
          "hierarchy": "Data Vinyl Relation",
          "module": "Data.Vinyl.Relation",
          "name": ":~:",
          "package": "vinyl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Relation.html#t::-126-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTerm-level record congruence.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Relation",
          "name": "(~=)",
          "package": "vinyl",
          "signature": "a -\u003e b -\u003e Bool",
          "source": "src/Data-Vinyl-Relation.html#~%3D",
          "type": "function"
        },
        "index": {
          "description": "Term-level record congruence",
          "hierarchy": "Data Vinyl Relation",
          "module": "Data.Vinyl.Relation",
          "name": "(~=) ~=",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "vinyl",
          "signature": "a-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Relation.html#v:-126--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Relation",
          "name": "cast",
          "package": "vinyl",
          "signature": "r1 -\u003e r2",
          "source": "src/Data-Vinyl-Relation.html#cast",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vinyl Relation",
          "module": "Data.Vinyl.Relation",
          "name": "cast",
          "normalized": "a-\u003ea",
          "package": "vinyl",
          "signature": "r-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Relation.html#v:cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Unicode",
          "name": "Unicode",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Unicode.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl Unicode",
          "module": "Data.Vinyl.Unicode",
          "name": "Unicode",
          "package": "vinyl",
          "partial": "Unicode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Unicode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Unicode",
          "name": "(∈)",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Unicode.html#%2208",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Vinyl Unicode",
          "module": "Data.Vinyl.Unicode",
          "name": "(∈) ∈",
          "package": "vinyl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Unicode.html#t:-8712-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Unicode",
          "name": "(≅)",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Unicode.html#%2245",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Vinyl Unicode",
          "module": "Data.Vinyl.Unicode",
          "name": "(≅) ≅",
          "package": "vinyl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Unicode.html#t:-8773-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Unicode",
          "name": "(⊆)",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Unicode.html#%2286",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Vinyl Unicode",
          "module": "Data.Vinyl.Unicode",
          "name": "(⊆) ⊆",
          "package": "vinyl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Unicode.html#t:-8838-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Unicode",
          "name": "(≅)",
          "package": "vinyl",
          "signature": "a -\u003e b -\u003e Bool",
          "source": "src/Data-Vinyl-Unicode.html#%2245",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Unicode",
          "module": "Data.Vinyl.Unicode",
          "name": "(≅) ≅",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "vinyl",
          "signature": "a-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Unicode.html#v:-8773-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Validation",
          "name": "Validation",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Validation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl Validation",
          "module": "Data.Vinyl.Validation",
          "name": "Validation",
          "package": "vinyl",
          "partial": "Validation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Validation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type which is similar to \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e, except that it has a\n slightly different Applicative instance.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Validation",
          "name": "Result",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Validation.html#Result",
          "type": "data"
        },
        "index": {
          "description": "type which is similar to Either except that it has slightly different Applicative instance",
          "hierarchy": "Data Vinyl Validation",
          "module": "Data.Vinyl.Validation",
          "name": "Result",
          "package": "vinyl",
          "partial": "Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Validation.html#t:Result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValidators transform identities into results.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Validation",
          "name": "Validator",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Validation.html#Validator",
          "type": "type"
        },
        "index": {
          "description": "Validators transform identities into results",
          "hierarchy": "Data Vinyl Validation",
          "module": "Data.Vinyl.Validation",
          "name": "Validator",
          "package": "vinyl",
          "partial": "Validator",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Validation.html#t:Validator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Validation",
          "name": "Failure",
          "package": "vinyl",
          "signature": "Failure e",
          "source": "src/Data-Vinyl-Validation.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Validation",
          "module": "Data.Vinyl.Validation",
          "name": "Failure",
          "package": "vinyl",
          "partial": "Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Validation.html#v:Failure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Validation",
          "name": "Success",
          "package": "vinyl",
          "signature": "Success a",
          "source": "src/Data-Vinyl-Validation.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Validation",
          "module": "Data.Vinyl.Validation",
          "name": "Success",
          "package": "vinyl",
          "partial": "Success",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Validation.html#v:Success"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Witnesses",
          "name": "Witnesses",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Witnesses.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "Witnesses",
          "package": "vinyl",
          "partial": "Witnesses",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn inductive list membership proposition.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Witnesses",
          "name": "Elem",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Witnesses.html#Elem",
          "type": "data"
        },
        "index": {
          "description": "An inductive list membership proposition",
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "Elem",
          "package": "vinyl",
          "partial": "Elem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#t:Elem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA constraint for implicit resolution of list membership proofs.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Witnesses",
          "name": "IElem",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Witnesses.html#IElem",
          "type": "type"
        },
        "index": {
          "description": "constraint for implicit resolution of list membership proofs",
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "IElem",
          "package": "vinyl",
          "partial": "IElem",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#t:IElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA constraint for implicit resolution of list subset proofs.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Witnesses",
          "name": "ISubset",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Witnesses.html#ISubset",
          "type": "type"
        },
        "index": {
          "description": "constraint for implicit resolution of list subset proofs",
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "ISubset",
          "package": "vinyl",
          "partial": "ISubset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#t:ISubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Witnesses",
          "name": "Implicit",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Witnesses.html#Implicit",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "Implicit",
          "package": "vinyl",
          "partial": "Implicit",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#t:Implicit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn inductive list subset relation.\n\u003c/p\u003e",
          "module": "Data.Vinyl.Witnesses",
          "name": "Subset",
          "package": "vinyl",
          "source": "src/Data-Vinyl-Witnesses.html#Subset",
          "type": "data"
        },
        "index": {
          "description": "An inductive list subset relation",
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "Subset",
          "package": "vinyl",
          "partial": "Subset",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#t:Subset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Witnesses",
          "name": "Here",
          "package": "vinyl",
          "signature": "Elem x (x : xs)",
          "source": "src/Data-Vinyl-Witnesses.html#Elem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "Here",
          "package": "vinyl",
          "partial": "Here",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#v:Here"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Witnesses",
          "name": "SubsetCons",
          "package": "vinyl",
          "signature": "Elem x ys -\u003e Subset xs ys -\u003e Subset (x : xs) ys",
          "source": "src/Data-Vinyl-Witnesses.html#Subset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "SubsetCons",
          "normalized": "Elem a b-\u003eSubset c b-\u003eSubset(a c)b",
          "package": "vinyl",
          "partial": "Subset Cons",
          "signature": "Elem x ys-\u003eSubset xs ys-\u003eSubset(x xs)ys",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#v:SubsetCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Witnesses",
          "name": "SubsetNil",
          "package": "vinyl",
          "signature": "Subset `[]` xs",
          "source": "src/Data-Vinyl-Witnesses.html#Subset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "SubsetNil",
          "normalized": "Subset[]a",
          "package": "vinyl",
          "partial": "Subset Nil",
          "signature": "Subset[]xs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#v:SubsetNil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Witnesses",
          "name": "There",
          "package": "vinyl",
          "signature": "Elem x xs -\u003e Elem x (y : xs)",
          "source": "src/Data-Vinyl-Witnesses.html#Elem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "There",
          "normalized": "Elem a b-\u003eElem a(c b)",
          "package": "vinyl",
          "partial": "There",
          "signature": "Elem x xs-\u003eElem x(y xs)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#v:There"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl.Witnesses",
          "name": "implicitly",
          "package": "vinyl",
          "signature": "p",
          "source": "src/Data-Vinyl-Witnesses.html#implicitly",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vinyl Witnesses",
          "module": "Data.Vinyl.Witnesses",
          "name": "implicitly",
          "package": "vinyl",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl-Witnesses.html#v:implicitly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vinyl",
          "name": "Vinyl",
          "package": "vinyl",
          "source": "src/Data-Vinyl.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vinyl",
          "module": "Data.Vinyl",
          "name": "Vinyl",
          "package": "vinyl",
          "partial": "Vinyl",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vinyl/docs/Data-Vinyl.html#"
      }
    }
  ]
]