[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "arithmoi"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLow level gcd and coprimality functions using the binary gcd algorithm.\n Normally, accessing these via the higher level interface of \u003ca\u003eMath.NumberTheory.GCD\u003c/a\u003e\n should be sufficient.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "LowLevel",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html",
          "type": "module"
        },
        "index": {
          "description": "Low level gcd and coprimality functions using the binary gcd algorithm Normally accessing these via the higher level interface of Math.NumberTheory.GCD should be sufficient",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "LowLevel",
          "package": "arithmoi",
          "partial": "Low Level",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether two \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003es are coprime, using an abbreviated binary gcd algorithm.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeInt",
          "package": "arithmoi",
          "signature": "Int -\u003e Int -\u003e Bool",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#coprimeInt",
          "type": "function"
        },
        "index": {
          "description": "Test whether two Int are coprime using an abbreviated binary gcd algorithm",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeInt",
          "normalized": "Int-\u003eInt-\u003eBool",
          "package": "arithmoi",
          "partial": "Int",
          "signature": "Int-\u003eInt-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:coprimeInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether two \u003ccode\u003e\u003ca\u003eInt#\u003c/a\u003e\u003c/code\u003es are coprime.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeInt#",
          "package": "arithmoi",
          "signature": "Int# -\u003e Int# -\u003e Bool",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#coprimeInt%23",
          "type": "function"
        },
        "index": {
          "description": "Test whether two Int are coprime",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeInt#",
          "normalized": "Int #-\u003eInt #-\u003eBool",
          "package": "arithmoi",
          "partial": "Int",
          "signature": "Int #-\u003eInt #-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:coprimeInt-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether two \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003es are coprime, using an abbreviated binary gcd algorithm.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeWord",
          "package": "arithmoi",
          "signature": "Word -\u003e Word -\u003e Bool",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#coprimeWord",
          "type": "function"
        },
        "index": {
          "description": "Test whether two Word are coprime using an abbreviated binary gcd algorithm",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeWord",
          "normalized": "Word-\u003eWord-\u003eBool",
          "package": "arithmoi",
          "partial": "Word",
          "signature": "Word-\u003eWord-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:coprimeWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether two \u003ccode\u003e\u003ca\u003eWord#\u003c/a\u003e\u003c/code\u003es are coprime.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeWord#",
          "package": "arithmoi",
          "signature": "Word# -\u003e Word# -\u003e Bool",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#coprimeWord%23",
          "type": "function"
        },
        "index": {
          "description": "Test whether two Word are coprime",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "coprimeWord#",
          "normalized": "Word #-\u003eWord #-\u003eBool",
          "package": "arithmoi",
          "partial": "Word",
          "signature": "Word #-\u003eWord #-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:coprimeWord-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreatest common divisor of two \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003es, calculated with the binary gcd algorithm.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdInt",
          "package": "arithmoi",
          "signature": "Int -\u003e Int -\u003e Int",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#gcdInt",
          "type": "function"
        },
        "index": {
          "description": "Greatest common divisor of two Int calculated with the binary gcd algorithm",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdInt",
          "normalized": "Int-\u003eInt-\u003eInt",
          "package": "arithmoi",
          "partial": "Int",
          "signature": "Int-\u003eInt-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:gcdInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreatest common divisor of two \u003ccode\u003e\u003ca\u003eInt#\u003c/a\u003e\u003c/code\u003es, calculated with the binary gcd algorithm.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdInt#",
          "package": "arithmoi",
          "signature": "Int# -\u003e Int# -\u003e Int#",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#gcdInt%23",
          "type": "function"
        },
        "index": {
          "description": "Greatest common divisor of two Int calculated with the binary gcd algorithm",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdInt#",
          "normalized": "Int #-\u003eInt #-\u003eInt #",
          "package": "arithmoi",
          "partial": "Int",
          "signature": "Int #-\u003eInt #-\u003eInt #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:gcdInt-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreatest common divisor of two \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003es, calculated with the binary gcd algorithm.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdWord",
          "package": "arithmoi",
          "signature": "Word -\u003e Word -\u003e Word",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#gcdWord",
          "type": "function"
        },
        "index": {
          "description": "Greatest common divisor of two Word calculated with the binary gcd algorithm",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdWord",
          "normalized": "Word-\u003eWord-\u003eWord",
          "package": "arithmoi",
          "partial": "Word",
          "signature": "Word-\u003eWord-\u003eWord",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:gcdWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreatest common divisor of two \u003ccode\u003e\u003ca\u003eWord#\u003c/a\u003e\u003c/code\u003es, calculated with the binary gcd algorithm.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdWord#",
          "package": "arithmoi",
          "signature": "Word# -\u003e Word# -\u003e Word#",
          "source": "src/Math-NumberTheory-GCD-LowLevel.html#gcdWord%23",
          "type": "function"
        },
        "index": {
          "description": "Greatest common divisor of two Word calculated with the binary gcd algorithm",
          "hierarchy": "Math NumberTheory GCD LowLevel",
          "module": "Math.NumberTheory.GCD.LowLevel",
          "name": "gcdWord#",
          "normalized": "Word #-\u003eWord #-\u003eWord #",
          "package": "arithmoi",
          "partial": "Word",
          "signature": "Word #-\u003eWord #-\u003eWord #",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD-LowLevel.html#v:gcdWord-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports GCD and coprimality test using the binary gcd algorithm\n and GCD with the extended Euclidean algorithm.\n\u003c/p\u003e\u003cp\u003eEfficiently counting the number of trailing zeros, the binary gcd algorithm\n can perform considerably faster than the Euclidean algorithm on average.\n For \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e, GHC has a rewrite rule to use GMP's fast gcd, depending on\n hardware and/or GMP version, that can be faster or slower than the binary\n algorithm (on my 32-bit box, binary is faster, on my 64-bit box, GMP).\n For \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e and the sized \u003ccode\u003eIntN/WordN\u003c/code\u003e types, there is no rewrite rule (yet)\n in GHC, and the binary algorithm performs consistently (so far as my tests go)\n much better (if this module's rewrite rules fire).\n\u003c/p\u003e\u003cp\u003eWhen using this module, always compile with optimisations turned on to\n benefit from GHC's primops and the rewrite rules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.GCD",
          "name": "GCD",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-GCD.html",
          "type": "module"
        },
        "index": {
          "description": "This module exports GCD and coprimality test using the binary gcd algorithm and GCD with the extended Euclidean algorithm Efficiently counting the number of trailing zeros the binary gcd algorithm can perform considerably faster than the Euclidean algorithm on average For Int GHC has rewrite rule to use GMP fast gcd depending on hardware and or GMP version that can be faster or slower than the binary algorithm on my bit box binary is faster on my bit box GMP For Word and the sized IntN WordN types there is no rewrite rule yet in GHC and the binary algorithm performs consistently so far as my tests go much better if this module rewrite rules fire When using this module always compile with optimisations turned on to benefit from GHC primops and the rewrite rules",
          "hierarchy": "Math NumberTheory GCD",
          "module": "Math.NumberTheory.GCD",
          "name": "GCD",
          "package": "arithmoi",
          "partial": "GCD",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the greatest common divisor using the binary gcd algorithm.\n   Depending on type and hardware, that can be considerably faster than\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e but it may also be significantly slower.\n\u003c/p\u003e\u003cp\u003eThere are specialised functions for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and rewrite rules\n   for those and \u003ccode\u003eIntN\u003c/code\u003e and \u003ccode\u003eWordN\u003c/code\u003e, \u003ccode\u003eN \u003c= 32\u003c/code\u003e, to use the\n   specialised variants. These types are worth benchmarking, others probably not.\n\u003c/p\u003e\u003cp\u003eIt is very slow for \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e (and probably every type except the abovementioned),\n   I recommend not using it for those.\n\u003c/p\u003e\u003cp\u003eRelies on twos complement or sign and magnitude representaion for signed types.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD",
          "name": "binaryGCD",
          "package": "arithmoi",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Math-NumberTheory-GCD.html#binaryGCD",
          "type": "function"
        },
        "index": {
          "description": "Calculate the greatest common divisor using the binary gcd algorithm Depending on type and hardware that can be considerably faster than gcd but it may also be significantly slower There are specialised functions for Int and Word and rewrite rules for those and IntN and WordN to use the specialised variants These types are worth benchmarking others probably not It is very slow for Integer and probably every type except the abovementioned recommend not using it for those Relies on twos complement or sign and magnitude representaion for signed types",
          "hierarchy": "Math NumberTheory GCD",
          "module": "Math.NumberTheory.GCD",
          "name": "binaryGCD",
          "normalized": "a-\u003ea-\u003ea",
          "package": "arithmoi",
          "partial": "GCD",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD.html#v:binaryGCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether two numbers are coprime using an abbreviated binary gcd algorithm.\n   A little bit faster than checking \u003ccode\u003ebinaryGCD a b == 1\u003c/code\u003e if one of the arguments\n   is even, much faster if both are even.\n\u003c/p\u003e\u003cp\u003eThe remarks about performance at \u003ccode\u003e\u003ca\u003ebinaryGCD\u003c/a\u003e\u003c/code\u003e apply here too, use this function\n   only at the types with rewrite rules.\n\u003c/p\u003e\u003cp\u003eRelies on twos complement or sign and magnitude representaion for signed types.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD",
          "name": "coprime",
          "package": "arithmoi",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Math-NumberTheory-GCD.html#coprime",
          "type": "function"
        },
        "index": {
          "description": "Test whether two numbers are coprime using an abbreviated binary gcd algorithm little bit faster than checking binaryGCD if one of the arguments is even much faster if both are even The remarks about performance at binaryGCD apply here too use this function only at the types with rewrite rules Relies on twos complement or sign and magnitude representaion for signed types",
          "hierarchy": "Math NumberTheory GCD",
          "module": "Math.NumberTheory.GCD",
          "name": "coprime",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "arithmoi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD.html#v:coprime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the greatest common divisor of two numbers and coefficients\n   for the linear combination.\n\u003c/p\u003e\u003cp\u003eSatisfies:\n\u003c/p\u003e\u003cpre\u003e case extendedGCD a b of\n   (d, u, v) -\u003e u*a + v*b == d\n\n d == gcd a b\n\u003c/pre\u003e\u003cp\u003eand, for signed types,\n\u003c/p\u003e\u003cpre\u003e\n abs u \u003c abs b || abs b \u003c= 1\n\n abs v \u003c abs a || abs a \u003c= 1\n\u003c/pre\u003e\u003cp\u003e(except if one of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e of a signed type).\n\u003c/p\u003e",
          "module": "Math.NumberTheory.GCD",
          "name": "extendedGCD",
          "package": "arithmoi",
          "signature": "a -\u003e a -\u003e (a, a, a)",
          "source": "src/Math-NumberTheory-GCD.html#extendedGCD",
          "type": "function"
        },
        "index": {
          "description": "Calculate the greatest common divisor of two numbers and coefficients for the linear combination Satisfies case extendedGCD of gcd and for signed types abs abs abs abs abs abs except if one of and is minBound of signed type",
          "hierarchy": "Math NumberTheory GCD",
          "module": "Math.NumberTheory.GCD",
          "name": "extendedGCD",
          "normalized": "a-\u003ea-\u003e(a,a,a)",
          "package": "arithmoi",
          "partial": "GCD",
          "signature": "a-\u003ea-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-GCD.html#v:extendedGCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInteger Logarithms. For efficiency, the internal representation of \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003es\n from integer-gmp is used.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "Logarithms",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Logarithms.html",
          "type": "module"
        },
        "index": {
          "description": "Integer Logarithms For efficiency the internal representation of Integer from integer-gmp is used",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "Logarithms",
          "package": "arithmoi",
          "partial": "Logarithms",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer logarithm of an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e to base 2.\n   The argument must be positive, otherwise an error is thrown.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "intLog2",
          "package": "arithmoi",
          "signature": "Int -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#intLog2",
          "type": "function"
        },
        "index": {
          "description": "Calculate the integer logarithm of an Int to base The argument must be positive otherwise an error is thrown",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "intLog2",
          "normalized": "Int-\u003eInt",
          "package": "arithmoi",
          "partial": "Log",
          "signature": "Int-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:intLog2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eintLog2\u003c/a\u003e\u003c/code\u003e, but without checks, saves a little time when\n   called often for known good input.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "intLog2'",
          "package": "arithmoi",
          "signature": "Int -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#intLog2%27",
          "type": "function"
        },
        "index": {
          "description": "Same as intLog2 but without checks saves little time when called often for known good input",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "intLog2'",
          "normalized": "Int-\u003eInt",
          "package": "arithmoi",
          "partial": "Log",
          "signature": "Int-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:intLog2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer logarithm of an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e to base 2.\n   The argument must be positive, otherwise an error is thrown.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLog2",
          "package": "arithmoi",
          "signature": "Integer -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#integerLog2",
          "type": "function"
        },
        "index": {
          "description": "Calculate the integer logarithm of an Integer to base The argument must be positive otherwise an error is thrown",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLog2",
          "normalized": "Integer-\u003eInt",
          "package": "arithmoi",
          "partial": "Log",
          "signature": "Integer-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:integerLog2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eintegerLog2\u003c/a\u003e\u003c/code\u003e, but without checks, saves a little time when\n   called often for known good input.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLog2'",
          "package": "arithmoi",
          "signature": "Integer -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#integerLog2%27",
          "type": "function"
        },
        "index": {
          "description": "Same as integerLog2 but without checks saves little time when called often for known good input",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLog2'",
          "normalized": "Integer-\u003eInt",
          "package": "arithmoi",
          "partial": "Log",
          "signature": "Integer-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:integerLog2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer logarithm for an arbitrary base.\n   The base must be greater than 1, the second argument, the number\n   whose logarithm is sought, must be positive, otherwise an error is thrown.\n   If \u003ccode\u003ebase == 2\u003c/code\u003e, the specialised version is called, which is more\n   efficient than the general algorithm.\n\u003c/p\u003e\u003cp\u003eSatisfies:\n\u003c/p\u003e\u003cpre\u003e base ^ integerLogBase base m \u003c= m \u003c base ^ (integerLogBase base m + 1)\n\u003c/pre\u003e\u003cp\u003efor \u003ccode\u003ebase \u003e 1\u003c/code\u003e and \u003ccode\u003em \u003e 0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLogBase",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#integerLogBase",
          "type": "function"
        },
        "index": {
          "description": "Calculate the integer logarithm for an arbitrary base The base must be greater than the second argument the number whose logarithm is sought must be positive otherwise an error is thrown If base the specialised version is called which is more efficient than the general algorithm Satisfies base integerLogBase base base integerLogBase base for base and",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLogBase",
          "normalized": "Integer-\u003eInteger-\u003eInt",
          "package": "arithmoi",
          "partial": "Log Base",
          "signature": "Integer-\u003eInteger-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:integerLogBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eintegerLogBase\u003c/a\u003e\u003c/code\u003e, but without checks, saves a little time when\n   called often for known good input.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLogBase'",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#integerLogBase%27",
          "type": "function"
        },
        "index": {
          "description": "Same as integerLogBase but without checks saves little time when called often for known good input",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "integerLogBase'",
          "normalized": "Integer-\u003eInteger-\u003eInt",
          "package": "arithmoi",
          "partial": "Log Base'",
          "signature": "Integer-\u003eInteger-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:integerLogBase-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer logarithm of a \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e to base 2.\n   The argument must be positive, otherwise an error is thrown.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "wordLog2",
          "package": "arithmoi",
          "signature": "Word -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#wordLog2",
          "type": "function"
        },
        "index": {
          "description": "Calculate the integer logarithm of Word to base The argument must be positive otherwise an error is thrown",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "wordLog2",
          "normalized": "Word-\u003eInt",
          "package": "arithmoi",
          "partial": "Log",
          "signature": "Word-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:wordLog2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ewordLog2\u003c/a\u003e\u003c/code\u003e, but without checks, saves a little time when\n   called often for known good input.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Logarithms",
          "name": "wordLog2'",
          "package": "arithmoi",
          "signature": "Word -\u003e Int",
          "source": "src/Math-NumberTheory-Logarithms.html#wordLog2%27",
          "type": "function"
        },
        "index": {
          "description": "Same as wordLog2 but without checks saves little time when called often for known good input",
          "hierarchy": "Math NumberTheory Logarithms",
          "module": "Math.NumberTheory.Logarithms",
          "name": "wordLog2'",
          "normalized": "Word-\u003eInt",
          "package": "arithmoi",
          "partial": "Log",
          "signature": "Word-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Logarithms.html#v:wordLog2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEfficient calculation of Lucas sequences.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Lucas",
          "name": "Lucas",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Lucas.html",
          "type": "module"
        },
        "index": {
          "description": "Efficient calculation of Lucas sequences",
          "hierarchy": "Math NumberTheory Lucas",
          "module": "Math.NumberTheory.Lucas",
          "name": "Lucas",
          "package": "arithmoi",
          "partial": "Lucas",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Lucas.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efibonacci\u003c/a\u003e\u003c/code\u003e k\u003c/code\u003e calculates the \u003ccode\u003ek\u003c/code\u003e-th Fibonacci number in\n   \u003cem\u003eO\u003c/em\u003e(\u003ccode\u003elog (abs k)\u003c/code\u003e) steps. The index may be negative. This\n   is efficient for calculating single Fibonacci numbers (with\n   large index), but for computing many Fibonacci numbers in\n   close proximity, it is better to use the simple addition\n   formula starting from an appropriate pair of successive\n   Fibonacci numbers.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Lucas",
          "name": "fibonacci",
          "package": "arithmoi",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-NumberTheory-Lucas.html#fibonacci",
          "type": "function"
        },
        "index": {
          "description": "fibonacci calculates the th Fibonacci number in log abs steps The index may be negative This is efficient for calculating single Fibonacci numbers with large index but for computing many Fibonacci numbers in close proximity it is better to use the simple addition formula starting from an appropriate pair of successive Fibonacci numbers",
          "hierarchy": "Math NumberTheory Lucas",
          "module": "Math.NumberTheory.Lucas",
          "name": "fibonacci",
          "normalized": "Int-\u003eInteger",
          "package": "arithmoi",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Lucas.html#v:fibonacci"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efibonacciPair\u003c/a\u003e\u003c/code\u003e k\u003c/code\u003e returns the pair \u003ccode\u003e(F(k), F(k+1))\u003c/code\u003e of the \u003ccode\u003ek\u003c/code\u003e-th\n   Fibonacci number and its successor, thus it can be used to calculate\n   the Fibonacci numbers from some index on without needing to compute\n   the previous. The pair is efficiently calculated\n   in \u003cem\u003eO\u003c/em\u003e(\u003ccode\u003elog (abs k)\u003c/code\u003e) steps. The index may be negative.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Lucas",
          "name": "fibonacciPair",
          "package": "arithmoi",
          "signature": "Int -\u003e (Integer, Integer)",
          "source": "src/Math-NumberTheory-Lucas.html#fibonacciPair",
          "type": "function"
        },
        "index": {
          "description": "fibonacciPair returns the pair of the th Fibonacci number and its successor thus it can be used to calculate the Fibonacci numbers from some index on without needing to compute the previous The pair is efficiently calculated in log abs steps The index may be negative",
          "hierarchy": "Math NumberTheory Lucas",
          "module": "Math.NumberTheory.Lucas",
          "name": "fibonacciPair",
          "normalized": "Int-\u003e(Integer,Integer)",
          "package": "arithmoi",
          "partial": "Pair",
          "signature": "Int-\u003e(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Lucas.html#v:fibonacciPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003egeneralLucas\u003c/a\u003e\u003c/code\u003e p q k\u003c/code\u003e calculates the quadruple \u003ccode\u003e(U(k), U(k+1), V(k), V(k+1))\u003c/code\u003e\n   where \u003ccode\u003eU(i)\u003c/code\u003e is the Lucas sequence of the first kind and \u003ccode\u003eV(i)\u003c/code\u003e the Lucas\n   sequence of the second kind for the parameters \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e, where \u003ccode\u003ep^2-4q /= 0\u003c/code\u003e.\n   Both sequences satisfy the recurrence relation \u003ccode\u003eA(j+2) = p*A(j+1) - q*A(j)\u003c/code\u003e,\n   the starting values are \u003ccode\u003eU(0) = 0, U(1) = 1\u003c/code\u003e and \u003ccode\u003eV(0) = 2, V(1) = p\u003c/code\u003e.\n   The Fibonacci numbers form the Lucas sequence of the first kind for the\n   parameters \u003ccode\u003ep = 1, q = -1\u003c/code\u003e and the Lucas numbers form the Lucas sequence of\n   the second kind for these parameters.\n   Here, the index must be non-negative, since the terms of the sequence for\n   negative indices are in general not integers.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Lucas",
          "name": "generalLucas",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Int -\u003e (Integer, Integer, Integer, Integer)",
          "source": "src/Math-NumberTheory-Lucas.html#generalLucas",
          "type": "function"
        },
        "index": {
          "description": "generalLucas calculates the quadruple where is the Lucas sequence of the first kind and the Lucas sequence of the second kind for the parameters and where Both sequences satisfy the recurrence relation the starting values are and The Fibonacci numbers form the Lucas sequence of the first kind for the parameters and the Lucas numbers form the Lucas sequence of the second kind for these parameters Here the index must be non-negative since the terms of the sequence for negative indices are in general not integers",
          "hierarchy": "Math NumberTheory Lucas",
          "module": "Math.NumberTheory.Lucas",
          "name": "generalLucas",
          "normalized": "Integer-\u003eInteger-\u003eInt-\u003e(Integer,Integer,Integer,Integer)",
          "package": "arithmoi",
          "partial": "Lucas",
          "signature": "Integer-\u003eInteger-\u003eInt-\u003e(Integer,Integer,Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Lucas.html#v:generalLucas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003elucas\u003c/a\u003e\u003c/code\u003e k\u003c/code\u003e computes the \u003ccode\u003ek\u003c/code\u003e-th Lucas number. Very similar\n   to \u003ccode\u003e\u003ccode\u003e\u003ca\u003efibonacci\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Lucas",
          "name": "lucas",
          "package": "arithmoi",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-NumberTheory-Lucas.html#lucas",
          "type": "function"
        },
        "index": {
          "description": "lucas computes the th Lucas number Very similar to fibonacci",
          "hierarchy": "Math NumberTheory Lucas",
          "module": "Math.NumberTheory.Lucas",
          "name": "lucas",
          "normalized": "Int-\u003eInteger",
          "package": "arithmoi",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Lucas.html#v:lucas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003elucasPair\u003c/a\u003e\u003c/code\u003e k\u003c/code\u003e computes the pair \u003ccode\u003e(L(k), L(k+1))\u003c/code\u003e of the \u003ccode\u003ek\u003c/code\u003e-th\n   Lucas number and its successor. Very similar to \u003ccode\u003e\u003ccode\u003e\u003ca\u003efibonacciPair\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Lucas",
          "name": "lucasPair",
          "package": "arithmoi",
          "signature": "Int -\u003e (Integer, Integer)",
          "source": "src/Math-NumberTheory-Lucas.html#lucasPair",
          "type": "function"
        },
        "index": {
          "description": "lucasPair computes the pair of the th Lucas number and its successor Very similar to fibonacciPair",
          "hierarchy": "Math NumberTheory Lucas",
          "module": "Math.NumberTheory.Lucas",
          "name": "lucasPair",
          "normalized": "Int-\u003e(Integer,Integer)",
          "package": "arithmoi",
          "partial": "Pair",
          "signature": "Int-\u003e(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Lucas.html#v:lucasPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMiscellaneous functions related to modular arithmetic.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "Moduli",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Moduli.html",
          "type": "module"
        },
        "index": {
          "description": "Miscellaneous functions related to modular arithmetic",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "Moduli",
          "package": "arithmoi",
          "partial": "Moduli",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list \u003ccode\u003e[(r_1,m_1), ..., (r_n,m_n)]\u003c/code\u003e of \u003ccode\u003e(residue,modulus)\u003c/code\u003e\n   pairs, \u003ccode\u003echineseRemainder\u003c/code\u003e calculates the solution to the simultaneous\n   congruences\n\u003c/p\u003e\u003cpre\u003e\n r &#8801; r_k (mod m_k)\n\n\u003c/pre\u003e\u003cp\u003eif all moduli are pairwise coprime. If not all moduli are\n   pairwise coprime, the result is \u003ccode\u003eNothing\u003c/code\u003e regardless of whether\n   a solution exists.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "chineseRemainder",
          "package": "arithmoi",
          "signature": "[(Integer, Integer)] -\u003e Maybe Integer",
          "source": "src/Math-NumberTheory-Moduli.html#chineseRemainder",
          "type": "function"
        },
        "index": {
          "description": "Given list of residue modulus pairs chineseRemainder calculates the solution to the simultaneous congruences mod if all moduli are pairwise coprime If not all moduli are pairwise coprime the result is Nothing regardless of whether solution exists",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "chineseRemainder",
          "normalized": "[(Integer,Integer)]-\u003eMaybe Integer",
          "package": "arithmoi",
          "partial": "Remainder",
          "signature": "[(Integer,Integer)]-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:chineseRemainder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echineseRemainder2 (r_1,m_1) (r_2,m_2)\u003c/code\u003e calculates the solution of\n\u003c/p\u003e\u003cpre\u003e\n r &#8801; r_k (mod m_k)\n\u003c/pre\u003e\u003cp\u003eif \u003ccode\u003em_1\u003c/code\u003e and \u003ccode\u003em_2\u003c/code\u003e are coprime.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "chineseRemainder2",
          "package": "arithmoi",
          "signature": "(Integer, Integer) -\u003e (Integer, Integer) -\u003e Integer",
          "source": "src/Math-NumberTheory-Moduli.html#chineseRemainder2",
          "type": "function"
        },
        "index": {
          "description": "chineseRemainder2 calculates the solution of mod if and are coprime",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "chineseRemainder2",
          "normalized": "(Integer,Integer)-\u003e(Integer,Integer)-\u003eInteger",
          "package": "arithmoi",
          "partial": "Remainder",
          "signature": "(Integer,Integer)-\u003e(Integer,Integer)-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:chineseRemainder2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert a number relative to a modulus.\n   If \u003ccode\u003enumber\u003c/code\u003e and \u003ccode\u003emodulus\u003c/code\u003e are coprime, the result is\n   \u003ccode\u003eJust inverse\u003c/code\u003e where\n\u003c/p\u003e\u003cpre\u003e    (number * inverse) `mod` (abs modulus) == 1\n    0 \u003c= inverse \u003c abs modulus\n\u003c/pre\u003e\u003cp\u003eunless \u003ccode\u003emodulus == 0\u003c/code\u003e and \u003ccode\u003eabs number == 1\u003c/code\u003e, in which case the\n   result is \u003ccode\u003eJust number\u003c/code\u003e.\n   If \u003ccode\u003egcd number modulus \u003e 1\u003c/code\u003e, the result is \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "invertMod",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Maybe Integer",
          "source": "src/Math-NumberTheory-Moduli.html#invertMod",
          "type": "function"
        },
        "index": {
          "description": "Invert number relative to modulus If number and modulus are coprime the result is Just inverse where number inverse mod abs modulus inverse abs modulus unless modulus and abs number in which case the result is Just number If gcd number modulus the result is Nothing",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "invertMod",
          "normalized": "Integer-\u003eInteger-\u003eMaybe Integer",
          "package": "arithmoi",
          "partial": "Mod",
          "signature": "Integer-\u003eInteger-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:invertMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJacobi symbol of two numbers.\n   The \"denominator\" must be odd and positive, this condition is checked.\n\u003c/p\u003e\u003cp\u003eIf both numbers have a common prime factor, the result\n   is \u003ccode\u003e0\u003c/code\u003e, otherwise it is &#177;1.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "jacobi",
          "package": "arithmoi",
          "signature": "a -\u003e a -\u003e Int",
          "source": "src/Math-NumberTheory-Moduli.html#jacobi",
          "type": "function"
        },
        "index": {
          "description": "Jacobi symbol of two numbers The denominator must be odd and positive this condition is checked If both numbers have common prime factor the result is otherwise it is",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "jacobi",
          "normalized": "a-\u003ea-\u003eInt",
          "package": "arithmoi",
          "signature": "a-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:jacobi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJacobi symbol of two numbers without validity check of\n   the \"denominator\".\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "jacobi'",
          "package": "arithmoi",
          "signature": "a -\u003e a -\u003e Int",
          "source": "src/Math-NumberTheory-Moduli.html#jacobi%27",
          "type": "function"
        },
        "index": {
          "description": "Jacobi symbol of two numbers without validity check of the denominator",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "jacobi'",
          "normalized": "a-\u003ea-\u003eInt",
          "package": "arithmoi",
          "signature": "a-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:jacobi-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModular power.\n\u003c/p\u003e\u003cpre\u003e powerMod base exponent modulus\n\u003c/pre\u003e\u003cp\u003ecalculates \u003ccode\u003e(base ^ exponent) `mod` modulus\u003c/code\u003e by repeated squaring and reduction.\n   If \u003ccode\u003eexponent \u003c 0\u003c/code\u003e and \u003ccode\u003ebase\u003c/code\u003e is invertible modulo \u003ccode\u003emodulus\u003c/code\u003e, \u003ccode\u003e(inverse ^ |exponent|) `mod` modulus\u003c/code\u003e\n   is calculated. This function does some input checking and sanitation before calling the unsafe worker.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Moduli\",\"Math.NumberTheory.Powers\"]",
          "name": "powerMod",
          "package": "arithmoi",
          "signature": "Integer -\u003e a -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Moduli.html#powerMod",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:powerMod\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:powerMod\"]"
        },
        "index": {
          "description": "Modular power powerMod base exponent modulus calculates base exponent mod modulus by repeated squaring and reduction If exponent and base is invertible modulo modulus inverse exponent mod modulus is calculated This function does some input checking and sanitation before calling the unsafe worker",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "powerMod",
          "normalized": "Integer-\u003ea-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Mod",
          "signature": "Integer-\u003ea-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:powerMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModular power worker without input checking.\n   Assumes all arguments strictly positive and modulus greater than 1.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "powerMod'",
          "package": "arithmoi",
          "signature": "Integer -\u003e a -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Moduli.html#powerMod%27",
          "type": "function"
        },
        "index": {
          "description": "Modular power worker without input checking Assumes all arguments strictly positive and modulus greater than",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "powerMod'",
          "normalized": "Integer-\u003ea-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Mod'",
          "signature": "Integer-\u003ea-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:powerMod-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialised version of \u003ccode\u003e\u003ca\u003epowerMod\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e exponents.\n   Reduces the number of shifts of the exponent since shifting\n   large \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003es is expensive. Call this function directly\n   if you don't want or can't rely on rewrite rules.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "powerModInteger",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Moduli.html#powerModInteger",
          "type": "function"
        },
        "index": {
          "description": "Specialised version of powerMod for Integer exponents Reduces the number of shifts of the exponent since shifting large Integer is expensive Call this function directly if you don want or can rely on rewrite rules",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "powerModInteger",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Mod Integer",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:powerModInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialised worker without input checks. Makes the same assumptions\n   as the general version \u003ccode\u003e\u003ca\u003epowerMod'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "powerModInteger'",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Moduli.html#powerModInteger%27",
          "type": "function"
        },
        "index": {
          "description": "Specialised worker without input checks Makes the same assumptions as the general version powerMod",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "powerModInteger'",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Mod Integer'",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:powerModInteger-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esqrtModF n primePowers\u003c/code\u003e calculates a square root of \u003ccode\u003en\u003c/code\u003e modulo\n   \u003ccode\u003eproduct [p^k | (p,k) \u003c- primePowers]\u003c/code\u003e if one exists and all primes\n   are distinct.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModF",
          "package": "arithmoi",
          "signature": "Integer -\u003e [(Integer, Int)] -\u003e Maybe Integer",
          "source": "src/Math-NumberTheory-Moduli.html#sqrtModF",
          "type": "function"
        },
        "index": {
          "description": "sqrtModF primePowers calculates square root of modulo product primePowers if one exists and all primes are distinct",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModF",
          "normalized": "Integer-\u003e[(Integer,Int)]-\u003eMaybe Integer",
          "package": "arithmoi",
          "partial": "Mod",
          "signature": "Integer-\u003e[(Integer,Int)]-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:sqrtModF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esqrtModFList n primePowers\u003c/code\u003e calculates all square roots of \u003ccode\u003en\u003c/code\u003e modulo\n   \u003ccode\u003eproduct [p^k | (p,k) \u003c- primePowers]\u003c/code\u003e if all primes are distinct.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModFList",
          "package": "arithmoi",
          "signature": "Integer -\u003e [(Integer, Int)] -\u003e [Integer]",
          "source": "src/Math-NumberTheory-Moduli.html#sqrtModFList",
          "type": "function"
        },
        "index": {
          "description": "sqrtModFList primePowers calculates all square roots of modulo product primePowers if all primes are distinct",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModFList",
          "normalized": "Integer-\u003e[(Integer,Int)]-\u003e[Integer]",
          "package": "arithmoi",
          "partial": "Mod FList",
          "signature": "Integer-\u003e[(Integer,Int)]-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:sqrtModFList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esqrtModP n prime\u003c/code\u003e calculates a modular square root of \u003ccode\u003en\u003c/code\u003e modulo \u003ccode\u003eprime\u003c/code\u003e\n   if that exists. The second argument \u003cem\u003emust\u003c/em\u003e be a (positive) prime, otherwise\n   the computation may not terminate and if it does, may yield a wrong result.\n   The precondition is \u003cem\u003enot\u003c/em\u003e checked.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003eprime\u003c/code\u003e is a prime and \u003ccode\u003en\u003c/code\u003e a quadratic residue modulo \u003ccode\u003eprime\u003c/code\u003e, the result\n   is \u003ccode\u003eJust r\u003c/code\u003e where \u003ccode\u003er^2 &#8801; n (mod prime)\u003c/code\u003e, if \u003ccode\u003en\u003c/code\u003e is a quadratic nonresidue,\n   the result is \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModP",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Maybe Integer",
          "source": "src/Math-NumberTheory-Moduli.html#sqrtModP",
          "type": "function"
        },
        "index": {
          "description": "sqrtModP prime calculates modular square root of modulo prime if that exists The second argument must be positive prime otherwise the computation may not terminate and if it does may yield wrong result The precondition is not checked If prime is prime and quadratic residue modulo prime the result is Just where mod prime if is quadratic nonresidue the result is Nothing",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModP",
          "normalized": "Integer-\u003eInteger-\u003eMaybe Integer",
          "package": "arithmoi",
          "partial": "Mod",
          "signature": "Integer-\u003eInteger-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:sqrtModP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esqrtModP' square prime\u003c/code\u003e finds a square root of \u003ccode\u003esquare\u003c/code\u003e modulo\n   prime. \u003ccode\u003eprime\u003c/code\u003e \u003cem\u003emust\u003c/em\u003e be a (positive) prime, and \u003ccode\u003esqaure\u003c/code\u003e \u003cem\u003emust\u003c/em\u003e be a\n   quadratic residue modulo \u003ccode\u003eprime\u003c/code\u003e, i.e. \u003ccode\u003e'jacobi square prime == 1\u003c/code\u003e.\n   The precondition is \u003cem\u003enot\u003c/em\u003e checked.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModP'",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Moduli.html#sqrtModP%27",
          "type": "function"
        },
        "index": {
          "description": "sqrtModP square prime finds square root of square modulo prime prime must be positive prime and sqaure must be quadratic residue modulo prime i.e jacobi square prime The precondition is not checked",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModP'",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Mod P'",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:sqrtModP-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esqrtModPList n prime\u003c/code\u003e computes the list of all square roots of \u003ccode\u003en\u003c/code\u003e\n   modulo \u003ccode\u003eprime\u003c/code\u003e. \u003ccode\u003eprime\u003c/code\u003e \u003cem\u003emust\u003c/em\u003e be a (positive) prime.\n   The precondition is \u003cem\u003enot\u003c/em\u003e checked.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModPList",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e [Integer]",
          "source": "src/Math-NumberTheory-Moduli.html#sqrtModPList",
          "type": "function"
        },
        "index": {
          "description": "sqrtModPList prime computes the list of all square roots of modulo prime prime must be positive prime The precondition is not checked",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModPList",
          "normalized": "Integer-\u003eInteger-\u003e[Integer]",
          "package": "arithmoi",
          "partial": "Mod PList",
          "signature": "Integer-\u003eInteger-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:sqrtModPList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esqrtModPP n (prime,expo)\u003c/code\u003e calculates a square root of \u003ccode\u003en\u003c/code\u003e\n   modulo \u003ccode\u003eprime^expo\u003c/code\u003e if one exists. \u003ccode\u003eprime\u003c/code\u003e \u003cem\u003emust\u003c/em\u003e be a\n   (positive) prime. \u003ccode\u003eexpo\u003c/code\u003e must be positive, \u003ccode\u003en\u003c/code\u003e must be coprime\n   to \u003ccode\u003eprime\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModPP",
          "package": "arithmoi",
          "signature": "Integer -\u003e (Integer, Int) -\u003e Maybe Integer",
          "source": "src/Math-NumberTheory-Moduli.html#sqrtModPP",
          "type": "function"
        },
        "index": {
          "description": "sqrtModPP prime expo calculates square root of modulo prime expo if one exists prime must be positive prime expo must be positive must be coprime to prime",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModPP",
          "normalized": "Integer-\u003e(Integer,Int)-\u003eMaybe Integer",
          "package": "arithmoi",
          "partial": "Mod PP",
          "signature": "Integer-\u003e(Integer,Int)-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:sqrtModPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esqrtModPPList n (prime,expo)\u003c/code\u003e calculates the list of all\n   square roots of \u003ccode\u003en\u003c/code\u003e modulo \u003ccode\u003eprime^expo\u003c/code\u003e. The same restriction\n   as in \u003ccode\u003e\u003ca\u003esqrtModPP\u003c/a\u003e\u003c/code\u003e applies to the arguments.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModPPList",
          "package": "arithmoi",
          "signature": "Integer -\u003e (Integer, Int) -\u003e [Integer]",
          "source": "src/Math-NumberTheory-Moduli.html#sqrtModPPList",
          "type": "function"
        },
        "index": {
          "description": "sqrtModPPList prime expo calculates the list of all square roots of modulo prime expo The same restriction as in sqrtModPP applies to the arguments",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "sqrtModPPList",
          "normalized": "Integer-\u003e(Integer,Int)-\u003e[Integer]",
          "package": "arithmoi",
          "partial": "Mod PPList",
          "signature": "Integer-\u003e(Integer,Int)-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:sqrtModPPList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etonelliShanks square prime\u003c/code\u003e calculates a square root of \u003ccode\u003esquare\u003c/code\u003e\n   modulo \u003ccode\u003eprime\u003c/code\u003e, where \u003ccode\u003eprime\u003c/code\u003e is a prime of the form \u003ccode\u003e4*k + 1\u003c/code\u003e and\n   \u003ccode\u003esquare\u003c/code\u003e is a quadratic residue modulo \u003ccode\u003eprime\u003c/code\u003e, using the\n   Tonelli-Shanks algorithm.\n   No checks on the input are performed.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Moduli",
          "name": "tonelliShanks",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Moduli.html#tonelliShanks",
          "type": "function"
        },
        "index": {
          "description": "tonelliShanks square prime calculates square root of square modulo prime where prime is prime of the form and square is quadratic residue modulo prime using the Tonelli-Shanks algorithm No checks on the input are performed",
          "hierarchy": "Math NumberTheory Moduli",
          "module": "Math.NumberTheory.Moduli",
          "name": "tonelliShanks",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Shanks",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Moduli.html#v:tonelliShanks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneralised Moebius inversion for \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e valued functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.MoebiusInversion.Int",
          "name": "Int",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-MoebiusInversion-Int.html",
          "type": "module"
        },
        "index": {
          "description": "Generalised Moebius inversion for Int valued functions",
          "hierarchy": "Math NumberTheory MoebiusInversion Int",
          "module": "Math.NumberTheory.MoebiusInversion.Int",
          "name": "Int",
          "package": "arithmoi",
          "partial": "Int",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-MoebiusInversion-Int.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeneralInversion g n\u003c/code\u003e evaluates the generalised Moebius inversion of \u003ccode\u003eg\u003c/code\u003e\n   at the argument \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe generalised Moebius inversion implemented here allows an efficient\n   calculation of isolated values of the function \u003ccode\u003ef : N -\u003e Z\u003c/code\u003e if the function\n   \u003ccode\u003eg\u003c/code\u003e defined by\n\u003c/p\u003e\u003cpre\u003e\n g n = sum [f (n `quot` k) | k \u003c- [1 .. n]]\n\n\u003c/pre\u003e\u003cp\u003ecan be cheaply computed. By the generalised Moebius inversion formula, then\n\u003c/p\u003e\u003cpre\u003e\n f n = sum [moebius k * g (n `quot` k) | k \u003c- [1 .. n]]\n\n\u003c/pre\u003e\u003cp\u003ewhich allows the computation in \u003cem\u003eO\u003c/em\u003e(n) steps, if the values of the\n   Moebius function are known. A slightly different formula, used here,\n   does not need the values of the Moebius function and allows the\n   computation in \u003cem\u003eO\u003c/em\u003e(n^0.75) steps, using \u003cem\u003eO\u003c/em\u003e(n^0.5) memory.\n\u003c/p\u003e\u003cp\u003eAn example of a pair of such functions where the inversion allows a\n   more efficient computation than the direct approach is\n\u003c/p\u003e\u003cpre\u003e\n f n = number of reduced proper fractions with denominator \u003c= n\n g n = number of proper fractions with denominator \u003c= n\n\n\u003c/pre\u003e\u003cp\u003e(a \u003cem\u003eproper fraction\u003c/em\u003e is a fraction \u003ccode\u003e0 \u003c n/d \u003c 1\u003c/code\u003e). Then \u003ccode\u003ef n\u003c/code\u003e is the\n   cardinality of the Farey sequence of order \u003ccode\u003en\u003c/code\u003e (minus 1 or 2 if 0 and/or\n   1 are included in the Farey sequence), or the sum of the totients of\n   the numbers \u003ccode\u003e2 \u003c= k \u003c= n\u003c/code\u003e. \u003ccode\u003ef n\u003c/code\u003e is not easily directly computable,\n   but then \u003ccode\u003eg n = n*(n-1)/2\u003c/code\u003e is very easy to compute, and hence the inversion\n   gives an efficient method of computing \u003ccode\u003ef n\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e valued functions, unboxed arrays can be used for greater efficiency.\n   That bears the risk of overflow, however, so be sure to use it only when it's\n   safe.\n\u003c/p\u003e\u003cp\u003eThe value \u003ccode\u003ef n\u003c/code\u003e is then computed by \u003ccode\u003egeneralInversion g n\u003c/code\u003e). Note that when\n   many values of \u003ccode\u003ef\u003c/code\u003e are needed, there are far more efficient methods, this\n   method is only appropriate to compute isolated values of \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.MoebiusInversion.Int",
          "name": "generalInversion",
          "package": "arithmoi",
          "signature": "(Int -\u003e Int) -\u003e Int -\u003e Int",
          "source": "src/Math-NumberTheory-MoebiusInversion-Int.html#generalInversion",
          "type": "function"
        },
        "index": {
          "description": "generalInversion evaluates the generalised Moebius inversion of at the argument The generalised Moebius inversion implemented here allows an efficient calculation of isolated values of the function if the function defined by sum quot can be cheaply computed By the generalised Moebius inversion formula then sum moebius quot which allows the computation in steps if the values of the Moebius function are known slightly different formula used here does not need the values of the Moebius function and allows the computation in steps using memory An example of pair of such functions where the inversion allows more efficient computation than the direct approach is number of reduced proper fractions with denominator number of proper fractions with denominator proper fraction is fraction Then is the cardinality of the Farey sequence of order minus or if and or are included in the Farey sequence or the sum of the totients of the numbers is not easily directly computable but then n-1 is very easy to compute and hence the inversion gives an efficient method of computing For Int valued functions unboxed arrays can be used for greater efficiency That bears the risk of overflow however so be sure to use it only when it safe The value is then computed by generalInversion Note that when many values of are needed there are far more efficient methods this method is only appropriate to compute isolated values of",
          "hierarchy": "Math NumberTheory MoebiusInversion Int",
          "module": "Math.NumberTheory.MoebiusInversion.Int",
          "name": "generalInversion",
          "normalized": "(Int-\u003eInt)-\u003eInt-\u003eInt",
          "package": "arithmoi",
          "partial": "Inversion",
          "signature": "(Int-\u003eInt)-\u003eInt-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-MoebiusInversion-Int.html#v:generalInversion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etotientSum n\u003c/code\u003e is, for \u003ccode\u003en \u003e 0\u003c/code\u003e, the sum of \u003ccode\u003e[totient k | k \u003c- [1 .. n]]\u003c/code\u003e,\n   computed via generalised Moebius inversion.\n   Arguments less than 1 cause an error to be raised.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.MoebiusInversion.Int",
          "name": "totientSum",
          "package": "arithmoi",
          "signature": "Int -\u003e Int",
          "source": "src/Math-NumberTheory-MoebiusInversion-Int.html#totientSum",
          "type": "function"
        },
        "index": {
          "description": "totientSum is for the sum of totient computed via generalised Moebius inversion Arguments less than cause an error to be raised",
          "hierarchy": "Math NumberTheory MoebiusInversion Int",
          "module": "Math.NumberTheory.MoebiusInversion.Int",
          "name": "totientSum",
          "normalized": "Int-\u003eInt",
          "package": "arithmoi",
          "partial": "Sum",
          "signature": "Int-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-MoebiusInversion-Int.html#v:totientSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneralised Moebius inversion\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.MoebiusInversion",
          "name": "MoebiusInversion",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-MoebiusInversion.html",
          "type": "module"
        },
        "index": {
          "description": "Generalised Moebius inversion",
          "hierarchy": "Math NumberTheory MoebiusInversion",
          "module": "Math.NumberTheory.MoebiusInversion",
          "name": "MoebiusInversion",
          "package": "arithmoi",
          "partial": "Moebius Inversion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-MoebiusInversion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeneralInversion g n\u003c/code\u003e evaluates the generalised Moebius inversion of \u003ccode\u003eg\u003c/code\u003e\n   at the argument \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe generalised Moebius inversion implemented here allows an efficient\n   calculation of isolated values of the function \u003ccode\u003ef : N -\u003e Z\u003c/code\u003e if the function\n   \u003ccode\u003eg\u003c/code\u003e defined by\n\u003c/p\u003e\u003cpre\u003e\n g n = sum [f (n `quot` k) | k \u003c- [1 .. n]]\n\n\u003c/pre\u003e\u003cp\u003ecan be cheaply computed. By the generalised Moebius inversion formula, then\n\u003c/p\u003e\u003cpre\u003e\n f n = sum [moebius k * g (n `quot` k) | k \u003c- [1 .. n]]\n\n\u003c/pre\u003e\u003cp\u003ewhich allows the computation in \u003cem\u003eO\u003c/em\u003e(n) steps, if the values of the\n   Moebius function are known. A slightly different formula, used here,\n   does not need the values of the Moebius function and allows the\n   computation in \u003cem\u003eO\u003c/em\u003e(n^0.75) steps, using \u003cem\u003eO\u003c/em\u003e(n^0.5) memory.\n\u003c/p\u003e\u003cp\u003eAn example of a pair of such functions where the inversion allows a\n   more efficient computation than the direct approach is\n\u003c/p\u003e\u003cpre\u003e\n f n = number of reduced proper fractions with denominator \u003c= n\n\n g n = number of proper fractions with denominator \u003c= n\n\n\u003c/pre\u003e\u003cp\u003e(a \u003cem\u003eproper fraction\u003c/em\u003e is a fraction \u003ccode\u003e0 \u003c n/d \u003c 1\u003c/code\u003e). Then \u003ccode\u003ef n\u003c/code\u003e is the\n   cardinality of the Farey sequence of order \u003ccode\u003en\u003c/code\u003e (minus 1 or 2 if 0 and/or\n   1 are included in the Farey sequence), or the sum of the totients of\n   the numbers \u003ccode\u003e2 \u003c= k \u003c= n\u003c/code\u003e. \u003ccode\u003ef n\u003c/code\u003e is not easily directly computable,\n   but then \u003ccode\u003eg n = n*(n-1)/2\u003c/code\u003e is very easy to compute, and hence the inversion\n   gives an efficient method of computing \u003ccode\u003ef n\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSince the function arguments are used as array indices, the domain of\n   \u003ccode\u003ef\u003c/code\u003e is restricted to \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe value \u003ccode\u003ef n\u003c/code\u003e is then computed by \u003ccode\u003egeneralInversion g n\u003c/code\u003e). Note that when\n   many values of \u003ccode\u003ef\u003c/code\u003e are needed, there are far more efficient methods, this\n   method is only appropriate to compute isolated values of \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.MoebiusInversion",
          "name": "generalInversion",
          "package": "arithmoi",
          "signature": "(Int -\u003e Integer) -\u003e Int -\u003e Integer",
          "source": "src/Math-NumberTheory-MoebiusInversion.html#generalInversion",
          "type": "function"
        },
        "index": {
          "description": "generalInversion evaluates the generalised Moebius inversion of at the argument The generalised Moebius inversion implemented here allows an efficient calculation of isolated values of the function if the function defined by sum quot can be cheaply computed By the generalised Moebius inversion formula then sum moebius quot which allows the computation in steps if the values of the Moebius function are known slightly different formula used here does not need the values of the Moebius function and allows the computation in steps using memory An example of pair of such functions where the inversion allows more efficient computation than the direct approach is number of reduced proper fractions with denominator number of proper fractions with denominator proper fraction is fraction Then is the cardinality of the Farey sequence of order minus or if and or are included in the Farey sequence or the sum of the totients of the numbers is not easily directly computable but then n-1 is very easy to compute and hence the inversion gives an efficient method of computing Since the function arguments are used as array indices the domain of is restricted to Int The value is then computed by generalInversion Note that when many values of are needed there are far more efficient methods this method is only appropriate to compute isolated values of",
          "hierarchy": "Math NumberTheory MoebiusInversion",
          "module": "Math.NumberTheory.MoebiusInversion",
          "name": "generalInversion",
          "normalized": "(Int-\u003eInteger)-\u003eInt-\u003eInteger",
          "package": "arithmoi",
          "partial": "Inversion",
          "signature": "(Int-\u003eInteger)-\u003eInt-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-MoebiusInversion.html#v:generalInversion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003etotientSum n\u003c/code\u003e is, for \u003ccode\u003en \u003e 0\u003c/code\u003e, the sum of \u003ccode\u003e[totient k | k \u003c- [1 .. n]]\u003c/code\u003e,\n   computed via generalised Moebius inversion.\n   Arguments less than 1 cause an error to be raised.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.MoebiusInversion",
          "name": "totientSum",
          "package": "arithmoi",
          "signature": "Int -\u003e Integer",
          "source": "src/Math-NumberTheory-MoebiusInversion.html#totientSum",
          "type": "function"
        },
        "index": {
          "description": "totientSum is for the sum of totient computed via generalised Moebius inversion Arguments less than cause an error to be raised",
          "hierarchy": "Math NumberTheory MoebiusInversion",
          "module": "Math.NumberTheory.MoebiusInversion",
          "name": "totientSum",
          "normalized": "Int-\u003eInteger",
          "package": "arithmoi",
          "partial": "Sum",
          "signature": "Int-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-MoebiusInversion.html#v:totientSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions dealing with cubes. Moderately efficient calculation of integer\n cube roots and testing for cubeness.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "Cubes",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Powers-Cubes.html",
          "type": "module"
        },
        "index": {
          "description": "Functions dealing with cubes Moderately efficient calculation of integer cube roots and testing for cubeness",
          "hierarchy": "Math NumberTheory Powers Cubes",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "Cubes",
          "package": "arithmoi",
          "partial": "Cubes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003eNothing\u003c/code\u003e if the argument is not a cube,\n   \u003ccode\u003eJust r\u003c/code\u003e if \u003ccode\u003en == r^3\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Cubes\",\"Math.NumberTheory.Powers\"]",
          "name": "exactCubeRoot",
          "package": "arithmoi",
          "signature": "a -\u003e Maybe a",
          "source": "src/Math-NumberTheory-Powers-Cubes.html#exactCubeRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:exactCubeRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:exactCubeRoot\"]"
        },
        "index": {
          "description": "Returns Nothing if the argument is not cube Just if",
          "hierarchy": "Math NumberTheory Powers Cubes",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "exactCubeRoot",
          "normalized": "a-\u003eMaybe a",
          "package": "arithmoi",
          "partial": "Cube Root",
          "signature": "a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:exactCubeRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer cube root of an integer \u003ccode\u003en\u003c/code\u003e,\n   that is the largest integer \u003ccode\u003er\u003c/code\u003e such that \u003ccode\u003er^3 \u003c= n\u003c/code\u003e.\n   Note that this is not symmetric about \u003ccode\u003e0\u003c/code\u003e, for example\n   \u003ccode\u003eintegerCubeRoot (-2) = (-2)\u003c/code\u003e while \u003ccode\u003eintegerCubeRoot 2 = 1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Cubes\",\"Math.NumberTheory.Powers\"]",
          "name": "integerCubeRoot",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Powers-Cubes.html#integerCubeRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:integerCubeRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:integerCubeRoot\"]"
        },
        "index": {
          "description": "Calculate the integer cube root of an integer that is the largest integer such that Note that this is not symmetric about for example integerCubeRoot while integerCubeRoot",
          "hierarchy": "Math NumberTheory Powers Cubes",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "integerCubeRoot",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Cube Root",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:integerCubeRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer cube root of a nonnegative integer \u003ccode\u003en\u003c/code\u003e,\n   that is, the largest integer \u003ccode\u003er\u003c/code\u003e such that \u003ccode\u003er^3 \u003c= n\u003c/code\u003e.\n   The precondition \u003ccode\u003en \u003e= 0\u003c/code\u003e is not checked.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "integerCubeRoot'",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Powers-Cubes.html#integerCubeRoot%27",
          "type": "function"
        },
        "index": {
          "description": "Calculate the integer cube root of nonnegative integer that is the largest integer such that The precondition is not checked",
          "hierarchy": "Math NumberTheory Powers Cubes",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "integerCubeRoot'",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Cube Root'",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:integerCubeRoot-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether an integer is a cube.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Cubes\",\"Math.NumberTheory.Powers\"]",
          "name": "isCube",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Cubes.html#isCube",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:isCube\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:isCube\"]"
        },
        "index": {
          "description": "Test whether an integer is cube",
          "hierarchy": "Math NumberTheory Powers Cubes",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "isCube",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Cube",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:isCube"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a nonnegative integer is a cube.\n   Before \u003ccode\u003e\u003ca\u003eintegerCubeRoot\u003c/a\u003e\u003c/code\u003e is calculated, a few tests\n   of remainders modulo small primes weed out most non-cubes.\n   For testing many numbers, most of which aren't cubes,\n   this is much faster than \u003ccode\u003elet r = cubeRoot n in r*r*r == n\u003c/code\u003e.\n   The condition \u003ccode\u003en \u003e= 0\u003c/code\u003e is \u003cem\u003enot\u003c/em\u003e checked.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "isCube'",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Cubes.html#isCube%27",
          "type": "function"
        },
        "index": {
          "description": "Test whether nonnegative integer is cube Before integerCubeRoot is calculated few tests of remainders modulo small primes weed out most non-cubes For testing many numbers most of which aren cubes this is much faster than let cubeRoot in The condition is not checked",
          "hierarchy": "Math NumberTheory Powers Cubes",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "isCube'",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Cube'",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:isCube-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a nonnegative number is possibly a cube.\n   Only about 0.08% of all numbers pass this test.\n   The precondition \u003ccode\u003en \u003e= 0\u003c/code\u003e is \u003cem\u003enot\u003c/em\u003e checked.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "isPossibleCube",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Cubes.html#isPossibleCube",
          "type": "function"
        },
        "index": {
          "description": "Test whether nonnegative number is possibly cube Only about of all numbers pass this test The precondition is not checked",
          "hierarchy": "Math NumberTheory Powers Cubes",
          "module": "Math.NumberTheory.Powers.Cubes",
          "name": "isPossibleCube",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Possible Cube",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Cubes.html#v:isPossibleCube"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions dealing with fourth powers. Efficient calculation of integer fourth\n roots and efficient testing for being a square's square.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "Fourth",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Powers-Fourth.html",
          "type": "module"
        },
        "index": {
          "description": "Functions dealing with fourth powers Efficient calculation of integer fourth roots and efficient testing for being square square",
          "hierarchy": "Math NumberTheory Powers Fourth",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "Fourth",
          "package": "arithmoi",
          "partial": "Fourth",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003eNothing\u003c/code\u003e if \u003ccode\u003en\u003c/code\u003e is not a fourth power,\n   \u003ccode\u003eJust r\u003c/code\u003e if \u003ccode\u003en == r^4\u003c/code\u003e and \u003ccode\u003er \u003e= 0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Fourth\",\"Math.NumberTheory.Powers\"]",
          "name": "exactFourthRoot",
          "package": "arithmoi",
          "signature": "a -\u003e Maybe a",
          "source": "src/Math-NumberTheory-Powers-Fourth.html#exactFourthRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:exactFourthRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:exactFourthRoot\"]"
        },
        "index": {
          "description": "Returns Nothing if is not fourth power Just if and",
          "hierarchy": "Math NumberTheory Powers Fourth",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "exactFourthRoot",
          "normalized": "a-\u003eMaybe a",
          "package": "arithmoi",
          "partial": "Fourth Root",
          "signature": "a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:exactFourthRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer fourth root of a nonnegative number,\n   that is, the largest integer \u003ccode\u003er\u003c/code\u003e with \u003ccode\u003er^4 \u003c= n\u003c/code\u003e.\n   Throws an error on negaitve input.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Fourth\",\"Math.NumberTheory.Powers\"]",
          "name": "integerFourthRoot",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Powers-Fourth.html#integerFourthRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:integerFourthRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:integerFourthRoot\"]"
        },
        "index": {
          "description": "Calculate the integer fourth root of nonnegative number that is the largest integer with Throws an error on negaitve input",
          "hierarchy": "Math NumberTheory Powers Fourth",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "integerFourthRoot",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Fourth Root",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:integerFourthRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer fourth root of a nonnegative number,\n   that is, the largest integer \u003ccode\u003er\u003c/code\u003e with \u003ccode\u003er^4 \u003c= n\u003c/code\u003e.\n   The condition is \u003cem\u003enot\u003c/em\u003e checked.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "integerFourthRoot'",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Powers-Fourth.html#integerFourthRoot%27",
          "type": "function"
        },
        "index": {
          "description": "Calculate the integer fourth root of nonnegative number that is the largest integer with The condition is not checked",
          "hierarchy": "Math NumberTheory Powers Fourth",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "integerFourthRoot'",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Fourth Root'",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:integerFourthRoot-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether an integer is a fourth power.\n   First nonnegativity is checked, then the unchecked\n   test is called.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Fourth\",\"Math.NumberTheory.Powers\"]",
          "name": "isFourthPower",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Fourth.html#isFourthPower",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:isFourthPower\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:isFourthPower\"]"
        },
        "index": {
          "description": "Test whether an integer is fourth power First nonnegativity is checked then the unchecked test is called",
          "hierarchy": "Math NumberTheory Powers Fourth",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "isFourthPower",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Fourth Power",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:isFourthPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a nonnegative number is a fourth power.\n   The condition is \u003cem\u003enot\u003c/em\u003e checked. If a number passes the\n   \u003ccode\u003e\u003ca\u003eisPossibleFourthPower\u003c/a\u003e\u003c/code\u003e test, its integer fourth root\n   is calculated.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "isFourthPower'",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Fourth.html#isFourthPower%27",
          "type": "function"
        },
        "index": {
          "description": "Test whether nonnegative number is fourth power The condition is not checked If number passes the isPossibleFourthPower test its integer fourth root is calculated",
          "hierarchy": "Math NumberTheory Powers Fourth",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "isFourthPower'",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Fourth Power'",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:isFourthPower-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a nonnegative number is a possible fourth power.\n   The condition is \u003cem\u003enot\u003c/em\u003e checked.\n   This eliminates about 99.958% of numbers.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "isPossibleFourthPower",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Fourth.html#isPossibleFourthPower",
          "type": "function"
        },
        "index": {
          "description": "Test whether nonnegative number is possible fourth power The condition is not checked This eliminates about of numbers",
          "hierarchy": "Math NumberTheory Powers Fourth",
          "module": "Math.NumberTheory.Powers.Fourth",
          "name": "isPossibleFourthPower",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Possible Fourth Power",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Fourth.html#v:isPossibleFourthPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCalculating integer roots and determining perfect powers.\n The algorithms are moderately efficient.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Powers.General",
          "name": "General",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Powers-General.html",
          "type": "module"
        },
        "index": {
          "description": "Calculating integer roots and determining perfect powers The algorithms are moderately efficient",
          "hierarchy": "Math NumberTheory Powers General",
          "module": "Math.NumberTheory.Powers.General",
          "name": "General",
          "package": "arithmoi",
          "partial": "General",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eexactRoot\u003c/a\u003e\u003c/code\u003e k n\u003c/code\u003e returns \u003ccode\u003e\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e if \u003ccode\u003en\u003c/code\u003e is not a \u003ccode\u003ek\u003c/code\u003e-th power,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e r\u003c/code\u003e if \u003ccode\u003en == r^k\u003c/code\u003e. If \u003ccode\u003ek\u003c/code\u003e is divisible by \u003ccode\u003e4, 3\u003c/code\u003e or \u003ccode\u003e2\u003c/code\u003e, a\n   residue test is performed to avoid the expensive calculation if it\n   can thus be determined that \u003ccode\u003en\u003c/code\u003e is not a \u003ccode\u003ek\u003c/code\u003e-th power.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.General\",\"Math.NumberTheory.Powers\"]",
          "name": "exactRoot",
          "package": "arithmoi",
          "signature": "b -\u003e a -\u003e Maybe a",
          "source": "src/Math-NumberTheory-Powers-General.html#exactRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:exactRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:exactRoot\"]"
        },
        "index": {
          "description": "exactRoot returns Nothing if is not th power Just if If is divisible by or residue test is performed to avoid the expensive calculation if it can thus be determined that is not th power",
          "hierarchy": "Math NumberTheory Powers General",
          "module": "Math.NumberTheory.Powers.General",
          "name": "exactRoot",
          "normalized": "a-\u003eb-\u003eMaybe b",
          "package": "arithmoi",
          "partial": "Root",
          "signature": "b-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:exactRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ehighestPower\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e produces the pair \u003ccode\u003e(b,k)\u003c/code\u003e with the largest\n   exponent \u003ccode\u003ek\u003c/code\u003e such that \u003ccode\u003en == b^k\u003c/code\u003e, except for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e n \u003c= 1\u003c/code\u003e,\n   in which case arbitrarily large exponents exist, and by an\n   arbitrary decision \u003ccode\u003e(n,3)\u003c/code\u003e is returned.\n\u003c/p\u003e\u003cp\u003eFirst, by trial division with small primes, the range of possible\n   exponents is reduced (if \u003ccode\u003ep^e\u003c/code\u003e exactly divides \u003ccode\u003en\u003c/code\u003e, then \u003ccode\u003ek\u003c/code\u003e must\n   be a divisor of \u003ccode\u003ee\u003c/code\u003e, if several small primes divide \u003ccode\u003en\u003c/code\u003e, \u003ccode\u003ek\u003c/code\u003e must\n   divide the greatest common divisor of their exponents, which mostly\n   will be \u003ccode\u003e1\u003c/code\u003e, generally small; if none of the small primes divides\n   \u003ccode\u003en\u003c/code\u003e, the range of possible exponents is reduced since the base is\n   necessarily large), if that has not yet determined the result, the\n   remaining factor is examined by trying the divisors of the \u003ccode\u003egcd\u003c/code\u003e\n   of the prime exponents if some have been found, otherwise by trying\n   prime exponents recursively.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.General\",\"Math.NumberTheory.Powers\"]",
          "name": "highestPower",
          "package": "arithmoi",
          "signature": "a -\u003e (a, Int)",
          "source": "src/Math-NumberTheory-Powers-General.html#highestPower",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:highestPower\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:highestPower\"]"
        },
        "index": {
          "description": "highestPower produces the pair with the largest exponent such that except for abs in which case arbitrarily large exponents exist and by an arbitrary decision is returned First by trial division with small primes the range of possible exponents is reduced if exactly divides then must be divisor of if several small primes divide must divide the greatest common divisor of their exponents which mostly will be generally small if none of the small primes divides the range of possible exponents is reduced since the base is necessarily large if that has not yet determined the result the remaining factor is examined by trying the divisors of the gcd of the prime exponents if some have been found otherwise by trying prime exponents recursively",
          "hierarchy": "Math NumberTheory Powers General",
          "module": "Math.NumberTheory.Powers.General",
          "name": "highestPower",
          "normalized": "a-\u003e(a,Int)",
          "package": "arithmoi",
          "partial": "Power",
          "signature": "a-\u003e(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:highestPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate an integer root, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eintegerRoot\u003c/a\u003e\u003c/code\u003e k n\u003c/code\u003e computes the (floor of) the \u003ccode\u003ek\u003c/code\u003e-th\n   root of \u003ccode\u003en\u003c/code\u003e, where \u003ccode\u003ek\u003c/code\u003e must be positive.\n   \u003ccode\u003er = \u003ccode\u003e\u003ca\u003eintegerRoot\u003c/a\u003e\u003c/code\u003e k n\u003c/code\u003e means \u003ccode\u003er^k \u003c= n \u003c (r+1)^k\u003c/code\u003e if that is possible at all.\n   It is impossible if \u003ccode\u003ek\u003c/code\u003e is even and \u003ccode\u003en \u003c 0\u003c/code\u003e, since then \u003ccode\u003er^k \u003e= 0\u003c/code\u003e for all \u003ccode\u003er\u003c/code\u003e,\n   then, and if \u003ccode\u003ek \u003c= 0\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eintegerRoot\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e raises an error. For \u003ccode\u003ek \u003c 5\u003c/code\u003e, a specialised\n   version is called which should be more efficient than the general algorithm.\n   However, it is not guaranteed that the rewrite rules for those fire, so if \u003ccode\u003ek\u003c/code\u003e is\n   known in advance, it is safer to directly call the specialised versions.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.General\",\"Math.NumberTheory.Powers\"]",
          "name": "integerRoot",
          "package": "arithmoi",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Math-NumberTheory-Powers-General.html#integerRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:integerRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:integerRoot\"]"
        },
        "index": {
          "description": "Calculate an integer root integerRoot computes the floor of the th root of where must be positive integerRoot means if that is possible at all It is impossible if is even and since then for all then and if integerRoot raises an error For specialised version is called which should be more efficient than the general algorithm However it is not guaranteed that the rewrite rules for those fire so if is known in advance it is safer to directly call the specialised versions",
          "hierarchy": "Math NumberTheory Powers General",
          "module": "Math.NumberTheory.Powers.General",
          "name": "integerRoot",
          "normalized": "a-\u003eb-\u003eb",
          "package": "arithmoi",
          "partial": "Root",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:integerRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisKthPower\u003c/a\u003e\u003c/code\u003e k n\u003c/code\u003e checks whether \u003ccode\u003en\u003c/code\u003e is a \u003ccode\u003ek\u003c/code\u003e-th power.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.General\",\"Math.NumberTheory.Powers\"]",
          "name": "isKthPower",
          "package": "arithmoi",
          "signature": "b -\u003e a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-General.html#isKthPower",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:isKthPower\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:isKthPower\"]"
        },
        "index": {
          "description": "isKthPower checks whether is th power",
          "hierarchy": "Math NumberTheory Powers General",
          "module": "Math.NumberTheory.Powers.General",
          "name": "isKthPower",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "arithmoi",
          "partial": "Kth Power",
          "signature": "b-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:isKthPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisPerfectPower\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e checks whether \u003ccode\u003en == r^k\u003c/code\u003e for some \u003ccode\u003ek \u003e 1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.General\",\"Math.NumberTheory.Powers\"]",
          "name": "isPerfectPower",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-General.html#isPerfectPower",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:isPerfectPower\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:isPerfectPower\"]"
        },
        "index": {
          "description": "isPerfectPower checks whether for some",
          "hierarchy": "Math NumberTheory Powers General",
          "module": "Math.NumberTheory.Powers.General",
          "name": "isPerfectPower",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Perfect Power",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-General.html#v:isPerfectPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions dealing with squares. Efficient calculation of integer square roots\n and efficient testing for squareness.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "Squares",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Powers-Squares.html",
          "type": "module"
        },
        "index": {
          "description": "Functions dealing with squares Efficient calculation of integer square roots and efficient testing for squareness",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "Squares",
          "package": "arithmoi",
          "partial": "Squares",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the argument is not a square,\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e r\u003c/code\u003e if \u003ccode\u003er*r == n\u003c/code\u003e and \u003ccode\u003er \u003e= 0\u003c/code\u003e. Avoids the expensive calculation\n   of the square root if \u003ccode\u003en\u003c/code\u003e is recognized as a non-square\n   before, prevents repeated calculation of the square root\n   if only the roots of perfect squares are needed.\n   Checks for negativity and \u003ccode\u003e\u003ca\u003eisPossibleSquare\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Squares\",\"Math.NumberTheory.Powers\"]",
          "name": "exactSquareRoot",
          "package": "arithmoi",
          "signature": "a -\u003e Maybe a",
          "source": "src/Math-NumberTheory-Powers-Squares.html#exactSquareRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:exactSquareRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:exactSquareRoot\"]"
        },
        "index": {
          "description": "Returns Nothing if the argument is not square Just if and Avoids the expensive calculation of the square root if is recognized as non-square before prevents repeated calculation of the square root if only the roots of perfect squares are needed Checks for negativity and isPossibleSquare",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "exactSquareRoot",
          "normalized": "a-\u003eMaybe a",
          "package": "arithmoi",
          "partial": "Square Root",
          "signature": "a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:exactSquareRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer square root of a nonnegative number \u003ccode\u003en\u003c/code\u003e,\n   that is, the largest integer \u003ccode\u003er\u003c/code\u003e with \u003ccode\u003er*r \u003c= n\u003c/code\u003e.\n   Throws an error on negative input.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Squares\",\"Math.NumberTheory.Powers\"]",
          "name": "integerSquareRoot",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Powers-Squares.html#integerSquareRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:integerSquareRoot\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:integerSquareRoot\"]"
        },
        "index": {
          "description": "Calculate the integer square root of nonnegative number that is the largest integer with Throws an error on negative input",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "integerSquareRoot",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Square Root",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:integerSquareRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the integer square root of a nonnegative number \u003ccode\u003en\u003c/code\u003e,\n   that is, the largest integer \u003ccode\u003er\u003c/code\u003e with \u003ccode\u003er*r \u003c= n\u003c/code\u003e.\n   The precondition \u003ccode\u003en \u003e= 0\u003c/code\u003e is not checked.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "integerSquareRoot'",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Powers-Squares.html#integerSquareRoot%27",
          "type": "function"
        },
        "index": {
          "description": "Calculate the integer square root of nonnegative number that is the largest integer with The precondition is not checked",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "integerSquareRoot'",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Square Root'",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:integerSquareRoot-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a non-negative number may be a square.\n   Non-negativity is not checked, passing negative arguments may\n   cause any kind of havoc.\n\u003c/p\u003e\u003cp\u003eFirst the remainder modulo 256 is checked (that can be calculated\n   easily without division and eliminates about 82% of all numbers).\n   After that, the remainders modulo 9, 25, 7, 11 and 13 are tested\n   to eliminate altogether about 99.436% of all numbers.\n\u003c/p\u003e\u003cp\u003eThis is the test used by \u003ccode\u003e\u003ca\u003eexactSquareRoot\u003c/a\u003e\u003c/code\u003e. For large numbers,\n   the slower but more discriminating test \u003ccode\u003eisPossibleSqure2\u003c/code\u003e is\n   faster.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "isPossibleSquare",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Squares.html#isPossibleSquare",
          "type": "function"
        },
        "index": {
          "description": "Test whether non-negative number may be square Non-negativity is not checked passing negative arguments may cause any kind of havoc First the remainder modulo is checked that can be calculated easily without division and eliminates about of all numbers After that the remainders modulo and are tested to eliminate altogether about of all numbers This is the test used by exactSquareRoot For large numbers the slower but more discriminating test isPossibleSqure2 is faster",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "isPossibleSquare",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Possible Square",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:isPossibleSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a non-negative number may be a square.\n   Non-negativity is not checked, passing negative arguments may\n   cause any kind of havoc.\n\u003c/p\u003e\u003cp\u003eFirst the remainder modulo 256 is checked (that can be calculated\n   easily without division and eliminates about 82% of all numbers).\n   After that, the remainders modulo several small primes are tested\n   to eliminate altogether about 99.98954% of all numbers.\n\u003c/p\u003e\u003cp\u003eFor smallish to medium sized numbers, this hardly performs better\n   than \u003ccode\u003e\u003ca\u003eisPossibleSquare\u003c/a\u003e\u003c/code\u003e, which uses smaller arrays, but for large\n   numbers, where calculating the square root becomes more expensive,\n   it is much faster (if the vast majority of tested numbers aren't squares).\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "isPossibleSquare2",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Squares.html#isPossibleSquare2",
          "type": "function"
        },
        "index": {
          "description": "Test whether non-negative number may be square Non-negativity is not checked passing negative arguments may cause any kind of havoc First the remainder modulo is checked that can be calculated easily without division and eliminates about of all numbers After that the remainders modulo several small primes are tested to eliminate altogether about of all numbers For smallish to medium sized numbers this hardly performs better than isPossibleSquare which uses smaller arrays but for large numbers where calculating the square root becomes more expensive it is much faster if the vast majority of tested numbers aren squares",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "isPossibleSquare2",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Possible Square",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:isPossibleSquare2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the argument is a square.\n   After a number is found to be positive, first \u003ccode\u003e\u003ca\u003eisPossibleSquare\u003c/a\u003e\u003c/code\u003e\n   is checked, if it is, the integer square root is calculated.\n\u003c/p\u003e",
          "module": "[\"Math.NumberTheory.Powers.Squares\",\"Math.NumberTheory.Powers\"]",
          "name": "isSquare",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Squares.html#isSquare",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:isSquare\",\"http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#v:isSquare\"]"
        },
        "index": {
          "description": "Test whether the argument is square After number is found to be positive first isPossibleSquare is checked if it is the integer square root is calculated",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "isSquare",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Square",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:isSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the input (a nonnegative number) \u003ccode\u003en\u003c/code\u003e is a square.\n   The same as \u003ccode\u003e\u003ca\u003eisSquare\u003c/a\u003e\u003c/code\u003e, but without the negativity test.\n   Faster if many known positive numbers are tested.\n\u003c/p\u003e\u003cp\u003eThe precondition \u003ccode\u003en \u003e= 0\u003c/code\u003e is not tested, passing negative\n   arguments may cause any kind of havoc.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "isSquare'",
          "package": "arithmoi",
          "signature": "a -\u003e Bool",
          "source": "src/Math-NumberTheory-Powers-Squares.html#isSquare%27",
          "type": "function"
        },
        "index": {
          "description": "Test whether the input nonnegative number is square The same as isSquare but without the negativity test Faster if many known positive numbers are tested The precondition is not tested passing negative arguments may cause any kind of havoc",
          "hierarchy": "Math NumberTheory Powers Squares",
          "module": "Math.NumberTheory.Powers.Squares",
          "name": "isSquare'",
          "normalized": "a-\u003eBool",
          "package": "arithmoi",
          "partial": "Square'",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers-Squares.html#v:isSquare-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCalculating integer roots, modular powers and related things.\n This module reexports the most needed functions from the implementation\n modules. The implementation modules provide some additional functions,\n in particular some unsafe functions which omit some tests for performance\n reasons.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Powers",
          "name": "Powers",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Powers.html",
          "type": "module"
        },
        "index": {
          "description": "Calculating integer roots modular powers and related things This module reexports the most needed functions from the implementation modules The implementation modules provide some additional functions in particular some unsafe functions which omit some tests for performance reasons",
          "hierarchy": "Math NumberTheory Powers",
          "module": "Math.NumberTheory.Powers",
          "name": "Powers",
          "package": "arithmoi",
          "partial": "Powers",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Powers.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumber of primes not exceeding \u003ccode\u003en\u003c/code\u003e, \u003ccode\u003e&#960;(n)\u003c/code\u003e, and \u003ccode\u003en\u003c/code\u003e-th prime; also fast, but\n reasonably accurate approximations to these.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "Counting",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Counting.html",
          "type": "module"
        },
        "index": {
          "description": "Number of primes not exceeding and th prime also fast but reasonably accurate approximations to these",
          "hierarchy": "Math NumberTheory Primes Counting",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "Counting",
          "package": "arithmoi",
          "partial": "Counting",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Counting.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eapproxPrimeCount\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e gives (for \u003ccode\u003en \u003e 0\u003c/code\u003e) an\n   approximation of the number of primes not exceeding\n   \u003ccode\u003en\u003c/code\u003e. The approximation is fairly good for \u003ccode\u003en\u003c/code\u003e large enough.\n   The number of primes should be slightly overestimated\n   (so it is suitable for allocation of storage) and is\n   never underestimated for \u003ccode\u003en \u003c= 10^12\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "approxPrimeCount",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Primes-Counting-Approximate.html#approxPrimeCount",
          "type": "function"
        },
        "index": {
          "description": "approxPrimeCount gives for an approximation of the number of primes not exceeding The approximation is fairly good for large enough The number of primes should be slightly overestimated so it is suitable for allocation of storage and is never underestimated for",
          "hierarchy": "Math NumberTheory Primes Counting",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "approxPrimeCount",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Prime Count",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Counting.html#v:approxPrimeCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003enthPrime\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e calculates the \u003ccode\u003en\u003c/code\u003e-th prime. Numbering of primes is\n   \u003ccode\u003e1\u003c/code\u003e-based, so \u003ccode\u003e\u003ccode\u003e\u003ca\u003enthPrime\u003c/a\u003e\u003c/code\u003e 1 == 2\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eRequires \u003ccode\u003e\u003cem\u003eO\u003c/em\u003e((n*log n)^0.5)\u003c/code\u003e space, the time complexity is roughly \u003ccode\u003e\u003cem\u003eO\u003c/em\u003e((n*log n)^0.7\u003c/code\u003e.\n   The argument must be strictly positive, and must not exceed \u003ccode\u003e1.5 * 10^17\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "nthPrime",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Counting-Impl.html#nthPrime",
          "type": "function"
        },
        "index": {
          "description": "nthPrime calculates the th prime Numbering of primes is based so nthPrime Requires log space the time complexity is roughly log The argument must be strictly positive and must not exceed",
          "hierarchy": "Math NumberTheory Primes Counting",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "nthPrime",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "partial": "Prime",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Counting.html#v:nthPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003enthPrimeApprox\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e gives (for \u003ccode\u003en \u003e 0\u003c/code\u003e) an\n   approximation to the n-th prime. The approximation\n   is fairly good for \u003ccode\u003en\u003c/code\u003e large enough. Dual to\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003eapproxPrimeCount\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, this estimate should err\n   on the low side (and does for \u003ccode\u003en \u003c 10^12\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "nthPrimeApprox",
          "package": "arithmoi",
          "signature": "a -\u003e a",
          "source": "src/Math-NumberTheory-Primes-Counting-Approximate.html#nthPrimeApprox",
          "type": "function"
        },
        "index": {
          "description": "nthPrimeApprox gives for an approximation to the n-th prime The approximation is fairly good for large enough Dual to approxPrimeCount this estimate should err on the low side and does for",
          "hierarchy": "Math NumberTheory Primes Counting",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "nthPrimeApprox",
          "normalized": "a-\u003ea",
          "package": "arithmoi",
          "partial": "Prime Approx",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Counting.html#v:nthPrimeApprox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eprimeCount\u003c/a\u003e\u003c/code\u003e n == &#960;(n)\u003c/code\u003e is the number of (positive) primes not exceeding \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor efficiency, the calculations are done on 64-bit signed integers, therefore \u003ccode\u003en\u003c/code\u003e must\n   not exceed \u003ccode\u003e8 * 10^18\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eRequires \u003ccode\u003e\u003cem\u003eO\u003c/em\u003e(n^0.5)\u003c/code\u003e space, the time complexity is roughly \u003ccode\u003e\u003cem\u003eO\u003c/em\u003e(n^0.7)\u003c/code\u003e.\n   For small bounds, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eprimeCount\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e simply counts the primes not exceeding \u003ccode\u003en\u003c/code\u003e,\n   for bounds from \u003ccode\u003e30000\u003c/code\u003e on, Meissel's algorithm is used in the improved form due to\n   D.H. Lehmer, cf.\n   \u003ca\u003ehttp://en.wikipedia.org/wiki/Prime_counting_function#Algorithms_for_evaluating_.CF.80.28x.29\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "primeCount",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Counting-Impl.html#primeCount",
          "type": "function"
        },
        "index": {
          "description": "primeCount is the number of positive primes not exceeding For efficiency the calculations are done on bit signed integers therefore must not exceed Requires space the time complexity is roughly For small bounds primeCount simply counts the primes not exceeding for bounds from on Meissel algorithm is used in the improved form due to D.H Lehmer cf http en.wikipedia.org wiki Prime counting function Algorithms for evaluating CF.80.28x.29",
          "hierarchy": "Math NumberTheory Primes Counting",
          "module": "Math.NumberTheory.Primes.Counting",
          "name": "primeCount",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "partial": "Count",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Counting.html#v:primeCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactorisation proving the primality of the found factors.\n\u003c/p\u003e\u003cp\u003eFor large numbers, this will be very slow in general.\n Use only if you're paranoid or must be \u003cem\u003ereally\u003c/em\u003e sure.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "Certified",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Certified.html",
          "type": "module"
        },
        "index": {
          "description": "Factorisation proving the primality of the found factors For large numbers this will be very slow in general Use only if you re paranoid or must be really sure",
          "hierarchy": "Math NumberTheory Primes Factorisation Certified",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "Certified",
          "package": "arithmoi",
          "partial": "Certified",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation-Certified.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecertificateFactorisation\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e produces a \u003ccode\u003e\u003ca\u003eprovenFactorisation\u003c/a\u003e\u003c/code\u003e\n   with a default bound of \u003ccode\u003e100000\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "certificateFactorisation",
          "package": "arithmoi",
          "signature": "Integer -\u003e [((Integer, Int), PrimalityProof)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Certified.html#certificateFactorisation",
          "type": "function"
        },
        "index": {
          "description": "certificateFactorisation produces provenFactorisation with default bound of",
          "hierarchy": "Math NumberTheory Primes Factorisation Certified",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "certificateFactorisation",
          "normalized": "Integer-\u003e[((Integer,Int),PrimalityProof)]",
          "package": "arithmoi",
          "partial": "Factorisation",
          "signature": "Integer-\u003e[((Integer,Int),PrimalityProof)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation-Certified.html#v:certificateFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecertifiedFactorisation\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e produces the prime factorisation\n   of \u003ccode\u003en\u003c/code\u003e, proving the primality of the factors, but doesn't report the proofs.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "certifiedFactorisation",
          "package": "arithmoi",
          "signature": "Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Certified.html#certifiedFactorisation",
          "type": "function"
        },
        "index": {
          "description": "certifiedFactorisation produces the prime factorisation of proving the primality of the factors but doesn report the proofs",
          "hierarchy": "Math NumberTheory Primes Factorisation Certified",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "certifiedFactorisation",
          "normalized": "Integer-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Factorisation",
          "signature": "Integer-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation-Certified.html#v:certifiedFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eprovenFactorisation\u003c/a\u003e\u003c/code\u003e bound n\u003c/code\u003e constructs a the prime factorisation of \u003ccode\u003en\u003c/code\u003e\n   (which must be positive) together with proofs of primality of the factors,\n   using trial division up to \u003ccode\u003ebound\u003c/code\u003e (which is arbitrarily replaced by \u003ccode\u003e2000\u003c/code\u003e\n   if the supplied value is smaller) and elliptic curve factorisation for the\n   remaining factors if necessary.\n\u003c/p\u003e\u003cp\u003eConstruction of primality proofs can take a \u003cem\u003every\u003c/em\u003e long time, so this\n   will usually be slow (but should be faster than using \u003ccode\u003e\u003ca\u003efactorise\u003c/a\u003e\u003c/code\u003e and\n   proving the primality of the factors from scratch).\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "provenFactorisation",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e [((Integer, Int), PrimalityProof)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Certified.html#provenFactorisation",
          "type": "function"
        },
        "index": {
          "description": "provenFactorisation bound constructs the prime factorisation of which must be positive together with proofs of primality of the factors using trial division up to bound which is arbitrarily replaced by if the supplied value is smaller and elliptic curve factorisation for the remaining factors if necessary Construction of primality proofs can take very long time so this will usually be slow but should be faster than using factorise and proving the primality of the factors from scratch",
          "hierarchy": "Math NumberTheory Primes Factorisation Certified",
          "module": "Math.NumberTheory.Primes.Factorisation.Certified",
          "name": "provenFactorisation",
          "normalized": "Integer-\u003eInteger-\u003e[((Integer,Int),PrimalityProof)]",
          "package": "arithmoi",
          "partial": "Factorisation",
          "signature": "Integer-\u003eInteger-\u003e[((Integer,Int),PrimalityProof)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation-Certified.html#v:provenFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious functions related to prime factorisation.\n Many of these functions use the prime factorisation of an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n If several of them are used on the same \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e, it would be inefficient\n to recalculate the factorisation, hence there are also functions working\n on the canonical factorisation, these require that the number be positive\n and in the case of the Carmichael function that the list of prime factors\n with their multiplicities is ascending.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "Factorisation",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html",
          "type": "module"
        },
        "index": {
          "description": "Various functions related to prime factorisation Many of these functions use the prime factorisation of an Integer If several of them are used on the same Integer it would be inefficient to recalculate the factorisation hence there are also functions working on the canonical factorisation these require that the number be positive and in the case of the Carmichael function that the list of prime factors with their multiplicities is ascending",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "Factorisation",
          "package": "arithmoi",
          "partial": "Factorisation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compact store of values of the Carmichael function.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "CarmichaelSieve",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#CarmichaelSieve",
          "type": "data"
        },
        "index": {
          "description": "compact store of values of the Carmichael function",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "CarmichaelSieve",
          "package": "arithmoi",
          "partial": "Carmichael Sieve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#t:CarmichaelSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compact store of smallest prime factors.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "FactorSieve",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#FactorSieve",
          "type": "data"
        },
        "index": {
          "description": "compact store of smallest prime factors",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "FactorSieve",
          "package": "arithmoi",
          "partial": "Factor Sieve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#t:FactorSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compact store of totients.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "TotientSieve",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#TotientSieve",
          "type": "data"
        },
        "index": {
          "description": "compact store of totients",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "TotientSieve",
          "package": "arithmoi",
          "partial": "Totient Sieve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias of \u003ccode\u003e\u003ca\u003ecarmichael\u003c/a\u003e\u003c/code\u003e for people who prefer Greek letters.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "λ",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#%3BB",
          "type": "function"
        },
        "index": {
          "description": "Alias of carmichael for people who prefer Greek letters",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "λ",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:-955-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003esigma\u003c/a\u003e\u003c/code\u003e for people preferring Greek letters.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "σ",
          "package": "arithmoi",
          "signature": "Int -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#%3C3",
          "type": "function"
        },
        "index": {
          "description": "Alias for sigma for people preferring Greek letters",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "σ",
          "normalized": "Int-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "signature": "Int-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:-963-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003etau\u003c/a\u003e\u003c/code\u003e for people preferring Greek letters.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "τ",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#%3C4",
          "type": "function"
        },
        "index": {
          "description": "Alias for tau for people preferring Greek letters",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "τ",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:-964-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias of \u003ccode\u003e\u003ca\u003etotient\u003c/a\u003e\u003c/code\u003e for people who prefer Greek letters.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "φ",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#%3C6",
          "type": "function"
        },
        "index": {
          "description": "Alias of totient for people who prefer Greek letters",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "φ",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:-966-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculates the Carmichael function for a positive integer, that is,\n   the (smallest) exponent of the group of units in \u003ccode\u003e&8484;/(n)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "carmichael",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#carmichael",
          "type": "function"
        },
        "index": {
          "description": "Calculates the Carmichael function for positive integer that is the smallest exponent of the group of units in",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "carmichael",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:carmichael"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the Carmichael function from the factorisation.\n   Requires that the list of prime factors is strictly ascending.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "carmichaelFromCanonical",
          "package": "arithmoi",
          "signature": "[(Integer, Int)] -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Utils.html#carmichaelFromCanonical",
          "type": "function"
        },
        "index": {
          "description": "Calculate the Carmichael function from the factorisation Requires that the list of prime factors is strictly ascending",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "carmichaelFromCanonical",
          "normalized": "[(Integer,Int)]-\u003eInteger",
          "package": "arithmoi",
          "partial": "From Canonical",
          "signature": "[(Integer,Int)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:carmichaelFromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecarmichaelSieve\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e creates a store of values of the Carmichael function\n   for numbers not exceeding \u003ccode\u003en\u003c/code\u003e.\n   Like a \u003ccode\u003e\u003ca\u003eTotientSieve\u003c/a\u003e\u003c/code\u003e, a \u003ccode\u003e\u003ca\u003eCarmichaelSieve\u003c/a\u003e\u003c/code\u003e only stores values for numbers coprime to \u003ccode\u003e30\u003c/code\u003e\n   to reduce space usage. The maximal admissible value for \u003ccode\u003en\u003c/code\u003e is \u003ccode\u003e\u003ccode\u003e\u003ca\u003efromIntegral\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "carmichaelSieve",
          "package": "arithmoi",
          "signature": "Integer -\u003e CarmichaelSieve",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#carmichaelSieve",
          "type": "function"
        },
        "index": {
          "description": "carmichaelSieve creates store of values of the Carmichael function for numbers not exceeding Like TotientSieve CarmichaelSieve only stores values for numbers coprime to to reduce space usage The maximal admissible value for is fromIntegral maxBound Word",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "carmichaelSieve",
          "normalized": "Integer-\u003eCarmichaelSieve",
          "package": "arithmoi",
          "partial": "Sieve",
          "signature": "Integer-\u003eCarmichaelSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:carmichaelSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecurveFactorisation\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is the driver for the factorisation. Its performance (and success)\n   can be influenced by passing appropriate arguments. If you know that \u003ccode\u003en\u003c/code\u003e has no prime divisors\n   below \u003ccode\u003eb\u003c/code\u003e, any divisor found less than \u003ccode\u003eb*b\u003c/code\u003e must be prime, thus giving \u003ccode\u003eJust (b*b)\u003c/code\u003e as the\n   first argument allows skipping the comparatively expensive primality test for those.\n   If \u003ccode\u003en\u003c/code\u003e is such that all prime divisors must have a specific easy to test for structure, a\n   custom primality test can improve the performance (normally, it will make very little\n   difference, since \u003ccode\u003en\u003c/code\u003e has not many divisors, and many curves have to be tried to find one).\n   More influence has the pseudo random generator (a function \u003ccode\u003eprng\u003c/code\u003e with \u003ccode\u003e6 \u003c= fst (prng k s) \u003c= k-2\u003c/code\u003e\n   and an initial state for the PRNG) used to generate the curves to try. A lucky choice here can\n   make a huge difference. So, if the default takes too long, try another one; or you can improve your\n   chances for a quick result by running several instances in parallel.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecurveFactorisation\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e requires that small prime factors have been stripped before. Also, it is\n   unlikely to succeed if \u003ccode\u003en\u003c/code\u003e has more than one (really) large prime factor.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "curveFactorisation",
          "package": "arithmoi",
          "signature": "Maybe Integer-\u003e (Integer -\u003e Bool)-\u003e (Integer -\u003e g -\u003e (Integer, g))-\u003e g-\u003e Maybe Int-\u003e Integer-\u003e [(Integer, Int)]",
          "type": "function"
        },
        "index": {
          "description": "curveFactorisation is the driver for the factorisation Its performance and success can be influenced by passing appropriate arguments If you know that has no prime divisors below any divisor found less than must be prime thus giving Just as the first argument allows skipping the comparatively expensive primality test for those If is such that all prime divisors must have specific easy to test for structure custom primality test can improve the performance normally it will make very little difference since has not many divisors and many curves have to be tried to find one More influence has the pseudo random generator function prng with fst prng k-2 and an initial state for the PRNG used to generate the curves to try lucky choice here can make huge difference So if the default takes too long try another one or you can improve your chances for quick result by running several instances in parallel curveFactorisation requires that small prime factors have been stripped before Also it is unlikely to succeed if has more than one really large prime factor",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "curveFactorisation",
          "normalized": "Maybe Integer-\u003e(Integer-\u003eBool)-\u003e(Integer-\u003ea-\u003e(Integer,a))-\u003ea-\u003eMaybe Int-\u003eInteger-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Factorisation",
          "signature": "Maybe Integer-\u003e(Integer-\u003eBool)-\u003e(Integer-\u003eg-\u003e(Integer,g))-\u003eg-\u003eMaybe Int-\u003eInteger-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:curveFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003edefaultStdGenFactorisation\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e first strips off all small prime factors and then,\n   if the factorisation is not complete, proceeds to curve factorisation.\n   For negative numbers, a factor of \u003ccode\u003e-1\u003c/code\u003e is included, the factorisation of \u003ccode\u003e1\u003c/code\u003e\n   is empty. Since \u003ccode\u003e0\u003c/code\u003e has no prime factorisation, a zero argument causes\n   an error.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "defaultStdGenFactorisation",
          "package": "arithmoi",
          "signature": "StdGen -\u003e Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Montgomery.html#defaultStdGenFactorisation",
          "type": "function"
        },
        "index": {
          "description": "defaultStdGenFactorisation first strips off all small prime factors and then if the factorisation is not complete proceeds to curve factorisation For negative numbers factor of is included the factorisation of is empty Since has no prime factorisation zero argument causes an error",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "defaultStdGenFactorisation",
          "normalized": "StdGen-\u003eInteger-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Std Gen Factorisation",
          "signature": "StdGen-\u003eInteger-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:defaultStdGenFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003edefaultStdGenFactorisation\u003c/a\u003e\u003c/code\u003e, but without input checking, so\n   \u003ccode\u003en\u003c/code\u003e must be larger than \u003ccode\u003e1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "defaultStdGenFactorisation'",
          "package": "arithmoi",
          "signature": "StdGen -\u003e Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Montgomery.html#defaultStdGenFactorisation%27",
          "type": "function"
        },
        "index": {
          "description": "Like defaultStdGenFactorisation but without input checking so must be larger than",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "defaultStdGenFactorisation'",
          "normalized": "StdGen-\u003eInteger-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Std Gen Factorisation'",
          "signature": "StdGen-\u003eInteger-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:defaultStdGenFactorisation-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003etau\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorCount",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#divisorCount",
          "type": "function"
        },
        "index": {
          "description": "Alias for tau",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorCount",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "partial": "Count",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:divisorCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for \u003ccode\u003e\u003ca\u003esigma\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorPowerSum",
          "package": "arithmoi",
          "signature": "Int -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#divisorPowerSum",
          "type": "function"
        },
        "index": {
          "description": "Alias for sigma",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorPowerSum",
          "normalized": "Int-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Power Sum",
          "signature": "Int-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:divisorPowerSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of all (positive) divisors of a positive number \u003ccode\u003en\u003c/code\u003e,\n   calculated from its prime factorisation.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorSum",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#divisorSum",
          "type": "function"
        },
        "index": {
          "description": "The sum of all positive divisors of positive number calculated from its prime factorisation",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorSum",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "partial": "Sum",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:divisorSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of all divisors, efficiently calculated from the canonical factorisation.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorSumFromCanonical",
          "package": "arithmoi",
          "signature": "[(Integer, Int)] -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Utils.html#divisorSumFromCanonical",
          "type": "function"
        },
        "index": {
          "description": "The sum of all divisors efficiently calculated from the canonical factorisation",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorSumFromCanonical",
          "normalized": "[(Integer,Int)]-\u003eInteger",
          "package": "arithmoi",
          "partial": "Sum From Canonical",
          "signature": "[(Integer,Int)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:divisorSumFromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003edivisors\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e is the set of all (positive) divisors of \u003ccode\u003en\u003c/code\u003e.\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003edivisors\u003c/a\u003e\u003c/code\u003e 0\u003c/code\u003e is an error because we can't create the set of all \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisors",
          "package": "arithmoi",
          "signature": "Integer -\u003e Set Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#divisors",
          "type": "function"
        },
        "index": {
          "description": "divisors is the set of all positive divisors of divisors is an error because we can create the set of all Integer",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisors",
          "normalized": "Integer-\u003eSet Integer",
          "package": "arithmoi",
          "signature": "Integer-\u003eSet Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:divisors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of divisors, efficiently calculated from the canonical factorisation.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorsFromCanonical",
          "package": "arithmoi",
          "signature": "[(Integer, Int)] -\u003e Set Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Utils.html#divisorsFromCanonical",
          "type": "function"
        },
        "index": {
          "description": "The set of divisors efficiently calculated from the canonical factorisation",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "divisorsFromCanonical",
          "normalized": "[(Integer,Int)]-\u003eSet Integer",
          "package": "arithmoi",
          "partial": "From Canonical",
          "signature": "[(Integer,Int)]-\u003eSet Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:divisorsFromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efactorSieve\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e creates a store of smallest prime factors of the numbers not exceeding \u003ccode\u003en\u003c/code\u003e.\n   If you need to factorise many smallish numbers, this can give a big speedup since it avoids\n   many superfluous divisions. However, a too large sieve leads to a slowdown due to cache misses.\n   The prime factors are stored as \u003ccode\u003e\u003ca\u003eWord16\u003c/a\u003e\u003c/code\u003e for compactness, so \u003ccode\u003en\u003c/code\u003e must be\n   smaller than \u003ccode\u003e2^32\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "factorSieve",
          "package": "arithmoi",
          "signature": "Integer -\u003e FactorSieve",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#factorSieve",
          "type": "function"
        },
        "index": {
          "description": "factorSieve creates store of smallest prime factors of the numbers not exceeding If you need to factorise many smallish numbers this can give big speedup since it avoids many superfluous divisions However too large sieve leads to slowdown due to cache misses The prime factors are stored as Word16 for compactness so must be smaller than",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "factorSieve",
          "normalized": "Integer-\u003eFactorSieve",
          "package": "arithmoi",
          "partial": "Sieve",
          "signature": "Integer-\u003eFactorSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:factorSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efactorise\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e produces the prime factorisation of \u003ccode\u003en\u003c/code\u003e, including\n   a factor of \u003ccode\u003e(-1)\u003c/code\u003e if \u003ccode\u003en \u003c 0\u003c/code\u003e. \u003ccode\u003e\u003ccode\u003e\u003ca\u003efactorise\u003c/a\u003e\u003c/code\u003e 0\u003c/code\u003e is an error and the\n   factorisation of \u003ccode\u003e1\u003c/code\u003e is empty. Uses a \u003ccode\u003e\u003ca\u003eStdGen\u003c/a\u003e\u003c/code\u003e produced in an arbitrary\n   manner from the bit-pattern of \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "factorise",
          "package": "arithmoi",
          "signature": "Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Montgomery.html#factorise",
          "type": "function"
        },
        "index": {
          "description": "factorise produces the prime factorisation of including factor of if factorise is an error and the factorisation of is empty Uses StdGen produced in an arbitrary manner from the bit-pattern of",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "factorise",
          "normalized": "Integer-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "signature": "Integer-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:factorise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003efactorise\u003c/a\u003e\u003c/code\u003e, but without input checking, hence \u003ccode\u003en \u003e 1\u003c/code\u003e is required.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "factorise'",
          "package": "arithmoi",
          "signature": "Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Montgomery.html#factorise%27",
          "type": "function"
        },
        "index": {
          "description": "Like factorise but without input checking hence is required",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "factorise'",
          "normalized": "Integer-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "signature": "Integer-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:factorise-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003emontgomeryFactorisation\u003c/a\u003e\u003c/code\u003e n b1 b2 s\u003c/code\u003e tries to find a factor of \u003ccode\u003en\u003c/code\u003e using the\n   curve and point determined by the seed \u003ccode\u003es\u003c/code\u003e (\u003ccode\u003e6 \u003c= s \u003c n-1\u003c/code\u003e), multiplying the\n   point by the least common multiple of all numbers \u003ccode\u003e\u003c= b1\u003c/code\u003e and all primes\n   between \u003ccode\u003eb1\u003c/code\u003e and \u003ccode\u003eb2\u003c/code\u003e. The idea is that there's a good chance that the order\n   of the point in the curve over one prime factor divides the multiplier, but the\n   order over another factor doesn't, if \u003ccode\u003eb1\u003c/code\u003e and \u003ccode\u003eb2\u003c/code\u003e are appropriately chosen.\n   If they are too small, none of the orders will probably divide the multiplier,\n   if they are too large, all probably will, so they should be chosen to fit\n   the expected size of the smallest factor.\n\u003c/p\u003e\u003cp\u003eIt is assumed that \u003ccode\u003en\u003c/code\u003e has no small prime factors.\n\u003c/p\u003e\u003cp\u003eThe result is maybe a nontrivial divisor of \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "montgomeryFactorisation",
          "package": "arithmoi",
          "signature": "Integer -\u003e Word -\u003e Word -\u003e Integer -\u003e Maybe Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Montgomery.html#montgomeryFactorisation",
          "type": "function"
        },
        "index": {
          "description": "montgomeryFactorisation b1 b2 tries to find factor of using the curve and point determined by the seed n-1 multiplying the point by the least common multiple of all numbers b1 and all primes between b1 and b2 The idea is that there good chance that the order of the point in the curve over one prime factor divides the multiplier but the order over another factor doesn if b1 and b2 are appropriately chosen If they are too small none of the orders will probably divide the multiplier if they are too large all probably will so they should be chosen to fit the expected size of the smallest factor It is assumed that has no small prime factors The result is maybe nontrivial divisor of",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "montgomeryFactorisation",
          "normalized": "Integer-\u003eWord-\u003eWord-\u003eInteger-\u003eMaybe Integer",
          "package": "arithmoi",
          "partial": "Factorisation",
          "signature": "Integer-\u003eWord-\u003eWord-\u003eInteger-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:montgomeryFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esieveCarmichael\u003c/a\u003e\u003c/code\u003e cs n\u003c/code\u003e finds the value of \u003ccode\u003e&#955;(n)\u003c/code\u003e (or \u003ccode\u003e&#968;(n)\u003c/code\u003e), the smallest positive\n   integer \u003ccode\u003ee\u003c/code\u003e such that for all \u003ccode\u003ea\u003c/code\u003e with \u003ccode\u003egcd a n == 1\u003c/code\u003e the congruence \u003ccode\u003ea^e &#8801; 1 (mod n)\u003c/code\u003e holds,\n   in other words, the (smallest) exponent of the group of units in \u003ccode\u003e&#8484;/(n)\u003c/code\u003e.\n   The strategy is analogous to \u003ccode\u003e\u003ca\u003esieveTotient\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sieveCarmichael",
          "package": "arithmoi",
          "signature": "CarmichaelSieve -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#sieveCarmichael",
          "type": "function"
        },
        "index": {
          "description": "sieveCarmichael cs finds the value of or the smallest positive integer such that for all with gcd the congruence mod holds in other words the smallest exponent of the group of units in The strategy is analogous to sieveTotient",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sieveCarmichael",
          "normalized": "CarmichaelSieve-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Carmichael",
          "signature": "CarmichaelSieve-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:sieveCarmichael"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esieveFactor\u003c/a\u003e\u003c/code\u003e fs n\u003c/code\u003e finds the prime factorisation of \u003ccode\u003en\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003eFactorSieve\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efs\u003c/code\u003e.\n   For negative \u003ccode\u003en\u003c/code\u003e, a factor of \u003ccode\u003e-1\u003c/code\u003e is included with multiplicity \u003ccode\u003e1\u003c/code\u003e.\n   After stripping any present factors \u003ccode\u003e2\u003c/code\u003e, the remaining cofactor \u003ccode\u003ec\u003c/code\u003e (if larger\n   than \u003ccode\u003e1\u003c/code\u003e) is factorised with \u003ccode\u003efs\u003c/code\u003e. This is most efficient of course if \u003ccode\u003ec\u003c/code\u003e does not\n   exceed the bound with which \u003ccode\u003efs\u003c/code\u003e was constructed. If it does, trial division is performed\n   until either the cofactor falls below the bound or the sieve is exhausted. In the latter\n   case, the elliptic curve method is used to finish the factorisation.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sieveFactor",
          "package": "arithmoi",
          "signature": "FactorSieve -\u003e Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#sieveFactor",
          "type": "function"
        },
        "index": {
          "description": "sieveFactor fs finds the prime factorisation of using the FactorSieve fs For negative factor of is included with multiplicity After stripping any present factors the remaining cofactor if larger than is factorised with fs This is most efficient of course if does not exceed the bound with which fs was constructed If it does trial division is performed until either the cofactor falls below the bound or the sieve is exhausted In the latter case the elliptic curve method is used to finish the factorisation",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sieveFactor",
          "normalized": "FactorSieve-\u003eInteger-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Factor",
          "signature": "FactorSieve-\u003eInteger-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:sieveFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esieveTotient\u003c/a\u003e\u003c/code\u003e ts n\u003c/code\u003e finds the totient \u003ccode\u003e&#960;(n)\u003c/code\u003e, i.e. the number of integers \u003ccode\u003ek\u003c/code\u003e with\n   \u003ccode\u003e1 \u003c= k \u003c= n\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e n k == 1\u003c/code\u003e, in other words, the order of the group of units\n   in \u003ccode\u003e&#8484;/(n)\u003c/code\u003e, using the \u003ccode\u003e\u003ca\u003eTotientSieve\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ets\u003c/code\u003e.\n   First, factors of \u003ccode\u003e2, 3\u003c/code\u003e and \u003ccode\u003e5\u003c/code\u003e are handled individually, if the remaining\n   cofactor of \u003ccode\u003en\u003c/code\u003e is within the sieve range, its totient is looked up, otherwise\n   the calculation falls back on factorisation, first by trial division and\n   if necessary, elliptic curves.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sieveTotient",
          "package": "arithmoi",
          "signature": "TotientSieve -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#sieveTotient",
          "type": "function"
        },
        "index": {
          "description": "sieveTotient ts finds the totient i.e the number of integers with and gcd in other words the order of the group of units in using the TotientSieve ts First factors of and are handled individually if the remaining cofactor of is within the sieve range its totient is looked up otherwise the calculation falls back on factorisation first by trial division and if necessary elliptic curves",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sieveTotient",
          "normalized": "TotientSieve-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "partial": "Totient",
          "signature": "TotientSieve-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:sieveTotient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esigma\u003c/a\u003e\u003c/code\u003e k n\u003c/code\u003e is the sum of the \u003ccode\u003ek\u003c/code\u003e-th powers of the\n   (positive) divisors of \u003ccode\u003en\u003c/code\u003e. \u003ccode\u003ek\u003c/code\u003e must be non-negative and \u003ccode\u003en\u003c/code\u003e positive.\n   For \u003ccode\u003ek == 0\u003c/code\u003e, it is the divisor count (\u003ccode\u003ed^0 = 1\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sigma",
          "package": "arithmoi",
          "signature": "Int -\u003e Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#sigma",
          "type": "function"
        },
        "index": {
          "description": "sigma is the sum of the th powers of the positive divisors of must be non-negative and positive For it is the divisor count",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sigma",
          "normalized": "Int-\u003eInteger-\u003eInteger",
          "package": "arithmoi",
          "signature": "Int-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:sigma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of the powers (with fixed exponent) of all divisors,\n   efficiently calculated from the canonical factorisation.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sigmaFromCanonical",
          "package": "arithmoi",
          "signature": "Int -\u003e [(Integer, Int)] -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Utils.html#sigmaFromCanonical",
          "type": "function"
        },
        "index": {
          "description": "The sum of the powers with fixed exponent of all divisors efficiently calculated from the canonical factorisation",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "sigmaFromCanonical",
          "normalized": "Int-\u003e[(Integer,Int)]-\u003eInteger",
          "package": "arithmoi",
          "partial": "From Canonical",
          "signature": "Int-\u003e[(Integer,Int)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:sigmaFromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esmallFactors\u003c/a\u003e\u003c/code\u003e bound n\u003c/code\u003e finds all prime divisors of \u003ccode\u003en \u003e 1\u003c/code\u003e up to \u003ccode\u003ebound\u003c/code\u003e by trial division and returns the\n   list of these together with their multiplicities, and a possible remaining factor which may be composite.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "smallFactors",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e ([(Integer, Int)], Maybe Integer)",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Montgomery.html#smallFactors",
          "type": "function"
        },
        "index": {
          "description": "smallFactors bound finds all prime divisors of up to bound by trial division and returns the list of these together with their multiplicities and possible remaining factor which may be composite",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "smallFactors",
          "normalized": "Integer-\u003eInteger-\u003e([(Integer,Int)],Maybe Integer)",
          "package": "arithmoi",
          "partial": "Factors",
          "signature": "Integer-\u003eInteger-\u003e([(Integer,Int)],Maybe Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:smallFactors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA wrapper around \u003ccode\u003e\u003ca\u003ecurveFactorisation\u003c/a\u003e\u003c/code\u003e providing a few default arguments.\n   The primality test is \u003ccode\u003e\u003ca\u003ebailliePSW\u003c/a\u003e\u003c/code\u003e, the \u003ccode\u003eprng\u003c/code\u003e function - naturally -\n   \u003ccode\u003e\u003ca\u003erandomR\u003c/a\u003e\u003c/code\u003e. This function also requires small prime factors to have been\n   stripped before.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "stdGenFactorisation",
          "package": "arithmoi",
          "signature": "Maybe Integer-\u003e StdGen-\u003e Maybe Int-\u003e Integer-\u003e [(Integer, Int)]",
          "type": "function"
        },
        "index": {
          "description": "wrapper around curveFactorisation providing few default arguments The primality test is bailliePSW the prng function naturally randomR This function also requires small prime factors to have been stripped before",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "stdGenFactorisation",
          "normalized": "Maybe Integer-\u003eStdGen-\u003eMaybe Int-\u003eInteger-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Gen Factorisation",
          "signature": "Maybe Integer-\u003eStdGen-\u003eMaybe Int-\u003eInteger-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:stdGenFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003estepFactorisation\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is like \u003ccode\u003e\u003ca\u003efactorise'\u003c/a\u003e\u003c/code\u003e, except that it doesn't use a\n   pseudo random generator but steps through the curves in order.\n   This strategy turns out to be surprisingly fast, on average it doesn't\n   seem to be slower than the \u003ccode\u003e\u003ca\u003eStdGen\u003c/a\u003e\u003c/code\u003e based variant.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "stepFactorisation",
          "package": "arithmoi",
          "signature": "Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Montgomery.html#stepFactorisation",
          "type": "function"
        },
        "index": {
          "description": "stepFactorisation is like factorise except that it doesn use pseudo random generator but steps through the curves in order This strategy turns out to be surprisingly fast on average it doesn seem to be slower than the StdGen based variant",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "stepFactorisation",
          "normalized": "Integer-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Factorisation",
          "signature": "Integer-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:stepFactorisation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003etau\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e is the number of (positive) divisors of \u003ccode\u003en\u003c/code\u003e.\n   \u003ccode\u003e\u003ccode\u003e\u003ca\u003etau\u003c/a\u003e\u003c/code\u003e 0\u003c/code\u003e is an error because \u003ccode\u003e0\u003c/code\u003e has infinitely many divisors.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "tau",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#tau",
          "type": "function"
        },
        "index": {
          "description": "tau is the number of positive divisors of tau is an error because has infinitely many divisors",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "tau",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:tau"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of divisors, efficiently calculated from the canonical factorisation.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "tauFromCanonical",
          "package": "arithmoi",
          "signature": "[(a, Int)] -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Utils.html#tauFromCanonical",
          "type": "function"
        },
        "index": {
          "description": "The number of divisors efficiently calculated from the canonical factorisation",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "tauFromCanonical",
          "normalized": "[(a,Int)]-\u003eInteger",
          "package": "arithmoi",
          "partial": "From Canonical",
          "signature": "[(a,Int)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:tauFromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculates the totient of a positive number \u003ccode\u003en\u003c/code\u003e, i.e.\n   the number of \u003ccode\u003ek\u003c/code\u003e with \u003ccode\u003e1 \u003c= k \u003c= n\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e n k == 1\u003c/code\u003e,\n   in other words, the order of the group of units in \u003ccode\u003e&#8484;/(n)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "totient",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation.html#totient",
          "type": "function"
        },
        "index": {
          "description": "Calculates the totient of positive number i.e the number of with and gcd in other words the order of the group of units in",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "totient",
          "normalized": "Integer-\u003eInteger",
          "package": "arithmoi",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:totient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the totient from the canonical factorisation.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "totientFromCanonical",
          "package": "arithmoi",
          "signature": "[(Integer, Int)] -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Factorisation-Utils.html#totientFromCanonical",
          "type": "function"
        },
        "index": {
          "description": "Calculate the totient from the canonical factorisation",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "totientFromCanonical",
          "normalized": "[(Integer,Int)]-\u003eInteger",
          "package": "arithmoi",
          "partial": "From Canonical",
          "signature": "[(Integer,Int)]-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:totientFromCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003etotientSieve\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e creates a store of the totients of the numbers not exceeding \u003ccode\u003en\u003c/code\u003e.\n   A \u003ccode\u003e\u003ca\u003eTotientSieve\u003c/a\u003e\u003c/code\u003e only stores values for numbers coprime to \u003ccode\u003e30\u003c/code\u003e to reduce space usage.\n   The maximal admissible value for \u003ccode\u003en\u003c/code\u003e is \u003ccode\u003e\u003ccode\u003e\u003ca\u003efromIntegral\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "totientSieve",
          "package": "arithmoi",
          "signature": "Integer -\u003e TotientSieve",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#totientSieve",
          "type": "function"
        },
        "index": {
          "description": "totientSieve creates store of the totients of the numbers not exceeding TotientSieve only stores values for numbers coprime to to reduce space usage The maximal admissible value for is fromIntegral maxBound Word",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "totientSieve",
          "normalized": "Integer-\u003eTotientSieve",
          "package": "arithmoi",
          "partial": "Sieve",
          "signature": "Integer-\u003eTotientSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:totientSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003etrialDivisionTo\u003c/a\u003e\u003c/code\u003e bound n\u003c/code\u003e produces a factorisation of \u003ccode\u003en\u003c/code\u003e using the\n   primes \u003ccode\u003e\u003ca\u003e= bound@. If @n@ has prime divisors @\u003c/a\u003e bound\u003c/code\u003e, the last entry\n   in the list is the product of all these. If \u003ccode\u003en \u003c= bound^2\u003c/code\u003e, this is a\n   full factorisation, but very slow if \u003ccode\u003en\u003c/code\u003e has large prime divisors.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "trialDivisionTo",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e [(Integer, Int)]",
          "source": "src/Math-NumberTheory-Primes-Factorisation-TrialDivision.html#trialDivisionTo",
          "type": "function"
        },
        "index": {
          "description": "trialDivisionTo bound produces factorisation of using the primes bound If has prime divisors bound the last entry in the list is the product of all these If bound this is full factorisation but very slow if has large prime divisors",
          "hierarchy": "Math NumberTheory Primes Factorisation",
          "module": "Math.NumberTheory.Primes.Factorisation",
          "name": "trialDivisionTo",
          "normalized": "Integer-\u003eInteger-\u003e[(Integer,Int)]",
          "package": "arithmoi",
          "partial": "Division To",
          "signature": "Integer-\u003eInteger-\u003e[(Integer,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Factorisation.html#v:trialDivisionTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePrime generation using a priority queue for the composites.\n The algorithm is basically the one described in\n \u003ca\u003ehttp://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\u003c/a\u003e, but\n it uses a more efficient heap for the priority queue and a\n larger wheel, thus it is faster (in particular, the speed\n penalty for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is much smaller) and uses less memory.\n It is nevertheless very slow compared to a bit sieve.\n This module is mainly intended for comparison and verification.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Primes.Heap",
          "name": "Heap",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Heap.html",
          "type": "module"
        },
        "index": {
          "description": "Prime generation using priority queue for the composites The algorithm is basically the one described in http www.cs.hmc.edu oneill papers Sieve-JFP.pdf but it uses more efficient heap for the priority queue and larger wheel thus it is faster in particular the speed penalty for Integer is much smaller and uses less memory It is nevertheless very slow compared to bit sieve This module is mainly intended for comparison and verification",
          "hierarchy": "Math NumberTheory Primes Heap",
          "module": "Math.NumberTheory.Primes.Heap",
          "name": "Heap",
          "package": "arithmoi",
          "partial": "Heap",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Heap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of primes. The sieve does not handle overflow, hence for\n   bounded types, garbage occurs near \u003ccode\u003e\u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. If primes that\n   large are requested, use\n\u003c/p\u003e\u003cpre\u003e\n   \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efromInteger\u003c/a\u003e\u003c/code\u003e $ \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e (\u003c= \u003ccode\u003e\u003ca\u003efromIntegral\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e) \u003ccode\u003e\u003ca\u003eprimes\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003einstead. Checking for overflow would be slower. The sieve is specialised\n   for \u003ccode\u003e\u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, since these are the most commonly\n   used. For the fixed-width \u003ccode\u003eInt\u003c/code\u003e or \u003ccode\u003eWord\u003c/code\u003e types, sieving at one of the\n   specialised types and converting is faster.\n   To ensure sharing of the list of primes, bind it to a monomorphic variable,\n   to make sure that it is not shared, use \u003ccode\u003e\u003ccode\u003e\u003ca\u003esieveFrom\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e with different\n   arguments.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Heap",
          "name": "primes",
          "package": "arithmoi",
          "signature": "[a]",
          "source": "src/Math-NumberTheory-Primes-Heap.html#primes",
          "type": "function"
        },
        "index": {
          "description": "list of primes The sieve does not handle overflow hence for bounded types garbage occurs near maxBound If primes that large are requested use map fromInteger takeWhile fromIntegral maxBound primes instead Checking for overflow would be slower The sieve is specialised for Int Word and Integer since these are the most commonly used For the fixed-width Int or Word types sieving at one of the specialised types and converting is faster To ensure sharing of the list of primes bind it to monomorphic variable to make sure that it is not shared use sieveFrom with different arguments",
          "hierarchy": "Math NumberTheory Primes Heap",
          "module": "Math.NumberTheory.Primes.Heap",
          "name": "primes",
          "normalized": "[a]",
          "package": "arithmoi",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Heap.html#v:primes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esieveFrom\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e generates the list of primes \u003ccode\u003e\u003e= n\u003c/code\u003e.\n   The remarks about overflow and performance in the documentation\n   of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eprimes\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e apply here too.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Heap",
          "name": "sieveFrom",
          "package": "arithmoi",
          "signature": "a -\u003e [a]",
          "source": "src/Math-NumberTheory-Primes-Heap.html#sieveFrom",
          "type": "function"
        },
        "index": {
          "description": "sieveFrom generates the list of primes The remarks about overflow and performance in the documentation of primes apply here too",
          "hierarchy": "Math NumberTheory Primes Heap",
          "module": "Math.NumberTheory.Primes.Heap",
          "name": "sieveFrom",
          "normalized": "a-\u003e[a]",
          "package": "arithmoi",
          "partial": "From",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Heap.html#v:sieveFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePrime generation using a sieve.\n Currently, an enhanced sieve of Eratosthenes is used, switching to an\n Atkin sieve is planned (if I get around to implementing it and it's not slower).\n\u003c/p\u003e\u003cp\u003eThe sieve used is segmented, with a chunk size chosen to give good (enough)\n cache locality while still getting something substantial done per chunk.\n However, that means we must store data for primes up to the square root of\n where sieving is done, thus sieving primes up to \u003ccode\u003en\u003c/code\u003e requires\n \u003ccode\u003e\u003cem\u003eO\u003c/em\u003e(sqrt n/log n)\u003c/code\u003e space.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "Sieve",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Sieve.html",
          "type": "module"
        },
        "index": {
          "description": "Prime generation using sieve Currently an enhanced sieve of Eratosthenes is used switching to an Atkin sieve is planned if get around to implementing it and it not slower The sieve used is segmented with chunk size chosen to give good enough cache locality while still getting something substantial done per chunk However that means we must store data for primes up to the square root of where sieving is done thus sieving primes up to requires sqrt log space",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "Sieve",
          "package": "arithmoi",
          "partial": "Sieve",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompact store of primality flags.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "PrimeSieve",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Sieve-Eratosthenes.html#PrimeSieve",
          "type": "data"
        },
        "index": {
          "description": "Compact store of primality flags",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "PrimeSieve",
          "package": "arithmoi",
          "partial": "Prime Sieve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#t:PrimeSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a list of primes for consumption from a\n   \u003ccode\u003e\u003ca\u003ePrimeSieve\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "primeList",
          "package": "arithmoi",
          "signature": "PrimeSieve -\u003e [Integer]",
          "source": "src/Math-NumberTheory-Primes-Sieve-Eratosthenes.html#primeList",
          "type": "function"
        },
        "index": {
          "description": "Generate list of primes for consumption from PrimeSieve",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "primeList",
          "normalized": "PrimeSieve-\u003e[Integer]",
          "package": "arithmoi",
          "partial": "List",
          "signature": "PrimeSieve-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#v:primeList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSieve primes up to (and including) a bound.\n   For small enough bounds, this is more efficient than\n   using the segmented sieve.\n\u003c/p\u003e\u003cp\u003eSince arrays are \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e-indexed, overflow occurs when the sieve\n   size comes near \u003ccode\u003e\u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, that corresponds to an\n   upper bound near \u003ccode\u003e15/8*\u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. On \u003ccode\u003e32\u003c/code\u003e-bit systems, that\n   is often within memory limits, so don't give bounds larger than\n   \u003ccode\u003e8*10^9\u003c/code\u003e there.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "primeSieve",
          "package": "arithmoi",
          "signature": "Integer -\u003e PrimeSieve",
          "source": "src/Math-NumberTheory-Primes-Sieve-Eratosthenes.html#primeSieve",
          "type": "function"
        },
        "index": {
          "description": "Sieve primes up to and including bound For small enough bounds this is more efficient than using the segmented sieve Since arrays are Int indexed overflow occurs when the sieve size comes near maxBound Int that corresponds to an upper bound near maxBound On bit systems that is often within memory limits so don give bounds larger than there",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "primeSieve",
          "normalized": "Integer-\u003ePrimeSieve",
          "package": "arithmoi",
          "partial": "Sieve",
          "signature": "Integer-\u003ePrimeSieve",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#v:primeSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of primes.\n   Since the sieve uses unboxed arrays, overflow occurs at some point.\n   On 64-bit systems, that point is beyond the memory limits, on\n   32-bit systems, it is at about \u003ccode\u003e1.7*10^18\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "primes",
          "package": "arithmoi",
          "signature": "[Integer]",
          "source": "src/Math-NumberTheory-Primes-Sieve-Eratosthenes.html#primes",
          "type": "function"
        },
        "index": {
          "description": "List of primes Since the sieve uses unboxed arrays overflow occurs at some point On bit systems that point is beyond the memory limits on bit systems it is at about",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "primes",
          "normalized": "[Integer]",
          "package": "arithmoi",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#v:primes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003epsieveFrom\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e creates the list of \u003ccode\u003e\u003ca\u003ePrimeSieve\u003c/a\u003e\u003c/code\u003es starting roughly\n   at \u003ccode\u003en\u003c/code\u003e. Due to the organisation of the sieve, the list may contain\n   a few primes less than \u003ccode\u003en\u003c/code\u003e.\n   This form uses less memory than \u003ccode\u003e[\u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e]\u003c/code\u003e, hence it may be preferable\n   to use this if it is to be reused.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "psieveFrom",
          "package": "arithmoi",
          "signature": "Integer -\u003e [PrimeSieve]",
          "source": "src/Math-NumberTheory-Primes-Sieve-Eratosthenes.html#psieveFrom",
          "type": "function"
        },
        "index": {
          "description": "psieveFrom creates the list of PrimeSieve starting roughly at Due to the organisation of the sieve the list may contain few primes less than This form uses less memory than Integer hence it may be preferable to use this if it is to be reused",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "psieveFrom",
          "normalized": "Integer-\u003e[PrimeSieve]",
          "package": "arithmoi",
          "partial": "From",
          "signature": "Integer-\u003e[PrimeSieve]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#v:psieveFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of primes in the form of a list of \u003ccode\u003e\u003ca\u003ePrimeSieve\u003c/a\u003e\u003c/code\u003es, more compact than\n   \u003ccode\u003e\u003ca\u003eprimes\u003c/a\u003e\u003c/code\u003e, thus it may be better to use \u003ccode\u003e\u003ccode\u003e\u003ca\u003epsieveList\u003c/a\u003e\u003c/code\u003e \u003e\u003e= \u003ccode\u003e\u003ca\u003eprimeList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n   than keeping the list of primes alive during the entire run.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "psieveList",
          "package": "arithmoi",
          "signature": "[PrimeSieve]",
          "source": "src/Math-NumberTheory-Primes-Sieve-Eratosthenes.html#psieveList",
          "type": "function"
        },
        "index": {
          "description": "List of primes in the form of list of PrimeSieve more compact than primes thus it may be better to use psieveList primeList than keeping the list of primes alive during the entire run",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "psieveList",
          "normalized": "[PrimeSieve]",
          "package": "arithmoi",
          "partial": "List",
          "signature": "[PrimeSieve]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#v:psieveList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003esieveFrom\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e creates the list of primes not less than \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "sieveFrom",
          "package": "arithmoi",
          "signature": "Integer -\u003e [Integer]",
          "source": "src/Math-NumberTheory-Primes-Sieve-Eratosthenes.html#sieveFrom",
          "type": "function"
        },
        "index": {
          "description": "sieveFrom creates the list of primes not less than",
          "hierarchy": "Math NumberTheory Primes Sieve",
          "module": "Math.NumberTheory.Primes.Sieve",
          "name": "sieveFrom",
          "normalized": "Integer-\u003e[Integer]",
          "package": "arithmoi",
          "partial": "From",
          "signature": "Integer-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Sieve.html#v:sieveFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCertificates for primality or compositeness.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Certificates",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates.html",
          "type": "module"
        },
        "index": {
          "description": "Certificates for primality or compositeness",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Certificates",
          "package": "arithmoi",
          "partial": "Certificates",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA certificate of either compositeness or primality of an\n   \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e. Only numbers \u003ccode\u003e\u003e 1\u003c/code\u003e can be certified, trying to\n   create a certificate for other numbers raises an error.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Certificate",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#Certificate",
          "type": "data"
        },
        "index": {
          "description": "certificate of either compositeness or primality of an Integer Only numbers can be certified trying to create certificate for other numbers raises an error",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Certificate",
          "package": "arithmoi",
          "partial": "Certificate",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#t:Certificate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn argument for compositeness of a number (which must be \u003ccode\u003e\u003e 1\u003c/code\u003e).\n   \u003ccode\u003e\u003ca\u003eCompositenessProof\u003c/a\u003e\u003c/code\u003es translate directly to \u003ccode\u003eCompositenessArguments\u003c/code\u003e,\n   correct arguments can be transformed into proofs. This type allows the\n   manipulation of proofs while maintaining their correctness.\n   The only way to access components of a \u003ccode\u003e\u003ca\u003eCompositenessProof\u003c/a\u003e\u003c/code\u003e except\n   the composite is through this type.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "CompositenessArgument",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "data"
        },
        "index": {
          "description": "An argument for compositeness of number which must be CompositenessProof translate directly to CompositenessArguments correct arguments can be transformed into proofs This type allows the manipulation of proofs while maintaining their correctness The only way to access components of CompositenessProof except the composite is through this type",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "CompositenessArgument",
          "package": "arithmoi",
          "partial": "Compositeness Argument",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#t:CompositenessArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA proof of compositeness of a positive number. The type is\n   abstract to ensure the validity of proofs.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "CompositenessProof",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessProof",
          "type": "data"
        },
        "index": {
          "description": "proof of compositeness of positive number The type is abstract to ensure the validity of proofs",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "CompositenessProof",
          "package": "arithmoi",
          "partial": "Compositeness Proof",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#t:CompositenessProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn argument for primality of a number (which must be \u003ccode\u003e\u003e 1\u003c/code\u003e).\n   \u003ccode\u003e\u003ca\u003ePrimalityProof\u003c/a\u003e\u003c/code\u003es translate directly to \u003ccode\u003ePrimalityArguments\u003c/code\u003e,\n   correct arguments can be transformed into proofs. This type allows the\n   manipulation of proofs while maintaining their correctness.\n   The only way to access components of a \u003ccode\u003e\u003ca\u003ePrimalityProof\u003c/a\u003e\u003c/code\u003e except\n   the prime is through this type.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "PrimalityArgument",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "data"
        },
        "index": {
          "description": "An argument for primality of number which must be PrimalityProof translate directly to PrimalityArguments correct arguments can be transformed into proofs This type allows the manipulation of proofs while maintaining their correctness The only way to access components of PrimalityProof except the prime is through this type",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "PrimalityArgument",
          "package": "arithmoi",
          "partial": "Primality Argument",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#t:PrimalityArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA proof of primality of a positive number. The type is\n   abstract to ensure the validity of proofs.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "PrimalityProof",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityProof",
          "type": "data"
        },
        "index": {
          "description": "proof of primality of positive number The type is abstract to ensure the validity of proofs",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "PrimalityProof",
          "package": "arithmoi",
          "partial": "Primality Proof",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#t:PrimalityProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimality assumed\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Assumption",
          "package": "arithmoi",
          "signature": "Assumption",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "description": "Primality assumed",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Assumption",
          "package": "arithmoi",
          "partial": "Assumption",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Assumption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo particular reason given\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Belief",
          "package": "arithmoi",
          "signature": "Belief",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "description": "No particular reason given",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Belief",
          "package": "arithmoi",
          "partial": "Belief",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Belief"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Composite",
          "package": "arithmoi",
          "signature": "Composite !CompositenessProof",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#Certificate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Composite",
          "package": "arithmoi",
          "partial": "Composite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Composite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimality should be provable by trial division to \u003ccode\u003ealimit\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Division",
          "package": "arithmoi",
          "signature": "Division",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "description": "Primality should be provable by trial division to alimit",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Division",
          "package": "arithmoi",
          "partial": "Division",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Division"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecompo == firstDiv*secondDiv\u003c/code\u003e, where all are \u003ccode\u003e\u003e 1\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Divisors",
          "package": "arithmoi",
          "signature": "Divisors",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "description": "compo firstDiv secondDiv where all are",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Divisors",
          "package": "arithmoi",
          "partial": "Divisors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Divisors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecompo\u003c/code\u003e fails the strong Fermat test for \u003ccode\u003efermatBase\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Fermat",
          "package": "arithmoi",
          "signature": "Fermat",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "description": "compo fails the strong Fermat test for fermatBase",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Fermat",
          "package": "arithmoi",
          "partial": "Fermat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Fermat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecompo\u003c/code\u003e fails the Lucas-Selfridge test\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Lucas",
          "package": "arithmoi",
          "signature": "Lucas",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "description": "compo fails the Lucas-Selfridge test",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Lucas",
          "package": "arithmoi",
          "partial": "Lucas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Lucas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eaprime\u003c/code\u003e is said to be obviously prime, that holds for primes \u003ccode\u003e\u003c 30\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Obvious",
          "package": "arithmoi",
          "signature": "Obvious",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "description": "aprime is said to be obviously prime that holds for primes",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Obvious",
          "package": "arithmoi",
          "partial": "Obvious",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Obvious"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA suggested Pocklington certificate\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Pock",
          "package": "arithmoi",
          "signature": "Pock",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "description": "suggested Pocklington certificate",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Pock",
          "package": "arithmoi",
          "partial": "Pock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Pock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Prime",
          "package": "arithmoi",
          "signature": "Prime !PrimalityProof",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#Certificate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "Prime",
          "package": "arithmoi",
          "partial": "Prime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:Prime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "alimit",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "alimit",
          "package": "arithmoi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:alimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "aprime",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "aprime",
          "package": "arithmoi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:aprime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "argueCertificate",
          "package": "arithmoi",
          "signature": "Certificate -\u003e Either CompositenessArgument PrimalityArgument",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#argueCertificate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "argueCertificate",
          "normalized": "Certificate-\u003eEither CompositenessArgument PrimalityArgument",
          "package": "arithmoi",
          "partial": "Certificate",
          "signature": "Certificate-\u003eEither CompositenessArgument PrimalityArgument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:argueCertificate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eargueCompositeness\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e transforms a proof of compositeness into an argument\n   for compositeness.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "argueCompositeness",
          "package": "arithmoi",
          "signature": "CompositenessProof -\u003e CompositenessArgument",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#argueCompositeness",
          "type": "function"
        },
        "index": {
          "description": "argueCompositeness transforms proof of compositeness into an argument for compositeness",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "argueCompositeness",
          "normalized": "CompositenessProof-\u003eCompositenessArgument",
          "package": "arithmoi",
          "partial": "Compositeness",
          "signature": "CompositenessProof-\u003eCompositenessArgument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:argueCompositeness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003earguePrimality\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e transforms a proof of primality into an argument for primality.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "arguePrimality",
          "package": "arithmoi",
          "signature": "PrimalityProof -\u003e PrimalityArgument",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#arguePrimality",
          "type": "function"
        },
        "index": {
          "description": "arguePrimality transforms proof of primality into an argument for primality",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "arguePrimality",
          "normalized": "PrimalityProof-\u003ePrimalityArgument",
          "package": "arithmoi",
          "partial": "Primality",
          "signature": "PrimalityProof-\u003ePrimalityArgument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:arguePrimality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecertify\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e constructs, for \u003ccode\u003en \u003e 1\u003c/code\u003e, a proof of either\n   primality or compositeness of \u003ccode\u003en\u003c/code\u003e. This may take a very long\n   time if the number has no small(ish) prime divisors\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "certify",
          "package": "arithmoi",
          "signature": "Integer -\u003e Certificate",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#certify",
          "type": "function"
        },
        "index": {
          "description": "certify constructs for proof of either primality or compositeness of This may take very long time if the number has no small ish prime divisors",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "certify",
          "normalized": "Integer-\u003eCertificate",
          "package": "arithmoi",
          "signature": "Integer-\u003eCertificate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:certify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck the validity of a \u003ccode\u003e\u003ca\u003eCertificate\u003c/a\u003e\u003c/code\u003e. Since it should be impossible\n   to construct invalid certificates by the public interface, this should\n   never return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "checkCertificate",
          "package": "arithmoi",
          "signature": "Certificate -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#checkCertificate",
          "type": "function"
        },
        "index": {
          "description": "Check the validity of Certificate Since it should be impossible to construct invalid certificates by the public interface this should never return False",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "checkCertificate",
          "normalized": "Certificate-\u003eBool",
          "package": "arithmoi",
          "partial": "Certificate",
          "signature": "Certificate-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:checkCertificate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck the validity of a \u003ccode\u003e\u003ca\u003eCompositenessProof\u003c/a\u003e\u003c/code\u003e. Since it should be\n   impossible to create invalid proofs by the public interface, this\n   should never return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "checkCompositenessProof",
          "package": "arithmoi",
          "signature": "CompositenessProof -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#checkCompositenessProof",
          "type": "function"
        },
        "index": {
          "description": "Check the validity of CompositenessProof Since it should be impossible to create invalid proofs by the public interface this should never return False",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "checkCompositenessProof",
          "normalized": "CompositenessProof-\u003eBool",
          "package": "arithmoi",
          "partial": "Compositeness Proof",
          "signature": "CompositenessProof-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:checkCompositenessProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck the validity of a \u003ccode\u003e\u003ca\u003ePrimalityProof\u003c/a\u003e\u003c/code\u003e. Since it should be\n   impossible to create invalid proofs by the public interface, this\n   should never return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "checkPrimalityProof",
          "package": "arithmoi",
          "signature": "PrimalityProof -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#checkPrimalityProof",
          "type": "function"
        },
        "index": {
          "description": "Check the validity of PrimalityProof Since it should be impossible to create invalid proofs by the public interface this should never return False",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "checkPrimalityProof",
          "normalized": "PrimalityProof-\u003eBool",
          "package": "arithmoi",
          "partial": "Primality Proof",
          "signature": "PrimalityProof-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:checkPrimalityProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "compo",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "compo",
          "package": "arithmoi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:compo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number whose compositeness is proved.\n\u003c/p\u003e\u003cp\u003eThe number whose compositeness is proved.\n\u003c/p\u003e\u003cp\u003eThe number whose compositeness is proved.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "composite",
          "package": "arithmoi",
          "signature": "CompositenessProof -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#composite",
          "type": "function"
        },
        "index": {
          "description": "The number whose compositeness is proved The number whose compositeness is proved The number whose compositeness is proved",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "composite",
          "normalized": "CompositenessProof-\u003eInteger",
          "package": "arithmoi",
          "signature": "CompositenessProof-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:composite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number whose primality is proved.\n\u003c/p\u003e\u003cp\u003eThe number whose primality is proved.\n\u003c/p\u003e\u003cp\u003eThe number whose primality is proved.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "cprime",
          "package": "arithmoi",
          "signature": "PrimalityProof -\u003e Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#cprime",
          "type": "function"
        },
        "index": {
          "description": "The number whose primality is proved The number whose primality is proved The number whose primality is proved",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "cprime",
          "normalized": "PrimalityProof-\u003eInteger",
          "package": "arithmoi",
          "signature": "PrimalityProof-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:cprime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "factorList",
          "package": "arithmoi",
          "signature": "[(Integer, Int, Integer, PrimalityArgument)]",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "factorList",
          "normalized": "[(Integer,Int,Integer,PrimalityArgument)]",
          "package": "arithmoi",
          "partial": "List",
          "signature": "[(Integer,Int,Integer,PrimalityArgument)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:factorList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "fermatBase",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "fermatBase",
          "package": "arithmoi",
          "partial": "Base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:fermatBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "firstDivisor",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "firstDivisor",
          "package": "arithmoi",
          "partial": "Divisor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:firstDivisor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "largeFactor",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "largeFactor",
          "package": "arithmoi",
          "partial": "Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:largeFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "secondDivisor",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#CompositenessArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "secondDivisor",
          "package": "arithmoi",
          "partial": "Divisor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:secondDivisor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "smallFactor",
          "package": "arithmoi",
          "signature": "Integer",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#PrimalityArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "smallFactor",
          "package": "arithmoi",
          "partial": "Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:smallFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003everifyCompositenessArgument\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e checks the given argument and constructs a proof from\n   it, if it is valid. For the explicit arguments, this is simple and resonably fast,\n   for a \u003ccode\u003e\u003ca\u003eBelief\u003c/a\u003e\u003c/code\u003e, the verification uses \u003ccode\u003e\u003ca\u003ecertify\u003c/a\u003e\u003c/code\u003e and hence may take a long time.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "verifyCompositenessArgument",
          "package": "arithmoi",
          "signature": "CompositenessArgument -\u003e Maybe CompositenessProof",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#verifyCompositenessArgument",
          "type": "function"
        },
        "index": {
          "description": "verifyCompositenessArgument checks the given argument and constructs proof from it if it is valid For the explicit arguments this is simple and resonably fast for Belief the verification uses certify and hence may take long time",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "verifyCompositenessArgument",
          "normalized": "CompositenessArgument-\u003eMaybe CompositenessProof",
          "package": "arithmoi",
          "partial": "Compositeness Argument",
          "signature": "CompositenessArgument-\u003eMaybe CompositenessProof",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:verifyCompositenessArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003everifyPrimalityArgument\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e checks the given argument and constructs a proof from\n   it, if it is valid. For the explicit arguments, this is simple and resonably fast,\n   for an \u003ccode\u003e\u003ca\u003eAssumption\u003c/a\u003e\u003c/code\u003e, the verification uses \u003ccode\u003e\u003ca\u003ecertify\u003c/a\u003e\u003c/code\u003e and hence may take a long time.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "verifyPrimalityArgument",
          "package": "arithmoi",
          "signature": "PrimalityArgument -\u003e Maybe PrimalityProof",
          "source": "src/Math-NumberTheory-Primes-Testing-Certificates-Internal.html#verifyPrimalityArgument",
          "type": "function"
        },
        "index": {
          "description": "verifyPrimalityArgument checks the given argument and constructs proof from it if it is valid For the explicit arguments this is simple and resonably fast for an Assumption the verification uses certify and hence may take long time",
          "hierarchy": "Math NumberTheory Primes Testing Certificates",
          "module": "Math.NumberTheory.Primes.Testing.Certificates",
          "name": "verifyPrimalityArgument",
          "normalized": "PrimalityArgument-\u003eMaybe PrimalityProof",
          "package": "arithmoi",
          "partial": "Primality Argument",
          "signature": "PrimalityArgument-\u003eMaybe PrimalityProof",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing-Certificates.html#v:verifyPrimalityArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePrimality tests.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "Testing",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Testing.html",
          "type": "module"
        },
        "index": {
          "description": "Primality tests",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "Testing",
          "package": "arithmoi",
          "partial": "Testing",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA compact store of smallest prime factors.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "FactorSieve",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes-Sieve-Misc.html#FactorSieve",
          "type": "data"
        },
        "index": {
          "description": "compact store of smallest prime factors",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "FactorSieve",
          "package": "arithmoi",
          "partial": "Factor Sieve",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#t:FactorSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimality test after Baillie, Pomerance, Selfridge and Wagstaff.\n   The Baillie PSW test consists of a strong Fermat probable primality\n   test followed by a (strong) Lucas primality test. This implementation\n   assumes that the number \u003ccode\u003en\u003c/code\u003e to test is odd and larger than \u003ccode\u003e3\u003c/code\u003e.\n   Even and small numbers have to be handled before. Also, before\n   applying this test, trial division by small primes should be performed\n   to identify many composites cheaply (although the Baillie PSW test is\n   rather fast, about the same speed as a strong Fermat test for four or\n   five bases usually, it is, for large numbers, much more costly than\n   trial division by small primes, the primes less than \u003ccode\u003e1000\u003c/code\u003e, say, so\n   eliminating numbers with small prime factors beforehand is more efficient).\n\u003c/p\u003e\u003cp\u003eThe Baillie PSW test is very reliable, so far no composite numbers\n   passing it are known, and it is known (Gilchrist 2010) that no\n   Baillie PSW pseudoprimes exist below \u003ccode\u003e2^64\u003c/code\u003e. However, a heuristic argument\n   by Pomerance indicates that there are likely infinitely many Baillie PSW\n   pseudoprimes. On the other hand, according to\n   \u003ca\u003ehttp://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html\u003c/a\u003e there is\n   reason to believe that there are none with less than several\n   thousand digits, so that for most use cases the test can be\n   considered definitive.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "bailliePSW",
          "package": "arithmoi",
          "signature": "Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Probabilistic.html#bailliePSW",
          "type": "function"
        },
        "index": {
          "description": "Primality test after Baillie Pomerance Selfridge and Wagstaff The Baillie PSW test consists of strong Fermat probable primality test followed by strong Lucas primality test This implementation assumes that the number to test is odd and larger than Even and small numbers have to be handled before Also before applying this test trial division by small primes should be performed to identify many composites cheaply although the Baillie PSW test is rather fast about the same speed as strong Fermat test for four or five bases usually it is for large numbers much more costly than trial division by small primes the primes less than say so eliminating numbers with small prime factors beforehand is more efficient The Baillie PSW test is very reliable so far no composite numbers passing it are known and it is known Gilchrist that no Baillie PSW pseudoprimes exist below However heuristic argument by Pomerance indicates that there are likely infinitely many Baillie PSW pseudoprimes On the other hand according to http mathworld.wolfram.com Baillie-PSWPrimalityTest.html there is reason to believe that there are none with less than several thousand digits so that for most use cases the test can be considered definitive",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "bailliePSW",
          "normalized": "Integer-\u003eBool",
          "package": "arithmoi",
          "partial": "PSW",
          "signature": "Integer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:bailliePSW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest primality using a \u003ccode\u003e\u003ca\u003eFactorSieve\u003c/a\u003e\u003c/code\u003e. If \u003ccode\u003en\u003c/code\u003e is out of bounds\n   of the sieve, fall back to \u003ccode\u003e\u003ca\u003eisPrime\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "fsIsPrime",
          "package": "arithmoi",
          "signature": "FactorSieve -\u003e Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing.html#fsIsPrime",
          "type": "function"
        },
        "index": {
          "description": "Test primality using FactorSieve If is out of bounds of the sieve fall back to isPrime",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "fsIsPrime",
          "normalized": "FactorSieve-\u003eInteger-\u003eBool",
          "package": "arithmoi",
          "partial": "Is Prime",
          "signature": "FactorSieve-\u003eInteger-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:fsIsPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisCertifiedPrime\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e tests primality of \u003ccode\u003en\u003c/code\u003e, first trial division\n   by small primes is performed, then a Baillie PSW test and finally a\n   prime certificate is constructed and verified, provided no step before\n   found \u003ccode\u003en\u003c/code\u003e to be composite. Constructing prime certificates can take\n   a \u003cem\u003every\u003c/em\u003e long time, so use this with care.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isCertifiedPrime",
          "package": "arithmoi",
          "signature": "Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Certified.html#isCertifiedPrime",
          "type": "function"
        },
        "index": {
          "description": "isCertifiedPrime tests primality of first trial division by small primes is performed then Baillie PSW test and finally prime certificate is constructed and verified provided no step before found to be composite Constructing prime certificates can take very long time so use this with care",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isCertifiedPrime",
          "normalized": "Integer-\u003eBool",
          "package": "arithmoi",
          "partial": "Certified Prime",
          "signature": "Integer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:isCertifiedPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisFermatPP\u003c/a\u003e\u003c/code\u003e n b\u003c/code\u003e tests whether \u003ccode\u003en\u003c/code\u003e is a Fermat probable prime\n   for the base \u003ccode\u003eb\u003c/code\u003e, that is, whether \u003ccode\u003eb^(n-1) \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e n == 1\u003c/code\u003e.\n   This is a weaker but simpler condition. However, more is lost\n   in strength than is gained in simplicity, so for primality testing,\n   the strong check should be used. The remarks about\n   the choice of bases to test from \u003ccode\u003e\u003ccode\u003e\u003ca\u003eisStrongFermatPP\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e apply\n   with the modification that if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are Fermat bases\n   for \u003ccode\u003en\u003c/code\u003e, then \u003ccode\u003ea*b\u003c/code\u003e \u003cem\u003ealways\u003c/em\u003e is a Fermat base for \u003ccode\u003en\u003c/code\u003e too.\n   A \u003cem\u003eCharmichael number\u003c/em\u003e is a composite number \u003ccode\u003en\u003c/code\u003e which is a\n   Fermat probable prime for all bases \u003ccode\u003eb\u003c/code\u003e coprime to \u003ccode\u003en\u003c/code\u003e. By the\n   above, only primes \u003ccode\u003ep \u003c= n/2\u003c/code\u003e not dividing \u003ccode\u003en\u003c/code\u003e need to be tested\n   to identify Carmichael numbers (however, testing all those\n   primes would be less efficient than determining Carmichaelness\n   from the prime factorisation; but testing an appropriate number\n   of prime bases is reasonable to find out whether it's worth the\n   effort to undertake the prime factorisation).\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isFermatPP",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Probabilistic.html#isFermatPP",
          "type": "function"
        },
        "index": {
          "description": "isFermatPP tests whether is Fermat probable prime for the base that is whether n-1 mod This is weaker but simpler condition However more is lost in strength than is gained in simplicity so for primality testing the strong check should be used The remarks about the choice of bases to test from isStrongFermatPP apply with the modification that if and are Fermat bases for then always is Fermat base for too Charmichael number is composite number which is Fermat probable prime for all bases coprime to By the above only primes not dividing need to be tested to identify Carmichael numbers however testing all those primes would be less efficient than determining Carmichaelness from the prime factorisation but testing an appropriate number of prime bases is reasonable to find out whether it worth the effort to undertake the prime factorisation",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isFermatPP",
          "normalized": "Integer-\u003eInteger-\u003eBool",
          "package": "arithmoi",
          "partial": "Fermat PP",
          "signature": "Integer-\u003eInteger-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:isFermatPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisPrime\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e tests whether \u003ccode\u003en\u003c/code\u003e is a prime (negative or positive).\n   First, trial division by the primes less than \u003ccode\u003e1200\u003c/code\u003e is performed.\n   If that hasn't determined primality or compositeness, a Baillie PSW\n   test is performed.\n\u003c/p\u003e\u003cp\u003eSince the Baillie PSW test may not be perfect, it is possible that\n   some large composites are wrongly deemed prime, however, no composites\n   passing the test are known and none exist below \u003ccode\u003e2^64\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isPrime",
          "package": "arithmoi",
          "signature": "Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Probabilistic.html#isPrime",
          "type": "function"
        },
        "index": {
          "description": "isPrime tests whether is prime negative or positive First trial division by the primes less than is performed If that hasn determined primality or compositeness Baillie PSW test is performed Since the Baillie PSW test may not be perfect it is possible that some large composites are wrongly deemed prime however no composites passing the test are known and none exist below",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isPrime",
          "normalized": "Integer-\u003eBool",
          "package": "arithmoi",
          "partial": "Prime",
          "signature": "Integer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:isPrime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisStrongFermatPP\u003c/a\u003e\u003c/code\u003e n b\u003c/code\u003e tests whether \u003ccode\u003en\u003c/code\u003e is a strong Fermat\n   probable prime for base \u003ccode\u003eb\u003c/code\u003e, where \u003ccode\u003en \u003e 2\u003c/code\u003e and \u003ccode\u003e1 \u003c b \u003c n\u003c/code\u003e.\n   The conditions on the arguments are not checked.\n\u003c/p\u003e\u003cp\u003eApart from primes, also some composite numbers have the tested\n   property, but those are rare. Very rare are composite numbers\n   having the property for many bases, so testing a large prime\n   candidate with several bases can identify composite numbers\n   with high probability. An odd number \u003ccode\u003en \u003e 3\u003c/code\u003e is prime if and\n   only if \u003ccode\u003e\u003ccode\u003e\u003ca\u003eisStrongFermatPP\u003c/a\u003e\u003c/code\u003e n b\u003c/code\u003e holds for all \u003ccode\u003eb\u003c/code\u003e with\n   \u003ccode\u003e2 \u003c= b \u003c= (n-1)/2\u003c/code\u003e, but of course checking all those bases\n   would be less efficient than trial division, so one normally\n   checks only a relatively small number of bases, depending on\n   the desired degree of certainty. The probability that a randomly\n   chosen base doesn't identify a composite number \u003ccode\u003en\u003c/code\u003e is less than\n   \u003ccode\u003e1/4\u003c/code\u003e, so five to ten tests give a reasonable level of certainty\n   in general.\n\u003c/p\u003e\u003cp\u003eSome notes about the choice of bases: \u003ccode\u003eb\u003c/code\u003e is a strong Fermat base\n   for \u003ccode\u003en\u003c/code\u003e if and only if \u003ccode\u003en-b\u003c/code\u003e is, hence one needs only test \u003ccode\u003eb \u003c= (n-1)/2\u003c/code\u003e.\n   If \u003ccode\u003eb\u003c/code\u003e is a strong Fermat base for \u003ccode\u003en\u003c/code\u003e, then so is \u003ccode\u003eb^k \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e for\n   all \u003ccode\u003ek \u003e 1\u003c/code\u003e, hence one needs not test perfect powers, since their\n   base yields a stronger condition. Finally, if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are strong\n   Fermat bases for \u003ccode\u003en\u003c/code\u003e, then \u003ccode\u003ea*b\u003c/code\u003e is in most cases a strong Fermat\n   base for \u003ccode\u003en\u003c/code\u003e, it can only fail to be so if \u003ccode\u003en \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e 4 == 1\u003c/code\u003e and\n   the strong Fermat condition is reached at the same step for \u003ccode\u003ea\u003c/code\u003e as for \u003ccode\u003eb\u003c/code\u003e,\n   so primes are the most powerful bases to test.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isStrongFermatPP",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Probabilistic.html#isStrongFermatPP",
          "type": "function"
        },
        "index": {
          "description": "isStrongFermatPP tests whether is strong Fermat probable prime for base where and The conditions on the arguments are not checked Apart from primes also some composite numbers have the tested property but those are rare Very rare are composite numbers having the property for many bases so testing large prime candidate with several bases can identify composite numbers with high probability An odd number is prime if and only if isStrongFermatPP holds for all with n-1 but of course checking all those bases would be less efficient than trial division so one normally checks only relatively small number of bases depending on the desired degree of certainty The probability that randomly chosen base doesn identify composite number is less than so five to ten tests give reasonable level of certainty in general Some notes about the choice of bases is strong Fermat base for if and only if n-b is hence one needs only test n-1 If is strong Fermat base for then so is mod for all hence one needs not test perfect powers since their base yields stronger condition Finally if and are strong Fermat bases for then is in most cases strong Fermat base for it can only fail to be so if mod and the strong Fermat condition is reached at the same step for as for so primes are the most powerful bases to test",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "isStrongFermatPP",
          "normalized": "Integer-\u003eInteger-\u003eBool",
          "package": "arithmoi",
          "partial": "Strong Fermat PP",
          "signature": "Integer-\u003eInteger-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:isStrongFermatPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Miller-Rabin like probabilistic primality test with preceding\n   trial division. While the classic Miller-Rabin test uses\n   randomly chosen bases, \u003ccode\u003e\u003ccode\u003e\u003ca\u003emillerRabinV\u003c/a\u003e\u003c/code\u003e k n\u003c/code\u003e uses the \u003ccode\u003ek\u003c/code\u003e\n   smallest primes as bases if trial division has not reached\n   a conclusive result. (Only the primes up to \u003ccode\u003e1200\u003c/code\u003e are\n   available in this module, so the maximal effective \u003ccode\u003ek\u003c/code\u003e is \u003ccode\u003e196\u003c/code\u003e.)\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "millerRabinV",
          "package": "arithmoi",
          "signature": "Int -\u003e Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Testing-Probabilistic.html#millerRabinV",
          "type": "function"
        },
        "index": {
          "description": "Miller-Rabin like probabilistic primality test with preceding trial division While the classic Miller-Rabin test uses randomly chosen bases millerRabinV uses the smallest primes as bases if trial division has not reached conclusive result Only the primes up to are available in this module so the maximal effective is",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "millerRabinV",
          "normalized": "Int-\u003eInteger-\u003eBool",
          "package": "arithmoi",
          "partial": "Rabin",
          "signature": "Int-\u003eInteger-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:millerRabinV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003etrialDivisionPrimeTo\u003c/a\u003e\u003c/code\u003e bound n\u003c/code\u003e tests whether \u003ccode\u003en\u003c/code\u003e is coprime to all primes \u003ccode\u003e\u003c= bound\u003c/code\u003e.\n   If \u003ccode\u003en \u003c= bound^2\u003c/code\u003e, this is a full prime test, but very slow if \u003ccode\u003en\u003c/code\u003e has no small prime divisors.\n\u003c/p\u003e",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "trialDivisionPrimeTo",
          "package": "arithmoi",
          "signature": "Integer -\u003e Integer -\u003e Bool",
          "source": "src/Math-NumberTheory-Primes-Factorisation-TrialDivision.html#trialDivisionPrimeTo",
          "type": "function"
        },
        "index": {
          "description": "trialDivisionPrimeTo bound tests whether is coprime to all primes bound If bound this is full prime test but very slow if has no small prime divisors",
          "hierarchy": "Math NumberTheory Primes Testing",
          "module": "Math.NumberTheory.Primes.Testing",
          "name": "trialDivisionPrimeTo",
          "normalized": "Integer-\u003eInteger-\u003eBool",
          "package": "arithmoi",
          "partial": "Division Prime To",
          "signature": "Integer-\u003eInteger-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes-Testing.html#v:trialDivisionPrimeTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Math.NumberTheory.Primes",
          "name": "Primes",
          "package": "arithmoi",
          "source": "src/Math-NumberTheory-Primes.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Math NumberTheory Primes",
          "module": "Math.NumberTheory.Primes",
          "name": "Primes",
          "package": "arithmoi",
          "partial": "Primes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/arithmoi/docs/Math-NumberTheory-Primes.html#"
      }
    }
  ]
]