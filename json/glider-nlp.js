[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "glider-nlp"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis code was taken from: http:\u003cem/\u003etartarus.org\u003cem\u003e~martin\u003c/em\u003ePorterStemmer/haskell.txt \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Glider.NLP.Language.English.Porter",
          "name": "Porter",
          "package": "glider-nlp",
          "source": "src/Glider-NLP-Language-English-Porter.html",
          "type": "module"
        },
        "index": {
          "description": "This code was taken from http tartarus.org martin PorterStemmer haskell.txt",
          "hierarchy": "Glider NLP Language English Porter",
          "module": "Glider.NLP.Language.English.Porter",
          "name": "Porter",
          "package": "glider-nlp",
          "partial": "Porter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Language-English-Porter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAPI stemming function\n\u003c/p\u003e",
          "module": "Glider.NLP.Language.English.Porter",
          "name": "stem",
          "package": "glider-nlp",
          "signature": "Text -\u003e Text",
          "source": "src/Glider-NLP-Language-English-Porter.html#stem",
          "type": "function"
        },
        "index": {
          "description": "API stemming function",
          "hierarchy": "Glider NLP Language English Porter",
          "module": "Glider.NLP.Language.English.Porter",
          "name": "stem",
          "normalized": "Text-\u003eText",
          "package": "glider-nlp",
          "signature": "Text-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Language-English-Porter.html#v:stem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule contains stop words for English language\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Glider.NLP.Language.English.StopWords",
          "name": "StopWords",
          "package": "glider-nlp",
          "source": "src/Glider-NLP-Language-English-StopWords.html",
          "type": "module"
        },
        "index": {
          "description": "Module contains stop words for English language",
          "hierarchy": "Glider NLP Language English StopWords",
          "module": "Glider.NLP.Language.English.StopWords",
          "name": "StopWords",
          "package": "glider-nlp",
          "partial": "Stop Words",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Language-English-StopWords.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate to check if given words is a stop word\n\u003c/p\u003e",
          "module": "Glider.NLP.Language.English.StopWords",
          "name": "isStopWord",
          "package": "glider-nlp",
          "signature": "Text -\u003e Bool",
          "source": "src/Glider-NLP-Language-English-StopWords.html#isStopWord",
          "type": "function"
        },
        "index": {
          "description": "Predicate to check if given words is stop word",
          "hierarchy": "Glider NLP Language English StopWords",
          "module": "Glider.NLP.Language.English.StopWords",
          "name": "isStopWord",
          "normalized": "Text-\u003eBool",
          "package": "glider-nlp",
          "partial": "Stop Word",
          "signature": "Text-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Language-English-StopWords.html#v:isStopWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule contains stop words for Polish language\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Glider.NLP.Language.Polish.StopWords",
          "name": "StopWords",
          "package": "glider-nlp",
          "source": "src/Glider-NLP-Language-Polish-StopWords.html",
          "type": "module"
        },
        "index": {
          "description": "Module contains stop words for Polish language",
          "hierarchy": "Glider NLP Language Polish StopWords",
          "module": "Glider.NLP.Language.Polish.StopWords",
          "name": "StopWords",
          "package": "glider-nlp",
          "partial": "Stop Words",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Language-Polish-StopWords.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate to check if given words is a stop word\n\u003c/p\u003e",
          "module": "Glider.NLP.Language.Polish.StopWords",
          "name": "isStopWord",
          "package": "glider-nlp",
          "signature": "Text -\u003e Bool",
          "source": "src/Glider-NLP-Language-Polish-StopWords.html#isStopWord",
          "type": "function"
        },
        "index": {
          "description": "Predicate to check if given words is stop word",
          "hierarchy": "Glider NLP Language Polish StopWords",
          "module": "Glider.NLP.Language.Polish.StopWords",
          "name": "isStopWord",
          "normalized": "Text-\u003eBool",
          "package": "glider-nlp",
          "partial": "Stop Word",
          "signature": "Text-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Language-Polish-StopWords.html#v:isStopWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module counts different statistics on the text\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Glider.NLP.Statistics",
          "name": "Statistics",
          "package": "glider-nlp",
          "source": "src/Glider-NLP-Statistics.html",
          "type": "module"
        },
        "index": {
          "description": "This module counts different statistics on the text",
          "hierarchy": "Glider NLP Statistics",
          "module": "Glider.NLP.Statistics",
          "name": "Statistics",
          "package": "glider-nlp",
          "partial": "Statistics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Statistics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount number of words in the text.\n\u003c/p\u003e\u003cpre\u003e countWords (T.pack \"one two three\") == 3\n\u003c/pre\u003e",
          "module": "Glider.NLP.Statistics",
          "name": "countWords",
          "package": "glider-nlp",
          "signature": "Text -\u003e Int",
          "source": "src/Glider-NLP-Statistics.html#countWords",
          "type": "function"
        },
        "index": {
          "description": "Count number of words in the text countWords T.pack one two three",
          "hierarchy": "Glider NLP Statistics",
          "module": "Glider.NLP.Statistics",
          "name": "countWords",
          "normalized": "Text-\u003eInt",
          "package": "glider-nlp",
          "partial": "Words",
          "signature": "Text-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Statistics.html#v:countWords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount word frequency\n\u003c/p\u003e\u003cpre\u003e wordFreq (T.pack \"one two, three one\") == [(\"one\", 2), (\"two\", 1), (\"three\", 1)]\n\u003c/pre\u003e",
          "module": "Glider.NLP.Statistics",
          "name": "wordFreq",
          "package": "glider-nlp",
          "signature": "Text -\u003e [(Text, Int)]",
          "source": "src/Glider-NLP-Statistics.html#wordFreq",
          "type": "function"
        },
        "index": {
          "description": "Count word frequency wordFreq T.pack one two three one one two three",
          "hierarchy": "Glider NLP Statistics",
          "module": "Glider.NLP.Statistics",
          "name": "wordFreq",
          "normalized": "Text-\u003e[(Text,Int)]",
          "package": "glider-nlp",
          "partial": "Freq",
          "signature": "Text-\u003e[(Text,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Statistics.html#v:wordFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains functions which parses text into tokens. \ntokens are not normalized. If you need all tokens from the document then \ncheck function \u003ca\u003etokenize\u003c/a\u003e. If you need only words (na dots, numbers etc.) \nthen check function \u003ca\u003egetWords\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "Tokenizer",
          "package": "glider-nlp",
          "source": "src/Glider-NLP-Tokenizer.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains functions which parses text into tokens tokens are not normalized If you need all tokens from the document then check function tokenize If you need only words na dots numbers etc then check function getWords",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Tokenizer",
          "package": "glider-nlp",
          "partial": "Tokenizer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eToken type\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "Token",
          "package": "glider-nlp",
          "source": "src/Glider-NLP-Tokenizer.html#Token",
          "type": "data"
        },
        "index": {
          "description": "Token type",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Token",
          "package": "glider-nlp",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Glider.NLP.Tokenizer",
          "name": "Number",
          "package": "glider-nlp",
          "signature": "Number Text",
          "source": "src/Glider-NLP-Tokenizer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Number",
          "package": "glider-nlp",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Glider.NLP.Tokenizer",
          "name": "Punctuation",
          "package": "glider-nlp",
          "signature": "Punctuation Char",
          "source": "src/Glider-NLP-Tokenizer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Punctuation",
          "package": "glider-nlp",
          "partial": "Punctuation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:Punctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Glider.NLP.Tokenizer",
          "name": "Symbol",
          "package": "glider-nlp",
          "signature": "Symbol Char",
          "source": "src/Glider-NLP-Tokenizer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Symbol",
          "package": "glider-nlp",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Glider.NLP.Tokenizer",
          "name": "Unknown",
          "package": "glider-nlp",
          "signature": "Unknown Char",
          "source": "src/Glider-NLP-Tokenizer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Unknown",
          "package": "glider-nlp",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Glider.NLP.Tokenizer",
          "name": "Whitespace",
          "package": "glider-nlp",
          "signature": "Whitespace",
          "source": "src/Glider-NLP-Tokenizer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Whitespace",
          "package": "glider-nlp",
          "partial": "Whitespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:Whitespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Glider.NLP.Tokenizer",
          "name": "Word",
          "package": "glider-nlp",
          "signature": "Word Text",
          "source": "src/Glider-NLP-Tokenizer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "Word",
          "package": "glider-nlp",
          "partial": "Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:Word"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply all parsers to the input. \n Return result from the first which will parse correctly given text.\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "allParser",
          "package": "glider-nlp",
          "signature": "Parser",
          "source": "src/Glider-NLP-Tokenizer.html#allParser",
          "type": "function"
        },
        "index": {
          "description": "Apply all parsers to the input Return result from the first which will parse correctly given text",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "allParser",
          "package": "glider-nlp",
          "partial": "Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:allParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert all words to the same case\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "foldCase",
          "package": "glider-nlp",
          "signature": "[Text] -\u003e [Text]",
          "source": "src/Glider-NLP-Tokenizer.html#foldCase",
          "type": "function"
        },
        "index": {
          "description": "Convert all words to the same case",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "foldCase",
          "normalized": "[Text]-\u003e[Text]",
          "package": "glider-nlp",
          "partial": "Case",
          "signature": "[Text]-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:foldCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExctract all words from tokens\n\u003c/p\u003e\u003cpre\u003e getWords \"one two.\" == [\"one\", \"two\"] \n\u003c/pre\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "getWords",
          "package": "glider-nlp",
          "signature": "[Token] -\u003e [Text]",
          "source": "src/Glider-NLP-Tokenizer.html#getWords",
          "type": "function"
        },
        "index": {
          "description": "Exctract all words from tokens getWords one two one two",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "getWords",
          "normalized": "[Token]-\u003e[Text]",
          "package": "glider-nlp",
          "partial": "Words",
          "signature": "[Token]-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:getWords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse number\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "numberParser",
          "package": "glider-nlp",
          "signature": "Parser",
          "source": "src/Glider-NLP-Tokenizer.html#numberParser",
          "type": "function"
        },
        "index": {
          "description": "Parse number",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "numberParser",
          "package": "glider-nlp",
          "partial": "Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:numberParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse punctuation\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "punctuationParser",
          "package": "glider-nlp",
          "signature": "Parser",
          "source": "src/Glider-NLP-Tokenizer.html#punctuationParser",
          "type": "function"
        },
        "index": {
          "description": "Parse punctuation",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "punctuationParser",
          "package": "glider-nlp",
          "partial": "Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:punctuationParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse whitespaces\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "spaceParser",
          "package": "glider-nlp",
          "signature": "Parser",
          "source": "src/Glider-NLP-Tokenizer.html#spaceParser",
          "type": "function"
        },
        "index": {
          "description": "Parse whitespaces",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "spaceParser",
          "package": "glider-nlp",
          "partial": "Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:spaceParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse symbol\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "symbolParser",
          "package": "glider-nlp",
          "signature": "Parser",
          "source": "src/Glider-NLP-Tokenizer.html#symbolParser",
          "type": "function"
        },
        "index": {
          "description": "Parse symbol",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "symbolParser",
          "package": "glider-nlp",
          "partial": "Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:symbolParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit text into tokens\n\u003c/p\u003e\u003cpre\u003e tokenize \"one two.\" == [Word \"one\", Whitespace, Word \"two\", \"Separator \".\"] \n\u003c/pre\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "tokenize",
          "package": "glider-nlp",
          "signature": "Text -\u003e [Token]",
          "source": "src/Glider-NLP-Tokenizer.html#tokenize",
          "type": "function"
        },
        "index": {
          "description": "Split text into tokens tokenize one two Word one Whitespace Word two Separator",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "tokenize",
          "normalized": "Text-\u003e[Token]",
          "package": "glider-nlp",
          "signature": "Text-\u003e[Token]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:tokenize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse word\n\u003c/p\u003e",
          "module": "Glider.NLP.Tokenizer",
          "name": "wordParser",
          "package": "glider-nlp",
          "signature": "Parser",
          "source": "src/Glider-NLP-Tokenizer.html#wordParser",
          "type": "function"
        },
        "index": {
          "description": "Parse word",
          "hierarchy": "Glider NLP Tokenizer",
          "module": "Glider.NLP.Tokenizer",
          "name": "wordParser",
          "package": "glider-nlp",
          "partial": "Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/glider-nlp/docs/Glider-NLP-Tokenizer.html#v:wordParser"
      }
    }
  ]
]