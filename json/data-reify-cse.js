[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "data-reify-cse"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements common sub-expression elimination for graphs\n generated by the Data.Reify package. The algorithm performs a simple\n fixed point iteration and is not optimized for speed.\n\u003c/p\u003e\u003cp\u003eAs an illustration, take this simple datatype representing an embedded\n language containing primitives and function application.  The datatype\n abstracts away from the recursive points which is common when using the\n \u003ccode\u003e\u003ca\u003eReify\u003c/a\u003e\u003c/code\u003e package.  A fixed point combinator can be used to tie the knot.\n\u003c/p\u003e\u003cpre\u003edata Val f = App f f | Prim String\n  deriving (Eq, Ord, Show)\n\nnewtype Fix f = In { out :: f (Fix f) }\n\u003c/pre\u003e\u003cp\u003eNo we can add some useful instances and make the fixed point combinator an\n instance of the \u003ccode\u003e\u003ca\u003eReify\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMuRef\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e\u003cpre\u003einstance Functor Val      ...\ninstance Foldable Val     ...\ninstance Traversable Val  ...\n\ninstance Traversable a =\u003e MuRef (Fix a) where\n  type DeRef (Fix a) = a\n  mapDeRef f = traverse f . out\n\u003c/pre\u003e\u003cp\u003eWhen we now take the following example term in our embedded language we can\n see that the \u003ccode\u003e\u003ca\u003ecse\u003c/a\u003e\u003c/code\u003e function can eliminate common terms without changing the\n semantics. Evidently, we assume our language is referential transparent language.\n\u003c/p\u003e\u003cpre\u003emyTerm :: Fix Val\nmyTerm = In $ clc `mul` clc\n  where clc = Prim \"2\" `add` Prim \"5\"\n        add a b = Prim \"+\" `app` a `app` b\n        mul a b = Prim \"*\" `app` a `app` b\n        app a b = App (In a) (In b)\n\u003c/pre\u003e\u003cp\u003eThe term \u003ccode\u003efmap cse $ reifyGraph myTerm\u003c/code\u003e yields an optimized graph compared\n to the normal result of \u003ccode\u003e\u003ca\u003ereifyGraph\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003ewith CSE:       without CSE:\n\n(1,App 2 9)     (1,App 2 9)\n(2,App 3 9)     (9,App 10 13)\n(10,App 6 7)    (13,Prim \"5\")\n(9,App 10 8)    (10,App 11 12)\n(3,Prim \"*\")    (12,Prim \"2\")\n(6,Prim \"+\")    (11,Prim \"+\")\n(7,Prim \"2\")    (2,App 3 4)\n(8,Prim \"5\")    (4,App 5 8)\n                (8,Prim \"5\")\n                (5,App 6 7)\n                (7,Prim \"2\")\n                (6,Prim \"+\")\n                (3,Prim \"*\")\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.Reify.Graph.CSE",
          "name": "CSE",
          "package": "data-reify-cse",
          "source": "src/Data-Reify-Graph-CSE.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements common sub-expression elimination for graphs generated by the Data.Reify package The algorithm performs simple fixed point iteration and is not optimized for speed As an illustration take this simple datatype representing an embedded language containing primitives and function application The datatype abstracts away from the recursive points which is common when using the Reify package fixed point combinator can be used to tie the knot data Val App Prim String deriving Eq Ord Show newtype Fix In out Fix No we can add some useful instances and make the fixed point combinator an instance of the Reify MuRef class instance Functor Val instance Foldable Val instance Traversable Val instance Traversable MuRef Fix where type DeRef Fix mapDeRef traverse out When we now take the following example term in our embedded language we can see that the cse function can eliminate common terms without changing the semantics Evidently we assume our language is referential transparent language myTerm Fix Val myTerm In clc mul clc where clc Prim add Prim add Prim app app mul Prim app app app App In In The term fmap cse reifyGraph myTerm yields an optimized graph compared to the normal result of reifyGraph with CSE without CSE App App App App App Prim App App Prim Prim Prim Prim Prim App Prim App Prim App Prim Prim Prim",
          "hierarchy": "Data Reify Graph CSE",
          "module": "Data.Reify.Graph.CSE",
          "name": "CSE",
          "package": "data-reify-cse",
          "partial": "CSE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/data-reify-cse/docs/Data-Reify-Graph-CSE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform CSE on the input graph. \n\u003c/p\u003e",
          "module": "Data.Reify.Graph.CSE",
          "name": "cse",
          "package": "data-reify-cse",
          "signature": "Graph f -\u003e Graph f",
          "source": "src/Data-Reify-Graph-CSE.html#cse",
          "type": "function"
        },
        "index": {
          "description": "Perform CSE on the input graph",
          "hierarchy": "Data Reify Graph CSE",
          "module": "Data.Reify.Graph.CSE",
          "name": "cse",
          "normalized": "Graph a-\u003eGraph a",
          "package": "data-reify-cse",
          "signature": "Graph f-\u003eGraph f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/data-reify-cse/docs/Data-Reify-Graph-CSE.html#v:cse"
      }
    }
  ]
]