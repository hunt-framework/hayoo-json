[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "ReadArgs"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "ReadArgs",
          "name": "ReadArgs",
          "package": "ReadArgs",
          "source": "src/ReadArgs.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "ReadArgs",
          "package": "ReadArgs",
          "partial": "Read Args",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse :& to construct arbitrary length tuples of any parsable arguments\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": ":&",
          "package": "ReadArgs",
          "source": "src/ReadArgs.html#%3A%26",
          "type": "data"
        },
        "index": {
          "description": "use to construct arbitrary length tuples of any parsable arguments",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": ":&",
          "package": "ReadArgs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t::-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea class for types that can be parsed from exactly one command line argument\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "Arguable",
          "package": "ReadArgs",
          "source": "src/ReadArgs.html#Arguable",
          "type": "class"
        },
        "index": {
          "description": "class for types that can be parsed from exactly one command line argument",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "Arguable",
          "package": "ReadArgs",
          "partial": "Arguable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:Arguable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea class for types that can be parsed from some number of command line\n arguments\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "Argument",
          "package": "ReadArgs",
          "source": "src/ReadArgs.html#Argument",
          "type": "class"
        },
        "index": {
          "description": "class for types that can be parsed from some number of command line arguments",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "Argument",
          "package": "ReadArgs",
          "partial": "Argument",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:Argument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea class for tuples of types that can be parsed from the entire list\n of arguments\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "ArgumentTuple",
          "package": "ReadArgs",
          "source": "src/ReadArgs.html#ArgumentTuple",
          "type": "class"
        },
        "index": {
          "description": "class for tuples of types that can be parsed from the entire list of arguments",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "ArgumentTuple",
          "package": "ReadArgs",
          "partial": "Argument Tuple",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:ArgumentTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea wrapper type to indicate a non-greedy list or maybe\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "NonGreedy",
          "package": "ReadArgs",
          "source": "src/ReadArgs.html#NonGreedy",
          "type": "newtype"
        },
        "index": {
          "description": "wrapper type to indicate non-greedy list or maybe",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "NonGreedy",
          "package": "ReadArgs",
          "partial": "Non Greedy",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#t:NonGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "ReadArgs",
          "name": ":&",
          "package": "ReadArgs",
          "signature": "a :& b",
          "source": "src/ReadArgs.html#%3A%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": ":&",
          "package": "ReadArgs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v::-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "ReadArgs",
          "name": "NonGreedy",
          "package": "ReadArgs",
          "signature": "NonGreedy",
          "source": "src/ReadArgs.html#NonGreedy",
          "type": "function"
        },
        "index": {
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "NonGreedy",
          "package": "ReadArgs",
          "partial": "Non Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:NonGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eargName's argument will usually be undefined, so when defining instances of\n Arguable, it should be lazy in its argument\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "argName",
          "package": "ReadArgs",
          "signature": "a -\u003e String",
          "source": "src/ReadArgs.html#argName",
          "type": "method"
        },
        "index": {
          "description": "argName argument will usually be undefined so when defining instances of Arguable it should be lazy in its argument",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "argName",
          "normalized": "a-\u003eString",
          "package": "ReadArgs",
          "partial": "Name",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:argName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename's argument will usually be undefined, so when defining instances of\n Arguable, it should be lazy in its argument\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "name",
          "package": "ReadArgs",
          "signature": "a -\u003e String",
          "source": "src/ReadArgs.html#name",
          "type": "method"
        },
        "index": {
          "description": "name argument will usually be undefined so when defining instances of Arguable it should be lazy in its argument",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "name",
          "normalized": "a-\u003eString",
          "package": "ReadArgs",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "ReadArgs",
          "name": "parse",
          "package": "ReadArgs",
          "signature": "String -\u003e Maybe a",
          "source": "src/ReadArgs.html#parse",
          "type": "method"
        },
        "index": {
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "parse",
          "normalized": "String-\u003eMaybe a",
          "package": "ReadArgs",
          "signature": "String-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "ReadArgs",
          "name": "parseArg",
          "package": "ReadArgs",
          "signature": "[String] -\u003e [(a, [String])]",
          "source": "src/ReadArgs.html#parseArg",
          "type": "method"
        },
        "index": {
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "parseArg",
          "normalized": "[String]-\u003e[(a,[String])]",
          "package": "ReadArgs",
          "partial": "Arg",
          "signature": "[String]-\u003e[(a,[String])]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:parseArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "ReadArgs",
          "name": "parseArgsFrom",
          "package": "ReadArgs",
          "signature": "[String] -\u003e Maybe a",
          "source": "src/ReadArgs.html#parseArgsFrom",
          "type": "method"
        },
        "index": {
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "parseArgsFrom",
          "normalized": "[String]-\u003eMaybe a",
          "package": "ReadArgs",
          "partial": "Args From",
          "signature": "[String]-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:parseArgsFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse the desired argument tuple from the command line or \n  print a simple usage statment and quit\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "readArgs",
          "package": "ReadArgs",
          "signature": "IO a",
          "source": "src/ReadArgs.html#readArgs",
          "type": "function"
        },
        "index": {
          "description": "parse the desired argument tuple from the command line or print simple usage statment and quit",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "readArgs",
          "package": "ReadArgs",
          "partial": "Args",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:readArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread args from the given strings or \n  print a simple usage statment and quit\n  (so you can do option parsing first)\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "readArgsFrom",
          "package": "ReadArgs",
          "signature": "[String] -\u003e IO a",
          "source": "src/ReadArgs.html#readArgsFrom",
          "type": "function"
        },
        "index": {
          "description": "read args from the given strings or print simple usage statment and quit so you can do option parsing first",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "readArgsFrom",
          "normalized": "[String]-\u003eIO a",
          "package": "ReadArgs",
          "partial": "Args From",
          "signature": "[String]-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:readArgsFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "ReadArgs",
          "name": "unNonGreedy",
          "package": "ReadArgs",
          "signature": "m a",
          "source": "src/ReadArgs.html#NonGreedy",
          "type": "function"
        },
        "index": {
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "unNonGreedy",
          "package": "ReadArgs",
          "partial": "Non Greedy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:unNonGreedy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eusageFor's argument will usually be undefined, so when defining instances of\n Arguable, it should be lazy in its argument\n\u003c/p\u003e",
          "module": "ReadArgs",
          "name": "usageFor",
          "package": "ReadArgs",
          "signature": "a -\u003e String",
          "source": "src/ReadArgs.html#usageFor",
          "type": "method"
        },
        "index": {
          "description": "usageFor argument will usually be undefined so when defining instances of Arguable it should be lazy in its argument",
          "hierarchy": "ReadArgs",
          "module": "ReadArgs",
          "name": "usageFor",
          "normalized": "a-\u003eString",
          "package": "ReadArgs",
          "partial": "For",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ReadArgs/docs/ReadArgs.html#v:usageFor"
      }
    }
  ]
]