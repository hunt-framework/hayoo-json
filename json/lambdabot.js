[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "lambdabot"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.ChanName",
          "name": "ChanName",
          "package": "lambdabot",
          "source": "src/Lambdabot-ChanName.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot ChanName",
          "module": "Lambdabot.ChanName",
          "name": "ChanName",
          "package": "lambdabot",
          "partial": "Chan Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-ChanName.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.ChanName",
          "name": "ChanName",
          "package": "lambdabot",
          "source": "src/Lambdabot-ChanName.html#ChanName",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot ChanName",
          "module": "Lambdabot.ChanName",
          "name": "ChanName",
          "package": "lambdabot",
          "partial": "Chan Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-ChanName.html#t:ChanName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambdabot.ChanName\",\"Lambdabot.Plugin\"]",
          "name": "getCN",
          "package": "lambdabot",
          "signature": "ChanName -\u003e Nick",
          "source": "src/Lambdabot-ChanName.html#getCN",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-ChanName.html#v:getCN\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:getCN\"]"
        },
        "index": {
          "hierarchy": "Lambdabot ChanName",
          "module": "Lambdabot.ChanName",
          "name": "getCN",
          "normalized": "ChanName-\u003eNick",
          "package": "lambdabot",
          "partial": "CN",
          "signature": "ChanName-\u003eNick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-ChanName.html#v:getCN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambdabot.ChanName\",\"Lambdabot.Plugin\"]",
          "name": "mkCN",
          "package": "lambdabot",
          "signature": "Nick -\u003e ChanName",
          "source": "src/Lambdabot-ChanName.html#mkCN",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-ChanName.html#v:mkCN\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:mkCN\"]"
        },
        "index": {
          "hierarchy": "Lambdabot ChanName",
          "module": "Lambdabot.ChanName",
          "name": "mkCN",
          "normalized": "Nick-\u003eChanName",
          "package": "lambdabot",
          "partial": "CN",
          "signature": "Nick-\u003eChanName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-ChanName.html#v:mkCN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "Command",
          "package": "lambdabot",
          "source": "src/Lambdabot-Command.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "Command",
          "package": "lambdabot",
          "partial": "Command",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "Cmd",
          "package": "lambdabot",
          "source": "src/Lambdabot-Command.html#Cmd",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "Cmd",
          "package": "lambdabot",
          "partial": "Cmd",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#t:Cmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "Command",
          "package": "lambdabot",
          "source": "src/Lambdabot-Command.html#Command",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "Command",
          "package": "lambdabot",
          "partial": "Command",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#t:Command"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "Command",
          "package": "lambdabot",
          "signature": "Command",
          "source": "src/Lambdabot-Command.html#Command",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "Command",
          "package": "lambdabot",
          "partial": "Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:Command"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "aliases",
          "package": "lambdabot",
          "signature": "[String]",
          "source": "src/Lambdabot-Command.html#Command",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "aliases",
          "normalized": "[String]",
          "package": "lambdabot",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:aliases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "cmdName",
          "package": "lambdabot",
          "signature": "String",
          "source": "src/Lambdabot-Command.html#Command",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "cmdName",
          "package": "lambdabot",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:cmdName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "cmdNames",
          "package": "lambdabot",
          "signature": "Command m -\u003e [String]",
          "source": "src/Lambdabot-Command.html#cmdNames",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "cmdNames",
          "normalized": "Command a-\u003e[String]",
          "package": "lambdabot",
          "partial": "Names",
          "signature": "Command m-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:cmdNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "command",
          "package": "lambdabot",
          "signature": "String -\u003e Command Identity",
          "source": "src/Lambdabot-Command.html#command",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "command",
          "normalized": "String-\u003eCommand Identity",
          "package": "lambdabot",
          "signature": "String-\u003eCommand Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:command"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "execCmd",
          "package": "lambdabot",
          "signature": "Cmd m t -\u003e a -\u003e Nick -\u003e String -\u003e m [String]",
          "source": "src/Lambdabot-Command.html#execCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "execCmd",
          "normalized": "Cmd a b-\u003ec-\u003eNick-\u003eString-\u003ea[String]",
          "package": "lambdabot",
          "partial": "Cmd",
          "signature": "Cmd m t-\u003ea-\u003eNick-\u003eString-\u003em[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:execCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "getCmdName",
          "package": "lambdabot",
          "signature": "Cmd m String",
          "source": "src/Lambdabot-Command.html#getCmdName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "getCmdName",
          "package": "lambdabot",
          "partial": "Cmd Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:getCmdName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "getLambdabotName",
          "package": "lambdabot",
          "signature": "Cmd m Nick",
          "source": "src/Lambdabot-Command.html#getLambdabotName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "getLambdabotName",
          "package": "lambdabot",
          "partial": "Lambdabot Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:getLambdabotName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "getSender",
          "package": "lambdabot",
          "signature": "Cmd m Nick",
          "source": "src/Lambdabot-Command.html#getSender",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "getSender",
          "package": "lambdabot",
          "partial": "Sender",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:getSender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "getServer",
          "package": "lambdabot",
          "signature": "Cmd m String",
          "source": "src/Lambdabot-Command.html#getServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "getServer",
          "package": "lambdabot",
          "partial": "Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:getServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "getTarget",
          "package": "lambdabot",
          "signature": "Cmd m Nick",
          "source": "src/Lambdabot-Command.html#getTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "getTarget",
          "package": "lambdabot",
          "partial": "Target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:getTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "help",
          "package": "lambdabot",
          "signature": "Cmd m ()",
          "source": "src/Lambdabot-Command.html#Command",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "help",
          "normalized": "Cmd a()",
          "package": "lambdabot",
          "signature": "Cmd m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:help"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "privileged",
          "package": "lambdabot",
          "signature": "Bool",
          "source": "src/Lambdabot-Command.html#Command",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "privileged",
          "package": "lambdabot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:privileged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "process",
          "package": "lambdabot",
          "signature": "String -\u003e Cmd m ()",
          "source": "src/Lambdabot-Command.html#Command",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "process",
          "normalized": "String-\u003eCmd a()",
          "package": "lambdabot",
          "signature": "String-\u003eCmd m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:process"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "readNick",
          "package": "lambdabot",
          "signature": "String -\u003e Cmd m Nick",
          "source": "src/Lambdabot-Command.html#readNick",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "readNick",
          "normalized": "String-\u003eCmd a Nick",
          "package": "lambdabot",
          "partial": "Nick",
          "signature": "String-\u003eCmd m Nick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:readNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "runCommand",
          "package": "lambdabot",
          "signature": "Command m -\u003e a -\u003e Nick -\u003e String -\u003e String -\u003e m [String]",
          "source": "src/Lambdabot-Command.html#runCommand",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "runCommand",
          "normalized": "Command a-\u003eb-\u003eNick-\u003eString-\u003eString-\u003ea[String]",
          "package": "lambdabot",
          "partial": "Command",
          "signature": "Command m-\u003ea-\u003eNick-\u003eString-\u003eString-\u003em[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:runCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "say",
          "package": "lambdabot",
          "signature": "String -\u003e Cmd m ()",
          "source": "src/Lambdabot-Command.html#say",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "say",
          "normalized": "String-\u003eCmd a()",
          "package": "lambdabot",
          "signature": "String-\u003eCmd m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:say"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "showNick",
          "package": "lambdabot",
          "signature": "Nick -\u003e Cmd m String",
          "source": "src/Lambdabot-Command.html#showNick",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "showNick",
          "normalized": "Nick-\u003eCmd a String",
          "package": "lambdabot",
          "partial": "Nick",
          "signature": "Nick-\u003eCmd m String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:showNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Command",
          "name": "withMsg",
          "package": "lambdabot",
          "signature": "a -\u003e Cmd m t) -\u003e Cmd m t",
          "source": "src/Lambdabot-Command.html#withMsg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Command",
          "module": "Lambdabot.Command",
          "name": "withMsg",
          "normalized": "a-\u003eCmd b c)-\u003eCmd b c",
          "package": "lambdabot",
          "partial": "Msg",
          "signature": "a-\u003eCmd m t)-\u003eCmd m t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Command.html#v:withMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTime compatibility layer\n (stuff to support old lambdabot state serialization formats)\n\u003c/p\u003e\u003cp\u003eTODO: trim this down to just the explicitly serialization-related stuff\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Compat.AltTime",
          "name": "AltTime",
          "package": "lambdabot",
          "source": "src/Lambdabot-Compat-AltTime.html",
          "type": "module"
        },
        "index": {
          "description": "Time compatibility layer stuff to support old lambdabot state serialization formats TODO trim this down to just the explicitly serialization-related stuff",
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "AltTime",
          "package": "lambdabot",
          "partial": "Alt Time",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapping ClockTime (which doesn't provide a Read instance!) seems\n easier than talking care of the serialization of UserStatus\n ourselves.\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.AltTime",
          "name": "ClockTime",
          "package": "lambdabot",
          "source": "src/Lambdabot-Compat-AltTime.html#ClockTime",
          "type": "data"
        },
        "index": {
          "description": "Wrapping ClockTime which doesn provide Read instance seems easier than talking care of the serialization of UserStatus ourselves",
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "ClockTime",
          "package": "lambdabot",
          "partial": "Clock Time",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#t:ClockTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.AltTime",
          "name": "TimeDiff",
          "package": "lambdabot",
          "source": "src/Lambdabot-Compat-AltTime.html#TimeDiff",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "TimeDiff",
          "package": "lambdabot",
          "partial": "Time Diff",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#t:TimeDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.AltTime",
          "name": "TimeDiff",
          "package": "lambdabot",
          "signature": "TimeDiff NominalDiffTime",
          "source": "src/Lambdabot-Compat-AltTime.html#TimeDiff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "TimeDiff",
          "package": "lambdabot",
          "partial": "Time Diff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#v:TimeDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eaddToClockTime\u003c/a\u003e\u003c/code\u003e d t\u003c/code\u003e adds a time difference \u003ccode\u003ed\u003c/code\u003e and a -- clock\n time \u003ccode\u003et\u003c/code\u003e to yield a new clock time.\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.AltTime",
          "name": "addToClockTime",
          "package": "lambdabot",
          "signature": "TimeDiff -\u003e ClockTime -\u003e ClockTime",
          "source": "src/Lambdabot-Compat-AltTime.html#addToClockTime",
          "type": "function"
        },
        "index": {
          "description": "addToClockTime adds time difference and clock time to yield new clock time",
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "addToClockTime",
          "normalized": "TimeDiff-\u003eClockTime-\u003eClockTime",
          "package": "lambdabot",
          "partial": "To Clock Time",
          "signature": "TimeDiff-\u003eClockTime-\u003eClockTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#v:addToClockTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifference of two clock times\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.AltTime",
          "name": "diffClockTimes",
          "package": "lambdabot",
          "signature": "ClockTime -\u003e ClockTime -\u003e TimeDiff",
          "source": "src/Lambdabot-Compat-AltTime.html#diffClockTimes",
          "type": "function"
        },
        "index": {
          "description": "Difference of two clock times",
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "diffClockTimes",
          "normalized": "ClockTime-\u003eClockTime-\u003eTimeDiff",
          "package": "lambdabot",
          "partial": "Clock Times",
          "signature": "ClockTime-\u003eClockTime-\u003eTimeDiff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#v:diffClockTimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the current clocktime\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.AltTime",
          "name": "getClockTime",
          "package": "lambdabot",
          "signature": "IO ClockTime",
          "source": "src/Lambdabot-Compat-AltTime.html#getClockTime",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the current clocktime",
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "getClockTime",
          "package": "lambdabot",
          "partial": "Clock Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#v:getClockTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.AltTime",
          "name": "noTimeDiff",
          "package": "lambdabot",
          "signature": "TimeDiff",
          "source": "src/Lambdabot-Compat-AltTime.html#noTimeDiff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "noTimeDiff",
          "package": "lambdabot",
          "partial": "Time Diff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#v:noTimeDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty-print a TimeDiff. Both positive and negative Timediffs produce\n   the same output.\n\u003c/p\u003e\u003cp\u003e14d 17h 8m 53s\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.AltTime",
          "name": "timeDiffPretty",
          "package": "lambdabot",
          "signature": "TimeDiff -\u003e String",
          "source": "src/Lambdabot-Compat-AltTime.html#timeDiffPretty",
          "type": "function"
        },
        "index": {
          "description": "Pretty-print TimeDiff Both positive and negative Timediffs produce the same output",
          "hierarchy": "Lambdabot Compat AltTime",
          "module": "Lambdabot.Compat.AltTime",
          "name": "timeDiffPretty",
          "normalized": "TimeDiff-\u003eString",
          "package": "lambdabot",
          "partial": "Diff Pretty",
          "signature": "TimeDiff-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-AltTime.html#v:timeDiffPretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBackward-compatibility shim for (de-)serializing \u003ccode\u003e\u003ca\u003eNick\u003c/a\u003e\u003c/code\u003es\n using the old 'Read'/'Show' instances which gave freenode\n special treatment.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "FreenodeNick",
          "package": "lambdabot",
          "source": "src/Lambdabot-Compat-FreenodeNick.html",
          "type": "module"
        },
        "index": {
          "description": "Backward-compatibility shim for de serializing Nick using the old Read Show instances which gave freenode special treatment",
          "hierarchy": "Lambdabot Compat FreenodeNick",
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "FreenodeNick",
          "package": "lambdabot",
          "partial": "Freenode Nick",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-FreenodeNick.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "FreenodeNick",
          "package": "lambdabot",
          "source": "src/Lambdabot-Compat-FreenodeNick.html#FreenodeNick",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Lambdabot Compat FreenodeNick",
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "FreenodeNick",
          "package": "lambdabot",
          "partial": "Freenode Nick",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-FreenodeNick.html#t:FreenodeNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "FreenodeNick",
          "package": "lambdabot",
          "signature": "FreenodeNick",
          "source": "src/Lambdabot-Compat-FreenodeNick.html#FreenodeNick",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Compat FreenodeNick",
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "FreenodeNick",
          "package": "lambdabot",
          "partial": "Freenode Nick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-FreenodeNick.html#v:FreenodeNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "freenodeNickMapSerial",
          "package": "lambdabot",
          "signature": "Serial (Map Nick v)",
          "source": "src/Lambdabot-Compat-FreenodeNick.html#freenodeNickMapSerial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Compat FreenodeNick",
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "freenodeNickMapSerial",
          "package": "lambdabot",
          "partial": "Nick Map Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-FreenodeNick.html#v:freenodeNickMapSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "getFreenodeNick",
          "package": "lambdabot",
          "signature": "Nick",
          "source": "src/Lambdabot-Compat-FreenodeNick.html#FreenodeNick",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Compat FreenodeNick",
          "module": "Lambdabot.Compat.FreenodeNick",
          "name": "getFreenodeNick",
          "package": "lambdabot",
          "partial": "Freenode Nick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-FreenodeNick.html#v:getFreenodeNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Compat.PackedNick",
          "name": "PackedNick",
          "package": "lambdabot",
          "source": "src/Lambdabot-Compat-PackedNick.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Compat PackedNick",
          "module": "Lambdabot.Compat.PackedNick",
          "name": "PackedNick",
          "package": "lambdabot",
          "partial": "Packed Nick",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-PackedNick.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of nicknames\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.PackedNick",
          "name": "PackedNick",
          "package": "lambdabot",
          "source": "src/Lambdabot-Compat-PackedNick.html#PackedNick",
          "type": "type"
        },
        "index": {
          "description": "The type of nicknames",
          "hierarchy": "Lambdabot Compat PackedNick",
          "module": "Lambdabot.Compat.PackedNick",
          "name": "PackedNick",
          "package": "lambdabot",
          "partial": "Packed Nick",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-PackedNick.html#t:PackedNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePack a nickname into a ByteString.  Note that the resulting strings are\n not optimally formatted for human consumtion.\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.PackedNick",
          "name": "packNick",
          "package": "lambdabot",
          "signature": "Nick -\u003e ByteString",
          "source": "src/Lambdabot-Compat-PackedNick.html#packNick",
          "type": "function"
        },
        "index": {
          "description": "Pack nickname into ByteString Note that the resulting strings are not optimally formatted for human consumtion",
          "hierarchy": "Lambdabot Compat PackedNick",
          "module": "Lambdabot.Compat.PackedNick",
          "name": "packNick",
          "normalized": "Nick-\u003eByteString",
          "package": "lambdabot",
          "partial": "Nick",
          "signature": "Nick-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-PackedNick.html#v:packNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack a nickname packed by \u003ccode\u003e\u003ca\u003epackNick\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Lambdabot.Compat.PackedNick",
          "name": "unpackNick",
          "package": "lambdabot",
          "signature": "ByteString -\u003e Nick",
          "source": "src/Lambdabot-Compat-PackedNick.html#unpackNick",
          "type": "function"
        },
        "index": {
          "description": "Unpack nickname packed by packNick",
          "hierarchy": "Lambdabot Compat PackedNick",
          "module": "Lambdabot.Compat.PackedNick",
          "name": "unpackNick",
          "normalized": "ByteString-\u003eNick",
          "package": "lambdabot",
          "partial": "Nick",
          "signature": "ByteString-\u003eNick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Compat-PackedNick.html#v:unpackNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "Core",
          "package": "lambdabot",
          "source": "src/Lambdabot-Config-Core.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "Core",
          "package": "lambdabot",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "aspellBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#aspellBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "aspellBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:aspellBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "bfBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#bfBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "bfBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:bfBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "commandPrefixes",
          "package": "lambdabot",
          "signature": "Config [String]",
          "source": "src/Lambdabot-Config-Core.html#commandPrefixes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "commandPrefixes",
          "normalized": "Config[String]",
          "package": "lambdabot",
          "partial": "Prefixes",
          "signature": "Config[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:commandPrefixes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "consoleLogFormat",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#consoleLogFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "consoleLogFormat",
          "package": "lambdabot",
          "partial": "Log Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:consoleLogFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "consoleLogHandle",
          "package": "lambdabot",
          "signature": "Config Handle",
          "source": "src/Lambdabot-Config-Core.html#consoleLogHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "consoleLogHandle",
          "package": "lambdabot",
          "partial": "Log Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:consoleLogHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "consoleLogLevel",
          "package": "lambdabot",
          "signature": "Config Priority",
          "source": "src/Lambdabot-Config-Core.html#consoleLogLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "consoleLogLevel",
          "package": "lambdabot",
          "partial": "Log Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:consoleLogLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "disabledCommands",
          "package": "lambdabot",
          "signature": "Config [String]",
          "source": "src/Lambdabot-Config-Core.html#disabledCommands",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "disabledCommands",
          "normalized": "Config[String]",
          "package": "lambdabot",
          "partial": "Commands",
          "signature": "Config[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:disabledCommands"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "djinnBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#djinnBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "djinnBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:djinnBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "evalPrefixes",
          "package": "lambdabot",
          "signature": "Config [String]",
          "source": "src/Lambdabot-Config-Core.html#evalPrefixes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "evalPrefixes",
          "normalized": "Config[String]",
          "package": "lambdabot",
          "partial": "Prefixes",
          "signature": "Config[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:evalPrefixes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "ghcBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#ghcBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "ghcBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:ghcBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "ghciBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#ghciBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "ghciBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:ghciBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "hoogleBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#hoogleBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "hoogleBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:hoogleBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "lbRootLoggerPath",
          "package": "lambdabot",
          "signature": "Config [String]",
          "source": "src/Lambdabot-Config-Core.html#lbRootLoggerPath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "lbRootLoggerPath",
          "normalized": "Config[String]",
          "package": "lambdabot",
          "partial": "Root Logger Path",
          "signature": "Config[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:lbRootLoggerPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "muevalBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#muevalBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "muevalBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:muevalBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "onStartupCmds",
          "package": "lambdabot",
          "signature": "Config [String]",
          "source": "src/Lambdabot-Config-Core.html#onStartupCmds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "onStartupCmds",
          "normalized": "Config[String]",
          "package": "lambdabot",
          "partial": "Startup Cmds",
          "signature": "Config[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:onStartupCmds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambdabot.Config.Core\",\"Lambdabot.File\"]",
          "name": "outputDir",
          "package": "lambdabot",
          "signature": "Config FilePath",
          "source": "src/Lambdabot-Config-Core.html#outputDir",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:outputDir\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-File.html#v:outputDir\"]"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "outputDir",
          "package": "lambdabot",
          "partial": "Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:outputDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "proxy",
          "package": "lambdabot",
          "signature": "Config Proxy",
          "source": "src/Lambdabot-Config-Core.html#proxy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "proxy",
          "package": "lambdabot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:proxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "replaceRootLogger",
          "package": "lambdabot",
          "signature": "Config Bool",
          "source": "src/Lambdabot-Config-Core.html#replaceRootLogger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "replaceRootLogger",
          "package": "lambdabot",
          "partial": "Root Logger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:replaceRootLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "trustedPackages",
          "package": "lambdabot",
          "signature": "Config [String]",
          "source": "src/Lambdabot-Config-Core.html#trustedPackages",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "trustedPackages",
          "normalized": "Config[String]",
          "package": "lambdabot",
          "partial": "Packages",
          "signature": "Config[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:trustedPackages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "uncaughtExceptionHandler",
          "package": "lambdabot",
          "signature": "Config (SomeException -\u003e IO ())",
          "source": "src/Lambdabot-Config-Core.html#uncaughtExceptionHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "uncaughtExceptionHandler",
          "normalized": "Config(SomeException-\u003eIO())",
          "package": "lambdabot",
          "partial": "Exception Handler",
          "signature": "Config(SomeException-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:uncaughtExceptionHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config.Core",
          "name": "unlambdaBinary",
          "package": "lambdabot",
          "signature": "Config String",
          "source": "src/Lambdabot-Config-Core.html#unlambdaBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config Core",
          "module": "Lambdabot.Config.Core",
          "name": "unlambdaBinary",
          "package": "lambdabot",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config-Core.html#v:unlambdaBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtensible configuration system for lambdabot\n\u003c/p\u003e\u003cp\u003eTODO: there's notthing lambdabot-specific about this, it could be a useful standalone library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Config",
          "name": "Config",
          "package": "lambdabot",
          "source": "src/Lambdabot-Config.html",
          "type": "module"
        },
        "index": {
          "description": "Extensible configuration system for lambdabot TODO there notthing lambdabot-specific about this it could be useful standalone library",
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "Config",
          "package": "lambdabot",
          "partial": "Config",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config",
          "name": "Config",
          "package": "lambdabot",
          "source": "src/Lambdabot-Config.html#Config",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "Config",
          "package": "lambdabot",
          "partial": "Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#t:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config",
          "name": "MonadConfig",
          "package": "lambdabot",
          "source": "src/Lambdabot-Config.html#MonadConfig",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "MonadConfig",
          "package": "lambdabot",
          "partial": "Monad Config",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#t:MonadConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine a new configuration key with the specified name, type and \n default value\n\u003c/p\u003e\u003cp\u003eYou should probably also provide an explicit export list for any\n module that defines config keys, because the definition introduces\n a few extra types that will clutter up the export list otherwise.\n\u003c/p\u003e",
          "module": "Lambdabot.Config",
          "name": "config",
          "package": "lambdabot",
          "signature": "String -\u003e TypeQ -\u003e ExpQ -\u003e Q [Dec]",
          "source": "src/Lambdabot-Config.html#config",
          "type": "function"
        },
        "index": {
          "description": "Define new configuration key with the specified name type and default value You should probably also provide an explicit export list for any module that defines config keys because the definition introduces few extra types that will clutter up the export list otherwise",
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "config",
          "normalized": "String-\u003eTypeQ-\u003eExpQ-\u003eQ[Dec]",
          "package": "lambdabot",
          "signature": "String-\u003eTypeQ-\u003eExpQ-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#v:config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003econfig\u003c/a\u003e\u003c/code\u003e, but also allowing you to specify a \"merge rule\"\n that will be used to combine multiple bindings of the same key.\n\u003c/p\u003e\u003cp\u003eFor example, in \u003ca\u003eLambdabot.Config.Core\u003c/a\u003e, \u003ccode\u003eonStartupCmds\u003c/code\u003e is\n defined as a list of commands to execute on startup.  Its default\n value is [\u003ca\u003eofflinerc\u003c/a\u003e], so if a user invokes the default lambdabot\n executable without arguments, they will get a REPL.  Each instance\n of \u003ca\u003e-e\u003c/a\u003e on the command-line adds a binding of the form:\n\u003c/p\u003e\u003cpre\u003e onStartupCmds :=\u003e [command]\n\u003c/pre\u003e\u003cp\u003eSo if they give one \u003ca\u003e-e\u003c/a\u003e, it replaces the default (note that it\n is _not_ merged with the default - the default is discarded), and\n if they give more than one they are merged using the specified\n operation (in this case, `(++)`).\n\u003c/p\u003e",
          "module": "Lambdabot.Config",
          "name": "configWithMerge",
          "package": "lambdabot",
          "signature": "ExpQ -\u003e String -\u003e TypeQ -\u003e ExpQ -\u003e Q [Dec]",
          "source": "src/Lambdabot-Config.html#configWithMerge",
          "type": "function"
        },
        "index": {
          "description": "Like config but also allowing you to specify merge rule that will be used to combine multiple bindings of the same key For example in Lambdabot.Config.Core onStartupCmds is defined as list of commands to execute on startup Its default value is offlinerc so if user invokes the default lambdabot executable without arguments they will get REPL Each instance of on the command-line adds binding of the form onStartupCmds command So if they give one it replaces the default note that it is not merged with the default the default is discarded and if they give more than one they are merged using the specified operation in this case",
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "configWithMerge",
          "normalized": "ExpQ-\u003eString-\u003eTypeQ-\u003eExpQ-\u003eQ[Dec]",
          "package": "lambdabot",
          "partial": "With Merge",
          "signature": "ExpQ-\u003eString-\u003eTypeQ-\u003eExpQ-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#v:configWithMerge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config",
          "name": "getConfig",
          "package": "lambdabot",
          "signature": "Config a -\u003e m a",
          "source": "src/Lambdabot-Config.html#getConfig",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "getConfig",
          "normalized": "Config a-\u003eb a",
          "package": "lambdabot",
          "partial": "Config",
          "signature": "Config a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#v:getConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config",
          "name": "getConfigDefault",
          "package": "lambdabot",
          "signature": "Config t -\u003e t",
          "source": "src/Lambdabot-Config.html#getConfigDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "getConfigDefault",
          "normalized": "Config a-\u003ea",
          "package": "lambdabot",
          "partial": "Config Default",
          "signature": "Config t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#v:getConfigDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Config",
          "name": "mergeConfig",
          "package": "lambdabot",
          "signature": "Config t -\u003e t -\u003e t -\u003e t",
          "source": "src/Lambdabot-Config.html#mergeConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Config",
          "module": "Lambdabot.Config",
          "name": "mergeConfig",
          "normalized": "Config a-\u003ea-\u003ea-\u003ea",
          "package": "lambdabot",
          "partial": "Config",
          "signature": "Config t-\u003et-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Config.html#v:mergeConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.File",
          "name": "File",
          "package": "lambdabot",
          "source": "src/Lambdabot-File.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot File",
          "module": "Lambdabot.File",
          "name": "File",
          "package": "lambdabot",
          "partial": "File",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-File.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to find a pre-existing file, searching first in ./State and then in \n ~\u003cem\u003e.lambdabot\u003c/em\u003eState\n\u003c/p\u003e",
          "module": "Lambdabot.File",
          "name": "findLBFile",
          "package": "lambdabot",
          "signature": "FilePath -\u003e LB (Maybe String)",
          "source": "src/Lambdabot-File.html#findLBFile",
          "type": "function"
        },
        "index": {
          "description": "Try to find pre-existing file searching first in State and then in lambdabot State",
          "hierarchy": "Lambdabot File",
          "module": "Lambdabot.File",
          "name": "findLBFile",
          "normalized": "FilePath-\u003eLB(Maybe String)",
          "package": "lambdabot",
          "partial": "LBFile",
          "signature": "FilePath-\u003eLB(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-File.html#v:findLBFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplicated. If a file exists locally, we return that. If a file exists in\n ~\u003cem\u003elambdabot\u003c/em\u003eState, we return that. If neither the file nor ~\u003cem\u003elambdabot\u003c/em\u003eState\n exist, we create the directories and then copy the file into it if a template\n exists, or create an empty file if it does not.\n Note that the return type is simple so we can just do a binding and stuff it\n into the conventional functions easily; unfortunately, this removes\n error-checking, as an error is now just \"\".\n\u003c/p\u003e",
          "module": "Lambdabot.File",
          "name": "findOrCreateLBFile",
          "package": "lambdabot",
          "signature": "FilePath -\u003e LB String",
          "source": "src/Lambdabot-File.html#findOrCreateLBFile",
          "type": "function"
        },
        "index": {
          "description": "Complicated If file exists locally we return that If file exists in lambdabot State we return that If neither the file nor lambdabot State exist we create the directories and then copy the file into it if template exists or create an empty file if it does not Note that the return type is simple so we can just do binding and stuff it into the conventional functions easily unfortunately this removes error-checking as an error is now just",
          "hierarchy": "Lambdabot File",
          "module": "Lambdabot.File",
          "name": "findOrCreateLBFile",
          "normalized": "FilePath-\u003eLB String",
          "package": "lambdabot",
          "partial": "Or Create LBFile",
          "signature": "FilePath-\u003eLB String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-File.html#v:findOrCreateLBFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe IRC module processes the IRC protocol and provides a nice API for sending\n   and recieving IRC messages with an IRC server.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.IRC",
          "name": "IRC",
          "package": "lambdabot",
          "source": "src/Lambdabot-IRC.html",
          "type": "module"
        },
        "index": {
          "description": "The IRC module processes the IRC protocol and provides nice API for sending and recieving IRC messages with an IRC server",
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "IRC",
          "package": "lambdabot",
          "partial": "IRC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn IRC message is a server, a prefix, a command and a list of parameters.\n\u003c/p\u003e",
          "module": "Lambdabot.IRC",
          "name": "IrcMessage",
          "package": "lambdabot",
          "source": "src/Lambdabot-IRC.html#IrcMessage",
          "type": "data"
        },
        "index": {
          "description": "An IRC message is server prefix command and list of parameters",
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "IrcMessage",
          "package": "lambdabot",
          "partial": "Irc Message",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#t:IrcMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "IrcMessage",
          "package": "lambdabot",
          "signature": "IrcMessage",
          "source": "src/Lambdabot-IRC.html#IrcMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "IrcMessage",
          "package": "lambdabot",
          "partial": "Irc Message",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:IrcMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "errShowMsg",
          "package": "lambdabot",
          "signature": "IrcMessage -\u003e String",
          "source": "src/Lambdabot-IRC.html#errShowMsg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "errShowMsg",
          "normalized": "IrcMessage-\u003eString",
          "package": "lambdabot",
          "partial": "Show Msg",
          "signature": "IrcMessage-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:errShowMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "getTopic",
          "package": "lambdabot",
          "signature": "Nick -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#getTopic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "getTopic",
          "normalized": "Nick-\u003eIrcMessage",
          "package": "lambdabot",
          "partial": "Topic",
          "signature": "Nick-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:getTopic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "ircMsgCommand",
          "package": "lambdabot",
          "signature": "String",
          "source": "src/Lambdabot-IRC.html#IrcMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "ircMsgCommand",
          "package": "lambdabot",
          "partial": "Msg Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:ircMsgCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "ircMsgLBName",
          "package": "lambdabot",
          "signature": "String",
          "source": "src/Lambdabot-IRC.html#IrcMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "ircMsgLBName",
          "package": "lambdabot",
          "partial": "Msg LBName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:ircMsgLBName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "ircMsgParams",
          "package": "lambdabot",
          "signature": "[String]",
          "source": "src/Lambdabot-IRC.html#IrcMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "ircMsgParams",
          "normalized": "[String]",
          "package": "lambdabot",
          "partial": "Msg Params",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:ircMsgParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "ircMsgPrefix",
          "package": "lambdabot",
          "signature": "String",
          "source": "src/Lambdabot-IRC.html#IrcMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "ircMsgPrefix",
          "package": "lambdabot",
          "partial": "Msg Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:ircMsgPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "ircMsgServer",
          "package": "lambdabot",
          "signature": "String",
          "source": "src/Lambdabot-IRC.html#IrcMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "ircMsgServer",
          "package": "lambdabot",
          "partial": "Msg Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:ircMsgServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "joinChannel",
          "package": "lambdabot",
          "signature": "Nick -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#joinChannel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "joinChannel",
          "normalized": "Nick-\u003eIrcMessage",
          "package": "lambdabot",
          "partial": "Channel",
          "signature": "Nick-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:joinChannel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "partChannel",
          "package": "lambdabot",
          "signature": "Nick -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#partChannel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "partChannel",
          "normalized": "Nick-\u003eIrcMessage",
          "package": "lambdabot",
          "partial": "Channel",
          "signature": "Nick-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:partChannel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eprivmsg\u003c/a\u003e\u003c/code\u003e creates a private message to the person designated.\n\u003c/p\u003e",
          "module": "Lambdabot.IRC",
          "name": "privmsg",
          "package": "lambdabot",
          "signature": "Nick-\u003e String-\u003e IrcMessage",
          "type": "function"
        },
        "index": {
          "description": "privmsg creates private message to the person designated",
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "privmsg",
          "normalized": "Nick-\u003eString-\u003eIrcMessage",
          "package": "lambdabot",
          "signature": "Nick-\u003eString-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:privmsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003equit\u003c/a\u003e\u003c/code\u003e creates a server QUIT message. The input string given is the\n   quit message, given to other parties when leaving the network.\n\u003c/p\u003e",
          "module": "Lambdabot.IRC",
          "name": "quit",
          "package": "lambdabot",
          "signature": "String -\u003e String -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#quit",
          "type": "function"
        },
        "index": {
          "description": "quit creates server QUIT message The input string given is the quit message given to other parties when leaving the network",
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "quit",
          "normalized": "String-\u003eString-\u003eIrcMessage",
          "package": "lambdabot",
          "signature": "String-\u003eString-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:quit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "setNick",
          "package": "lambdabot",
          "signature": "Nick -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#setNick",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "setNick",
          "normalized": "Nick-\u003eIrcMessage",
          "package": "lambdabot",
          "partial": "Nick",
          "signature": "Nick-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:setNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "setTopic",
          "package": "lambdabot",
          "signature": "Nick -\u003e String -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#setTopic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "setTopic",
          "normalized": "Nick-\u003eString-\u003eIrcMessage",
          "package": "lambdabot",
          "partial": "Topic",
          "signature": "Nick-\u003eString-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:setTopic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "timeReply",
          "package": "lambdabot",
          "signature": "IrcMessage -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#timeReply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "timeReply",
          "normalized": "IrcMessage-\u003eIrcMessage",
          "package": "lambdabot",
          "partial": "Reply",
          "signature": "IrcMessage-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:timeReply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.IRC",
          "name": "user",
          "package": "lambdabot",
          "signature": "String -\u003e String -\u003e String -\u003e String -\u003e IrcMessage",
          "source": "src/Lambdabot-IRC.html#user",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot IRC",
          "module": "Lambdabot.IRC",
          "name": "user",
          "normalized": "String-\u003eString-\u003eString-\u003eString-\u003eIrcMessage",
          "package": "lambdabot",
          "signature": "String-\u003eString-\u003eString-\u003eString-\u003eIrcMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-IRC.html#v:user"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "Logging",
          "package": "lambdabot",
          "source": "src/Lambdabot-Logging.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "Logging",
          "package": "lambdabot",
          "partial": "Logging",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "MonadLogging",
          "package": "lambdabot",
          "source": "src/Lambdabot-Logging.html#MonadLogging",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "MonadLogging",
          "package": "lambdabot",
          "partial": "Monad Logging",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#t:MonadLogging"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePriorities are used to define how important a log message is.\nUsers can filter log messages based on priorities.\n\u003c/p\u003e\u003cp\u003eThese have their roots on the traditional syslog system.  The standard\ndefinitions are given below, but you are free to interpret them however you\nlike.  They are listed here in ascending importance order.\n\u003c/p\u003e",
          "module": "Lambdabot.Logging",
          "name": "Priority",
          "package": "lambdabot",
          "type": "data"
        },
        "index": {
          "description": "Priorities are used to define how important log message is Users can filter log messages based on priorities These have their roots on the traditional syslog system The standard definitions are given below but you are free to interpret them however you like They are listed here in ascending importance order",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "Priority",
          "package": "lambdabot",
          "partial": "Priority",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#t:Priority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake immediate action\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "ALERT",
          "package": "lambdabot",
          "signature": "ALERT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:ALERT\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:ALERT\"]"
        },
        "index": {
          "description": "Take immediate action",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "ALERT",
          "package": "lambdabot",
          "partial": "ALERT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:ALERT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSevere situations\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "CRITICAL",
          "package": "lambdabot",
          "signature": "CRITICAL",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:CRITICAL\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:CRITICAL\"]"
        },
        "index": {
          "description": "Severe situations",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "CRITICAL",
          "package": "lambdabot",
          "partial": "CRITICAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:CRITICAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebug messages\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "DEBUG",
          "package": "lambdabot",
          "signature": "DEBUG",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:DEBUG\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:DEBUG\"]"
        },
        "index": {
          "description": "Debug messages",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "DEBUG",
          "package": "lambdabot",
          "partial": "DEBUG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:DEBUG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSystem is unusable\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "EMERGENCY",
          "package": "lambdabot",
          "signature": "EMERGENCY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:EMERGENCY\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:EMERGENCY\"]"
        },
        "index": {
          "description": "System is unusable",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "EMERGENCY",
          "package": "lambdabot",
          "partial": "EMERGENCY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:EMERGENCY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral Errors\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "ERROR",
          "package": "lambdabot",
          "signature": "ERROR",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:ERROR\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:ERROR\"]"
        },
        "index": {
          "description": "General Errors",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "ERROR",
          "package": "lambdabot",
          "partial": "ERROR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:ERROR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInformation\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "INFO",
          "package": "lambdabot",
          "signature": "INFO",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:INFO\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:INFO\"]"
        },
        "index": {
          "description": "Information",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "INFO",
          "package": "lambdabot",
          "partial": "INFO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:INFO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal runtime conditions\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "NOTICE",
          "package": "lambdabot",
          "signature": "NOTICE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:NOTICE\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:NOTICE\"]"
        },
        "index": {
          "description": "Normal runtime conditions",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "NOTICE",
          "package": "lambdabot",
          "partial": "NOTICE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:NOTICE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral Warnings\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Logging\",\"Lambdabot.Main\"]",
          "name": "WARNING",
          "package": "lambdabot",
          "signature": "WARNING",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:WARNING\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:WARNING\"]"
        },
        "index": {
          "description": "General Warnings",
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "WARNING",
          "package": "lambdabot",
          "partial": "WARNING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:WARNING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "alertM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#alertM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "alertM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:alertM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "criticalM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#criticalM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "criticalM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:criticalM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "debugM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#debugM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "debugM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:debugM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "emergencyM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#emergencyM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "emergencyM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:emergencyM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "errorM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#errorM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "errorM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:errorM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "getCurrentLogger",
          "package": "lambdabot",
          "signature": "m [String]",
          "source": "src/Lambdabot-Logging.html#getCurrentLogger",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "getCurrentLogger",
          "normalized": "a[String]",
          "package": "lambdabot",
          "partial": "Current Logger",
          "signature": "m[String]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:getCurrentLogger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "infoM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#infoM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "infoM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:infoM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "logM",
          "package": "lambdabot",
          "signature": "String -\u003e Priority -\u003e String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#logM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "logM",
          "normalized": "String-\u003ePriority-\u003eString-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003ePriority-\u003eString-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:logM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "noticeM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#noticeM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "noticeM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:noticeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Logging",
          "name": "warningM",
          "package": "lambdabot",
          "signature": "String -\u003e m ()",
          "source": "src/Lambdabot-Logging.html#warningM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Logging",
          "module": "Lambdabot.Logging",
          "name": "warningM",
          "normalized": "String-\u003ea()",
          "package": "lambdabot",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Logging.html#v:warningM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Main",
          "name": "Main",
          "package": "lambdabot",
          "source": "src/Lambdabot-Main.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "Main",
          "package": "lambdabot",
          "partial": "Main",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Main",
          "name": "Config",
          "package": "lambdabot",
          "source": "src/Lambdabot-Config.html#Config",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "Config",
          "package": "lambdabot",
          "partial": "Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#t:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA basic dependent sum type; the first component is a tag that specifies \n the type of the second;  for example, think of a GADT such as:\n\u003c/p\u003e\u003cpre\u003e data Tag a where\n    AString :: Tag String\n    AnInt   :: Tag Int\n\u003c/pre\u003e\u003cp\u003eThen, we have the following valid expressions of type \u003ccode\u003eDSum Tag\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e AString :=\u003e \"hello!\"\n AnInt   :=\u003e 42\n\u003c/pre\u003e\u003cp\u003eAnd we can write functions that consume \u003ccode\u003eDSum Tag\u003c/code\u003e values by matching, \n such as:\n\u003c/p\u003e\u003cpre\u003e toString :: DSum Tag -\u003e String\n toString (AString :=\u003e str) = str\n toString (AnInt   :=\u003e int) = show int\n\u003c/pre\u003e\u003cp\u003eBy analogy to the (key =\u003e value) construction for dictionary entries in \n many dynamic languages, we use (key :=\u003e value) as the constructor for \n dependent sums.  The :=\u003e operator has very low precedence and binds to \n the right, so if the \u003ccode\u003eTag\u003c/code\u003e GADT is extended with an additional constructor\n \u003ccode\u003eRec :: Tag (DSum Tag)\u003c/code\u003e, then \u003ccode\u003eRec :=\u003e AnInt :=\u003e 3 + 4\u003c/code\u003e is parsed as\n would be expected (\u003ccode\u003eRec :=\u003e (AnInt :=\u003e (3 + 4))\u003c/code\u003e) and has type \u003ccode\u003eDSum Tag\u003c/code\u003e.\n Its precedence is just above that of \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e, so \u003ccode\u003efoo bar $ AString :=\u003e \u003ca\u003eeep\u003c/a\u003e\u003c/code\u003e\n is equivalent to \u003ccode\u003efoo bar (AString :=\u003e \u003ca\u003eeep\u003c/a\u003e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Lambdabot.Main",
          "name": "DSum",
          "package": "lambdabot",
          "type": "data"
        },
        "index": {
          "description": "basic dependent sum type the first component is tag that specifies the type of the second for example think of GADT such as data Tag where AString Tag String AnInt Tag Int Then we have the following valid expressions of type DSum Tag AString hello AnInt And we can write functions that consume DSum Tag values by matching such as toString DSum Tag String toString AString str str toString AnInt int show int By analogy to the key value construction for dictionary entries in many dynamic languages we use key value as the constructor for dependent sums The operator has very low precedence and binds to the right so if the Tag GADT is extended with an additional constructor Rec Tag DSum Tag then Rec AnInt is parsed as would be expected Rec AnInt and has type DSum Tag Its precedence is just above that of so foo bar AString eep is equivalent to foo bar AString eep",
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "DSum",
          "package": "lambdabot",
          "partial": "DSum",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#t:DSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Main",
          "name": "Modules",
          "package": "lambdabot",
          "source": "src/Lambdabot-Main.html#Modules",
          "type": "type"
        },
        "index": {
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "Modules",
          "package": "lambdabot",
          "partial": "Modules",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#t:Modules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePriorities are used to define how important a log message is.\nUsers can filter log messages based on priorities.\n\u003c/p\u003e\u003cp\u003eThese have their roots on the traditional syslog system.  The standard\ndefinitions are given below, but you are free to interpret them however you\nlike.  They are listed here in ascending importance order.\n\u003c/p\u003e",
          "module": "Lambdabot.Main",
          "name": "Priority",
          "package": "lambdabot",
          "type": "data"
        },
        "index": {
          "description": "Priorities are used to define how important log message is Users can filter log messages based on priorities These have their roots on the traditional syslog system The standard definitions are given below but you are free to interpret them however you like They are listed here in ascending importance order",
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "Priority",
          "package": "lambdabot",
          "partial": "Priority",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#t:Priority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Main",
          "name": ":=\u003e",
          "package": "lambdabot",
          "signature": "(tag a) -\u003e a -\u003e DSum tag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": ":=\u003e",
          "normalized": "(a b)-\u003eb-\u003eDSum a",
          "package": "lambdabot",
          "signature": "(tag a)-\u003ea-\u003eDSum tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v::-61--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Lambdabot entry point.\n Initialise plugins, connect, and run the bot in the LB monad\n\u003c/p\u003e\u003cp\u003eAlso, handle any fatal exceptions (such as non-recoverable signals),\n (i.e. print a message and exit). Non-fatal exceptions should be dealt\n with in the mainLoop or further down.\n\u003c/p\u003e",
          "module": "Lambdabot.Main",
          "name": "lambdabotMain",
          "package": "lambdabot",
          "signature": "LB () -\u003e [DSum Config] -\u003e IO ExitCode",
          "source": "src/Lambdabot-Main.html#lambdabotMain",
          "type": "function"
        },
        "index": {
          "description": "The Lambdabot entry point Initialise plugins connect and run the bot in the LB monad Also handle any fatal exceptions such as non-recoverable signals i.e print message and exit Non-fatal exceptions should be dealt with in the mainLoop or further down",
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "lambdabotMain",
          "normalized": "LB()-\u003e[DSum Config]-\u003eIO ExitCode",
          "package": "lambdabot",
          "partial": "Main",
          "signature": "LB()-\u003e[DSum Config]-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:lambdabotMain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Main",
          "name": "lambdabotVersion",
          "package": "lambdabot",
          "signature": "Version",
          "source": "src/Lambdabot-Main.html#lambdabotVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "lambdabotVersion",
          "package": "lambdabot",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:lambdabotVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Main",
          "name": "modules",
          "package": "lambdabot",
          "signature": "[String] -\u003e Q Exp",
          "source": "src/Lambdabot-Main.html#modules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Main",
          "module": "Lambdabot.Main",
          "name": "modules",
          "normalized": "[String]-\u003eQ Exp",
          "package": "lambdabot",
          "signature": "[String]-\u003eQ Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Main.html#v:modules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Message",
          "name": "Message",
          "package": "lambdabot",
          "source": "src/Lambdabot-Message.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Message",
          "module": "Lambdabot.Message",
          "name": "Message",
          "package": "lambdabot",
          "partial": "Message",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Message.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Message",
          "name": "Message",
          "package": "lambdabot",
          "source": "src/Lambdabot-Message.html#Message",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambdabot Message",
          "module": "Lambdabot.Message",
          "name": "Message",
          "package": "lambdabot",
          "partial": "Message",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Message.html#t:Message"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003echannels\u003c/a\u003e\u003c/code\u003e extracts the channels a Message operate on.\n\u003c/p\u003e",
          "module": "Lambdabot.Message",
          "name": "channels",
          "package": "lambdabot",
          "signature": "a -\u003e [Nick]",
          "source": "src/Lambdabot-Message.html#channels",
          "type": "method"
        },
        "index": {
          "description": "channels extracts the channels Message operate on",
          "hierarchy": "Lambdabot Message",
          "module": "Lambdabot.Message",
          "name": "channels",
          "normalized": "a-\u003e[Nick]",
          "package": "lambdabot",
          "signature": "a-\u003e[Nick]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Message.html#v:channels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efullName\u003c/a\u003e\u003c/code\u003e extracts the full user name involved in a given message.\n\u003c/p\u003e",
          "module": "Lambdabot.Message",
          "name": "fullName",
          "package": "lambdabot",
          "signature": "a -\u003e String",
          "source": "src/Lambdabot-Message.html#fullName",
          "type": "method"
        },
        "index": {
          "description": "fullName extracts the full user name involved in given message",
          "hierarchy": "Lambdabot Message",
          "module": "Lambdabot.Message",
          "name": "fullName",
          "normalized": "a-\u003eString",
          "package": "lambdabot",
          "partial": "Name",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Message.html#v:fullName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Message",
          "name": "lambdabotName",
          "package": "lambdabot",
          "signature": "a -\u003e Nick",
          "source": "src/Lambdabot-Message.html#lambdabotName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Message",
          "module": "Lambdabot.Message",
          "name": "lambdabotName",
          "normalized": "a-\u003eNick",
          "package": "lambdabot",
          "partial": "Name",
          "signature": "a-\u003eNick",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Message.html#v:lambdabotName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextracts the nickname involved in a given message.\n\u003c/p\u003e",
          "module": "Lambdabot.Message",
          "name": "nick",
          "package": "lambdabot",
          "signature": "a -\u003e Nick",
          "source": "src/Lambdabot-Message.html#nick",
          "type": "method"
        },
        "index": {
          "description": "extracts the nickname involved in given message",
          "hierarchy": "Lambdabot Message",
          "module": "Lambdabot.Message",
          "name": "nick",
          "normalized": "a-\u003eNick",
          "package": "lambdabot",
          "signature": "a-\u003eNick",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Message.html#v:nick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextracts the tag of the server involved in a given message\n\u003c/p\u003e",
          "module": "Lambdabot.Message",
          "name": "server",
          "package": "lambdabot",
          "signature": "a -\u003e String",
          "source": "src/Lambdabot-Message.html#server",
          "type": "method"
        },
        "index": {
          "description": "extracts the tag of the server involved in given message",
          "hierarchy": "Lambdabot Message",
          "module": "Lambdabot.Message",
          "name": "server",
          "normalized": "a-\u003eString",
          "package": "lambdabot",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Message.html#v:server"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Module",
          "name": "Module",
          "package": "lambdabot",
          "source": "src/Lambdabot-Module.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "Module",
          "package": "lambdabot",
          "partial": "Module",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Module type class.\n\u003c/p\u003e",
          "module": "Lambdabot.Module",
          "name": "Module",
          "package": "lambdabot",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "data"
        },
        "index": {
          "description": "The Module type class",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "Module",
          "package": "lambdabot",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis transformer encodes the additional information a module might\n   need to access its name or its state.\n\u003c/p\u003e",
          "module": "Lambdabot.Module",
          "name": "ModuleT",
          "package": "lambdabot",
          "source": "src/Lambdabot-Module.html#ModuleT",
          "type": "newtype"
        },
        "index": {
          "description": "This transformer encodes the additional information module might need to access its name or its state",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "ModuleT",
          "package": "lambdabot",
          "partial": "Module",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#t:ModuleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "Module",
          "package": "lambdabot",
          "signature": "Module",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:Module\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:Module\"]"
        },
        "index": {
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "Module",
          "package": "lambdabot",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Module",
          "name": "ModuleT",
          "package": "lambdabot",
          "signature": "ModuleT",
          "source": "src/Lambdabot-Module.html#ModuleT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "ModuleT",
          "package": "lambdabot",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:ModuleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebind an action to the current module so it can be run from the plain\n   \u003ccode\u003e\u003ca\u003eLB\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "bindModule0",
          "package": "lambdabot",
          "signature": "ModuleT mod LB a -\u003e ModuleT mod LB (LB a)",
          "source": "src/Lambdabot-Module.html#bindModule0",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:bindModule0\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:bindModule0\"]"
        },
        "index": {
          "description": "bind an action to the current module so it can be run from the plain LB monad",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "bindModule0",
          "normalized": "ModuleT a LB b-\u003eModuleT a LB(LB b)",
          "package": "lambdabot",
          "partial": "Module",
          "signature": "ModuleT mod LB a-\u003eModuleT mod LB(LB a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:bindModule0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariant of \u003ccode\u003e\u003ca\u003ebindModule0\u003c/a\u003e\u003c/code\u003e for monad actions with one argument\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "bindModule1",
          "package": "lambdabot",
          "signature": "(a -\u003e ModuleT mod LB b) -\u003e ModuleT mod LB (a -\u003e LB b)",
          "source": "src/Lambdabot-Module.html#bindModule1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:bindModule1\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:bindModule1\"]"
        },
        "index": {
          "description": "variant of bindModule0 for monad actions with one argument",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "bindModule1",
          "normalized": "(a-\u003eModuleT b LB c)-\u003eModuleT b LB(a-\u003eLB c)",
          "package": "lambdabot",
          "partial": "Module",
          "signature": "(a-\u003eModuleT mod LB b)-\u003eModuleT mod LB(a-\u003eLB b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:bindModule1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariant of \u003ccode\u003e\u003ca\u003ebindModule0\u003c/a\u003e\u003c/code\u003e for monad actions with two arguments\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "bindModule2",
          "package": "lambdabot",
          "signature": "(a -\u003e b -\u003e ModuleT mod LB c) -\u003e ModuleT mod LB (a -\u003e b -\u003e LB c)",
          "source": "src/Lambdabot-Module.html#bindModule2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:bindModule2\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:bindModule2\"]"
        },
        "index": {
          "description": "variant of bindModule0 for monad actions with two arguments",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "bindModule2",
          "normalized": "(a-\u003eb-\u003eModuleT c LB d)-\u003eModuleT c LB(a-\u003eb-\u003eLB d)",
          "package": "lambdabot",
          "partial": "Module",
          "signature": "(a-\u003eb-\u003eModuleT mod LB c)-\u003eModuleT mod LB(a-\u003eb-\u003eLB c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:bindModule2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcess contextual input. A plugin that implements \u003ccode\u003e\u003ca\u003econtextual\u003c/a\u003e\u003c/code\u003e\n is able to respond to text not part of a normal command.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "contextual",
          "package": "lambdabot",
          "signature": "(String -\u003e Cmd (ModuleT st LB) ())",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:contextual\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:contextual\"]"
        },
        "index": {
          "description": "Process contextual input plugin that implements contextual is able to respond to text not part of normal command",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "contextual",
          "normalized": "(String-\u003eCmd(ModuleT a LB)())",
          "package": "lambdabot",
          "signature": "(String-\u003eCmd(ModuleT st LB)())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:contextual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "getModuleName",
          "package": "lambdabot",
          "signature": "ModuleT mod m String",
          "source": "src/Lambdabot-Module.html#getModuleName",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:getModuleName\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:getModuleName\"]"
        },
        "index": {
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "getModuleName",
          "package": "lambdabot",
          "partial": "Module Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:getModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Module",
          "name": "getRef",
          "package": "lambdabot",
          "signature": "ModuleT st m (MVar st)",
          "source": "src/Lambdabot-Module.html#getRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "getRef",
          "package": "lambdabot",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:getRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe commands the module listenes to.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "moduleCmds",
          "package": "lambdabot",
          "signature": "(ModuleT st LB [Command (ModuleT st LB)])",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleCmds\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:moduleCmds\"]"
        },
        "index": {
          "description": "The commands the module listenes to",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "moduleCmds",
          "normalized": "(ModuleT a LB[Command(ModuleT a LB)])",
          "package": "lambdabot",
          "partial": "Cmds",
          "signature": "(ModuleT st LB[Command(ModuleT st LB)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleCmds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the module maintains state, this method specifies the default state\n   (for example in case the state can't be read from a state).\n\u003c/p\u003e\u003cp\u003eThe default implementation returns an error and assumes the state is\n   never accessed.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "moduleDefState",
          "package": "lambdabot",
          "signature": "(LB st)",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleDefState\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:moduleDefState\"]"
        },
        "index": {
          "description": "If the module maintains state this method specifies the default state for example in case the state can be read from state The default implementation returns an error and assumes the state is never accessed",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "moduleDefState",
          "package": "lambdabot",
          "partial": "Def State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleDefState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinalize the module. The default implementation does nothing.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "moduleExit",
          "package": "lambdabot",
          "signature": "(ModuleT st LB ())",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleExit\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:moduleExit\"]"
        },
        "index": {
          "description": "Finalize the module The default implementation does nothing",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "moduleExit",
          "normalized": "(ModuleT a LB())",
          "package": "lambdabot",
          "partial": "Exit",
          "signature": "(ModuleT st LB())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleExit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialize the module. The default implementation does nothing.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "moduleInit",
          "package": "lambdabot",
          "signature": "(ModuleT st LB ())",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleInit\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:moduleInit\"]"
        },
        "index": {
          "description": "Initialize the module The default implementation does nothing",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "moduleInit",
          "normalized": "(ModuleT a LB())",
          "package": "lambdabot",
          "partial": "Init",
          "signature": "(ModuleT st LB())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the module wants its state to be saved, this function should\n   return a Serial.\n\u003c/p\u003e\u003cp\u003eThe default implementation returns Nothing.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "moduleSerialize",
          "package": "lambdabot",
          "signature": "(Maybe (Serial st))",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleSerialize\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:moduleSerialize\"]"
        },
        "index": {
          "description": "If the module wants its state to be saved this function should return Serial The default implementation returns Nothing",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "moduleSerialize",
          "package": "lambdabot",
          "partial": "Serialize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleSerialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the module sticky? Sticky modules (as well as static ones) can't be\n   unloaded. By default, modules are not sticky.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "moduleSticky",
          "package": "lambdabot",
          "signature": "Bool",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleSticky\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:moduleSticky\"]"
        },
        "index": {
          "description": "Is the module sticky Sticky modules as well as static ones can be unloaded By default modules are not sticky",
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "moduleSticky",
          "package": "lambdabot",
          "partial": "Sticky",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:moduleSticky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambdabot.Module\",\"Lambdabot.Plugin\"]",
          "name": "newModule",
          "package": "lambdabot",
          "signature": "Module st",
          "source": "src/Lambdabot-Module.html#newModule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:newModule\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:newModule\"]"
        },
        "index": {
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "newModule",
          "package": "lambdabot",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:newModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Module",
          "name": "runModuleT",
          "package": "lambdabot",
          "signature": "ReaderT (MVar st, String) m a",
          "source": "src/Lambdabot-Module.html#ModuleT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Module",
          "module": "Lambdabot.Module",
          "name": "runModuleT",
          "normalized": "ReaderT(MVar a,String)b c",
          "package": "lambdabot",
          "partial": "Module",
          "signature": "ReaderT(MVar st,String)m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Module.html#v:runModuleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "Monad",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "Monad",
          "package": "lambdabot",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "Callback",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#Callback",
          "type": "type"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "Callback",
          "package": "lambdabot",
          "partial": "Callback",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#t:Callback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "CommandRef",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#CommandRef",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "CommandRef",
          "package": "lambdabot",
          "partial": "Command Ref",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#t:CommandRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlobal read-only state.\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "IRCRState",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#IRCRState",
          "type": "data"
        },
        "index": {
          "description": "Global read-only state",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "IRCRState",
          "package": "lambdabot",
          "partial": "IRCRState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#t:IRCRState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlobal read/write state.\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "IRCRWState",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "data"
        },
        "index": {
          "description": "Global read write state",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "IRCRWState",
          "package": "lambdabot",
          "partial": "IRCRWState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#t:IRCRWState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe IRC Monad. The reader transformer holds information about the\n   connection to the IRC server.\n\u003c/p\u003e\u003cp\u003einstances Monad, Functor, MonadIO, MonadState, MonadError\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "LB",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#LB",
          "type": "newtype"
        },
        "index": {
          "description": "The IRC Monad The reader transformer holds information about the connection to the IRC server instances Monad Functor MonadIO MonadState MonadError",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "LB",
          "package": "lambdabot",
          "partial": "LB",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#t:LB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ModuleRef",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#ModuleRef",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ModuleRef",
          "package": "lambdabot",
          "partial": "Module Ref",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#t:ModuleRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "MonadLB",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#MonadLB",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "MonadLB",
          "package": "lambdabot",
          "partial": "Monad LB",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#t:MonadLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "CommandRef",
          "package": "lambdabot",
          "signature": "forall st . CommandRef (Module st) (MVar st) String (Command (ModuleT st LB))",
          "source": "src/Lambdabot-Monad.html#CommandRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "CommandRef",
          "package": "lambdabot",
          "partial": "Command Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:CommandRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "IRCRWState",
          "package": "lambdabot",
          "signature": "IRCRWState",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "IRCRWState",
          "package": "lambdabot",
          "partial": "IRCRWState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:IRCRWState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "LB",
          "package": "lambdabot",
          "signature": "LB",
          "source": "src/Lambdabot-Monad.html#LB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "LB",
          "package": "lambdabot",
          "partial": "LB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:LB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ModuleRef",
          "package": "lambdabot",
          "signature": "forall st . ModuleRef (Module st) (MVar st) String",
          "source": "src/Lambdabot-Monad.html#ModuleRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ModuleRef",
          "package": "lambdabot",
          "partial": "Module Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ModuleRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "addServer",
          "package": "lambdabot",
          "signature": "String -\u003e (IrcMessage -\u003e LB ()) -\u003e ModuleT mod LB ()",
          "source": "src/Lambdabot-Monad.html#addServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "addServer",
          "normalized": "String-\u003e(IrcMessage-\u003eLB())-\u003eModuleT a LB()",
          "package": "lambdabot",
          "partial": "Server",
          "signature": "String-\u003e(IrcMessage-\u003eLB())-\u003eModuleT mod LB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:addServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erun a computation in the LB monad\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "evalLB",
          "package": "lambdabot",
          "signature": "LB a -\u003e IRCRState -\u003e IRCRWState -\u003e IO a",
          "source": "src/Lambdabot-Monad.html#evalLB",
          "type": "function"
        },
        "index": {
          "description": "run computation in the LB monad",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "evalLB",
          "normalized": "LB a-\u003eIRCRState-\u003eIRCRWState-\u003eIO a",
          "package": "lambdabot",
          "partial": "LB",
          "signature": "LB a-\u003eIRCRState-\u003eIRCRWState-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:evalLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "getConfig",
          "package": "lambdabot",
          "signature": "Config a -\u003e m a",
          "source": "src/Lambdabot-Config.html#getConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "getConfig",
          "normalized": "Config a-\u003eb a",
          "package": "lambdabot",
          "partial": "Config",
          "signature": "Config a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:getConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault ro state\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "initRoState",
          "package": "lambdabot",
          "signature": "[DSum Config] -\u003e IO IRCRState",
          "source": "src/Lambdabot-Monad.html#initRoState",
          "type": "function"
        },
        "index": {
          "description": "Default ro state",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "initRoState",
          "normalized": "[DSum Config]-\u003eIO IRCRState",
          "package": "lambdabot",
          "partial": "Ro State",
          "signature": "[DSum Config]-\u003eIO IRCRState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:initRoState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault rw state\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "initRwState",
          "package": "lambdabot",
          "signature": "IRCRWState",
          "source": "src/Lambdabot-Monad.html#initRwState",
          "type": "function"
        },
        "index": {
          "description": "Default rw state",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "initRwState",
          "package": "lambdabot",
          "partial": "Rw State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:initRwState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ircCallbacks",
          "package": "lambdabot",
          "signature": "Map String [(String, Callback)]",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircCallbacks",
          "normalized": "Map String[(String,Callback)]",
          "package": "lambdabot",
          "partial": "Callbacks",
          "signature": "Map String[(String,Callback)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircCallbacks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaps channel names to topics\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "ircChannels",
          "package": "lambdabot",
          "signature": "Map ChanName String",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "description": "maps channel names to topics",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircChannels",
          "package": "lambdabot",
          "partial": "Channels",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircChannels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ircCommands",
          "package": "lambdabot",
          "signature": "Map String CommandRef",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircCommands",
          "package": "lambdabot",
          "partial": "Commands",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircCommands"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ircIgnoredUsers",
          "package": "lambdabot",
          "signature": "Set Nick",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircIgnoredUsers",
          "package": "lambdabot",
          "partial": "Ignored Users",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircIgnoredUsers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ircModules",
          "package": "lambdabot",
          "signature": "Map String ModuleRef",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircModules",
          "package": "lambdabot",
          "partial": "Modules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircModules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput filters, invoked from right to left\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "ircOutputFilters",
          "package": "lambdabot",
          "signature": "[(String, OutputFilter LB)]",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "description": "Output filters invoked from right to left",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircOutputFilters",
          "normalized": "[(String,OutputFilter LB)]",
          "package": "lambdabot",
          "partial": "Output Filters",
          "signature": "[(String,OutputFilter LB)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircOutputFilters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ircPrivilegedUsers",
          "package": "lambdabot",
          "signature": "Set Nick",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircPrivilegedUsers",
          "package": "lambdabot",
          "partial": "Privileged Users",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircPrivilegedUsers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ircServerMap",
          "package": "lambdabot",
          "signature": "Map String (String, IrcMessage -\u003e LB ())",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircServerMap",
          "normalized": "Map String(String,IrcMessage-\u003eLB())",
          "package": "lambdabot",
          "partial": "Server Map",
          "signature": "Map String(String,IrcMessage-\u003eLB())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircServerMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "ircStayConnected",
          "package": "lambdabot",
          "signature": "Bool",
          "source": "src/Lambdabot-Monad.html#IRCRWState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "ircStayConnected",
          "package": "lambdabot",
          "partial": "Stay Connected",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:ircStayConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "lb",
          "package": "lambdabot",
          "signature": "LB a -\u003e m a",
          "source": "src/Lambdabot-Monad.html#lb",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "lb",
          "normalized": "LB a-\u003eb a",
          "package": "lambdabot",
          "signature": "LB a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:lb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "received",
          "package": "lambdabot",
          "signature": "IrcMessage -\u003e LB ()",
          "source": "src/Lambdabot-Monad.html#received",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "received",
          "normalized": "IrcMessage-\u003eLB()",
          "package": "lambdabot",
          "signature": "IrcMessage-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:received"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "remServer",
          "package": "lambdabot",
          "signature": "String -\u003e LB ()",
          "source": "src/Lambdabot-Monad.html#remServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "remServer",
          "normalized": "String-\u003eLB()",
          "package": "lambdabot",
          "partial": "Server",
          "signature": "String-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:remServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "reportInitDone",
          "package": "lambdabot",
          "signature": "IRCRState -\u003e m ()",
          "source": "src/Lambdabot-Monad.html#reportInitDone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "reportInitDone",
          "normalized": "IRCRState-\u003ea()",
          "package": "lambdabot",
          "partial": "Init Done",
          "signature": "IRCRState-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:reportInitDone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "runLB",
          "package": "lambdabot",
          "signature": "ReaderT (IRCRState, IORef IRCRWState) IO a",
          "source": "src/Lambdabot-Monad.html#LB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "runLB",
          "normalized": "ReaderT(IRCRState,IORef IRCRWState)IO a",
          "package": "lambdabot",
          "partial": "LB",
          "signature": "ReaderT(IRCRState,IORef IRCRWState)IO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:runLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "send",
          "package": "lambdabot",
          "signature": "IrcMessage -\u003e LB ()",
          "source": "src/Lambdabot-Monad.html#send",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "send",
          "normalized": "IrcMessage-\u003eLB()",
          "package": "lambdabot",
          "signature": "IrcMessage-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:send"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "waitForInit",
          "package": "lambdabot",
          "signature": "m ()",
          "source": "src/Lambdabot-Monad.html#waitForInit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "waitForInit",
          "normalized": "a()",
          "package": "lambdabot",
          "partial": "For Init",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:waitForInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "waitForQuit",
          "package": "lambdabot",
          "signature": "m ()",
          "source": "src/Lambdabot-Monad.html#waitForQuit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "waitForQuit",
          "normalized": "a()",
          "package": "lambdabot",
          "partial": "For Quit",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:waitForQuit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpret a function in the context of all modules\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "withAllModules",
          "package": "lambdabot",
          "signature": "(forall st.  Module st -\u003e ModuleT st LB a) -\u003e LB ()",
          "source": "src/Lambdabot-Monad.html#withAllModules",
          "type": "function"
        },
        "index": {
          "description": "Interpret function in the context of all modules",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "withAllModules",
          "normalized": "(a b Module c-\u003eModuleT c LB d)-\u003eLB()",
          "package": "lambdabot",
          "partial": "All Modules",
          "signature": "(forall st. Module st-\u003eModuleT st LB a)-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:withAllModules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Monad",
          "name": "withCommand",
          "package": "lambdabot",
          "signature": "String -\u003e LB a -\u003e (forall st.  Module st -\u003e Command (ModuleT st LB) -\u003e ModuleT st LB a) -\u003e LB a",
          "source": "src/Lambdabot-Monad.html#withCommand",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "withCommand",
          "normalized": "String-\u003eLB a-\u003e(b c Module d-\u003eCommand(ModuleT d LB)-\u003eModuleT d LB a)-\u003eLB a",
          "package": "lambdabot",
          "partial": "Command",
          "signature": "String-\u003eLB a-\u003e(forall st. Module st-\u003eCommand(ModuleT st LB)-\u003eModuleT st LB a)-\u003eLB a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:withCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpret an expression in the context of a module.\n Arguments are which map to use (\u003ccode\u003eircModules\u003c/code\u003e and \u003ccode\u003eircCommands\u003c/code\u003e are\n the only sensible arguments here), the name of the module/command,\n action for the case that the lookup fails, action if the lookup\n succeeds.\n\u003c/p\u003e",
          "module": "Lambdabot.Monad",
          "name": "withModule",
          "package": "lambdabot",
          "signature": "String -\u003e LB a -\u003e (forall st.  Module st -\u003e ModuleT st LB a) -\u003e LB a",
          "source": "src/Lambdabot-Monad.html#withModule",
          "type": "function"
        },
        "index": {
          "description": "Interpret an expression in the context of module Arguments are which map to use ircModules and ircCommands are the only sensible arguments here the name of the module command action for the case that the lookup fails action if the lookup succeeds",
          "hierarchy": "Lambdabot Monad",
          "module": "Lambdabot.Monad",
          "name": "withModule",
          "normalized": "String-\u003eLB a-\u003e(b c Module d-\u003eModuleT d LB a)-\u003eLB a",
          "package": "lambdabot",
          "partial": "Module",
          "signature": "String-\u003eLB a-\u003e(forall st. Module st-\u003eModuleT st LB a)-\u003eLB a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Monad.html#v:withModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Nick",
          "name": "Nick",
          "package": "lambdabot",
          "source": "src/Lambdabot-Nick.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Nick",
          "module": "Lambdabot.Nick",
          "name": "Nick",
          "package": "lambdabot",
          "partial": "Nick",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of nicknames isolated from a message.\n\u003c/p\u003e",
          "module": "Lambdabot.Nick",
          "name": "Nick",
          "package": "lambdabot",
          "source": "src/Lambdabot-Nick.html#Nick",
          "type": "data"
        },
        "index": {
          "description": "The type of nicknames isolated from message",
          "hierarchy": "Lambdabot Nick",
          "module": "Lambdabot.Nick",
          "name": "Nick",
          "package": "lambdabot",
          "partial": "Nick",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#t:Nick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Lambdabot.Nick\",\"Lambdabot.Plugin\"]",
          "name": "Nick",
          "package": "lambdabot",
          "signature": "Nick",
          "source": "src/Lambdabot-Nick.html#Nick",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:Nick\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:Nick\"]"
        },
        "index": {
          "hierarchy": "Lambdabot Nick",
          "module": "Lambdabot.Nick",
          "name": "Nick",
          "package": "lambdabot",
          "partial": "Nick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:Nick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormat a nickname for display.  This will automatically omit the server\n field if it is the same as the server of the provided message.\n\u003c/p\u003e",
          "module": "Lambdabot.Nick",
          "name": "fmtNick",
          "package": "lambdabot",
          "signature": "String -\u003e Nick -\u003e String",
          "source": "src/Lambdabot-Nick.html#fmtNick",
          "type": "function"
        },
        "index": {
          "description": "Format nickname for display This will automatically omit the server field if it is the same as the server of the provided message",
          "hierarchy": "Lambdabot Nick",
          "module": "Lambdabot.Nick",
          "name": "fmtNick",
          "normalized": "String-\u003eNick-\u003eString",
          "package": "lambdabot",
          "partial": "Nick",
          "signature": "String-\u003eNick-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:fmtNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe server-specific nickname of this nick\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Nick\",\"Lambdabot.Plugin\"]",
          "name": "nName",
          "package": "lambdabot",
          "signature": "String",
          "source": "src/Lambdabot-Nick.html#Nick",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:nName\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:nName\"]"
        },
        "index": {
          "description": "The server-specific nickname of this nick",
          "hierarchy": "Lambdabot Nick",
          "module": "Lambdabot.Nick",
          "name": "nName",
          "package": "lambdabot",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:nName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe tag of the server this nick is on\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Nick\",\"Lambdabot.Plugin\"]",
          "name": "nTag",
          "package": "lambdabot",
          "signature": "String",
          "source": "src/Lambdabot-Nick.html#Nick",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:nTag\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:nTag\"]"
        },
        "index": {
          "description": "The tag of the server this nick is on",
          "hierarchy": "Lambdabot Nick",
          "module": "Lambdabot.Nick",
          "name": "nTag",
          "package": "lambdabot",
          "partial": "Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:nTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a nickname received in a message.  If the server field is not\n provided, it defaults to the same as that of the message.\n\u003c/p\u003e",
          "module": "Lambdabot.Nick",
          "name": "parseNick",
          "package": "lambdabot",
          "signature": "String -\u003e String -\u003e Nick",
          "source": "src/Lambdabot-Nick.html#parseNick",
          "type": "function"
        },
        "index": {
          "description": "Parse nickname received in message If the server field is not provided it defaults to the same as that of the message",
          "hierarchy": "Lambdabot Nick",
          "module": "Lambdabot.Nick",
          "name": "parseNick",
          "normalized": "String-\u003eString-\u003eNick",
          "package": "lambdabot",
          "partial": "Nick",
          "signature": "String-\u003eString-\u003eNick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Nick.html#v:parseNick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNickname equality subsystem.\n\u003c/p\u003e\u003cp\u003eThis component is responsible for deciding whether two nicknames\n refer to the same person, for the purposes of \u003ccode\u003etell et al.  Nickname\n equality must be monadic because it uses mutable state maintained\n by the \u003c/code\u003elink and \u003ccode\u003eunlink commands.\n\nAlso provided is a concept of polynicks (by analogy to polytypes);\n polynicks can refer to an (open) set of nicknames.  For instance '\u003c/code\u003etell\n *lambdabot Why does X do Y' could tell a message to anyone who has\n identified as a lambdabot maintainer.  A polynick consists of a\n bar-separated list of (nicks or open terms); an open term is like a\n nick but preceded with a star.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.NickEq",
          "name": "NickEq",
          "package": "lambdabot",
          "source": "src/Lambdabot-NickEq.html",
          "type": "module"
        },
        "index": {
          "description": "Nickname equality subsystem This component is responsible for deciding whether two nicknames refer to the same person for the purposes of tell et al Nickname equality must be monadic because it uses mutable state maintained by the link and unlink commands Also provided is concept of polynicks by analogy to polytypes polynicks can refer to an open set of nicknames For instance tell lambdabot Why does do could tell message to anyone who has identified as lambdabot maintainer polynick consists of bar-separated list of nicks or open terms an open term is like nick but preceded with star",
          "hierarchy": "Lambdabot NickEq",
          "module": "Lambdabot.NickEq",
          "name": "NickEq",
          "package": "lambdabot",
          "partial": "Nick Eq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-NickEq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.NickEq",
          "name": "Polynick",
          "package": "lambdabot",
          "source": "src/Lambdabot-NickEq.html#Polynick",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot NickEq",
          "module": "Lambdabot.NickEq",
          "name": "Polynick",
          "package": "lambdabot",
          "partial": "Polynick",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-NickEq.html#t:Polynick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup (using a polynick) in a map keyed on mononicks.\n\u003c/p\u003e",
          "module": "Lambdabot.NickEq",
          "name": "lookupMononickMap",
          "package": "lambdabot",
          "signature": "LB (Polynick -\u003e Map Nick a -\u003e [(Nick, a)])",
          "source": "src/Lambdabot-NickEq.html#lookupMononickMap",
          "type": "function"
        },
        "index": {
          "description": "Lookup using polynick in map keyed on mononicks",
          "hierarchy": "Lambdabot NickEq",
          "module": "Lambdabot.NickEq",
          "name": "lookupMononickMap",
          "normalized": "LB(Polynick-\u003eMap Nick a-\u003e[(Nick,a)])",
          "package": "lambdabot",
          "partial": "Mononick Map",
          "signature": "LB(Polynick-\u003eMap Nick a-\u003e[(Nick,a)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-NickEq.html#v:lookupMononickMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a regular mononick into a polynick.\n\u003c/p\u003e",
          "module": "Lambdabot.NickEq",
          "name": "mononickToPolynick",
          "package": "lambdabot",
          "signature": "Nick -\u003e Polynick",
          "source": "src/Lambdabot-NickEq.html#mononickToPolynick",
          "type": "function"
        },
        "index": {
          "description": "Convert regular mononick into polynick",
          "hierarchy": "Lambdabot NickEq",
          "module": "Lambdabot.NickEq",
          "name": "mononickToPolynick",
          "normalized": "Nick-\u003ePolynick",
          "package": "lambdabot",
          "partial": "To Polynick",
          "signature": "Nick-\u003ePolynick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-NickEq.html#v:mononickToPolynick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine if a nick matches a polynick.  The state is read at the\n point of binding.\n\u003c/p\u003e",
          "module": "Lambdabot.NickEq",
          "name": "nickMatches",
          "package": "lambdabot",
          "signature": "LB (Nick -\u003e Polynick -\u003e Bool)",
          "source": "src/Lambdabot-NickEq.html#nickMatches",
          "type": "function"
        },
        "index": {
          "description": "Determine if nick matches polynick The state is read at the point of binding",
          "hierarchy": "Lambdabot NickEq",
          "module": "Lambdabot.NickEq",
          "name": "nickMatches",
          "normalized": "LB(Nick-\u003ePolynick-\u003eBool)",
          "package": "lambdabot",
          "partial": "Matches",
          "signature": "LB(Nick-\u003ePolynick-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-NickEq.html#v:nickMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a read polynick.\n\u003c/p\u003e",
          "module": "Lambdabot.NickEq",
          "name": "readPolynick",
          "package": "lambdabot",
          "signature": "a -\u003e String -\u003e Polynick",
          "source": "src/Lambdabot-NickEq.html#readPolynick",
          "type": "function"
        },
        "index": {
          "description": "Parse read polynick",
          "hierarchy": "Lambdabot NickEq",
          "module": "Lambdabot.NickEq",
          "name": "readPolynick",
          "normalized": "a-\u003eString-\u003ePolynick",
          "package": "lambdabot",
          "partial": "Polynick",
          "signature": "a-\u003eString-\u003ePolynick",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-NickEq.html#v:readPolynick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormat a polynick.\n\u003c/p\u003e",
          "module": "Lambdabot.NickEq",
          "name": "showPolynick",
          "package": "lambdabot",
          "signature": "a -\u003e Polynick -\u003e String",
          "source": "src/Lambdabot-NickEq.html#showPolynick",
          "type": "function"
        },
        "index": {
          "description": "Format polynick",
          "hierarchy": "Lambdabot NickEq",
          "module": "Lambdabot.NickEq",
          "name": "showPolynick",
          "normalized": "a-\u003ePolynick-\u003eString",
          "package": "lambdabot",
          "partial": "Polynick",
          "signature": "a-\u003ePolynick-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-NickEq.html#v:showPolynick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.OutputFilter",
          "name": "OutputFilter",
          "package": "lambdabot",
          "source": "src/Lambdabot-OutputFilter.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot OutputFilter",
          "module": "Lambdabot.OutputFilter",
          "name": "OutputFilter",
          "package": "lambdabot",
          "partial": "Output Filter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-OutputFilter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.OutputFilter",
          "name": "OutputFilter",
          "package": "lambdabot",
          "source": "src/Lambdabot-OutputFilter.html#OutputFilter",
          "type": "type"
        },
        "index": {
          "hierarchy": "Lambdabot OutputFilter",
          "module": "Lambdabot.OutputFilter",
          "name": "OutputFilter",
          "package": "lambdabot",
          "partial": "Output Filter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-OutputFilter.html#t:OutputFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDon't send any output to alleged bots.\n\u003c/p\u003e",
          "module": "Lambdabot.OutputFilter",
          "name": "checkRecip",
          "package": "lambdabot",
          "signature": "OutputFilter m",
          "source": "src/Lambdabot-OutputFilter.html#checkRecip",
          "type": "function"
        },
        "index": {
          "description": "Don send any output to alleged bots",
          "hierarchy": "Lambdabot OutputFilter",
          "module": "Lambdabot.OutputFilter",
          "name": "checkRecip",
          "package": "lambdabot",
          "partial": "Recip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-OutputFilter.html#v:checkRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor now, this just checks for duplicate empty lines.\n\u003c/p\u003e",
          "module": "Lambdabot.OutputFilter",
          "name": "cleanOutput",
          "package": "lambdabot",
          "signature": "OutputFilter m",
          "source": "src/Lambdabot-OutputFilter.html#cleanOutput",
          "type": "function"
        },
        "index": {
          "description": "For now this just checks for duplicate empty lines",
          "hierarchy": "Lambdabot OutputFilter",
          "module": "Lambdabot.OutputFilter",
          "name": "cleanOutput",
          "package": "lambdabot",
          "partial": "Output",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-OutputFilter.html#v:cleanOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrap long lines.\n\u003c/p\u003e",
          "module": "Lambdabot.OutputFilter",
          "name": "lineify",
          "package": "lambdabot",
          "signature": "OutputFilter m",
          "source": "src/Lambdabot-OutputFilter.html#lineify",
          "type": "function"
        },
        "index": {
          "description": "wrap long lines",
          "hierarchy": "Lambdabot OutputFilter",
          "module": "Lambdabot.OutputFilter",
          "name": "lineify",
          "package": "lambdabot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-OutputFilter.html#v:lineify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.OutputFilter",
          "name": "textwidth",
          "package": "lambdabot",
          "signature": "Int",
          "source": "src/Lambdabot-OutputFilter.html#textwidth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot OutputFilter",
          "module": "Lambdabot.OutputFilter",
          "name": "textwidth",
          "package": "lambdabot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-OutputFilter.html#v:textwidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLogging an IRC channel..\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Activity",
          "name": "Activity",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Activity.html",
          "type": "module"
        },
        "index": {
          "description": "Logging an IRC channel",
          "hierarchy": "Lambdabot Plugin Activity",
          "module": "Lambdabot.Plugin.Activity",
          "name": "Activity",
          "package": "lambdabot",
          "partial": "Activity",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Activity.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Activity",
          "name": "activityPlugin",
          "package": "lambdabot",
          "signature": "Module [(UTCTime, Nick)]",
          "source": "src/Lambdabot-Plugin-Activity.html#activityPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Activity",
          "module": "Lambdabot.Plugin.Activity",
          "name": "activityPlugin",
          "normalized": "Module[(UTCTime,Nick)]",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module[(UTCTime,Nick)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Activity.html#v:activityPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA plugin for the Haskell interpreter for the brainf*ck language\n http:\u003cem/\u003ewww.muppetlabs.com\u003cem\u003e~breadbox\u003c/em\u003ebf/\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.BF",
          "name": "BF",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-BF.html",
          "type": "module"
        },
        "index": {
          "description": "plugin for the Haskell interpreter for the brainf ck language http www.muppetlabs.com breadbox bf",
          "hierarchy": "Lambdabot Plugin BF",
          "module": "Lambdabot.Plugin.BF",
          "name": "BF",
          "package": "lambdabot",
          "partial": "BF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-BF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.BF",
          "name": "bfPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-BF.html#bfPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin BF",
          "module": "Lambdabot.Plugin.BF",
          "name": "bfPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-BF.html#v:bfPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLambdabot base module. Controls message send and receive\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Base",
          "name": "Base",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Base.html",
          "type": "module"
        },
        "index": {
          "description": "Lambdabot base module Controls message send and receive",
          "hierarchy": "Lambdabot Plugin Base",
          "module": "Lambdabot.Plugin.Base",
          "name": "Base",
          "package": "lambdabot",
          "partial": "Base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Base.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Base",
          "name": "base",
          "package": "lambdabot",
          "signature": "Module (GlobalPrivate () ())",
          "source": "src/Lambdabot-Plugin-Base.html#base",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Base",
          "module": "Lambdabot.Plugin.Base",
          "name": "base",
          "normalized": "Module(GlobalPrivate()())",
          "package": "lambdabot",
          "signature": "Module(GlobalPrivate()())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Base.html#v:base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Check.ShowQ",
          "name": "ShowQ",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Check-ShowQ.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Check ShowQ",
          "module": "Lambdabot.Plugin.Check.ShowQ",
          "name": "ShowQ",
          "package": "lambdabot",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Check-ShowQ.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Check.ShowQ",
          "name": "myquickcheck",
          "package": "lambdabot",
          "signature": "prop -\u003e String",
          "source": "src/Lambdabot-Plugin-Check-ShowQ.html#myquickcheck",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Check ShowQ",
          "module": "Lambdabot.Plugin.Check.ShowQ",
          "name": "myquickcheck",
          "normalized": "a-\u003eString",
          "package": "lambdabot",
          "signature": "prop-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Check-ShowQ.html#v:myquickcheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTest a property with QuickCheck\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Check",
          "name": "Check",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Check.html",
          "type": "module"
        },
        "index": {
          "description": "Test property with QuickCheck",
          "hierarchy": "Lambdabot Plugin Check",
          "module": "Lambdabot.Plugin.Check",
          "name": "Check",
          "package": "lambdabot",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Check",
          "name": "checkPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Check.html#checkPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Check",
          "module": "Lambdabot.Plugin.Check",
          "name": "checkPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Check.html#v:checkPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Compose",
          "name": "Compose",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Compose.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Compose",
          "module": "Lambdabot.Plugin.Compose",
          "name": "Compose",
          "package": "lambdabot",
          "partial": "Compose",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Compose.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Compose",
          "name": "composePlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Compose.html#composePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Compose",
          "module": "Lambdabot.Plugin.Compose",
          "name": "composePlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Compose.html#v:composePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is for throwing dice for e.g. RPGs. (@dice 3d6+2)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Dice",
          "name": "Dice",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Dice.html",
          "type": "module"
        },
        "index": {
          "description": "This module is for throwing dice for e.g RPGs dice d6",
          "hierarchy": "Lambdabot Plugin Dice",
          "module": "Lambdabot.Plugin.Dice",
          "name": "Dice",
          "package": "lambdabot",
          "partial": "Dice",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Dice.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Dice",
          "name": "dicePlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Dice.html#dicePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Dice",
          "module": "Lambdabot.Plugin.Dice",
          "name": "dicePlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Dice.html#v:dicePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDICT (RFC 2229) Lookup Module for lambdabot IRC robot.\n Tom Moertel \u003ca\u003etom@moertel.com\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Dict",
          "name": "Dict",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Dict.html",
          "type": "module"
        },
        "index": {
          "description": "DICT RFC Lookup Module for lambdabot IRC robot Tom Moertel tom@moertel.com",
          "hierarchy": "Lambdabot Plugin Dict",
          "module": "Lambdabot.Plugin.Dict",
          "name": "Dict",
          "package": "lambdabot",
          "partial": "Dict",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Dict.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Dict",
          "name": "dictPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Dict.html#dictPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Dict",
          "module": "Lambdabot.Plugin.Dict",
          "name": "dictPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Dict.html#v:dictPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA binding to Djinn.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Djinn",
          "name": "Djinn",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Djinn.html",
          "type": "module"
        },
        "index": {
          "description": "binding to Djinn",
          "hierarchy": "Lambdabot Plugin Djinn",
          "module": "Lambdabot.Plugin.Djinn",
          "name": "Djinn",
          "package": "lambdabot",
          "partial": "Djinn",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Djinn.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Djinn",
          "name": "djinnPlugin",
          "package": "lambdabot",
          "signature": "Module (Maybe DjinnEnv)",
          "source": "src/Lambdabot-Plugin-Djinn.html#djinnPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Djinn",
          "module": "Lambdabot.Plugin.Djinn",
          "name": "djinnPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Djinn.html#v:djinnPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple template module\n Contains many constant bot commands.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Dummy",
          "name": "Dummy",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Dummy.html",
          "type": "module"
        },
        "index": {
          "description": "Simple template module Contains many constant bot commands",
          "hierarchy": "Lambdabot Plugin Dummy",
          "module": "Lambdabot.Plugin.Dummy",
          "name": "Dummy",
          "package": "lambdabot",
          "partial": "Dummy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Dummy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Dummy",
          "name": "dummyPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Dummy.html#dummyPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Dummy",
          "module": "Lambdabot.Plugin.Dummy",
          "name": "dummyPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Dummy.html#v:dummyPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Elite",
          "name": "Elite",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Elite.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Elite",
          "module": "Lambdabot.Plugin.Elite",
          "name": "Elite",
          "package": "lambdabot",
          "partial": "Elite",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Elite.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Elite",
          "name": "elitePlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Elite.html#elitePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Elite",
          "module": "Lambdabot.Plugin.Elite",
          "name": "elitePlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Elite.html#v:elitePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Error",
          "name": "Error",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Error.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Error",
          "module": "Lambdabot.Plugin.Error",
          "name": "Error",
          "package": "lambdabot",
          "partial": "Error",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Error.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Error",
          "name": "errorOnLoad",
          "package": "lambdabot",
          "signature": "Config Bool",
          "source": "src/Lambdabot-Plugin-Error.html#errorOnLoad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Error",
          "module": "Lambdabot.Plugin.Error",
          "name": "errorOnLoad",
          "package": "lambdabot",
          "partial": "On Load",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Error.html#v:errorOnLoad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Error",
          "name": "errorPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Error.html#errorPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Error",
          "module": "Lambdabot.Plugin.Error",
          "name": "errorPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Error.html#v:errorPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Error",
          "name": "failOnLoad",
          "package": "lambdabot",
          "signature": "Config Bool",
          "source": "src/Lambdabot-Plugin-Error.html#failOnLoad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Error",
          "module": "Lambdabot.Plugin.Error",
          "name": "failOnLoad",
          "package": "lambdabot",
          "partial": "On Load",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Error.html#v:failOnLoad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "Trusted",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "Trusted",
          "package": "lambdabot",
          "partial": "Trusted",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "Mu",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html#Mu",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "Mu",
          "package": "lambdabot",
          "partial": "Mu",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#t:Mu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "Rec",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html#Rec",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "Rec",
          "package": "lambdabot",
          "partial": "Rec",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#t:Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "In",
          "package": "lambdabot",
          "signature": "In",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html#Mu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "In",
          "package": "lambdabot",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#v:In"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "InR",
          "package": "lambdabot",
          "signature": "InR",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html#Rec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "InR",
          "package": "lambdabot",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#v:InR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "describeSequence",
          "package": "lambdabot",
          "signature": "SequenceData -\u003e Maybe String",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html#describeSequence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "describeSequence",
          "normalized": "SequenceData-\u003eMaybe String",
          "package": "lambdabot",
          "partial": "Sequence",
          "signature": "SequenceData-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#v:describeSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "out",
          "package": "lambdabot",
          "signature": "f (Mu f)",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html#Mu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "out",
          "package": "lambdabot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#v:out"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "outR",
          "package": "lambdabot",
          "signature": "Rec a -\u003e a",
          "source": "src/Lambdabot-Plugin-Eval-Trusted.html#Rec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval Trusted",
          "module": "Lambdabot.Plugin.Eval.Trusted",
          "name": "outR",
          "normalized": "Rec a-\u003ea",
          "package": "lambdabot",
          "signature": "Rec a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval-Trusted.html#v:outR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Haskell evaluator for the pure part, using mueval\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Eval",
          "name": "Eval",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Eval.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell evaluator for the pure part using mueval",
          "hierarchy": "Lambdabot Plugin Eval",
          "module": "Lambdabot.Plugin.Eval",
          "name": "Eval",
          "package": "lambdabot",
          "partial": "Eval",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval",
          "name": "evalPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Eval.html#evalPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval",
          "module": "Lambdabot.Plugin.Eval",
          "name": "evalPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval.html#v:evalPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval",
          "name": "exts",
          "package": "lambdabot",
          "signature": "[String]",
          "source": "src/Lambdabot-Plugin-Eval.html#exts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval",
          "module": "Lambdabot.Plugin.Eval",
          "name": "exts",
          "normalized": "[String]",
          "package": "lambdabot",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval.html#v:exts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Eval",
          "name": "runGHC",
          "package": "lambdabot",
          "signature": "String -\u003e m String",
          "source": "src/Lambdabot-Plugin-Eval.html#runGHC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Eval",
          "module": "Lambdabot.Plugin.Eval",
          "name": "runGHC",
          "normalized": "String-\u003ea String",
          "package": "lambdabot",
          "partial": "GHC",
          "signature": "String-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Eval.html#v:runGHC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGNU Talk Filters\n needs: http:\u003cem/\u003ewww.hyperrealm.com/main.php?s=talkfilters\n Edward Kmett 2006\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Filter",
          "name": "Filter",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Filter.html",
          "type": "module"
        },
        "index": {
          "description": "GNU Talk Filters needs http www.hyperrealm.com main.php talkfilters Edward Kmett",
          "hierarchy": "Lambdabot Plugin Filter",
          "module": "Lambdabot.Plugin.Filter",
          "name": "Filter",
          "package": "lambdabot",
          "partial": "Filter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Filter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Filter",
          "name": "filterPlugin",
          "package": "lambdabot",
          "signature": "Module [(String, FilePath, String)]",
          "source": "src/Lambdabot-Plugin-Filter.html#filterPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Filter",
          "module": "Lambdabot.Plugin.Filter",
          "name": "filterPlugin",
          "normalized": "Module[(String,FilePath,String)]",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module[(String,FilePath,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Filter.html#v:filterPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFree theorems plugin\n Andrew Bromage, 2006\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Free",
          "name": "Free",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Free.html",
          "type": "module"
        },
        "index": {
          "description": "Free theorems plugin Andrew Bromage",
          "hierarchy": "Lambdabot Plugin Free",
          "module": "Lambdabot.Plugin.Free",
          "name": "Free",
          "package": "lambdabot",
          "partial": "Free",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Free.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Free",
          "name": "freePlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Free.html#freePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Free",
          "module": "Lambdabot.Plugin.Free",
          "name": "freePlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Free.html#v:freePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell project name generation\n semi-joke\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Fresh",
          "name": "Fresh",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Fresh.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell project name generation semi-joke",
          "hierarchy": "Lambdabot Plugin Fresh",
          "module": "Lambdabot.Plugin.Fresh",
          "name": "Fresh",
          "package": "lambdabot",
          "partial": "Fresh",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Fresh.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Fresh",
          "name": "freshPlugin",
          "package": "lambdabot",
          "signature": "Module Integer",
          "source": "src/Lambdabot-Plugin-Fresh.html#freshPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Fresh",
          "module": "Lambdabot.Plugin.Fresh",
          "name": "freshPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Fresh.html#v:freshPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHackish Haddock module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Haddock",
          "name": "Haddock",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Haddock.html",
          "type": "module"
        },
        "index": {
          "description": "Hackish Haddock module",
          "hierarchy": "Lambdabot Plugin Haddock",
          "module": "Lambdabot.Plugin.Haddock",
          "name": "Haddock",
          "package": "lambdabot",
          "partial": "Haddock",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Haddock.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Haddock",
          "name": "haddockPlugin",
          "package": "lambdabot",
          "signature": "Module HaddockState",
          "source": "src/Lambdabot-Plugin-Haddock.html#haddockPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Haddock",
          "module": "Lambdabot.Plugin.Haddock",
          "name": "haddockPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Haddock.html#v:haddockPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHello world plugin\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Hello",
          "name": "Hello",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Hello.html",
          "type": "module"
        },
        "index": {
          "description": "Hello world plugin",
          "hierarchy": "Lambdabot Plugin Hello",
          "module": "Lambdabot.Plugin.Hello",
          "name": "Hello",
          "package": "lambdabot",
          "partial": "Hello",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Hello.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Hello",
          "name": "helloPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Hello.html#helloPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Hello",
          "module": "Lambdabot.Plugin.Hello",
          "name": "helloPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Hello.html#v:helloPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvide help for plugins\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Help",
          "name": "Help",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Help.html",
          "type": "module"
        },
        "index": {
          "description": "Provide help for plugins",
          "hierarchy": "Lambdabot Plugin Help",
          "module": "Lambdabot.Plugin.Help",
          "name": "Help",
          "package": "lambdabot",
          "partial": "Help",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Help.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Help",
          "name": "helpPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Help.html#helpPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Help",
          "module": "Lambdabot.Plugin.Help",
          "name": "helpPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Help.html#v:helpPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTalk to Neil Mitchell's \u003ccode\u003eHoogle\u003c/code\u003e program\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Hoogle",
          "name": "Hoogle",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Hoogle.html",
          "type": "module"
        },
        "index": {
          "description": "Talk to Neil Mitchell Hoogle program",
          "hierarchy": "Lambdabot Plugin Hoogle",
          "module": "Lambdabot.Plugin.Hoogle",
          "name": "Hoogle",
          "package": "lambdabot",
          "partial": "Hoogle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Hoogle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Hoogle",
          "name": "hooglePlugin",
          "package": "lambdabot",
          "signature": "Module [String]",
          "source": "src/Lambdabot-Plugin-Hoogle.html#hooglePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Hoogle",
          "module": "Lambdabot.Plugin.Hoogle",
          "name": "hooglePlugin",
          "normalized": "Module[String]",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Hoogle.html#v:hooglePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe plugin-level IRC interface.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.IRC",
          "name": "IRC",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-IRC.html",
          "type": "module"
        },
        "index": {
          "description": "The plugin-level IRC interface",
          "hierarchy": "Lambdabot Plugin IRC",
          "module": "Lambdabot.Plugin.IRC",
          "name": "IRC",
          "package": "lambdabot",
          "partial": "IRC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-IRC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.IRC",
          "name": "ircPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-IRC.html#ircPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin IRC",
          "module": "Lambdabot.Plugin.IRC",
          "name": "ircPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-IRC.html#v:ircPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module to output the instances of a typeclass.\n     Some sample input/output:\n\u003c/p\u003e\u003cpre\u003e lambdabot\u003e @instances Monad\n [], ArrowMonad a, WriterT w m, Writer w, ReaderT r m, Reader r,\n StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e,\n ContT r m, Cont r, Maybe, ST s, IO\n\n lambdabot\u003e @instances Show\n Float, Double, Integer, ST s a, [a], (a, b, c, d), (a, b, c), (a, b),\n (), Ordering, Maybe a, Int, Either a b, Char, Bool\n\n lambdabot\u003e @instances-importing Text.Html Data.Tree Show\n Float, Double, Tree a, HtmlTable, HtmlAttr, Html, HotLink, Integer,\n ST s a, [a], (a, b, c, d), (a, b, c), (a, b), (), Ordering, Maybe a,\n Int\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Instances",
          "name": "Instances",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "module to output the instances of typeclass Some sample input output lambdabot instances Monad ArrowMonad WriterT Writer ReaderT Reader StateT State RWST RWS ErrorT Either ContT Cont Maybe ST IO lambdabot instances Show Float Double Integer ST Ordering Maybe Int Either Char Bool lambdabot instances-importing Text.Html Data.Tree Show Float Double Tree HtmlTable HtmlAttr Html HotLink Integer ST Ordering Maybe Int",
          "hierarchy": "Lambdabot Plugin Instances",
          "module": "Lambdabot.Plugin.Instances",
          "name": "Instances",
          "package": "lambdabot",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Instances",
          "name": "instancesPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Instances.html#instancesPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Instances",
          "module": "Lambdabot.Plugin.Instances",
          "name": "instancesPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Instances.html#v:instancesPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eKarma\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Karma",
          "name": "Karma",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Karma.html",
          "type": "module"
        },
        "index": {
          "description": "Karma",
          "hierarchy": "Lambdabot Plugin Karma",
          "module": "Lambdabot.Plugin.Karma",
          "name": "Karma",
          "package": "lambdabot",
          "partial": "Karma",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Karma.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Karma",
          "name": "karmaPlugin",
          "package": "lambdabot",
          "signature": "Module KarmaState",
          "source": "src/Lambdabot-Plugin-Karma.html#karmaPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Karma",
          "module": "Lambdabot.Plugin.Karma",
          "name": "karmaPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Karma.html#v:karmaPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple wrapper over privmsg to get time information via the CTCP\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Localtime",
          "name": "Localtime",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Localtime.html",
          "type": "module"
        },
        "index": {
          "description": "Simple wrapper over privmsg to get time information via the CTCP",
          "hierarchy": "Lambdabot Plugin Localtime",
          "module": "Lambdabot.Plugin.Localtime",
          "name": "Localtime",
          "package": "lambdabot",
          "partial": "Localtime",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Localtime.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Localtime",
          "name": "localtimePlugin",
          "package": "lambdabot",
          "signature": "Module TimeMap",
          "source": "src/Lambdabot-Plugin-Localtime.html#localtimePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Localtime",
          "module": "Lambdabot.Plugin.Localtime",
          "name": "localtimePlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Localtime.html#v:localtimePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLogging an IRC channel..\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Log",
          "name": "Log",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Log.html",
          "type": "module"
        },
        "index": {
          "description": "Logging an IRC channel",
          "hierarchy": "Lambdabot Plugin Log",
          "module": "Lambdabot.Plugin.Log",
          "name": "Log",
          "package": "lambdabot",
          "partial": "Log",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Log.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Log",
          "name": "logPlugin",
          "package": "lambdabot",
          "signature": "Module (Map Channel ChanState)",
          "source": "src/Lambdabot-Plugin-Log.html#logPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Log",
          "module": "Lambdabot.Plugin.Log",
          "name": "logPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Log.html#v:logPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for more(1) buffering\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.More",
          "name": "More",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-More.html",
          "type": "module"
        },
        "index": {
          "description": "Support for more buffering",
          "hierarchy": "Lambdabot Plugin More",
          "module": "Lambdabot.Plugin.More",
          "name": "More",
          "package": "lambdabot",
          "partial": "More",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-More.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.More",
          "name": "morePlugin",
          "package": "lambdabot",
          "signature": "Module (GlobalPrivate () [String])",
          "source": "src/Lambdabot-Plugin-More.html#morePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin More",
          "module": "Lambdabot.Plugin.More",
          "name": "morePlugin",
          "normalized": "Module(GlobalPrivate()[String])",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module(GlobalPrivate()[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-More.html#v:morePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Numberwang",
          "name": "Numberwang",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Numberwang.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Numberwang",
          "module": "Lambdabot.Plugin.Numberwang",
          "name": "Numberwang",
          "package": "lambdabot",
          "partial": "Numberwang",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Numberwang.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Numberwang",
          "name": "numberwangPlugin",
          "package": "lambdabot",
          "signature": "Module NumberwangState",
          "source": "src/Lambdabot-Plugin-Numberwang.html#numberwangPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Numberwang",
          "module": "Lambdabot.Plugin.Numberwang",
          "name": "numberwangPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Numberwang.html#v:numberwangPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLook up sequences in the Online Encyclopedia of Integer Sequences\n   Based on the Math.OEIS library\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.OEIS",
          "name": "OEIS",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-OEIS.html",
          "type": "module"
        },
        "index": {
          "description": "Look up sequences in the Online Encyclopedia of Integer Sequences Based on the Math.OEIS library",
          "hierarchy": "Lambdabot Plugin OEIS",
          "module": "Lambdabot.Plugin.OEIS",
          "name": "OEIS",
          "package": "lambdabot",
          "partial": "OEIS",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-OEIS.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.OEIS",
          "name": "oeisPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-OEIS.html#oeisPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin OEIS",
          "module": "Lambdabot.Plugin.OEIS",
          "name": "oeisPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-OEIS.html#v:oeisPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOffline mode \u003cem\u003e RC file \u003c/em\u003e -e support module.  Handles spooling lists\n of commands (from haskeline, files, or the command line) into the vchat\n layer.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.OfflineRC",
          "name": "OfflineRC",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-OfflineRC.html",
          "type": "module"
        },
        "index": {
          "description": "Offline mode RC file support module Handles spooling lists of commands from haskeline files or the command line into the vchat layer",
          "hierarchy": "Lambdabot Plugin OfflineRC",
          "module": "Lambdabot.Plugin.OfflineRC",
          "name": "OfflineRC",
          "package": "lambdabot",
          "partial": "Offline RC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-OfflineRC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.OfflineRC",
          "name": "offlineRC",
          "package": "lambdabot",
          "signature": "Module OfflineRCState",
          "source": "src/Lambdabot-Plugin-OfflineRC.html#offlineRC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin OfflineRC",
          "module": "Lambdabot.Plugin.OfflineRC",
          "name": "offlineRC",
          "package": "lambdabot",
          "partial": "RC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-OfflineRC.html#v:offlineRC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePointfree programming fun\n\u003c/p\u003e\u003cp\u003eA catalogue of refactorings is at:\n      http:\u003cem/\u003ewww.cs.kent.ac.uk\u003cem\u003eprojects\u003c/em\u003erefactor-fp\u003cem\u003ecatalogue\u003c/em\u003e\n      http:\u003cem/\u003ewww.cs.kent.ac.uk\u003cem\u003eprojects\u003c/em\u003erefactor-fp\u003cem\u003ecatalogue\u003c/em\u003eRefacIdeasAug03.html\n\u003c/p\u003e\u003cp\u003eUse more Arrow stuff\n\u003c/p\u003e\u003cp\u003eTODO would be to plug into HaRe and use some of their refactorings.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Pl",
          "name": "Pl",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Pl.html",
          "type": "module"
        },
        "index": {
          "description": "Pointfree programming fun catalogue of refactorings is at http www.cs.kent.ac.uk projects refactor-fp catalogue http www.cs.kent.ac.uk projects refactor-fp catalogue RefacIdeasAug03.html Use more Arrow stuff TODO would be to plug into HaRe and use some of their refactorings",
          "hierarchy": "Lambdabot Plugin Pl",
          "module": "Lambdabot.Plugin.Pl",
          "name": "Pl",
          "package": "lambdabot",
          "partial": "Pl",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Pl.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Pl",
          "name": "plPlugin",
          "package": "lambdabot",
          "signature": "Module (GlobalPrivate () (Int, TopLevel))",
          "source": "src/Lambdabot-Plugin-Pl.html#plPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Pl",
          "module": "Lambdabot.Plugin.Pl",
          "name": "plPlugin",
          "normalized": "Module(GlobalPrivate()(Int,TopLevel))",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module(GlobalPrivate()(Int,TopLevel))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Pl.html#v:plPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Pointful",
          "name": "Pointful",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Pointful.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Pointful",
          "module": "Lambdabot.Plugin.Pointful",
          "name": "Pointful",
          "package": "lambdabot",
          "partial": "Pointful",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Pointful.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Pointful",
          "name": "pointfulPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Pointful.html#pointfulPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Pointful",
          "module": "Lambdabot.Plugin.Pointful",
          "name": "pointfulPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Pointful.html#v:pointfulPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e| Support for voting\n |\n | License: lGPL\n |\n | added by Kenneth Hoste (boegel), 22\u003cem\u003e11\u003c/em\u003e2005\n |  inspiration: Where plugin (thanks shapr,dons)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Poll",
          "name": "Poll",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Poll.html",
          "type": "module"
        },
        "index": {
          "description": "Support for voting License lGPL added by Kenneth Hoste boegel inspiration Where plugin thanks shapr dons",
          "hierarchy": "Lambdabot Plugin Poll",
          "module": "Lambdabot.Plugin.Poll",
          "name": "Poll",
          "package": "lambdabot",
          "partial": "Poll",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Poll.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Poll",
          "name": "pollPlugin",
          "package": "lambdabot",
          "signature": "Module (Map PollName Poll)",
          "source": "src/Lambdabot-Plugin-Poll.html#pollPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Poll",
          "module": "Lambdabot.Plugin.Poll",
          "name": "pollPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Poll.html#v:pollPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePretty-Printing echo\n\u003c/p\u003e\u003cp\u003eexample:\n\u003c/p\u003e\u003cpre\u003e @pretty fun x = case x of {3 -\u003e \"hello\" ; 5 -\u003e \"world\" ; _ -\u003e \"else\"}\n\u003c/pre\u003e\u003cpre\u003e fun x\n  = case x of\n   3 -\u003e \"hello\"\n   5 -\u003e \"world\"\n   _ -\u003e \"else\"\n\u003c/pre\u003e\u003cp\u003e(c) Johannes Ahlmann, 2005-12-13, released under GPL 2 \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Pretty",
          "name": "Pretty",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Pretty.html",
          "type": "module"
        },
        "index": {
          "description": "Pretty-Printing echo example pretty fun case of hello world else fun case of hello world else Johannes Ahlmann released under GPL",
          "hierarchy": "Lambdabot Plugin Pretty",
          "module": "Lambdabot.Plugin.Pretty",
          "name": "Pretty",
          "package": "lambdabot",
          "partial": "Pretty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Pretty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Pretty",
          "name": "prettyPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Pretty.html#prettyPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Pretty",
          "module": "Lambdabot.Plugin.Pretty",
          "name": "prettyPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Pretty.html#v:prettyPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for quotes\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Quote",
          "name": "Quote",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Quote.html",
          "type": "module"
        },
        "index": {
          "description": "Support for quotes",
          "hierarchy": "Lambdabot Plugin Quote",
          "module": "Lambdabot.Plugin.Quote",
          "name": "Quote",
          "package": "lambdabot",
          "partial": "Quote",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Quote.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Quote",
          "name": "quotePlugin",
          "package": "lambdabot",
          "signature": "Module (Map ByteString [ByteString])",
          "source": "src/Lambdabot-Plugin-Quote.html#quotePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Quote",
          "module": "Lambdabot.Plugin.Quote",
          "name": "quotePlugin",
          "normalized": "Module(Map ByteString[ByteString])",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module(Map ByteString[ByteString])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Quote.html#v:quotePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSearch various things, Wikipedia and google for now.\n\u003c/p\u003e\u003cp\u003e(c) 2005 Samuel Bronson\n (c) 2006 Don Stewart\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Search",
          "name": "Search",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Search.html",
          "type": "module"
        },
        "index": {
          "description": "Search various things Wikipedia and google for now Samuel Bronson Don Stewart",
          "hierarchy": "Lambdabot Plugin Search",
          "module": "Lambdabot.Plugin.Search",
          "name": "Search",
          "package": "lambdabot",
          "partial": "Search",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Search.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Search",
          "name": "searchPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Search.html#searchPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Search",
          "module": "Lambdabot.Plugin.Search",
          "name": "searchPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Search.html#v:searchPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eKeep track of IRC users.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Seen",
          "name": "Seen",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Seen.html",
          "type": "module"
        },
        "index": {
          "description": "Keep track of IRC users",
          "hierarchy": "Lambdabot Plugin Seen",
          "module": "Lambdabot.Plugin.Seen",
          "name": "Seen",
          "package": "lambdabot",
          "partial": "Seen",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Seen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Seen",
          "name": "seenPlugin",
          "package": "lambdabot",
          "signature": "Module (Map Channel Int, Map PackedNick UserStatus)",
          "source": "src/Lambdabot-Plugin-Seen.html#seenPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Seen",
          "module": "Lambdabot.Plugin.Seen",
          "name": "seenPlugin",
          "normalized": "Module(Map Channel Int,Map PackedNick UserStatus)",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module(Map Channel Int,Map PackedNick UserStatus)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Seen.html#v:seenPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for quotes\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Slap",
          "name": "Slap",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Slap.html",
          "type": "module"
        },
        "index": {
          "description": "Support for quotes",
          "hierarchy": "Lambdabot Plugin Slap",
          "module": "Lambdabot.Plugin.Slap",
          "name": "Slap",
          "package": "lambdabot",
          "partial": "Slap",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Slap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Slap",
          "name": "slapPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Slap.html#slapPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Slap",
          "module": "Lambdabot.Plugin.Slap",
          "name": "slapPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Slap.html#v:slapPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Source",
          "name": "Source",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Source.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Source",
          "module": "Lambdabot.Plugin.Source",
          "name": "Source",
          "package": "lambdabot",
          "partial": "Source",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Source.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Source",
          "name": "sourcePlugin",
          "package": "lambdabot",
          "signature": "Module (Map ByteString ByteString)",
          "source": "src/Lambdabot-Plugin-Source.html#sourcePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Source",
          "module": "Lambdabot.Plugin.Source",
          "name": "sourcePlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Source.html#v:sourcePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterface to \u003cem\u003easpell\u003c/em\u003e, an open source spelling checker, from a\n suggestion by Kai Engelhardt. Requires you to install aspell.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Spell",
          "name": "Spell",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Spell.html",
          "type": "module"
        },
        "index": {
          "description": "Interface to aspell an open source spelling checker from suggestion by Kai Engelhardt Requires you to install aspell",
          "hierarchy": "Lambdabot Plugin Spell",
          "module": "Lambdabot.Plugin.Spell",
          "name": "Spell",
          "package": "lambdabot",
          "partial": "Spell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Spell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Spell",
          "name": "spellPlugin",
          "package": "lambdabot",
          "signature": "Module Bool",
          "source": "src/Lambdabot-Plugin-Spell.html#spellPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Spell",
          "module": "Lambdabot.Plugin.Spell",
          "name": "spellPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Spell.html#v:spellPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Stats",
          "name": "Stats",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Stats.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Stats",
          "module": "Lambdabot.Plugin.Stats",
          "name": "Stats",
          "package": "lambdabot",
          "partial": "Stats",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Stats.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Stats",
          "name": "statsPlugin",
          "package": "lambdabot",
          "signature": "Module StatsD",
          "source": "src/Lambdabot-Plugin-Stats.html#statsPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Stats",
          "module": "Lambdabot.Plugin.Stats",
          "name": "statsPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Stats.html#v:statsPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSystem module : IRC control functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.System",
          "name": "System",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-System.html",
          "type": "module"
        },
        "index": {
          "description": "System module IRC control functions",
          "hierarchy": "Lambdabot Plugin System",
          "module": "Lambdabot.Plugin.System",
          "name": "System",
          "package": "lambdabot",
          "partial": "System",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-System.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.System",
          "name": "system",
          "package": "lambdabot",
          "signature": "Module SystemState",
          "source": "src/Lambdabot-Plugin-System.html#system",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin System",
          "module": "Lambdabot.Plugin.System",
          "name": "system",
          "package": "lambdabot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-System.html#v:system"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Tell",
          "name": "Tell",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Tell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Tell",
          "module": "Lambdabot.Plugin.Tell",
          "name": "Tell",
          "package": "lambdabot",
          "partial": "Tell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Tell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Tell",
          "name": "tellPlugin",
          "package": "lambdabot",
          "signature": "Module NoticeBoard",
          "source": "src/Lambdabot-Plugin-Tell.html#tellPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Tell",
          "module": "Lambdabot.Plugin.Tell",
          "name": "tellPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Tell.html#v:tellPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePull quotes down from yahoo.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Ticker",
          "name": "Ticker",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Ticker.html",
          "type": "module"
        },
        "index": {
          "description": "Pull quotes down from yahoo",
          "hierarchy": "Lambdabot Plugin Ticker",
          "module": "Lambdabot.Plugin.Ticker",
          "name": "Ticker",
          "package": "lambdabot",
          "partial": "Ticker",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Ticker.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Ticker",
          "name": "tickerPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Ticker.html#tickerPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Ticker",
          "module": "Lambdabot.Plugin.Ticker",
          "name": "tickerPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Ticker.html#v:tickerPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA todo list\n\u003c/p\u003e\u003cp\u003e(c) 2005 Samuel Bronson\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Todo",
          "name": "Todo",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Todo.html",
          "type": "module"
        },
        "index": {
          "description": "todo list Samuel Bronson",
          "hierarchy": "Lambdabot Plugin Todo",
          "module": "Lambdabot.Plugin.Todo",
          "name": "Todo",
          "package": "lambdabot",
          "partial": "Todo",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Todo.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Todo",
          "name": "todoPlugin",
          "package": "lambdabot",
          "signature": "Module TodoState",
          "source": "src/Lambdabot-Plugin-Todo.html#todoPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Todo",
          "module": "Lambdabot.Plugin.Todo",
          "name": "todoPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Todo.html#v:todoPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Topic plugin is an interface for messing with the channel topic.\n   It can alter the topic in various ways and keep track of the changes.\n   The advantage of having the bot maintain the topic is that we get an\n   authoritative source for the current topic, when the IRC server decides\n   to delete it due to Network Splits.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Topic",
          "name": "Topic",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Topic.html",
          "type": "module"
        },
        "index": {
          "description": "The Topic plugin is an interface for messing with the channel topic It can alter the topic in various ways and keep track of the changes The advantage of having the bot maintain the topic is that we get an authoritative source for the current topic when the IRC server decides to delete it due to Network Splits",
          "hierarchy": "Lambdabot Plugin Topic",
          "module": "Lambdabot.Plugin.Topic",
          "name": "Topic",
          "package": "lambdabot",
          "partial": "Topic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Topic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Topic",
          "name": "topicPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Topic.html#topicPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Topic",
          "module": "Lambdabot.Plugin.Topic",
          "name": "topicPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Topic.html#v:topicPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Type Module - another progressive plugin for lambdabot\n\u003c/p\u003e\u003cp\u003epesco hamburg 2003-04-05\n\u003c/p\u003e\u003cp\u003eGreetings reader,\n\u003c/p\u003e\u003cp\u003ewhether you're a regular follower of the series or dropping in for\n     the first time, let me present for your pleasure the Type Module:\n\u003c/p\u003e\u003cp\u003eOne thing we enjoy on #haskell is throwing function types at each\n     other instead of spelling out tiresome monologue about arguments\n     or return values. Unfortunately such a toss often involves a local\n     lookup of the type signature in question because one is seldom\n     sure about the actual argument order.\n\u003c/p\u003e\u003cp\u003eWell, what do you know, this plugin enables lambdabot to automate\n     that lookup for you and your fellow lambda hackers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Type",
          "name": "Type",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Type.html",
          "type": "module"
        },
        "index": {
          "description": "The Type Module another progressive plugin for lambdabot pesco hamburg Greetings reader whether you re regular follower of the series or dropping in for the first time let me present for your pleasure the Type Module One thing we enjoy on haskell is throwing function types at each other instead of spelling out tiresome monologue about arguments or return values Unfortunately such toss often involves local lookup of the type signature in question because one is seldom sure about the actual argument order Well what do you know this plugin enables lambdabot to automate that lookup for you and your fellow lambda hackers",
          "hierarchy": "Lambdabot Plugin Type",
          "module": "Lambdabot.Plugin.Type",
          "name": "Type",
          "package": "lambdabot",
          "partial": "Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Type.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Type",
          "name": "query_ghci",
          "package": "lambdabot",
          "signature": "String -\u003e String -\u003e m String",
          "source": "src/Lambdabot-Plugin-Type.html#query_ghci",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Type",
          "module": "Lambdabot.Plugin.Type",
          "name": "query_ghci",
          "normalized": "String-\u003eString-\u003ea String",
          "package": "lambdabot",
          "signature": "String-\u003eString-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Type.html#v:query_ghci"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Type",
          "name": "typePlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Type.html#typePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Type",
          "module": "Lambdabot.Plugin.Type",
          "name": "typePlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Type.html#v:typePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnroll the MTL monads with your favorite bot!\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.UnMtl",
          "name": "UnMtl",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-UnMtl.html",
          "type": "module"
        },
        "index": {
          "description": "Unroll the MTL monads with your favorite bot",
          "hierarchy": "Lambdabot Plugin UnMtl",
          "module": "Lambdabot.Plugin.UnMtl",
          "name": "UnMtl",
          "package": "lambdabot",
          "partial": "Un Mtl",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-UnMtl.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.UnMtl",
          "name": "unmtlPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-UnMtl.html#unmtlPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin UnMtl",
          "module": "Lambdabot.Plugin.UnMtl",
          "name": "unmtlPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-UnMtl.html#v:unmtlPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Undo",
          "name": "Undo",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Undo.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Undo",
          "module": "Lambdabot.Plugin.Undo",
          "name": "Undo",
          "package": "lambdabot",
          "partial": "Undo",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Undo.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Undo",
          "name": "undoPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Undo.html#undoPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Undo",
          "module": "Lambdabot.Plugin.Undo",
          "name": "undoPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Undo.html#v:undoPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA plugin for the Haskell interpreter for the unlambda language\n\u003c/p\u003e\u003cp\u003ehttp:\u003cem/\u003ewww.madore.org\u003cem\u003e~david\u003c/em\u003eprograms\u003cem\u003eunlambda\u003c/em\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Unlambda",
          "name": "Unlambda",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Unlambda.html",
          "type": "module"
        },
        "index": {
          "description": "plugin for the Haskell interpreter for the unlambda language http www.madore.org david programs unlambda",
          "hierarchy": "Lambdabot Plugin Unlambda",
          "module": "Lambdabot.Plugin.Unlambda",
          "name": "Unlambda",
          "package": "lambdabot",
          "partial": "Unlambda",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Unlambda.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Unlambda",
          "name": "unlambdaPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Unlambda.html#unlambdaPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Unlambda",
          "module": "Lambdabot.Plugin.Unlambda",
          "name": "unlambdaPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Unlambda.html#v:unlambdaPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFetch URL page titles of HTML links.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Url",
          "name": "Url",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Url.html",
          "type": "module"
        },
        "index": {
          "description": "Fetch URL page titles of HTML links",
          "hierarchy": "Lambdabot Plugin Url",
          "module": "Lambdabot.Plugin.Url",
          "name": "Url",
          "package": "lambdabot",
          "partial": "Url",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Url.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Url",
          "name": "urlPlugin",
          "package": "lambdabot",
          "signature": "Module Bool",
          "source": "src/Lambdabot-Plugin-Url.html#urlPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Url",
          "module": "Lambdabot.Plugin.Url",
          "name": "urlPlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Url.html#v:urlPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLambdabot version information\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Version",
          "name": "Version",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Version.html",
          "type": "module"
        },
        "index": {
          "description": "Lambdabot version information",
          "hierarchy": "Lambdabot Plugin Version",
          "module": "Lambdabot.Plugin.Version",
          "name": "Version",
          "package": "lambdabot",
          "partial": "Version",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Version.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Version",
          "name": "versionPlugin",
          "package": "lambdabot",
          "signature": "Module ()",
          "source": "src/Lambdabot-Plugin-Version.html#versionPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Version",
          "module": "Lambdabot.Plugin.Version",
          "name": "versionPlugin",
          "normalized": "Module()",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Version.html#v:versionPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTalk to hot chixxors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Vixen",
          "name": "Vixen",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Vixen.html",
          "type": "module"
        },
        "index": {
          "description": "Talk to hot chixxors",
          "hierarchy": "Lambdabot Plugin Vixen",
          "module": "Lambdabot.Plugin.Vixen",
          "name": "Vixen",
          "package": "lambdabot",
          "partial": "Vixen",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Vixen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Vixen",
          "name": "vixenPlugin",
          "package": "lambdabot",
          "signature": "Module (Bool, String -\u003e IO [Char])",
          "source": "src/Lambdabot-Plugin-Vixen.html#vixenPlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Vixen",
          "module": "Lambdabot.Plugin.Vixen",
          "name": "vixenPlugin",
          "normalized": "Module(Bool,String-\u003eIO[Char])",
          "package": "lambdabot",
          "partial": "Plugin",
          "signature": "Module(Bool,String-\u003eIO[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Vixen.html#v:vixenPlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSlightly specialised version of Where for associating projects with their urls.\n Code almost all copied.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Plugin.Where",
          "name": "Where",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin-Where.html",
          "type": "module"
        },
        "index": {
          "description": "Slightly specialised version of Where for associating projects with their urls Code almost all copied",
          "hierarchy": "Lambdabot Plugin Where",
          "module": "Lambdabot.Plugin.Where",
          "name": "Where",
          "package": "lambdabot",
          "partial": "Where",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Where.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin.Where",
          "name": "wherePlugin",
          "package": "lambdabot",
          "signature": "Module (Map ByteString ByteString)",
          "source": "src/Lambdabot-Plugin-Where.html#wherePlugin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin Where",
          "module": "Lambdabot.Plugin.Where",
          "name": "wherePlugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin-Where.html#v:wherePlugin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin",
          "name": "Plugin",
          "package": "lambdabot",
          "source": "src/Lambdabot-Plugin.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "Plugin",
          "package": "lambdabot",
          "partial": "Plugin",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin",
          "name": "ChanName",
          "package": "lambdabot",
          "source": "src/Lambdabot-ChanName.html#ChanName",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "ChanName",
          "package": "lambdabot",
          "partial": "Chan Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#t:ChanName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe IRC Monad. The reader transformer holds information about the\n   connection to the IRC server.\n\u003c/p\u003e\u003cp\u003einstances Monad, Functor, MonadIO, MonadState, MonadError\n\u003c/p\u003e",
          "module": "Lambdabot.Plugin",
          "name": "LB",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#LB",
          "type": "data"
        },
        "index": {
          "description": "The IRC Monad The reader transformer holds information about the connection to the IRC server instances Monad Functor MonadIO MonadState MonadError",
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "LB",
          "package": "lambdabot",
          "partial": "LB",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#t:LB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Module type class.\n\u003c/p\u003e",
          "module": "Lambdabot.Plugin",
          "name": "Module",
          "package": "lambdabot",
          "source": "src/Lambdabot-Module.html#Module",
          "type": "data"
        },
        "index": {
          "description": "The Module type class",
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "Module",
          "package": "lambdabot",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis transformer encodes the additional information a module might\n   need to access its name or its state.\n\u003c/p\u003e",
          "module": "Lambdabot.Plugin",
          "name": "ModuleT",
          "package": "lambdabot",
          "source": "src/Lambdabot-Module.html#ModuleT",
          "type": "data"
        },
        "index": {
          "description": "This transformer encodes the additional information module might need to access its name or its state",
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "ModuleT",
          "package": "lambdabot",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#t:ModuleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin",
          "name": "MonadLB",
          "package": "lambdabot",
          "source": "src/Lambdabot-Monad.html#MonadLB",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "MonadLB",
          "package": "lambdabot",
          "partial": "Monad LB",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#t:MonadLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of nicknames isolated from a message.\n\u003c/p\u003e",
          "module": "Lambdabot.Plugin",
          "name": "Nick",
          "package": "lambdabot",
          "source": "src/Lambdabot-Nick.html#Nick",
          "type": "data"
        },
        "index": {
          "description": "The type of nicknames isolated from message",
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "Nick",
          "package": "lambdabot",
          "partial": "Nick",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#t:Nick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenience, similar to ios but also cut output to channel to 80 characters\n usage:  \u003ccode\u003eprocess _ _ to _ s = ios80 to (plugs s)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Lambdabot.Plugin",
          "name": "ios80",
          "package": "lambdabot",
          "signature": "IO String -\u003e Cmd m ()",
          "source": "src/Lambdabot-Plugin.html#ios80",
          "type": "function"
        },
        "index": {
          "description": "convenience similar to ios but also cut output to channel to characters usage process to ios80 to plugs",
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "ios80",
          "normalized": "IO String-\u003eCmd a()",
          "package": "lambdabot",
          "signature": "IO String-\u003eCmd m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:ios80"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend a message to a channel/user. If the message is too long, the rest\n   of it is saved in the (global) more-state.\n\u003c/p\u003e",
          "module": "[\"Lambdabot.Plugin\",\"Lambdabot\"]",
          "name": "ircPrivmsg",
          "package": "lambdabot",
          "signature": "Nick-\u003e String-\u003e LB ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:ircPrivmsg\",\"http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircPrivmsg\"]"
        },
        "index": {
          "description": "Send message to channel user If the message is too long the rest of it is saved in the global more-state",
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "ircPrivmsg",
          "normalized": "Nick-\u003eString-\u003eLB()",
          "package": "lambdabot",
          "partial": "Privmsg",
          "signature": "Nick-\u003eString-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:ircPrivmsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin",
          "name": "lb",
          "package": "lambdabot",
          "signature": "LB a -\u003e m a",
          "source": "src/Lambdabot-Monad.html#lb",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "lb",
          "normalized": "LB a-\u003eb a",
          "package": "lambdabot",
          "signature": "LB a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:lb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Plugin",
          "name": "lim80",
          "package": "lambdabot",
          "signature": "m String -\u003e Cmd m ()",
          "source": "src/Lambdabot-Plugin.html#lim80",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Plugin",
          "module": "Lambdabot.Plugin",
          "name": "lim80",
          "normalized": "a String-\u003eCmd a()",
          "package": "lambdabot",
          "signature": "m String-\u003eCmd m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Plugin.html#v:lim80"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for the LB (LambdaBot) monad\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.State",
          "name": "State",
          "package": "lambdabot",
          "source": "src/Lambdabot-State.html",
          "type": "module"
        },
        "index": {
          "description": "Support for the LB LambdaBot monad",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "State",
          "package": "lambdabot",
          "partial": "State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis datatype allows modules to conviently maintain both global\n   (i.e. for all clients they're interacting with) and private state.\n   It is implemented on top of readMS/withMS.\n\u003c/p\u003e\u003cp\u003eThis simple implementation is linear in the number of private states used.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "GlobalPrivate",
          "package": "lambdabot",
          "source": "src/Lambdabot-State.html#GlobalPrivate",
          "type": "data"
        },
        "index": {
          "description": "This datatype allows modules to conviently maintain both global i.e for all clients they re interacting with and private state It is implemented on top of readMS withMS This simple implementation is linear in the number of private states used",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "GlobalPrivate",
          "package": "lambdabot",
          "partial": "Global Private",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#t:GlobalPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.State",
          "name": "MonadLBState",
          "package": "lambdabot",
          "source": "src/Lambdabot-State.html#MonadLBState",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "MonadLBState",
          "package": "lambdabot",
          "partial": "Monad LBState",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#t:MonadLBState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eflush state of modules\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "flushModuleState",
          "package": "lambdabot",
          "signature": "LB ()",
          "source": "src/Lambdabot-State.html#flushModuleState",
          "type": "function"
        },
        "index": {
          "description": "flush state of modules",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "flushModuleState",
          "normalized": "LB()",
          "package": "lambdabot",
          "partial": "Module State",
          "signature": "LB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:flushModuleState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a \u003ccode\u003eGlobalPrivate\u003c/code\u003e given the value of the global state. No private\n   state for clients will be created.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "mkGlobalPrivate",
          "package": "lambdabot",
          "signature": "Int -\u003e g -\u003e GlobalPrivate g p",
          "source": "src/Lambdabot-State.html#mkGlobalPrivate",
          "type": "function"
        },
        "index": {
          "description": "Creates GlobalPrivate given the value of the global state No private state for clients will be created",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "mkGlobalPrivate",
          "normalized": "Int-\u003ea-\u003eGlobalPrivate a b",
          "package": "lambdabot",
          "partial": "Global Private",
          "signature": "Int-\u003eg-\u003eGlobalPrivate g p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:mkGlobalPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the module's private state.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "modifyMS",
          "package": "lambdabot",
          "signature": "(LBState m -\u003e LBState m) -\u003e m ()",
          "source": "src/Lambdabot-State.html#modifyMS",
          "type": "function"
        },
        "index": {
          "description": "Modify the module private state",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "modifyMS",
          "normalized": "(LBState a-\u003eLBState a)-\u003ea()",
          "package": "lambdabot",
          "partial": "MS",
          "signature": "(LBState m-\u003eLBState m)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:modifyMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads global state.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "readGS",
          "package": "lambdabot",
          "signature": "m g",
          "source": "src/Lambdabot-State.html#readGS",
          "type": "function"
        },
        "index": {
          "description": "Reads global state",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "readGS",
          "package": "lambdabot",
          "partial": "GS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:readGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead it in\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "readGlobalState",
          "package": "lambdabot",
          "signature": "Module st -\u003e String -\u003e LB (Maybe st)",
          "source": "src/Lambdabot-State.html#readGlobalState",
          "type": "function"
        },
        "index": {
          "description": "Read it in",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "readGlobalState",
          "normalized": "Module a-\u003eString-\u003eLB(Maybe a)",
          "package": "lambdabot",
          "partial": "Global State",
          "signature": "Module st-\u003eString-\u003eLB(Maybe st)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:readGlobalState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the module's private state.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "readMS",
          "package": "lambdabot",
          "signature": "m (LBState m)",
          "source": "src/Lambdabot-State.html#readMS",
          "type": "function"
        },
        "index": {
          "description": "Read the module private state",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "readMS",
          "package": "lambdabot",
          "partial": "MS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:readMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads private state.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "readPS",
          "package": "lambdabot",
          "signature": "Nick -\u003e m (Maybe p)",
          "source": "src/Lambdabot-State.html#readPS",
          "type": "function"
        },
        "index": {
          "description": "Reads private state",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "readPS",
          "normalized": "Nick-\u003ea(Maybe b)",
          "package": "lambdabot",
          "partial": "PS",
          "signature": "Nick-\u003em(Maybe p)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:readPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrites global state. Locks everything\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "withGS",
          "package": "lambdabot",
          "signature": "(g -\u003e (g -\u003e m ()) -\u003e m ()) -\u003e m ()",
          "source": "src/Lambdabot-State.html#withGS",
          "type": "function"
        },
        "index": {
          "description": "Writes global state Locks everything",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "withGS",
          "normalized": "(a-\u003e(a-\u003eb())-\u003eb())-\u003eb()",
          "package": "lambdabot",
          "partial": "GS",
          "signature": "(g-\u003e(g-\u003em())-\u003em())-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:withGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the module's private state.\n This is the preferred way of changing the state. The state will be locked\n until the body returns. The function is exception-safe, i.e. even if\n an error occurs or the thread is killed (e.g. because it deadlocked and\n therefore exceeded its time limit), the state from the last write operation\n will be restored. If the writer escapes, calling it will have no observable\n effect.\n \u003ccode\u003ewithMS\u003c/code\u003e is not composable, in the sense that a readMS from within the body\n will cause a dead-lock. However, all other possibilies to access the state\n that came to my mind had even more serious deficiencies such as being prone\n to race conditions or semantic obscurities.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "withMS",
          "package": "lambdabot",
          "signature": "(LBState m -\u003e (LBState m -\u003e m ()) -\u003e m a) -\u003e m a",
          "source": "src/Lambdabot-State.html#withMS",
          "type": "method"
        },
        "index": {
          "description": "Update the module private state This is the preferred way of changing the state The state will be locked until the body returns The function is exception-safe i.e even if an error occurs or the thread is killed e.g because it deadlocked and therefore exceeded its time limit the state from the last write operation will be restored If the writer escapes calling it will have no observable effect withMS is not composable in the sense that readMS from within the body will cause dead-lock However all other possibilies to access the state that came to my mind had even more serious deficiencies such as being prone to race conditions or semantic obscurities",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "withMS",
          "normalized": "(LBState a-\u003e(LBState a-\u003ea())-\u003ea b)-\u003ea b",
          "package": "lambdabot",
          "partial": "MS",
          "signature": "(LBState m-\u003e(LBState m-\u003em())-\u003em a)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:withMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrites private state. For now, it locks everything.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "withPS",
          "package": "lambdabot",
          "signature": "Nick-\u003e (Maybe p -\u003e (Maybe p -\u003e LB ()) -\u003e LB a)-\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Writes private state For now it locks everything",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "withPS",
          "normalized": "Nick-\u003e(Maybe a-\u003e(Maybe a-\u003eLB())-\u003eLB b)-\u003ec b",
          "package": "lambdabot",
          "partial": "PS",
          "signature": "Nick-\u003e(Maybe p-\u003e(Maybe p-\u003eLB())-\u003eLB a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:withPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.State",
          "name": "writeGS",
          "package": "lambdabot",
          "signature": "g -\u003e m ()",
          "source": "src/Lambdabot-State.html#writeGS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "writeGS",
          "normalized": "a-\u003eb()",
          "package": "lambdabot",
          "partial": "GS",
          "signature": "g-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:writeGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePeristence: write the global state out\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "writeGlobalState",
          "package": "lambdabot",
          "signature": "Module st -\u003e String -\u003e ModuleT st LB ()",
          "source": "src/Lambdabot-State.html#writeGlobalState",
          "type": "function"
        },
        "index": {
          "description": "Peristence write the global state out",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "writeGlobalState",
          "normalized": "Module a-\u003eString-\u003eModuleT a LB()",
          "package": "lambdabot",
          "partial": "Global State",
          "signature": "Module st-\u003eString-\u003eModuleT st LB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:writeGlobalState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the module's private state. Try to use withMS instead.\n\u003c/p\u003e",
          "module": "Lambdabot.State",
          "name": "writeMS",
          "package": "lambdabot",
          "signature": "LBState m -\u003e m ()",
          "source": "src/Lambdabot-State.html#writeMS",
          "type": "function"
        },
        "index": {
          "description": "Write the module private state Try to use withMS instead",
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "writeMS",
          "normalized": "LBState a-\u003ea()",
          "package": "lambdabot",
          "partial": "MS",
          "signature": "LBState m-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:writeMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.State",
          "name": "writePS",
          "package": "lambdabot",
          "signature": "Nick -\u003e Maybe p -\u003e m ()",
          "source": "src/Lambdabot-State.html#writePS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot State",
          "module": "Lambdabot.State",
          "name": "writePS",
          "normalized": "Nick-\u003eMaybe a-\u003eb()",
          "package": "lambdabot",
          "partial": "PS",
          "signature": "Nick-\u003eMaybe p-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-State.html#v:writePS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eURL Utility Functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Util.Browser",
          "name": "Browser",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Browser.html",
          "type": "module"
        },
        "index": {
          "description": "URL Utility Functions",
          "hierarchy": "Lambdabot Util Browser",
          "module": "Lambdabot.Util.Browser",
          "name": "Browser",
          "package": "lambdabot",
          "partial": "Browser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Browser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a browser action with some standardized settings\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Browser",
          "name": "browseLB",
          "package": "lambdabot",
          "signature": "BrowserAction conn a -\u003e m a",
          "source": "src/Lambdabot-Util-Browser.html#browseLB",
          "type": "function"
        },
        "index": {
          "description": "Run browser action with some standardized settings",
          "hierarchy": "Lambdabot Util Browser",
          "module": "Lambdabot.Util.Browser",
          "name": "browseLB",
          "normalized": "BrowserAction a b-\u003ec b",
          "package": "lambdabot",
          "partial": "LB",
          "signature": "BrowserAction conn a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Browser.html#v:browseLB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFetches a page title suitable for display.  Ideally, other\n plugins should make use of this function if the result is to be\n displayed in an IRC channel because it ensures that a consistent\n look is used (and also lets the URL plugin effectively ignore\n contextual URLs that might be generated by another instance of\n lambdabot; the URL plugin matches on \u003ccode\u003eurlTitlePrompt\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Browser",
          "name": "urlPageTitle",
          "package": "lambdabot",
          "signature": "String -\u003e BrowserAction (HandleStream String) (Maybe String)",
          "source": "src/Lambdabot-Util-Browser.html#urlPageTitle",
          "type": "function"
        },
        "index": {
          "description": "Fetches page title suitable for display Ideally other plugins should make use of this function if the result is to be displayed in an IRC channel because it ensures that consistent look is used and also lets the URL plugin effectively ignore contextual URLs that might be generated by another instance of lambdabot the URL plugin matches on urlTitlePrompt",
          "hierarchy": "Lambdabot Util Browser",
          "module": "Lambdabot.Util.Browser",
          "name": "urlPageTitle",
          "normalized": "String-\u003eBrowserAction(HandleStream String)(Maybe String)",
          "package": "lambdabot",
          "partial": "Page Title",
          "signature": "String-\u003eBrowserAction(HandleStream String)(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Browser.html#v:urlPageTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Parser",
          "name": "Parser",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Parser.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Util Parser",
          "module": "Lambdabot.Util.Parser",
          "name": "Parser",
          "package": "lambdabot",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender haskell code in a compact format\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Parser",
          "name": "prettyPrintInLine",
          "package": "lambdabot",
          "signature": "a -\u003e String",
          "source": "src/Lambdabot-Util-Parser.html#prettyPrintInLine",
          "type": "function"
        },
        "index": {
          "description": "Render haskell code in compact format",
          "hierarchy": "Lambdabot Util Parser",
          "module": "Lambdabot.Util.Parser",
          "name": "prettyPrintInLine",
          "normalized": "a-\u003eString",
          "package": "lambdabot",
          "partial": "Print In Line",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Parser.html#v:prettyPrintInLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string as an \u003ccode\u003e\u003ca\u003eExp\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eDecl\u003c/a\u003e\u003c/code\u003e, apply the given generic transformation to it,\n and re-render it back to text.\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Parser",
          "name": "withParsed",
          "package": "lambdabot",
          "signature": "a -\u003e a) -\u003e String -\u003e String",
          "source": "src/Lambdabot-Util-Parser.html#withParsed",
          "type": "function"
        },
        "index": {
          "description": "Parse string as an Exp or Decl apply the given generic transformation to it and re-render it back to text",
          "hierarchy": "Lambdabot Util Parser",
          "module": "Lambdabot.Util.Parser",
          "name": "withParsed",
          "normalized": "a-\u003ea)-\u003eString-\u003eString",
          "package": "lambdabot",
          "partial": "Parsed",
          "signature": "a-\u003ea)-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Parser.html#v:withParsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Process",
          "name": "Process",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Process.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Lambdabot Util Process",
          "module": "Lambdabot.Util.Process",
          "name": "Process",
          "package": "lambdabot",
          "partial": "Process",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Process.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Process",
          "name": "run",
          "package": "lambdabot",
          "signature": "FilePath -\u003e String -\u003e (String -\u003e String) -\u003e IO String",
          "source": "src/Lambdabot-Util-Process.html#run",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Process",
          "module": "Lambdabot.Util.Process",
          "name": "run",
          "normalized": "FilePath-\u003eString-\u003e(String-\u003eString)-\u003eIO String",
          "package": "lambdabot",
          "signature": "FilePath-\u003eString-\u003e(String-\u003eString)-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Process.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSerialisation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Util.Serial",
          "name": "Serial",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Serial.html",
          "type": "module"
        },
        "index": {
          "description": "Serialisation",
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "Serial",
          "package": "lambdabot",
          "partial": "Serial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "Packable",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Serial.html#Packable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "Packable",
          "package": "lambdabot",
          "partial": "Packable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#t:Packable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "Serial",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Serial.html#Serial",
          "type": "data"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "Serial",
          "package": "lambdabot",
          "partial": "Serial",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#t:Serial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "Serial",
          "package": "lambdabot",
          "signature": "Serial",
          "source": "src/Lambdabot-Util-Serial.html#Serial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "Serial",
          "package": "lambdabot",
          "partial": "Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:Serial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "assocListPackedSerial",
          "package": "lambdabot",
          "signature": "Serial [(ByteString, ByteString)]",
          "source": "src/Lambdabot-Util-Serial.html#assocListPackedSerial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "assocListPackedSerial",
          "normalized": "Serial[(ByteString,ByteString)]",
          "package": "lambdabot",
          "partial": "List Packed Serial",
          "signature": "Serial[(ByteString,ByteString)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:assocListPackedSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "deserialize",
          "package": "lambdabot",
          "signature": "ByteString -\u003e Maybe s",
          "source": "src/Lambdabot-Util-Serial.html#Serial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "deserialize",
          "normalized": "ByteString-\u003eMaybe a",
          "package": "lambdabot",
          "signature": "ByteString-\u003eMaybe s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:deserialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "mapListPackedSerial",
          "package": "lambdabot",
          "signature": "Serial (Map ByteString [ByteString])",
          "source": "src/Lambdabot-Util-Serial.html#mapListPackedSerial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "mapListPackedSerial",
          "normalized": "Serial(Map ByteString[ByteString])",
          "package": "lambdabot",
          "partial": "List Packed Serial",
          "signature": "Serial(Map ByteString[ByteString])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:mapListPackedSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "mapPackedSerial",
          "package": "lambdabot",
          "signature": "Serial (Map ByteString ByteString)",
          "source": "src/Lambdabot-Util-Serial.html#mapPackedSerial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "mapPackedSerial",
          "package": "lambdabot",
          "partial": "Packed Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:mapPackedSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSerializes a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e type if both the key and the value are instances\n of Read and Show. The serialization is done by converting the map to\n and from lists. Results are saved line-wise, for better editing and\n revison control.\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Serial",
          "name": "mapSerial",
          "package": "lambdabot",
          "signature": "Serial (Map k v)",
          "source": "src/Lambdabot-Util-Serial.html#mapSerial",
          "type": "function"
        },
        "index": {
          "description": "Serializes Map type if both the key and the value are instances of Read and Show The serialization is done by converting the map to and from lists Results are saved line-wise for better editing and revison control",
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "mapSerial",
          "package": "lambdabot",
          "partial": "Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:mapSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereadM\u003c/a\u003e\u003c/code\u003e behaves like read, but catches failure in a monad.\n this allocates a 20-30 M on startup...\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Serial",
          "name": "readM",
          "package": "lambdabot",
          "signature": "String -\u003e m a",
          "source": "src/Lambdabot-Util-Serial.html#readM",
          "type": "function"
        },
        "index": {
          "description": "readM behaves like read but catches failure in monad this allocates on startup",
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "readM",
          "normalized": "String-\u003ea b",
          "package": "lambdabot",
          "signature": "String-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:readM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "readOnly",
          "package": "lambdabot",
          "signature": "(ByteString -\u003e b) -\u003e Serial b",
          "source": "src/Lambdabot-Util-Serial.html#readOnly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "readOnly",
          "normalized": "(ByteString-\u003ea)-\u003eSerial a",
          "package": "lambdabot",
          "partial": "Only",
          "signature": "(ByteString-\u003eb)-\u003eSerial b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:readOnly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "readPacked",
          "package": "lambdabot",
          "signature": "ByteString -\u003e t",
          "source": "src/Lambdabot-Util-Serial.html#readPacked",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "readPacked",
          "normalized": "ByteString-\u003ea",
          "package": "lambdabot",
          "partial": "Packed",
          "signature": "ByteString-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:readPacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "serialize",
          "package": "lambdabot",
          "signature": "s -\u003e Maybe ByteString",
          "source": "src/Lambdabot-Util-Serial.html#Serial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "serialize",
          "normalized": "a-\u003eMaybe ByteString",
          "package": "lambdabot",
          "signature": "s-\u003eMaybe ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:serialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Serial",
          "name": "showPacked",
          "package": "lambdabot",
          "signature": "t -\u003e ByteString",
          "source": "src/Lambdabot-Util-Serial.html#showPacked",
          "type": "method"
        },
        "index": {
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "showPacked",
          "normalized": "a-\u003eByteString",
          "package": "lambdabot",
          "partial": "Packed",
          "signature": "t-\u003eByteString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:showPacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault `instance' for a Serial\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Serial",
          "name": "stdSerial",
          "package": "lambdabot",
          "signature": "Serial s",
          "source": "src/Lambdabot-Util-Serial.html#stdSerial",
          "type": "function"
        },
        "index": {
          "description": "Default instance for Serial",
          "hierarchy": "Lambdabot Util Serial",
          "module": "Lambdabot.Util.Serial",
          "name": "stdSerial",
          "package": "lambdabot",
          "partial": "Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Serial.html#v:stdSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe signal story.\n Posix signals are external events that invoke signal handlers in\n Haskell. The signal handlers in turn throw dynamic exceptions.  Our\n instance of MonadError for LB maps the dynamic exceptions to\n SignalCaughts, which can then be caught by a normal catchError\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Util.Signals",
          "name": "Signals",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Signals.html",
          "type": "module"
        },
        "index": {
          "description": "The signal story Posix signals are external events that invoke signal handlers in Haskell The signal handlers in turn throw dynamic exceptions Our instance of MonadError for LB maps the dynamic exceptions to SignalCaughts which can then be caught by normal catchError",
          "hierarchy": "Lambdabot Util Signals",
          "module": "Lambdabot.Util.Signals",
          "name": "Signals",
          "package": "lambdabot",
          "partial": "Signals",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Signals.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Signals",
          "name": "Signal",
          "package": "lambdabot",
          "type": "type"
        },
        "index": {
          "hierarchy": "Lambdabot Util Signals",
          "module": "Lambdabot.Util.Signals",
          "name": "Signal",
          "package": "lambdabot",
          "partial": "Signal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Signals.html#t:Signal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Signals",
          "name": "SignalException",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util-Signals.html#SignalException",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Lambdabot Util Signals",
          "module": "Lambdabot.Util.Signals",
          "name": "SignalException",
          "package": "lambdabot",
          "partial": "Signal Exception",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Signals.html#t:SignalException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Signals",
          "name": "SignalException",
          "package": "lambdabot",
          "signature": "SignalException Signal",
          "source": "src/Lambdabot-Util-Signals.html#SignalException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Signals",
          "module": "Lambdabot.Util.Signals",
          "name": "SignalException",
          "package": "lambdabot",
          "partial": "Signal Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Signals.html#v:SignalException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util.Signals",
          "name": "ircSignalMessage",
          "package": "lambdabot",
          "signature": "Signal -\u003e String",
          "source": "src/Lambdabot-Util-Signals.html#ircSignalMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util Signals",
          "module": "Lambdabot.Util.Signals",
          "name": "ircSignalMessage",
          "normalized": "Signal-\u003eString",
          "package": "lambdabot",
          "partial": "Signal Message",
          "signature": "Signal-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Signals.html#v:ircSignalMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegister signal handlers to catch external signals\n\u003c/p\u003e",
          "module": "Lambdabot.Util.Signals",
          "name": "withIrcSignalCatch",
          "package": "lambdabot",
          "signature": "m a -\u003e m a",
          "source": "src/Lambdabot-Util-Signals.html#withIrcSignalCatch",
          "type": "function"
        },
        "index": {
          "description": "Register signal handlers to catch external signals",
          "hierarchy": "Lambdabot Util Signals",
          "module": "Lambdabot.Util.Signals",
          "name": "withIrcSignalCatch",
          "normalized": "a b-\u003ea b",
          "package": "lambdabot",
          "partial": "Irc Signal Catch",
          "signature": "m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util-Signals.html#v:withIrcSignalCatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eString and other utilities\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot.Util",
          "name": "Util",
          "package": "lambdabot",
          "source": "src/Lambdabot-Util.html",
          "type": "module"
        },
        "index": {
          "description": "String and other utilities",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "Util",
          "package": "lambdabot",
          "partial": "Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util",
          "name": "arePrefixesOf",
          "package": "lambdabot",
          "signature": "[String] -\u003e String -\u003e Bool",
          "source": "src/Lambdabot-Util.html#arePrefixesOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "arePrefixesOf",
          "normalized": "[String]-\u003eString-\u003eBool",
          "package": "lambdabot",
          "partial": "Prefixes Of",
          "signature": "[String]-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:arePrefixesOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util",
          "name": "arePrefixesWithSpaceOf",
          "package": "lambdabot",
          "signature": "[String] -\u003e String -\u003e Bool",
          "source": "src/Lambdabot-Util.html#arePrefixesWithSpaceOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "arePrefixesWithSpaceOf",
          "normalized": "[String]-\u003eString-\u003eBool",
          "package": "lambdabot",
          "partial": "Prefixes With Space Of",
          "signature": "[String]-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:arePrefixesWithSpaceOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util",
          "name": "confirmation",
          "package": "lambdabot",
          "signature": "[String]",
          "source": "src/Lambdabot-Util.html#confirmation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "confirmation",
          "normalized": "[String]",
          "package": "lambdabot",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:confirmation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util",
          "name": "dropNL",
          "package": "lambdabot",
          "signature": "[Char] -\u003e [Char]",
          "source": "src/Lambdabot-Util.html#dropNL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "dropNL",
          "normalized": "[Char]-\u003e[Char]",
          "package": "lambdabot",
          "partial": "NL",
          "signature": "[Char]-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:dropNL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edropSpace\u003c/a\u003e\u003c/code\u003e takes as input a String and strips spaces from the\n   prefix as well as the suffix of the String. Example:\n\u003c/p\u003e\u003cpre\u003e dropSpace \"   abc  \" ===\u003e \"abc\"\n\u003c/pre\u003e",
          "module": "Lambdabot.Util",
          "name": "dropSpace",
          "package": "lambdabot",
          "signature": "[Char] -\u003e [Char]",
          "source": "src/Lambdabot-Util.html#dropSpace",
          "type": "function"
        },
        "index": {
          "description": "dropSpace takes as input String and strips spaces from the prefix as well as the suffix of the String Example dropSpace abc abc",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "dropSpace",
          "normalized": "[Char]-\u003e[Char]",
          "package": "lambdabot",
          "partial": "Space",
          "signature": "[Char]-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:dropSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDrop space from the end of the string\n\u003c/p\u003e",
          "module": "Lambdabot.Util",
          "name": "dropSpaceEnd",
          "package": "lambdabot",
          "signature": "[Char] -\u003e [Char]",
          "source": "src/Lambdabot-Util.html#dropSpaceEnd",
          "type": "function"
        },
        "index": {
          "description": "Drop space from the end of the string",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "dropSpaceEnd",
          "normalized": "[Char]-\u003e[Char]",
          "package": "lambdabot",
          "partial": "Space End",
          "signature": "[Char]-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:dropSpaceEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euntab an string\n\u003c/p\u003e",
          "module": "Lambdabot.Util",
          "name": "expandTab",
          "package": "lambdabot",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Lambdabot-Util.html#expandTab",
          "type": "function"
        },
        "index": {
          "description": "untab an string",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "expandTab",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "lambdabot",
          "partial": "Tab",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:expandTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util",
          "name": "insult",
          "package": "lambdabot",
          "signature": "[String]",
          "source": "src/Lambdabot-Util.html#insult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "insult",
          "normalized": "[String]",
          "package": "lambdabot",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:insult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot.Util",
          "name": "io",
          "package": "lambdabot",
          "signature": "IO a -\u003e m a",
          "source": "src/Lambdabot-Util.html#io",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "io",
          "normalized": "IO a-\u003eb a",
          "package": "lambdabot",
          "signature": "IO a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:io"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTruncate a string to the specified length, putting ellipses at the\n end if necessary.\n\u003c/p\u003e",
          "module": "Lambdabot.Util",
          "name": "limitStr",
          "package": "lambdabot",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Lambdabot-Util.html#limitStr",
          "type": "function"
        },
        "index": {
          "description": "Truncate string to the specified length putting ellipses at the end if necessary",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "limitStr",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "lambdabot",
          "partial": "Str",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:limitStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm a list of terms using a single conjunction. Example:\n\u003c/p\u003e\u003cpre\u003e listToStr \"and\" [\"a\", \"b\", \"c\"] ===\u003e \"a, b and c\"\n\u003c/pre\u003e",
          "module": "Lambdabot.Util",
          "name": "listToStr",
          "package": "lambdabot",
          "signature": "String -\u003e [String] -\u003e String",
          "source": "src/Lambdabot-Util.html#listToStr",
          "type": "function"
        },
        "index": {
          "description": "Form list of terms using single conjunction Example listToStr and and",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "listToStr",
          "normalized": "String-\u003e[String]-\u003eString",
          "package": "lambdabot",
          "partial": "To Str",
          "signature": "String-\u003e[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:listToStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePick a random element of the list.\n\u003c/p\u003e",
          "module": "Lambdabot.Util",
          "name": "random",
          "package": "lambdabot",
          "signature": "[a] -\u003e m a",
          "source": "src/Lambdabot-Util.html#random",
          "type": "function"
        },
        "index": {
          "description": "Pick random element of the list",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "random",
          "normalized": "[a]-\u003eb a",
          "package": "lambdabot",
          "signature": "[a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:random"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshow a list without heavyweight formatting\n NB: assumes show instance outputs a quoted \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n under that assumption, strips the outer quotes.\n\u003c/p\u003e",
          "module": "Lambdabot.Util",
          "name": "showClean",
          "package": "lambdabot",
          "signature": "[a] -\u003e String",
          "source": "src/Lambdabot-Util.html#showClean",
          "type": "function"
        },
        "index": {
          "description": "show list without heavyweight formatting NB assumes show instance outputs quoted String under that assumption strips the outer quotes",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "showClean",
          "normalized": "[a]-\u003eString",
          "package": "lambdabot",
          "partial": "Clean",
          "signature": "[a]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:showClean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBreak a String into it's first word, and the rest of the string. Example:\n\u003c/p\u003e\u003cpre\u003e split_first_word \"A fine day\" ===\u003e (\"A\", \"fine day)\n\u003c/pre\u003e",
          "module": "Lambdabot.Util",
          "name": "splitFirstWord",
          "package": "lambdabot",
          "signature": "String-\u003e (String, String)",
          "type": "function"
        },
        "index": {
          "description": "Break String into it first word and the rest of the string Example split first word fine day fine day",
          "hierarchy": "Lambdabot Util",
          "module": "Lambdabot.Util",
          "name": "splitFirstWord",
          "normalized": "String-\u003e(String,String)",
          "package": "lambdabot",
          "partial": "First Word",
          "signature": "String-\u003e(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot-Util.html#v:splitFirstWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe guts of lambdabot.\n\u003c/p\u003e\u003cp\u003eThe LB/Lambdabot monad\n Generic server connection,disconnection\n The module typeclass, type and operations on modules\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Lambdabot",
          "name": "Lambdabot",
          "package": "lambdabot",
          "source": "src/Lambdabot.html",
          "type": "module"
        },
        "index": {
          "description": "The guts of lambdabot The LB Lambdabot monad Generic server connection disconnection The module typeclass type and operations on modules",
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "Lambdabot",
          "package": "lambdabot",
          "partial": "Lambdabot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if the given user is being ignored.\n   Privileged users can't be ignored.\n\u003c/p\u003e",
          "module": "Lambdabot",
          "name": "checkIgnore",
          "package": "lambdabot",
          "signature": "IrcMessage -\u003e LB Bool",
          "source": "src/Lambdabot.html#checkIgnore",
          "type": "function"
        },
        "index": {
          "description": "Checks if the given user is being ignored Privileged users can be ignored",
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "checkIgnore",
          "normalized": "IrcMessage-\u003eLB Bool",
          "package": "lambdabot",
          "partial": "Ignore",
          "signature": "IrcMessage-\u003eLB Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:checkIgnore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if the given user has admin permissions and excecute the action\n   only in this case.\n\u003c/p\u003e",
          "module": "Lambdabot",
          "name": "checkPrivs",
          "package": "lambdabot",
          "signature": "IrcMessage -\u003e LB Bool",
          "source": "src/Lambdabot.html#checkPrivs",
          "type": "function"
        },
        "index": {
          "description": "Checks if the given user has admin permissions and excecute the action only in this case",
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "checkPrivs",
          "normalized": "IrcMessage-\u003eLB Bool",
          "package": "lambdabot",
          "partial": "Privs",
          "signature": "IrcMessage-\u003eLB Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:checkPrivs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot",
          "name": "ircGetChannels",
          "package": "lambdabot",
          "signature": "LB [Nick]",
          "source": "src/Lambdabot.html#ircGetChannels",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircGetChannels",
          "normalized": "LB[Nick]",
          "package": "lambdabot",
          "partial": "Get Channels",
          "signature": "LB[Nick]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircGetChannels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot",
          "name": "ircInstallOutputFilter",
          "package": "lambdabot",
          "signature": "OutputFilter LB -\u003e ModuleT mod LB ()",
          "source": "src/Lambdabot.html#ircInstallOutputFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircInstallOutputFilter",
          "normalized": "OutputFilter LB-\u003eModuleT a LB()",
          "package": "lambdabot",
          "partial": "Install Output Filter",
          "signature": "OutputFilter LB-\u003eModuleT mod LB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircInstallOutputFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegister a module in the irc state\n\u003c/p\u003e",
          "module": "Lambdabot",
          "name": "ircLoadModule",
          "package": "lambdabot",
          "signature": "Module st -\u003e String -\u003e LB ()",
          "source": "src/Lambdabot.html#ircLoadModule",
          "type": "function"
        },
        "index": {
          "description": "Register module in the irc state",
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircLoadModule",
          "normalized": "Module a-\u003eString-\u003eLB()",
          "package": "lambdabot",
          "partial": "Load Module",
          "signature": "Module st-\u003eString-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircLoadModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot",
          "name": "ircPrivmsg'",
          "package": "lambdabot",
          "signature": "Nick -\u003e String -\u003e LB ()",
          "source": "src/Lambdabot.html#ircPrivmsg%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircPrivmsg'",
          "normalized": "Nick-\u003eString-\u003eLB()",
          "package": "lambdabot",
          "partial": "Privmsg'",
          "signature": "Nick-\u003eString-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircPrivmsg-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot",
          "name": "ircQuit",
          "package": "lambdabot",
          "signature": "String -\u003e String -\u003e LB ()",
          "source": "src/Lambdabot.html#ircQuit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircQuit",
          "normalized": "String-\u003eString-\u003eLB()",
          "package": "lambdabot",
          "partial": "Quit",
          "signature": "String-\u003eString-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircQuit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot",
          "name": "ircReconnect",
          "package": "lambdabot",
          "signature": "String -\u003e String -\u003e LB ()",
          "source": "src/Lambdabot.html#ircReconnect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircReconnect",
          "normalized": "String-\u003eString-\u003eLB()",
          "package": "lambdabot",
          "partial": "Reconnect",
          "signature": "String-\u003eString-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircReconnect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Lambdabot",
          "name": "ircSignalConnect",
          "package": "lambdabot",
          "signature": "String -\u003e Callback -\u003e ModuleT mod LB ()",
          "source": "src/Lambdabot.html#ircSignalConnect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircSignalConnect",
          "normalized": "String-\u003eCallback-\u003eModuleT a LB()",
          "package": "lambdabot",
          "partial": "Signal Connect",
          "signature": "String-\u003eCallback-\u003eModuleT mod LB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircSignalConnect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnregister a module's entry in the irc state\n\u003c/p\u003e",
          "module": "Lambdabot",
          "name": "ircUnloadModule",
          "package": "lambdabot",
          "signature": "String -\u003e LB ()",
          "source": "src/Lambdabot.html#ircUnloadModule",
          "type": "function"
        },
        "index": {
          "description": "Unregister module entry in the irc state",
          "hierarchy": "Lambdabot",
          "module": "Lambdabot",
          "name": "ircUnloadModule",
          "normalized": "String-\u003eLB()",
          "package": "lambdabot",
          "partial": "Unload Module",
          "signature": "String-\u003eLB()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdabot/docs/Lambdabot.html#v:ircUnloadModule"
      }
    }
  ]
]