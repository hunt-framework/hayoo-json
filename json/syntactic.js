[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "syntactic"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn alternative to \u003ca\u003eData.Dynamic\u003c/a\u003e with a different constraint on \u003ccode\u003e\u003ca\u003etoDyn\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.DynamicAlt",
          "name": "DynamicAlt",
          "package": "syntactic",
          "source": "src/Data-DynamicAlt.html",
          "type": "module"
        },
        "index": {
          "description": "An alternative to Data.Dynamic with different constraint on toDyn",
          "hierarchy": "Data DynamicAlt",
          "module": "Data.DynamicAlt",
          "name": "DynamicAlt",
          "package": "syntactic",
          "partial": "Dynamic Alt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-DynamicAlt.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DynamicAlt",
          "name": "Dynamic",
          "package": "syntactic",
          "source": "src/Data-DynamicAlt.html#Dynamic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data DynamicAlt",
          "module": "Data.DynamicAlt",
          "name": "Dynamic",
          "package": "syntactic",
          "partial": "Dynamic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-DynamicAlt.html#t:Dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DynamicAlt",
          "name": "Dynamic",
          "package": "syntactic",
          "signature": "Dynamic TypeRep Any",
          "source": "src/Data-DynamicAlt.html#Dynamic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DynamicAlt",
          "module": "Data.DynamicAlt",
          "name": "Dynamic",
          "package": "syntactic",
          "partial": "Dynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-DynamicAlt.html#v:Dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DynamicAlt",
          "name": "fromDyn",
          "package": "syntactic",
          "signature": "Dynamic -\u003e Maybe a",
          "source": "src/Data-DynamicAlt.html#fromDyn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DynamicAlt",
          "module": "Data.DynamicAlt",
          "name": "fromDyn",
          "normalized": "Dynamic-\u003eMaybe a",
          "package": "syntactic",
          "partial": "Dyn",
          "signature": "Dynamic-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-DynamicAlt.html#v:fromDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.DynamicAlt",
          "name": "toDyn",
          "package": "syntactic",
          "signature": "P (a -\u003e b) -\u003e a -\u003e Dynamic",
          "source": "src/Data-DynamicAlt.html#toDyn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data DynamicAlt",
          "module": "Data.DynamicAlt",
          "name": "toDyn",
          "normalized": "P(a-\u003eb)-\u003ea-\u003eDynamic",
          "package": "syntactic",
          "partial": "Dyn",
          "signature": "P(a-\u003eb)-\u003ea-\u003eDynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-DynamicAlt.html#v:toDyn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.PolyProxy",
          "name": "PolyProxy",
          "package": "syntactic",
          "source": "src/Data-PolyProxy.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data PolyProxy",
          "module": "Data.PolyProxy",
          "name": "PolyProxy",
          "package": "syntactic",
          "partial": "Poly Proxy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-PolyProxy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind-polymorphic proxy type\n\u003c/p\u003e",
          "module": "Data.PolyProxy",
          "name": "P",
          "package": "syntactic",
          "source": "src/Data-PolyProxy.html#P",
          "type": "data"
        },
        "index": {
          "description": "Kind-polymorphic proxy type",
          "hierarchy": "Data PolyProxy",
          "module": "Data.PolyProxy",
          "name": "P",
          "package": "syntactic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-PolyProxy.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.PolyProxy",
          "name": "P",
          "package": "syntactic",
          "signature": "P a",
          "source": "src/Data-PolyProxy.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data PolyProxy",
          "module": "Data.PolyProxy",
          "name": "P",
          "package": "syntactic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Data-PolyProxy.html#v:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType-constrained syntax trees\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "Constraint",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html",
          "type": "module"
        },
        "index": {
          "description": "Type-constrained syntax trees",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "Constraint",
          "package": "syntactic",
          "partial": "Constraint",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstrain the result type of the expression by the given predicate\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": ":|",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#%3A%7C",
          "type": "data"
        },
        "index": {
          "description": "Constrain the result type of the expression by the given predicate",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": ":|",
          "package": "syntactic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t::-124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstrain the result type of the expression by the given predicate\n\u003c/p\u003e\u003cp\u003eThe difference between \u003ccode\u003e\u003ca\u003e:||\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e:|\u003c/a\u003e\u003c/code\u003e is seen in the instances of the \u003ccode\u003e\u003ca\u003eSat\u003c/a\u003e\u003c/code\u003e\n type:\n\u003c/p\u003e\u003cpre\u003e type Sat (dom :|  pred) = pred :/\\: Sat dom\n type Sat (dom :|| pred) = pred\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": ":||",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#%3A%7C%7C",
          "type": "data"
        },
        "index": {
          "description": "Constrain the result type of the expression by the given predicate The difference between and is seen in the instances of the Sat type type Sat dom pred pred Sat dom type Sat dom pred pred",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": ":||",
          "package": "syntactic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t::-124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersection of type predicates\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": ":/\\:",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#%3A%2F%5C%3A",
          "type": "class"
        },
        "index": {
          "description": "Intersection of type predicates",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": ":/\\:",
          "package": "syntactic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t::-47--92-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubset relation on type predicates\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": ":\u003c",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#%3A%3C",
          "type": "class"
        },
        "index": {
          "description": "Subset relation on type predicates",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": ":\u003c",
          "package": "syntactic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t::-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e with bounded existentially quantified result type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "ASTB",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#ASTB",
          "type": "data"
        },
        "index": {
          "description": "AST with bounded existentially quantified result type",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "ASTB",
          "package": "syntactic",
          "partial": "ASTB",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:ASTB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e with existentially quantified result type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "ASTE",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#ASTE",
          "type": "data"
        },
        "index": {
          "description": "AST with existentially quantified result type",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "ASTE",
          "package": "syntactic",
          "partial": "ASTE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:ASTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "ASTSAT",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#ASTSAT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "ASTSAT",
          "package": "syntactic",
          "partial": "ASTSAT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:ASTSAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpressions that constrain their result types\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "Constrained",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#Constrained",
          "type": "class"
        },
        "index": {
          "description": "Expressions that constrain their result types",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "Constrained",
          "package": "syntactic",
          "partial": "Constrained",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:Constrained"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "ConstrainedBy",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#ConstrainedBy",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "ConstrainedBy",
          "package": "syntactic",
          "partial": "Constrained By",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:ConstrainedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty symbol type\n\u003c/p\u003e\u003cp\u003eUse-case:\n\u003c/p\u003e\u003cpre\u003e data A a\n data B a\n\n test :: AST (A :+: (B:||Eq) :+: Empty) a\n test = injC (undefined :: (B :|| Eq) a)\n\u003c/pre\u003e\u003cp\u003eWithout \u003ccode\u003e\u003ca\u003eEmpty\u003c/a\u003e\u003c/code\u003e, this would lead to an overlapping instance error due to the instances\n\u003c/p\u003e\u003cpre\u003e InjectC (B :|| Eq) (B :|| Eq) (DenResult a)\n\u003c/pre\u003e\u003cp\u003eand\n\u003c/p\u003e\u003cpre\u003e InjectC sub sup a, pred a) =\u003e InjectC sub (sup :|| pred) a\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "Empty",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#Empty",
          "type": "data"
        },
        "index": {
          "description": "Empty symbol type Use-case data data test AST Eq Empty test injC undefined Eq Without Empty this would lead to an overlapping instance error due to the instances InjectC Eq Eq DenResult and InjectC sub sup pred InjectC sub sup pred",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "Empty",
          "package": "syntactic",
          "partial": "Empty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymbol injection (like \u003ccode\u003e\u003ca\u003e:\u003c:\u003c/a\u003e\u003c/code\u003e) with constrained result types\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "InjectC",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#InjectC",
          "type": "class"
        },
        "index": {
          "description": "Symbol injection like with constrained result types",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "InjectC",
          "package": "syntactic",
          "partial": "Inject",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:InjectC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvidence that the predicate \u003ccode\u003esub\u003c/code\u003e is a subset of \u003ccode\u003esup\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "Sub",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#Sub",
          "type": "type"
        },
        "index": {
          "description": "Evidence that the predicate sub is subset of sup",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "Sub",
          "package": "syntactic",
          "partial": "Sub",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:Sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003e:||\u003c/a\u003e\u003c/code\u003e, but rather than constraining the whole result type, it assumes a result\n type of the form \u003ccode\u003ec a\u003c/code\u003e and constrains the \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr1",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#SubConstr1",
          "type": "data"
        },
        "index": {
          "description": "Similar to but rather than constraining the whole result type it assumes result type of the form and constrains the",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr1",
          "package": "syntactic",
          "partial": "Sub Constr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:SubConstr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eSubConstr1\u003c/a\u003e\u003c/code\u003e, but assumes a result type of the form \u003ccode\u003ec a b\u003c/code\u003e and constrains both \u003ccode\u003ea\u003c/code\u003e\n and \u003ccode\u003eb\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr2",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#SubConstr2",
          "type": "data"
        },
        "index": {
          "description": "Similar to SubConstr1 but assumes result type of the form and constrains both and",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr2",
          "package": "syntactic",
          "partial": "Sub Constr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:SubConstr2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniversal type predicate\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "Top",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constraint.html#Top",
          "type": "class"
        },
        "index": {
          "description": "Universal type predicate",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "Top",
          "package": "syntactic",
          "partial": "Top",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#t:Top"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "ASTB",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e ASTB dom p",
          "source": "src/Language-Syntactic-Constraint.html#ASTB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "ASTB",
          "normalized": "ASTF a b-\u003eASTB a c",
          "package": "syntactic",
          "partial": "ASTB",
          "signature": "ASTF dom a-\u003eASTB dom p",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:ASTB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "ASTE",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e ASTE dom",
          "source": "src/Language-Syntactic-Constraint.html#ASTE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "ASTE",
          "normalized": "ASTF a b-\u003eASTE a",
          "package": "syntactic",
          "partial": "ASTE",
          "signature": "ASTF dom a-\u003eASTE dom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:ASTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "C",
          "package": "syntactic",
          "signature": "expr sig -\u003e (expr :| pred) sig",
          "source": "src/Language-Syntactic-Constraint.html#%3A%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "C",
          "normalized": "a b-\u003e(a c)b",
          "package": "syntactic",
          "signature": "expr sig-\u003e(expr pred)sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "C'",
          "package": "syntactic",
          "signature": "expr sig -\u003e (expr :|| pred) sig",
          "source": "src/Language-Syntactic-Constraint.html#%3A%7C%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "C'",
          "normalized": "a b-\u003e(a c)b",
          "package": "syntactic",
          "partial": "C'",
          "signature": "expr sig-\u003e(expr pred)sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:C-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr1",
          "package": "syntactic",
          "signature": "dom sig -\u003e SubConstr1 c dom p sig",
          "source": "src/Language-Syntactic-Constraint.html#SubConstr1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr1",
          "normalized": "a b-\u003eSubConstr c a d b",
          "package": "syntactic",
          "partial": "Sub Constr",
          "signature": "dom sig-\u003eSubConstr c dom p sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:SubConstr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr2",
          "package": "syntactic",
          "signature": "dom sig -\u003e SubConstr2 c dom pa pb sig",
          "source": "src/Language-Syntactic-Constraint.html#SubConstr2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "SubConstr2",
          "normalized": "a b-\u003eSubConstr c a d e b",
          "package": "syntactic",
          "partial": "Sub Constr",
          "signature": "dom sig-\u003eSubConstr c dom pa pb sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:SubConstr2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric symbol application\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eappSymC\u003c/a\u003e\u003c/code\u003e has any type of the form:\n\u003c/p\u003e\u003cpre\u003e appSymC :: InjectC expr (AST dom) x\n     =\u003e expr (a :-\u003e b :-\u003e ... :-\u003e Full x)\n     -\u003e (ASTF dom a -\u003e ASTF dom b -\u003e ... -\u003e ASTF dom x)\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "appSymC",
          "package": "syntactic",
          "signature": "sym sig -\u003e f",
          "source": "src/Language-Syntactic-Constraint.html#appSymC",
          "type": "function"
        },
        "index": {
          "description": "Generic symbol application appSymC has any type of the form appSymC InjectC expr AST dom expr Full ASTF dom ASTF dom ASTF dom",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "appSymC",
          "normalized": "a b-\u003ec",
          "package": "syntactic",
          "partial": "Sym",
          "signature": "sym sig-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:appSymC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a constraint on the result type of an expression\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "exprDict",
          "package": "syntactic",
          "signature": "expr a -\u003e Dict (Sat expr (DenResult a))",
          "source": "src/Language-Syntactic-Constraint.html#exprDict",
          "type": "method"
        },
        "index": {
          "description": "Compute constraint on the result type of an expression",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "exprDict",
          "normalized": "a b-\u003eDict(Sat a(DenResult b))",
          "package": "syntactic",
          "partial": "Dict",
          "signature": "expr a-\u003eDict(Sat expr(DenResult a))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:exprDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003eexprDict\u003c/a\u003e\u003c/code\u003e that works for domains of the form\n \u003ccode\u003e(dom1 :+: dom2)\u003c/code\u003e as long as \u003ccode\u003e(Sat dom1 ~ Sat dom2)\u003c/code\u003e holds\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "exprDictPlus",
          "package": "syntactic",
          "signature": "AST (dom1 :+: dom2) a -\u003e Dict (Sat dom1 (DenResult a))",
          "source": "src/Language-Syntactic-Constraint.html#exprDictPlus",
          "type": "function"
        },
        "index": {
          "description": "version of exprDict that works for domains of the form dom1 dom2 as long as Sat dom1 Sat dom2 holds",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "exprDictPlus",
          "normalized": "AST(a a)b-\u003eDict(Sat a(DenResult b))",
          "package": "syntactic",
          "partial": "Dict Plus",
          "signature": "AST(dom dom)a-\u003eDict(Sat dom(DenResult a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:exprDictPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003eexprDict\u003c/a\u003e\u003c/code\u003e that returns a constraint for a particular\n predicate \u003ccode\u003ep\u003c/code\u003e as long as \u003ccode\u003e(p :\u003c Sat dom)\u003c/code\u003e holds\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "exprDictSub",
          "package": "syntactic",
          "signature": "P p -\u003e expr a -\u003e Dict (p (DenResult a))",
          "source": "src/Language-Syntactic-Constraint.html#exprDictSub",
          "type": "function"
        },
        "index": {
          "description": "version of exprDict that returns constraint for particular predicate as long as Sat dom holds",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "exprDictSub",
          "normalized": "P a-\u003eb c-\u003eDict(a(DenResult c))",
          "package": "syntactic",
          "partial": "Dict Sub",
          "signature": "P p-\u003eexpr a-\u003eDict(p(DenResult a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:exprDictSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "injC",
          "package": "syntactic",
          "signature": "sub sig -\u003e sup sig",
          "source": "src/Language-Syntactic-Constraint.html#injC",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "injC",
          "normalized": "a b-\u003ec b",
          "package": "syntactic",
          "signature": "sub sig-\u003esup sig",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:injC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTB",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e b) -\u003e ASTB dom p -\u003e b",
          "source": "src/Language-Syntactic-Constraint.html#liftASTB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTB",
          "normalized": "ASTF a b-\u003ec)-\u003eASTB a d-\u003ec",
          "package": "syntactic",
          "partial": "ASTB",
          "signature": "ASTF dom a-\u003eb)-\u003eASTB dom p-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:liftASTB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTB2",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e ASTF dom b -\u003e c) -\u003e ASTB dom p -\u003e ASTB dom p -\u003e c",
          "source": "src/Language-Syntactic-Constraint.html#liftASTB2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTB2",
          "normalized": "ASTF a b-\u003eASTF a c-\u003ed)-\u003eASTB a e-\u003eASTB a e-\u003ed",
          "package": "syntactic",
          "partial": "ASTB",
          "signature": "ASTF dom a-\u003eASTF dom b-\u003ec)-\u003eASTB dom p-\u003eASTB dom p-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:liftASTB2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTE",
          "package": "syntactic",
          "signature": "(forall a.  ASTF dom a -\u003e b) -\u003e ASTE dom -\u003e b",
          "source": "src/Language-Syntactic-Constraint.html#liftASTE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTE",
          "normalized": "(a b ASTF c d-\u003ee)-\u003eASTE c-\u003ee",
          "package": "syntactic",
          "partial": "ASTE",
          "signature": "(forall a. ASTF dom a-\u003eb)-\u003eASTE dom-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:liftASTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTE2",
          "package": "syntactic",
          "signature": "(forall a b.  ASTF dom a -\u003e ASTF dom b -\u003e c) -\u003e ASTE dom -\u003e ASTE dom -\u003e c",
          "source": "src/Language-Syntactic-Constraint.html#liftASTE2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "liftASTE2",
          "normalized": "(a b c ASTF d b-\u003eASTF d e-\u003ef)-\u003eASTE d-\u003eASTE d-\u003ef",
          "package": "syntactic",
          "partial": "ASTE",
          "signature": "(forall a b. ASTF dom a-\u003eASTF dom b-\u003ec)-\u003eASTE dom-\u003eASTE dom-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:liftASTE2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "pTop",
          "package": "syntactic",
          "signature": "P Top",
          "source": "src/Language-Syntactic-Constraint.html#pTop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "pTop",
          "package": "syntactic",
          "partial": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:pTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "pTypeable",
          "package": "syntactic",
          "signature": "P Typeable",
          "source": "src/Language-Syntactic-Constraint.html#pTypeable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "pTypeable",
          "package": "syntactic",
          "partial": "Typeable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:pTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute evidence that \u003ccode\u003esub\u003c/code\u003e is a subset of \u003ccode\u003esup\u003c/code\u003e (i.e. that \u003ccode\u003e(sup a)\u003c/code\u003e\n implies \u003ccode\u003e(sub a)\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "sub",
          "package": "syntactic",
          "signature": "Sub sub sup",
          "source": "src/Language-Syntactic-Constraint.html#sub",
          "type": "method"
        },
        "index": {
          "description": "Compute evidence that sub is subset of sup i.e that sup implies sub",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "sub",
          "package": "syntactic",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constraint",
          "name": "universe",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e [ASTE dom]",
          "source": "src/Language-Syntactic-Constraint.html#universe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "universe",
          "normalized": "ASTF a b-\u003e[ASTE a]",
          "package": "syntactic",
          "signature": "ASTF dom a-\u003e[ASTE dom]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:universe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeaken an intersection\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "weakL",
          "package": "syntactic",
          "signature": "Sub (c1 :/\\: c2) c1",
          "source": "src/Language-Syntactic-Constraint.html#weakL",
          "type": "function"
        },
        "index": {
          "description": "Weaken an intersection",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "weakL",
          "package": "syntactic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:weakL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeaken an intersection\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constraint",
          "name": "weakR",
          "package": "syntactic",
          "signature": "Sub (c1 :/\\: c2) c2",
          "source": "src/Language-Syntactic-Constraint.html#weakR",
          "type": "function"
        },
        "index": {
          "description": "Weaken an intersection",
          "hierarchy": "Language Syntactic Constraint",
          "module": "Language.Syntactic.Constraint",
          "name": "weakR",
          "package": "syntactic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constraint.html#v:weakR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides binding constructs using higher-order syntax and a\n function (\u003ccode\u003e\u003ca\u003ereify\u003c/a\u003e\u003c/code\u003e) for translating to first-order syntax. Expressions\n constructed using the exported interface (specifically, not introducing\n \u003ccode\u003e\u003ca\u003eVariable\u003c/a\u003e\u003c/code\u003es explicitly) are guaranteed to have well-behaved translation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HigherOrder",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides binding constructs using higher-order syntax and function reify for translating to first-order syntax Expressions constructed using the exported interface specifically not introducing Variable explicitly are guaranteed to have well-behaved translation",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HigherOrder",
          "package": "syntactic",
          "partial": "Higher Order",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eLambda\u003c/a\u003e\u003c/code\u003e with a constraint on the bound variable type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "CLambda",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#CLambda",
          "type": "type"
        },
        "index": {
          "description": "Lambda with constraint on the bound variable type",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "CLambda",
          "package": "syntactic",
          "partial": "CLambda",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#t:CLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003e\u003ca\u003eHODomain\u003c/a\u003e\u003c/code\u003e (including type constraints), but using a first-order representation\n of binding\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "FODomain",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#FODomain",
          "type": "type"
        },
        "index": {
          "description": "Equivalent to HODomain including type constraints but using first-order representation of binding",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "FODomain",
          "package": "syntactic",
          "partial": "FODomain",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#t:FODomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdding support for higher-order abstract syntax to a domain\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HODomain",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#HODomain",
          "type": "type"
        },
        "index": {
          "description": "Adding support for higher-order abstract syntax to domain",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HODomain",
          "package": "syntactic",
          "partial": "HODomain",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#t:HODomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHigher-order lambda binding\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HOLambda",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#HOLambda",
          "type": "data"
        },
        "index": {
          "description": "Higher-order lambda binding",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HOLambda",
          "package": "syntactic",
          "partial": "HOLambda",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#t:HOLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstraction of \u003ccode\u003e\u003ca\u003eHODomain\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "IsHODomain",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#IsHODomain",
          "type": "class"
        },
        "index": {
          "description": "An abstraction of HODomain",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "IsHODomain",
          "package": "syntactic",
          "partial": "Is HODomain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#t:IsHODomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLet binding\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eLet\u003c/a\u003e\u003c/code\u003e is just an application operator with flipped argument order. The argument\n \u003ccode\u003e(a -\u003e b)\u003c/code\u003e is preferably constructed by \u003ccode\u003e\u003ca\u003eLambda\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "Let",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Let",
          "type": "data"
        },
        "index": {
          "description": "Let binding Let is just an application operator with flipped argument order The argument is preferably constructed by Lambda",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "Let",
          "package": "syntactic",
          "partial": "Let",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#t:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariables\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "Variable",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Variable",
          "type": "data"
        },
        "index": {
          "description": "Variables",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "Variable",
          "package": "syntactic",
          "partial": "Variable",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#t:Variable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HOLambda",
          "package": "syntactic",
          "signature": "(ASTF (HODomain dom p pVar) a -\u003e ASTF (HODomain dom p pVar) b) -\u003e HOLambda dom p pVar (Full (a -\u003e b))",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#HOLambda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "HOLambda",
          "normalized": "(ASTF(HODomain a b c)d-\u003eASTF(HODomain a b c)e)-\u003eHOLambda a b c(Full(d-\u003ee))",
          "package": "syntactic",
          "partial": "HOLambda",
          "signature": "(ASTF(HODomain dom p pVar)a-\u003eASTF(HODomain dom p pVar)b)-\u003eHOLambda dom p pVar(Full(a-\u003eb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#v:HOLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Syntactic.Constructs.Binding.HigherOrder\",\"Language.Syntactic.Constructs.Binding\"]",
          "name": "Let",
          "package": "syntactic",
          "signature": "Let (a :-\u003e ((a -\u003e b) :-\u003e Full b))",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Let",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#v:Let\",\"http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:Let\"]"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "Let",
          "normalized": "Let(a-\u003e((a-\u003eb)-\u003eFull b))",
          "package": "syntactic",
          "partial": "Let",
          "signature": "Let(a-\u003e((a-\u003eb)-\u003eFull b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#v:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "lambda",
          "package": "syntactic",
          "signature": "(ASTF dom a -\u003e ASTF dom b) -\u003e ASTF dom (a -\u003e b)",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#lambda",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "lambda",
          "normalized": "(ASTF a b-\u003eASTF a c)-\u003eASTF a(b-\u003ec)",
          "package": "syntactic",
          "signature": "(ASTF dom a-\u003eASTF dom b)-\u003eASTF dom(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#v:lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify an n-ary syntactic function\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "reify",
          "package": "syntactic",
          "signature": "a -\u003e ASTF (FODomain dom p pVar) (Internal a)",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#reify",
          "type": "function"
        },
        "index": {
          "description": "Reify an n-ary syntactic function",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "reify",
          "normalized": "a-\u003eASTF(FODomain b c d)(Internal a)",
          "package": "syntactic",
          "signature": "a-\u003eASTF(FODomain dom p pVar)(Internal a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#v:reify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "reifyM",
          "package": "syntactic",
          "signature": "forall dom p pVar a.  AST (HODomain dom p pVar) a -\u003e State VarId (AST (FODomain dom p pVar) a)",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#reifyM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "reifyM",
          "normalized": "a b c d e AST(HODomain b c d)f-\u003eState VarId(AST(FODomain b c d)f)",
          "package": "syntactic",
          "signature": "forall dom p pVar a. AST(HODomain dom p pVar)a-\u003eState VarId(AST(FODomain dom p pVar)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#v:reifyM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslating expressions with higher-order binding to corresponding\n expressions using first-order binding\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "reifyTop",
          "package": "syntactic",
          "signature": "AST (HODomain dom p pVar) a -\u003e AST (FODomain dom p pVar) a",
          "source": "src/Language-Syntactic-Constructs-Binding-HigherOrder.html#reifyTop",
          "type": "function"
        },
        "index": {
          "description": "Translating expressions with higher-order binding to corresponding expressions using first-order binding",
          "hierarchy": "Language Syntactic Constructs Binding HigherOrder",
          "module": "Language.Syntactic.Constructs.Binding.HigherOrder",
          "name": "reifyTop",
          "normalized": "AST(HODomain a b c)d-\u003eAST(FODomain a b c)d",
          "package": "syntactic",
          "partial": "Top",
          "signature": "AST(HODomain dom p pVar)a-\u003eAST(FODomain dom p pVar)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-HigherOrder.html#v:reifyTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic optimization\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "Optimize",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html",
          "type": "module"
        },
        "index": {
          "description": "Basic optimization",
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "Optimize",
          "package": "syntactic",
          "partial": "Optimize",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant folder\n\u003c/p\u003e\u003cp\u003eGiven an expression and the statically known value of that expression,\n returns a (possibly) new expression with the same meaning as the original.\n Typically, the result will be a \u003ccode\u003e\u003ca\u003eLiteral\u003c/a\u003e\u003c/code\u003e, if the relevant type constraints\n are satisfied.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "ConstFolder",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html#ConstFolder",
          "type": "type"
        },
        "index": {
          "description": "Constant folder Given an expression and the statically known value of that expression returns possibly new expression with the same meaning as the original Typically the result will be Literal if the relevant type constraints are satisfied",
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "ConstFolder",
          "package": "syntactic",
          "partial": "Const Folder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#t:ConstFolder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic optimization\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "Optimize",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html#Optimize",
          "type": "class"
        },
        "index": {
          "description": "Basic optimization",
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "Optimize",
          "package": "syntactic",
          "partial": "Optimize",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#t:Optimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "Optimize'",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html#Optimize%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "Optimize'",
          "package": "syntactic",
          "partial": "Optimize'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#t:Optimize-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptimize an expression\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimize",
          "package": "syntactic",
          "signature": "ConstFolder dom -\u003e ASTF dom a -\u003e ASTF dom a",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html#optimize",
          "type": "function"
        },
        "index": {
          "description": "Optimize an expression",
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimize",
          "normalized": "ConstFolder a-\u003eASTF a b-\u003eASTF a b",
          "package": "syntactic",
          "signature": "ConstFolder dom-\u003eASTF dom a-\u003eASTF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#v:optimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimizeM",
          "package": "syntactic",
          "signature": "ConstFolder dom -\u003e ASTF dom a -\u003e Writer (Set VarId) (ASTF dom a)",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html#optimizeM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimizeM",
          "normalized": "ConstFolder a-\u003eASTF a b-\u003eWriter(Set VarId)(ASTF a b)",
          "package": "syntactic",
          "signature": "ConstFolder dom-\u003eASTF dom a-\u003eWriter(Set VarId)(ASTF dom a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#v:optimizeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBottom-up optimization of an expression. The optimization performed is\n up to each instance, but the intention is to provide a sensible set of\n \"always-appropriate\" optimizations. The default implementation\n \u003ccode\u003e\u003ca\u003eoptimizeSymDefault\u003c/a\u003e\u003c/code\u003e does only constant folding. This constant folding\n uses the set of free variables to know when it's static evaluation is\n possible. Thus it is possible to help constant folding of other\n constructs by pruning away parts of the syntax tree that are known not to\n be needed. For example, by replacing (using ordinary Haskell as an\n example)\n\u003c/p\u003e\u003cpre\u003e if True then a else b\n\u003c/pre\u003e\u003cp\u003ewith \u003ccode\u003ea\u003c/code\u003e, we don't need to report the free variables in \u003ccode\u003eb\u003c/code\u003e. This, in\n turn, can lead to more constant folding higher up in the expression.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimizeSym",
          "package": "syntactic",
          "signature": "ConstFolder dom -\u003e (sym sig -\u003e AST dom sig) -\u003e sym sig -\u003e Args (AST dom) sig -\u003e Writer (Set VarId) (ASTF dom (DenResult sig))",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html#optimizeSym",
          "type": "method"
        },
        "index": {
          "description": "Bottom-up optimization of an expression The optimization performed is up to each instance but the intention is to provide sensible set of always-appropriate optimizations The default implementation optimizeSymDefault does only constant folding This constant folding uses the set of free variables to know when it static evaluation is possible Thus it is possible to help constant folding of other constructs by pruning away parts of the syntax tree that are known not to be needed For example by replacing using ordinary Haskell as an example if True then else with we don need to report the free variables in This in turn can lead to more constant folding higher up in the expression",
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimizeSym",
          "normalized": "ConstFolder a-\u003e(b c-\u003eAST a c)-\u003eb c-\u003eArgs(AST a)c-\u003eWriter(Set VarId)(ASTF a(DenResult c))",
          "package": "syntactic",
          "partial": "Sym",
          "signature": "ConstFolder dom-\u003e(sym sig-\u003eAST dom sig)-\u003esym sig-\u003eArgs(AST dom)sig-\u003eWriter(Set VarId)(ASTF dom(DenResult sig))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#v:optimizeSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient default implementation of \u003ccode\u003e\u003ca\u003eoptimizeSym\u003c/a\u003e\u003c/code\u003e (uses \u003ccode\u003e\u003ca\u003eevalBind\u003c/a\u003e\u003c/code\u003e to\n partially evaluate)\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimizeSymDefault",
          "package": "syntactic",
          "signature": "ConstFolder dom -\u003e (sym sig -\u003e AST dom sig) -\u003e sym sig -\u003e Args (AST dom) sig -\u003e Writer (Set VarId) (ASTF dom (DenResult sig))",
          "source": "src/Language-Syntactic-Constructs-Binding-Optimize.html#optimizeSymDefault",
          "type": "function"
        },
        "index": {
          "description": "Convenient default implementation of optimizeSym uses evalBind to partially evaluate",
          "hierarchy": "Language Syntactic Constructs Binding Optimize",
          "module": "Language.Syntactic.Constructs.Binding.Optimize",
          "name": "optimizeSymDefault",
          "normalized": "ConstFolder a-\u003e(b c-\u003eAST a c)-\u003eb c-\u003eArgs(AST a)c-\u003eWriter(Set VarId)(ASTF a(DenResult c))",
          "package": "syntactic",
          "partial": "Sym Default",
          "signature": "ConstFolder dom-\u003e(sym sig-\u003eAST dom sig)-\u003esym sig-\u003eArgs(AST dom)sig-\u003eWriter(Set VarId)(ASTF dom(DenResult sig))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding-Optimize.html#v:optimizeSymDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneral binding constructs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Binding",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html",
          "type": "module"
        },
        "index": {
          "description": "General binding constructs",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Binding",
          "package": "syntactic",
          "partial": "Binding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlpha-equivalence\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "AlphaEq",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#AlphaEq",
          "type": "class"
        },
        "index": {
          "description": "Alpha-equivalence",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "AlphaEq",
          "package": "syntactic",
          "partial": "Alpha Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#t:AlphaEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluation of expressions with variables\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "EvalBind",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#EvalBind",
          "type": "class"
        },
        "index": {
          "description": "Evaluation of expressions with variables",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "EvalBind",
          "package": "syntactic",
          "partial": "Eval Bind",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#t:EvalBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLambda binding\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Lambda",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Lambda",
          "type": "data"
        },
        "index": {
          "description": "Lambda binding",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Lambda",
          "package": "syntactic",
          "partial": "Lambda",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#t:Lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLet binding\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eLet\u003c/a\u003e\u003c/code\u003e is just an application operator with flipped argument order. The argument\n \u003ccode\u003e(a -\u003e b)\u003c/code\u003e is preferably constructed by \u003ccode\u003e\u003ca\u003eLambda\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Let",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Let",
          "type": "data"
        },
        "index": {
          "description": "Let binding Let is just an application operator with flipped argument order The argument is preferably constructed by Lambda",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Let",
          "package": "syntactic",
          "partial": "Let",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#t:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironments containing a list of variable equivalences\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "VarEqEnv",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#VarEqEnv",
          "type": "class"
        },
        "index": {
          "description": "Environments containing list of variable equivalences",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "VarEqEnv",
          "package": "syntactic",
          "partial": "Var Eq Env",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#t:VarEqEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable identifier\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "VarId",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#VarId",
          "type": "newtype"
        },
        "index": {
          "description": "Variable identifier",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "VarId",
          "package": "syntactic",
          "partial": "Var Id",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#t:VarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariables\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Variable",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Variable",
          "type": "data"
        },
        "index": {
          "description": "Variables",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Variable",
          "package": "syntactic",
          "partial": "Variable",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#t:Variable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Lambda",
          "package": "syntactic",
          "signature": "VarId -\u003e Lambda (b :-\u003e Full (a -\u003e b))",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Lambda",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Lambda",
          "normalized": "VarId-\u003eLambda(a-\u003eFull(b-\u003ea))",
          "package": "syntactic",
          "partial": "Lambda",
          "signature": "VarId-\u003eLambda(b-\u003eFull(a-\u003eb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:Lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "VarId",
          "package": "syntactic",
          "signature": "VarId",
          "source": "src/Language-Syntactic-Constructs-Binding.html#VarId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "VarId",
          "package": "syntactic",
          "partial": "Var Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:VarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Variable",
          "package": "syntactic",
          "signature": "VarId -\u003e Variable (Full a)",
          "source": "src/Language-Syntactic-Constructs-Binding.html#Variable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "Variable",
          "normalized": "VarId-\u003eVariable(Full a)",
          "package": "syntactic",
          "partial": "Variable",
          "signature": "VarId-\u003eVariable(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:Variable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlpha-equivalence on lambda expressions. Free variables are taken to be\n equivalent if they have the same identifier.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEq",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e ASTF dom b -\u003e Bool",
          "source": "src/Language-Syntactic-Constructs-Binding.html#alphaEq",
          "type": "function"
        },
        "index": {
          "description": "Alpha-equivalence on lambda expressions Free variables are taken to be equivalent if they have the same identifier",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEq",
          "normalized": "ASTF a b-\u003eASTF a c-\u003eBool",
          "package": "syntactic",
          "partial": "Eq",
          "signature": "ASTF dom a-\u003eASTF dom b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:alphaEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqChildren",
          "package": "syntactic",
          "signature": "AST dom a -\u003e AST dom b -\u003e Reader env Bool",
          "source": "src/Language-Syntactic-Constructs-Binding.html#alphaEqChildren",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqChildren",
          "normalized": "AST a b-\u003eAST a c-\u003eReader d Bool",
          "package": "syntactic",
          "partial": "Eq Children",
          "signature": "AST dom a-\u003eAST dom b-\u003eReader env Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:alphaEqChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqM",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e ASTF dom b -\u003e Reader env Bool",
          "source": "src/Language-Syntactic-Constructs-Binding.html#alphaEqM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqM",
          "normalized": "ASTF a b-\u003eASTF a c-\u003eReader d Bool",
          "package": "syntactic",
          "partial": "Eq",
          "signature": "ASTF dom a-\u003eASTF dom b-\u003eReader env Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:alphaEqM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqM2",
          "package": "syntactic",
          "signature": "ASTF dom b -\u003e dom a -\u003e Args (AST dom) a -\u003e Reader env Bool",
          "source": "src/Language-Syntactic-Constructs-Binding.html#alphaEqM2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqM2",
          "normalized": "ASTF a b-\u003ea c-\u003eArgs(AST a)c-\u003eReader d Bool",
          "package": "syntactic",
          "partial": "Eq",
          "signature": "ASTF dom b-\u003edom a-\u003eArgs(AST dom)a-\u003eReader env Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:alphaEqM2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqSym",
          "package": "syntactic",
          "signature": "sub1 a -\u003e Args (AST dom) a -\u003e sub2 b -\u003e Args (AST dom) b -\u003e Reader env Bool",
          "source": "src/Language-Syntactic-Constructs-Binding.html#alphaEqSym",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqSym",
          "normalized": "a b-\u003eArgs(AST c)b-\u003ea d-\u003eArgs(AST c)d-\u003eReader e Bool",
          "package": "syntactic",
          "partial": "Eq Sym",
          "signature": "sub a-\u003eArgs(AST dom)a-\u003esub b-\u003eArgs(AST dom)b-\u003eReader env Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:alphaEqSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqSymDefault",
          "package": "syntactic",
          "signature": "sub a -\u003e Args (AST dom) a -\u003e sub b -\u003e Args (AST dom) b -\u003e Reader env Bool",
          "source": "src/Language-Syntactic-Constructs-Binding.html#alphaEqSymDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "alphaEqSymDefault",
          "normalized": "a b-\u003eArgs(AST c)b-\u003ea d-\u003eArgs(AST c)d-\u003eReader e Bool",
          "package": "syntactic",
          "partial": "Eq Sym Default",
          "signature": "sub a-\u003eArgs(AST dom)a-\u003esub b-\u003eArgs(AST dom)b-\u003eReader env Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:alphaEqSymDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a symbol denotation to a list of arguments\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "appDen",
          "package": "syntactic",
          "signature": "Denotation sig -\u003e Args Identity sig -\u003e DenResult sig",
          "source": "src/Language-Syntactic-Constructs-Binding.html#appDen",
          "type": "function"
        },
        "index": {
          "description": "Apply symbol denotation to list of arguments",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "appDen",
          "normalized": "Denotation a-\u003eArgs Identity a-\u003eDenResult a",
          "package": "syntactic",
          "partial": "Den",
          "signature": "Denotation sig-\u003eArgs Identity sig-\u003eDenResult sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:appDen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBeta-reduction of an expression. The expression to be reduced is assumed to\n be a \u003ccode\u003e\u003ca\u003eLambda\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "betaReduce",
          "package": "syntactic",
          "signature": "ASTF dom a-\u003e ASTF dom (a -\u003e b)-\u003e ASTF dom b",
          "type": "function"
        },
        "index": {
          "description": "Beta-reduction of an expression The expression to be reduced is assumed to be Lambda",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "betaReduce",
          "normalized": "ASTF a b-\u003eASTF a(b-\u003ec)-\u003eASTF a c",
          "package": "syntactic",
          "partial": "Reduce",
          "signature": "ASTF dom a-\u003eASTF dom(a-\u003eb)-\u003eASTF dom b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:betaReduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluation of closed expressions\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBind",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e a",
          "source": "src/Language-Syntactic-Constructs-Binding.html#evalBind",
          "type": "function"
        },
        "index": {
          "description": "Evaluation of closed expressions",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBind",
          "normalized": "ASTF a b-\u003eb",
          "package": "syntactic",
          "partial": "Bind",
          "signature": "ASTF dom a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:evalBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluation of possibly open expressions\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBindM",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e Reader [(VarId, Dynamic)] a",
          "source": "src/Language-Syntactic-Constructs-Binding.html#evalBindM",
          "type": "function"
        },
        "index": {
          "description": "Evaluation of possibly open expressions",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBindM",
          "normalized": "ASTF a b-\u003eReader[(VarId,Dynamic)]b",
          "package": "syntactic",
          "partial": "Bind",
          "signature": "ASTF dom a-\u003eReader[(VarId,Dynamic)]a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:evalBindM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBindSym",
          "package": "syntactic",
          "signature": "sub sig -\u003e Args (AST dom) sig -\u003e Reader [(VarId, Dynamic)] (DenResult sig)",
          "source": "src/Language-Syntactic-Constructs-Binding.html#evalBindSym",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBindSym",
          "normalized": "a b-\u003eArgs(AST c)b-\u003eReader[(VarId,Dynamic)](DenResult b)",
          "package": "syntactic",
          "partial": "Bind Sym",
          "signature": "sub sig-\u003eArgs(AST dom)sig-\u003eReader[(VarId,Dynamic)](DenResult sig)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:evalBindSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient default implementation of \u003ccode\u003e\u003ca\u003eevalBindSym\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBindSymDefault",
          "package": "syntactic",
          "signature": "sub sig -\u003e Args (AST dom) sig -\u003e Reader [(VarId, Dynamic)] (DenResult sig)",
          "source": "src/Language-Syntactic-Constructs-Binding.html#evalBindSymDefault",
          "type": "function"
        },
        "index": {
          "description": "Convenient default implementation of evalBindSym",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "evalBindSymDefault",
          "normalized": "a b-\u003eArgs(AST c)b-\u003eReader[(VarId,Dynamic)](DenResult b)",
          "package": "syntactic",
          "partial": "Bind Sym Default",
          "signature": "sub sig-\u003eArgs(AST dom)sig-\u003eReader[(VarId,Dynamic)](DenResult sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:evalBindSymDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "modVarEqEnv",
          "package": "syntactic",
          "signature": "([(VarId, VarId)] -\u003e [(VarId, VarId)]) -\u003e a -\u003e a",
          "source": "src/Language-Syntactic-Constructs-Binding.html#modVarEqEnv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "modVarEqEnv",
          "normalized": "([(VarId,VarId)]-\u003e[(VarId,VarId)])-\u003ea-\u003ea",
          "package": "syntactic",
          "partial": "Var Eq Env",
          "signature": "([(VarId,VarId)]-\u003e[(VarId,VarId)])-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:modVarEqEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "prjVarEqEnv",
          "package": "syntactic",
          "signature": "a -\u003e [(VarId, VarId)]",
          "source": "src/Language-Syntactic-Constructs-Binding.html#prjVarEqEnv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "prjVarEqEnv",
          "normalized": "a-\u003e[(VarId,VarId)]",
          "package": "syntactic",
          "partial": "Var Eq Env",
          "signature": "a-\u003e[(VarId,VarId)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:prjVarEqEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow an existing binding to be used with a body of a different type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "reuseLambda",
          "package": "syntactic",
          "signature": "Lambda (b :-\u003e Full (a -\u003e b)) -\u003e Lambda (c :-\u003e Full (a -\u003e c))",
          "source": "src/Language-Syntactic-Constructs-Binding.html#reuseLambda",
          "type": "function"
        },
        "index": {
          "description": "Allow an existing binding to be used with body of different type",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "reuseLambda",
          "normalized": "Lambda(a-\u003eFull(b-\u003ea))-\u003eLambda(c-\u003eFull(b-\u003ec))",
          "package": "syntactic",
          "partial": "Lambda",
          "signature": "Lambda(b-\u003eFull(a-\u003eb))-\u003eLambda(c-\u003eFull(a-\u003ec))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:reuseLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "showVar",
          "package": "syntactic",
          "signature": "VarId -\u003e String",
          "source": "src/Language-Syntactic-Constructs-Binding.html#showVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "showVar",
          "normalized": "VarId-\u003eString",
          "package": "syntactic",
          "partial": "Var",
          "signature": "VarId-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:showVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould be a capture-avoiding substitution, but it is currently not correct.\n\u003c/p\u003e\u003cp\u003eNote: Variables with a different type than the new expression will be\n silently ignored.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "subst",
          "package": "syntactic",
          "signature": "VarId-\u003e ASTF dom a-\u003e ASTF dom b-\u003e ASTF dom b",
          "type": "function"
        },
        "index": {
          "description": "Should be capture-avoiding substitution but it is currently not correct Note Variables with different type than the new expression will be silently ignored",
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "subst",
          "normalized": "VarId-\u003eASTF a b-\u003eASTF a c-\u003eASTF a c",
          "package": "syntactic",
          "signature": "VarId-\u003eASTF dom a-\u003eASTF dom b-\u003eASTF dom b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "varInteger",
          "package": "syntactic",
          "signature": "Integer",
          "source": "src/Language-Syntactic-Constructs-Binding.html#VarId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Binding",
          "module": "Language.Syntactic.Constructs.Binding",
          "name": "varInteger",
          "package": "syntactic",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Binding.html#v:varInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConditional expressions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Condition",
          "name": "Condition",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Condition.html",
          "type": "module"
        },
        "index": {
          "description": "Conditional expressions",
          "hierarchy": "Language Syntactic Constructs Condition",
          "module": "Language.Syntactic.Constructs.Condition",
          "name": "Condition",
          "package": "syntactic",
          "partial": "Condition",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Condition.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Condition",
          "name": "Condition",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Condition.html#Condition",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Condition",
          "module": "Language.Syntactic.Constructs.Condition",
          "name": "Condition",
          "package": "syntactic",
          "partial": "Condition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Condition.html#t:Condition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Condition",
          "name": "Condition",
          "package": "syntactic",
          "signature": "Condition (Bool :-\u003e (a :-\u003e (a :-\u003e Full a)))",
          "source": "src/Language-Syntactic-Constructs-Condition.html#Condition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Condition",
          "module": "Language.Syntactic.Constructs.Condition",
          "name": "Condition",
          "normalized": "Condition(Bool-\u003e(a-\u003e(a-\u003eFull a)))",
          "package": "syntactic",
          "partial": "Condition",
          "signature": "Condition(Bool-\u003e(a-\u003e(a-\u003eFull a)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Condition.html#v:Condition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvides a simple way to make syntactic constructs for prototyping. Note\n that \u003ccode\u003e\u003ca\u003eConstruct\u003c/a\u003e\u003c/code\u003e is quite unsafe as it only uses \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e to distinguish\n between different constructs. Also, \u003ccode\u003e\u003ca\u003eConstruct\u003c/a\u003e\u003c/code\u003e has a very free type that\n allows any number of arguments.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Construct",
          "name": "Construct",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Construct.html",
          "type": "module"
        },
        "index": {
          "description": "Provides simple way to make syntactic constructs for prototyping Note that Construct is quite unsafe as it only uses String to distinguish between different constructs Also Construct has very free type that allows any number of arguments",
          "hierarchy": "Language Syntactic Constructs Construct",
          "module": "Language.Syntactic.Constructs.Construct",
          "name": "Construct",
          "package": "syntactic",
          "partial": "Construct",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Construct.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Construct",
          "name": "Construct",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Construct.html#Construct",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Construct",
          "module": "Language.Syntactic.Constructs.Construct",
          "name": "Construct",
          "package": "syntactic",
          "partial": "Construct",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Construct.html#t:Construct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Construct",
          "name": "Construct",
          "package": "syntactic",
          "signature": "String -\u003e Denotation sig -\u003e Construct sig",
          "source": "src/Language-Syntactic-Constructs-Construct.html#Construct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Construct",
          "module": "Language.Syntactic.Constructs.Construct",
          "name": "Construct",
          "normalized": "String-\u003eDenotation a-\u003eConstruct a",
          "package": "syntactic",
          "partial": "Construct",
          "signature": "String-\u003eDenotation sig-\u003eConstruct sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Construct.html#v:Construct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstruct for decorating expressions with additional information\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "Decoration",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Decoration.html",
          "type": "module"
        },
        "index": {
          "description": "Construct for decorating expressions with additional information",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "Decoration",
          "package": "syntactic",
          "partial": "Decoration",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecorating symbols with additional information\n\u003c/p\u003e\u003cp\u003eOne usage of \u003ccode\u003e\u003ca\u003eDecor\u003c/a\u003e\u003c/code\u003e is to decorate every node of a syntax tree. This is done\n simply by changing\n\u003c/p\u003e\u003cpre\u003e AST dom sig\n\u003c/pre\u003e\u003cp\u003eto\n\u003c/p\u003e\u003cpre\u003e AST (Decor info dom) sig\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "Decor",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#Decor",
          "type": "data"
        },
        "index": {
          "description": "Decorating symbols with additional information One usage of Decor is to decorate every node of syntax tree This is done simply by changing AST dom sig to AST Decor info dom sig",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "Decor",
          "package": "syntactic",
          "partial": "Decor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#t:Decor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "Decor",
          "package": "syntactic",
          "signature": "info (DenResult sig) -\u003e expr sig -\u003e Decor info expr sig",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#Decor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "Decor",
          "normalized": "a(DenResult b)-\u003ec b-\u003eDecor a c b",
          "package": "syntactic",
          "partial": "Decor",
          "signature": "info(DenResult sig)-\u003eexpr sig-\u003eDecor info expr sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:Decor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect the decorations of all nodes\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "collectInfo",
          "package": "syntactic",
          "signature": "(forall sig.  info sig -\u003e b) -\u003e AST (Decor info dom) sig -\u003e [b]",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#collectInfo",
          "type": "function"
        },
        "index": {
          "description": "Collect the decorations of all nodes",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "collectInfo",
          "normalized": "(a b c d-\u003ee)-\u003eAST(Decor c f)d-\u003e[e]",
          "package": "syntactic",
          "partial": "Info",
          "signature": "(forall sig. info sig-\u003eb)-\u003eAST(Decor info dom)sig-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:collectInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "decorExpr",
          "package": "syntactic",
          "signature": "expr sig",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#Decor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "decorExpr",
          "package": "syntactic",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:decorExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "decorInfo",
          "package": "syntactic",
          "signature": "info (DenResult sig)",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#Decor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "decorInfo",
          "package": "syntactic",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:decorInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint an decorated syntax tree using ASCII art\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "drawDecorWith",
          "package": "syntactic",
          "signature": "(forall a.  info a -\u003e String) -\u003e ASTF (Decor info dom) a -\u003e IO ()",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#drawDecorWith",
          "type": "function"
        },
        "index": {
          "description": "Print an decorated syntax tree using ASCII art",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "drawDecorWith",
          "normalized": "(a b c d-\u003eString)-\u003eASTF(Decor c e)d-\u003eIO()",
          "package": "syntactic",
          "partial": "Decor With",
          "signature": "(forall a. info a-\u003eString)-\u003eASTF(Decor info dom)a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:drawDecorWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the decoration of the top-level node\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "getInfo",
          "package": "syntactic",
          "signature": "AST (Decor info dom) sig -\u003e info (DenResult sig)",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#getInfo",
          "type": "function"
        },
        "index": {
          "description": "Get the decoration of the top-level node",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "getInfo",
          "normalized": "AST(Decor a b)c-\u003ea(DenResult c)",
          "package": "syntactic",
          "partial": "Info",
          "signature": "AST(Decor info dom)sig-\u003einfo(DenResult sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:getInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a function that operates on expressions with associated information to\n operate on an \u003ccode\u003e\u003ca\u003eDecor\u003c/a\u003e\u003c/code\u003e expression. This function is convenient to use together\n with e.g. \u003ccode\u003equeryNodeSimple\u003c/code\u003e when the domain has the form\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eDecor\u003c/a\u003e\u003c/code\u003e info dom)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "liftDecor",
          "package": "syntactic",
          "signature": "(expr s -\u003e info (DenResult s) -\u003e b) -\u003e Decor info expr s -\u003e b",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#liftDecor",
          "type": "function"
        },
        "index": {
          "description": "Lift function that operates on expressions with associated information to operate on an Decor expression This function is convenient to use together with e.g queryNodeSimple when the domain has the form Decor info dom",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "liftDecor",
          "normalized": "(a b-\u003ec(DenResult b)-\u003ed)-\u003eDecor c a b-\u003ed",
          "package": "syntactic",
          "partial": "Decor",
          "signature": "(expr s-\u003einfo(DenResult s)-\u003eb)-\u003eDecor info expr s-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:liftDecor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow an decorated syntax tree using ASCII art\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "showDecorWith",
          "package": "syntactic",
          "signature": "(forall a.  info a -\u003e String) -\u003e ASTF (Decor info dom) a -\u003e String",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#showDecorWith",
          "type": "function"
        },
        "index": {
          "description": "Show an decorated syntax tree using ASCII art",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "showDecorWith",
          "normalized": "(a b c d-\u003eString)-\u003eASTF(Decor c e)d-\u003eString",
          "package": "syntactic",
          "partial": "Decor With",
          "signature": "(forall a. info a-\u003eString)-\u003eASTF(Decor info dom)a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:showDecorWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRendering of decorated syntax trees\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "stringTreeDecor",
          "package": "syntactic",
          "signature": "(forall a.  info a -\u003e String) -\u003e ASTF (Decor info dom) a -\u003e Tree String",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#stringTreeDecor",
          "type": "function"
        },
        "index": {
          "description": "Rendering of decorated syntax trees",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "stringTreeDecor",
          "normalized": "(a b c d-\u003eString)-\u003eASTF(Decor c e)d-\u003eTree String",
          "package": "syntactic",
          "partial": "Tree Decor",
          "signature": "(forall a. info a-\u003eString)-\u003eASTF(Decor info dom)a-\u003eTree String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:stringTreeDecor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrip decorations from an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "stripDecor",
          "package": "syntactic",
          "signature": "AST (Decor info dom) sig -\u003e AST dom sig",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#stripDecor",
          "type": "function"
        },
        "index": {
          "description": "Strip decorations from an AST",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "stripDecor",
          "normalized": "AST(Decor a b)c-\u003eAST b c",
          "package": "syntactic",
          "partial": "Decor",
          "signature": "AST(Decor info dom)sig-\u003eAST dom sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:stripDecor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the decoration of the top-level node\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "updateDecor",
          "package": "syntactic",
          "signature": "forall info dom a.  (info a -\u003e info a) -\u003e ASTF (Decor info dom) a -\u003e ASTF (Decor info dom) a",
          "source": "src/Language-Syntactic-Constructs-Decoration.html#updateDecor",
          "type": "function"
        },
        "index": {
          "description": "Update the decoration of the top-level node",
          "hierarchy": "Language Syntactic Constructs Decoration",
          "module": "Language.Syntactic.Constructs.Decoration",
          "name": "updateDecor",
          "normalized": "a b c d(b e-\u003eb e)-\u003eASTF(Decor b c)e-\u003eASTF(Decor b c)e",
          "package": "syntactic",
          "partial": "Decor",
          "signature": "forall info dom a.(info a-\u003einfo a)-\u003eASTF(Decor info dom)a-\u003eASTF(Decor info dom)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Decoration.html#v:updateDecor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIdentity function\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Identity",
          "name": "Identity",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Identity.html",
          "type": "module"
        },
        "index": {
          "description": "Identity function",
          "hierarchy": "Language Syntactic Constructs Identity",
          "module": "Language.Syntactic.Constructs.Identity",
          "name": "Identity",
          "package": "syntactic",
          "partial": "Identity",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Identity.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity function\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Identity",
          "name": "Identity",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Identity.html#Identity",
          "type": "data"
        },
        "index": {
          "description": "Identity function",
          "hierarchy": "Language Syntactic Constructs Identity",
          "module": "Language.Syntactic.Constructs.Identity",
          "name": "Identity",
          "package": "syntactic",
          "partial": "Identity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Identity.html#t:Identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Identity",
          "name": "Id",
          "package": "syntactic",
          "signature": "Identity (a :-\u003e Full a)",
          "source": "src/Language-Syntactic-Constructs-Identity.html#Identity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Identity",
          "module": "Language.Syntactic.Constructs.Identity",
          "name": "Id",
          "normalized": "Identity(a-\u003eFull a)",
          "package": "syntactic",
          "partial": "Id",
          "signature": "Identity(a-\u003eFull a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Identity.html#v:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLiteral expressions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Literal",
          "name": "Literal",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Literal.html",
          "type": "module"
        },
        "index": {
          "description": "Literal expressions",
          "hierarchy": "Language Syntactic Constructs Literal",
          "module": "Language.Syntactic.Constructs.Literal",
          "name": "Literal",
          "package": "syntactic",
          "partial": "Literal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Literal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Literal",
          "name": "Literal",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Literal.html#Literal",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Literal",
          "module": "Language.Syntactic.Constructs.Literal",
          "name": "Literal",
          "package": "syntactic",
          "partial": "Literal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Literal.html#t:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Literal",
          "name": "Literal",
          "package": "syntactic",
          "signature": "a -\u003e Literal (Full a)",
          "source": "src/Language-Syntactic-Constructs-Literal.html#Literal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Literal",
          "module": "Language.Syntactic.Constructs.Literal",
          "name": "Literal",
          "normalized": "a-\u003eLiteral(Full a)",
          "package": "syntactic",
          "partial": "Literal",
          "signature": "a-\u003eLiteral(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Literal.html#v:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonadic constructs\n\u003c/p\u003e\u003cp\u003eThis module is based on the paper\n \u003cem\u003eGeneric Monadic Constructs for Embedded Languages\u003c/em\u003e (Persson et al., IFL 2011\n \u003ca\u003ehttp://www.cse.chalmers.se/~emax/documents/persson2011generic.pdf\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Monad",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Monad.html",
          "type": "module"
        },
        "index": {
          "description": "Monadic constructs This module is based on the paper Generic Monadic Constructs for Embedded Languages Persson et al IFL http www.cse.chalmers.se emax documents persson2011generic.pdf",
          "hierarchy": "Language Syntactic Constructs Monad",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Monad",
          "package": "syntactic",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "MONAD",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Monad.html#MONAD",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Monad",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "MONAD",
          "package": "syntactic",
          "partial": "MONAD",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Monad.html#t:MONAD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Bind",
          "package": "syntactic",
          "signature": "MONAD m (m a :-\u003e ((a -\u003e m b) :-\u003e Full (m b)))",
          "source": "src/Language-Syntactic-Constructs-Monad.html#MONAD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Monad",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Bind",
          "normalized": "MONAD a(a b-\u003e((b-\u003ea c)-\u003eFull(a c)))",
          "package": "syntactic",
          "partial": "Bind",
          "signature": "MONAD m(m a-\u003e((a-\u003em b)-\u003eFull(m b)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Monad.html#v:Bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Return",
          "package": "syntactic",
          "signature": "MONAD m (a :-\u003e Full (m a))",
          "source": "src/Language-Syntactic-Constructs-Monad.html#MONAD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Monad",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Return",
          "normalized": "MONAD a(b-\u003eFull(a b))",
          "package": "syntactic",
          "partial": "Return",
          "signature": "MONAD m(a-\u003eFull(m a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Monad.html#v:Return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Then",
          "package": "syntactic",
          "signature": "MONAD m (m a :-\u003e (m b :-\u003e Full (m b)))",
          "source": "src/Language-Syntactic-Constructs-Monad.html#MONAD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Monad",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "Then",
          "normalized": "MONAD a(a b-\u003e(a c-\u003eFull(a c)))",
          "package": "syntactic",
          "partial": "Then",
          "signature": "MONAD m(m a-\u003e(m b-\u003eFull(m b)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Monad.html#v:Then"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "When",
          "package": "syntactic",
          "signature": "MONAD m (Bool :-\u003e (m () :-\u003e Full (m ())))",
          "source": "src/Language-Syntactic-Constructs-Monad.html#MONAD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Monad",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "When",
          "normalized": "MONAD a(Bool-\u003e(a()-\u003eFull(a())))",
          "package": "syntactic",
          "partial": "When",
          "signature": "MONAD m(Bool-\u003e(m()-\u003eFull(m())))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Monad.html#v:When"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjection with explicit monad type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "prjMonad",
          "package": "syntactic",
          "signature": "P m -\u003e sup sig -\u003e Maybe (MONAD m sig)",
          "source": "src/Language-Syntactic-Constructs-Monad.html#prjMonad",
          "type": "function"
        },
        "index": {
          "description": "Projection with explicit monad type",
          "hierarchy": "Language Syntactic Constructs Monad",
          "module": "Language.Syntactic.Constructs.Monad",
          "name": "prjMonad",
          "normalized": "P a-\u003eb c-\u003eMaybe(MONAD a c)",
          "package": "syntactic",
          "partial": "Monad",
          "signature": "P m-\u003esup sig-\u003eMaybe(MONAD m sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Monad.html#v:prjMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstruction and elimination of tuples in the object language\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tuple",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Tuple.html",
          "type": "module"
        },
        "index": {
          "description": "Construction and elimination of tuples in the object language",
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tuple",
          "package": "syntactic",
          "partial": "Tuple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThese families (\u003ccode\u003e\u003ca\u003eSel1'\u003c/a\u003e\u003c/code\u003e - \u003ccode\u003e\u003ca\u003eSel7'\u003c/a\u003e\u003c/code\u003e) are needed because of the problem\n described in:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://emil-fp.blogspot.com/2011/08/fundeps-weaker-than-type-families.html\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel1'",
          "package": "syntactic",
          "signature": "Sel1'",
          "type": "function"
        },
        "index": {
          "description": "These families Sel1 Sel7 are needed because of the problem described in http emil-fp.blogspot.com fundeps-weaker-than-type-families.html",
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel1'",
          "package": "syntactic",
          "partial": "Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Sel1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel2'",
          "package": "syntactic",
          "signature": "Sel2'",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel2'",
          "package": "syntactic",
          "partial": "Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Sel2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel3'",
          "package": "syntactic",
          "signature": "Sel3'",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel3'",
          "package": "syntactic",
          "partial": "Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Sel3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel4'",
          "package": "syntactic",
          "signature": "Sel4'",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel4'",
          "package": "syntactic",
          "partial": "Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Sel4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel5'",
          "package": "syntactic",
          "signature": "Sel5'",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel5'",
          "package": "syntactic",
          "partial": "Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Sel5-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel6'",
          "package": "syntactic",
          "signature": "Sel6'",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel6'",
          "package": "syntactic",
          "partial": "Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Sel6-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel7'",
          "package": "syntactic",
          "signature": "Sel7'",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel7'",
          "package": "syntactic",
          "partial": "Sel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Sel7-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpressions for selecting elements of a tuple\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Select",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "data"
        },
        "index": {
          "description": "Expressions for selecting elements of tuple",
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Select",
          "package": "syntactic",
          "partial": "Select",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpressions for constructing tuples\n\u003c/p\u003e",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tuple",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Tuple",
          "type": "data"
        },
        "index": {
          "description": "Expressions for constructing tuples",
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tuple",
          "package": "syntactic",
          "partial": "Tuple",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#t:Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel1",
          "package": "syntactic",
          "signature": "Select (a :-\u003e Full b)",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel1",
          "normalized": "Select(a-\u003eFull b)",
          "package": "syntactic",
          "partial": "Sel",
          "signature": "Select(a-\u003eFull b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Sel1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel2",
          "package": "syntactic",
          "signature": "Select (a :-\u003e Full b)",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel2",
          "normalized": "Select(a-\u003eFull b)",
          "package": "syntactic",
          "partial": "Sel",
          "signature": "Select(a-\u003eFull b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Sel2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel3",
          "package": "syntactic",
          "signature": "Select (a :-\u003e Full b)",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel3",
          "normalized": "Select(a-\u003eFull b)",
          "package": "syntactic",
          "partial": "Sel",
          "signature": "Select(a-\u003eFull b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Sel3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel4",
          "package": "syntactic",
          "signature": "Select (a :-\u003e Full b)",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel4",
          "normalized": "Select(a-\u003eFull b)",
          "package": "syntactic",
          "partial": "Sel",
          "signature": "Select(a-\u003eFull b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Sel4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel5",
          "package": "syntactic",
          "signature": "Select (a :-\u003e Full b)",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel5",
          "normalized": "Select(a-\u003eFull b)",
          "package": "syntactic",
          "partial": "Sel",
          "signature": "Select(a-\u003eFull b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Sel5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel6",
          "package": "syntactic",
          "signature": "Select (a :-\u003e Full b)",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel6",
          "normalized": "Select(a-\u003eFull b)",
          "package": "syntactic",
          "partial": "Sel",
          "signature": "Select(a-\u003eFull b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Sel6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel7",
          "package": "syntactic",
          "signature": "Select (a :-\u003e Full b)",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Select",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Sel7",
          "normalized": "Select(a-\u003eFull b)",
          "package": "syntactic",
          "partial": "Sel",
          "signature": "Select(a-\u003eFull b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Sel7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup2",
          "package": "syntactic",
          "signature": "Tuple (a :-\u003e (b :-\u003e Full (a, b)))",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Tuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup2",
          "normalized": "Tuple(a-\u003e(b-\u003eFull(a,b)))",
          "package": "syntactic",
          "partial": "Tup",
          "signature": "Tuple(a-\u003e(b-\u003eFull(a,b)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Tup2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup3",
          "package": "syntactic",
          "signature": "Tuple (a :-\u003e (b :-\u003e (c :-\u003e Full (a, b, c))))",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Tuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup3",
          "normalized": "Tuple(a-\u003e(b-\u003e(c-\u003eFull(a,b,c))))",
          "package": "syntactic",
          "partial": "Tup",
          "signature": "Tuple(a-\u003e(b-\u003e(c-\u003eFull(a,b,c))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Tup3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup4",
          "package": "syntactic",
          "signature": "Tuple (a :-\u003e (b :-\u003e (c :-\u003e (d :-\u003e Full (a, b, c, d)))))",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Tuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup4",
          "normalized": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003eFull(a,b,c,d)))))",
          "package": "syntactic",
          "partial": "Tup",
          "signature": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003eFull(a,b,c,d)))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Tup4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup5",
          "package": "syntactic",
          "signature": "Tuple (a :-\u003e (b :-\u003e (c :-\u003e (d :-\u003e (e :-\u003e Full (a, b, c, d, e))))))",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Tuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup5",
          "normalized": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003e(e-\u003eFull(a,b,c,d,e))))))",
          "package": "syntactic",
          "partial": "Tup",
          "signature": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003e(e-\u003eFull(a,b,c,d,e))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Tup5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup6",
          "package": "syntactic",
          "signature": "Tuple (a :-\u003e (b :-\u003e (c :-\u003e (d :-\u003e (e :-\u003e (f :-\u003e Full (a, b, c, d, e, f)))))))",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Tuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup6",
          "normalized": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003e(e-\u003e(f-\u003eFull(a,b,c,d,e,f)))))))",
          "package": "syntactic",
          "partial": "Tup",
          "signature": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003e(e-\u003e(f-\u003eFull(a,b,c,d,e,f)))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Tup6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup7",
          "package": "syntactic",
          "signature": "Tuple (a :-\u003e (b :-\u003e (c :-\u003e (d :-\u003e (e :-\u003e (f :-\u003e (g :-\u003e Full (a, b, c, d, e, f, g))))))))",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#Tuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "Tup7",
          "normalized": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003e(e-\u003e(f-\u003e(g-\u003eFull(a,b,c,d,e,f,g))))))))",
          "package": "syntactic",
          "partial": "Tup",
          "signature": "Tuple(a-\u003e(b-\u003e(c-\u003e(d-\u003e(e-\u003e(f-\u003e(g-\u003eFull(a,b,c,d,e,f,g))))))))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:Tup7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the selected position, e.g.\n\u003c/p\u003e\u003cpre\u003e selectPos (Sel3 poly :: Select Poly ((Int,Int,Int,Int) :-\u003e Full Int)) = 3\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "selectPos",
          "package": "syntactic",
          "signature": "Select a -\u003e Int",
          "source": "src/Language-Syntactic-Constructs-Tuple.html#selectPos",
          "type": "function"
        },
        "index": {
          "description": "Return the selected position e.g selectPos Sel3 poly Select Poly Int Int Int Int Full Int",
          "hierarchy": "Language Syntactic Constructs Tuple",
          "module": "Language.Syntactic.Constructs.Tuple",
          "name": "selectPos",
          "normalized": "Select a-\u003eInt",
          "package": "syntactic",
          "partial": "Pos",
          "signature": "Select a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Constructs-Tuple.html#v:selectPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonadic constructs\n\u003c/p\u003e\u003cp\u003eThis module is based on the paper\n \u003cem\u003eGeneric Monadic Constructs for Embedded Languages\u003c/em\u003e (Persson et al., IFL 2011\n \u003ca\u003ehttp://www.cse.chalmers.se/~emax/documents/persson2011generic.pdf\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "Monad",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Frontend-Monad.html",
          "type": "module"
        },
        "index": {
          "description": "Monadic constructs This module is based on the paper Generic Monadic Constructs for Embedded Languages Persson et al IFL http www.cse.chalmers.se emax documents persson2011generic.pdf",
          "hierarchy": "Language Syntactic Frontend Monad",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "Monad",
          "package": "syntactic",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUser interface to embedded monadic programs\n\u003c/p\u003e",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "Mon",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Frontend-Monad.html#Mon",
          "type": "newtype"
        },
        "index": {
          "description": "User interface to embedded monadic programs",
          "hierarchy": "Language Syntactic Frontend Monad",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "Mon",
          "package": "syntactic",
          "partial": "Mon",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-Monad.html#t:Mon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "Mon",
          "package": "syntactic",
          "signature": "Cont (ASTF dom (m r)) a) -\u003e Mon dom m a",
          "source": "src/Language-Syntactic-Frontend-Monad.html#Mon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Frontend Monad",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "Mon",
          "normalized": "Cont(ASTF a(b c))d)-\u003eMon a b d",
          "package": "syntactic",
          "partial": "Mon",
          "signature": "Cont(ASTF dom(m r))a)-\u003eMon dom m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-Monad.html#v:Mon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne-layer desugaring of monadic actions\n\u003c/p\u003e",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "desugarMonad",
          "package": "syntactic",
          "signature": "Mon dom m (ASTF dom a) -\u003e ASTF dom (m a)",
          "source": "src/Language-Syntactic-Frontend-Monad.html#desugarMonad",
          "type": "function"
        },
        "index": {
          "description": "One-layer desugaring of monadic actions",
          "hierarchy": "Language Syntactic Frontend Monad",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "desugarMonad",
          "normalized": "Mon a b(ASTF a c)-\u003eASTF a(b c)",
          "package": "syntactic",
          "partial": "Monad",
          "signature": "Mon dom m(ASTF dom a)-\u003eASTF dom(m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-Monad.html#v:desugarMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne-layer sugaring of monadic actions\n\u003c/p\u003e",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "sugarMonad",
          "package": "syntactic",
          "signature": "ASTF dom (m a) -\u003e Mon dom m (ASTF dom a)",
          "source": "src/Language-Syntactic-Frontend-Monad.html#sugarMonad",
          "type": "function"
        },
        "index": {
          "description": "One-layer sugaring of monadic actions",
          "hierarchy": "Language Syntactic Frontend Monad",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "sugarMonad",
          "normalized": "ASTF a(b c)-\u003eMon a b(ASTF a c)",
          "package": "syntactic",
          "partial": "Monad",
          "signature": "ASTF dom(m a)-\u003eMon dom m(ASTF dom a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-Monad.html#v:sugarMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "unMon",
          "package": "syntactic",
          "signature": "Cont (ASTF dom (m r)) a",
          "source": "src/Language-Syntactic-Frontend-Monad.html#Mon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Frontend Monad",
          "module": "Language.Syntactic.Frontend.Monad",
          "name": "unMon",
          "package": "syntactic",
          "partial": "Mon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-Monad.html#v:unMon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eSyntactic\u003c/a\u003e\u003c/code\u003e instances for Haskell tuples\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Frontend.Tuple",
          "name": "Tuple",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Frontend-Tuple.html",
          "type": "module"
        },
        "index": {
          "description": "Syntactic instances for Haskell tuples",
          "hierarchy": "Language Syntactic Frontend Tuple",
          "module": "Language.Syntactic.Frontend.Tuple",
          "name": "Tuple",
          "package": "syntactic",
          "partial": "Tuple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-Tuple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstrained \u003ccode\u003e\u003ca\u003eSyntactic\u003c/a\u003e\u003c/code\u003e instances for Haskell tuples\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Frontend.TupleConstrained",
          "name": "TupleConstrained",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Frontend-TupleConstrained.html",
          "type": "module"
        },
        "index": {
          "description": "Constrained Syntactic instances for Haskell tuples",
          "hierarchy": "Language Syntactic Frontend TupleConstrained",
          "module": "Language.Syntactic.Frontend.TupleConstrained",
          "name": "TupleConstrained",
          "package": "syntactic",
          "partial": "Tuple Constrained",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-TupleConstrained.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-level function computing the predicate attached to \u003ccode\u003e\u003ca\u003eTuple\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eSelect\u003c/a\u003e\u003c/code\u003e\n (whichever appears first) in a domain.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Frontend.TupleConstrained",
          "name": "TupleSat",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Frontend-TupleConstrained.html#TupleSat",
          "type": "class"
        },
        "index": {
          "description": "Type-level function computing the predicate attached to Tuple or Select whichever appears first in domain",
          "hierarchy": "Language Syntactic Frontend TupleConstrained",
          "module": "Language.Syntactic.Frontend.TupleConstrained",
          "name": "TupleSat",
          "package": "syntactic",
          "partial": "Tuple Sat",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Frontend-TupleConstrained.html#t:TupleSat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "Equality",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Equality.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Equality",
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "Equality",
          "package": "syntactic",
          "partial": "Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Equality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquality for expressions\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "Equality",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Equality.html#Equality",
          "type": "class"
        },
        "index": {
          "description": "Equality for expressions",
          "hierarchy": "Language Syntactic Interpretation Equality",
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "Equality",
          "package": "syntactic",
          "partial": "Equality",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Equality.html#t:Equality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquality for expressions\n\u003c/p\u003e\u003cp\u003eComparing expressions of different types is often needed when dealing\n with expressions with existentially quantified sub-terms.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "equal",
          "package": "syntactic",
          "signature": "expr a -\u003e expr b -\u003e Bool",
          "source": "src/Language-Syntactic-Interpretation-Equality.html#equal",
          "type": "method"
        },
        "index": {
          "description": "Equality for expressions Comparing expressions of different types is often needed when dealing with expressions with existentially quantified sub-terms",
          "hierarchy": "Language Syntactic Interpretation Equality",
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "equal",
          "normalized": "a b-\u003ea c-\u003eBool",
          "package": "syntactic",
          "signature": "expr a-\u003eexpr b-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Equality.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes a \u003ccode\u003e\u003ca\u003eHash\u003c/a\u003e\u003c/code\u003e for an expression. Expressions that are equal\n according to \u003ccode\u003e\u003ca\u003eequal\u003c/a\u003e\u003c/code\u003e must result in the same hash:\n\u003c/p\u003e\u003cpre\u003eequal a b  ==\u003e  exprHash a == exprHash b\u003c/pre\u003e",
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "exprHash",
          "package": "syntactic",
          "signature": "expr a -\u003e Hash",
          "source": "src/Language-Syntactic-Interpretation-Equality.html#exprHash",
          "type": "method"
        },
        "index": {
          "description": "Computes Hash for an expression Expressions that are equal according to equal must result in the same hash equal exprHash exprHash",
          "hierarchy": "Language Syntactic Interpretation Equality",
          "module": "Language.Syntactic.Interpretation.Equality",
          "name": "exprHash",
          "normalized": "a b-\u003eHash",
          "package": "syntactic",
          "partial": "Hash",
          "signature": "expr a-\u003eHash",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Equality.html#v:exprHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "Evaluation",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Evaluation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Evaluation",
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "Evaluation",
          "package": "syntactic",
          "partial": "Evaluation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Evaluation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe denotation of a symbol with the given signature\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "Denotation",
          "package": "syntactic",
          "signature": "Denotation",
          "type": "function"
        },
        "index": {
          "description": "The denotation of symbol with the given signature",
          "hierarchy": "Language Syntactic Interpretation Evaluation",
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "Denotation",
          "package": "syntactic",
          "partial": "Denotation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Evaluation.html#t:Denotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "Eval",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Evaluation.html#Eval",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Evaluation",
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "Eval",
          "package": "syntactic",
          "partial": "Eval",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Evaluation.html#t:Eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluation of expressions\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "evaluate",
          "package": "syntactic",
          "signature": "expr a -\u003e Denotation a",
          "source": "src/Language-Syntactic-Interpretation-Evaluation.html#evaluate",
          "type": "method"
        },
        "index": {
          "description": "Evaluation of expressions",
          "hierarchy": "Language Syntactic Interpretation Evaluation",
          "module": "Language.Syntactic.Interpretation.Evaluation",
          "name": "evaluate",
          "normalized": "a b-\u003eDenotation b",
          "package": "syntactic",
          "signature": "expr a-\u003eDenotation a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Evaluation.html#v:evaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "Render",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Render.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "Render",
          "package": "syntactic",
          "partial": "Render",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender a symbol as concrete syntax. A complete instance must define at least the \u003ccode\u003e\u003ca\u003erenderSym\u003c/a\u003e\u003c/code\u003e\n method.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "Render",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Render.html#Render",
          "type": "class"
        },
        "index": {
          "description": "Render symbol as concrete syntax complete instance must define at least the renderSym method",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "Render",
          "package": "syntactic",
          "partial": "Render",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#t:Render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a symbol to a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e of strings\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "StringTree",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Render.html#StringTree",
          "type": "class"
        },
        "index": {
          "description": "Convert symbol to Tree of strings",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "StringTree",
          "package": "syntactic",
          "partial": "String Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#t:StringTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint a syntax tree using ASCII art\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "drawAST",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e IO ()",
          "source": "src/Language-Syntactic-Interpretation-Render.html#drawAST",
          "type": "function"
        },
        "index": {
          "description": "Print syntax tree using ASCII art",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "drawAST",
          "normalized": "ASTF a b-\u003eIO()",
          "package": "syntactic",
          "partial": "AST",
          "signature": "ASTF dom a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:drawAST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender an expression as concrete syntax\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "render",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e String",
          "source": "src/Language-Syntactic-Interpretation-Render.html#render",
          "type": "function"
        },
        "index": {
          "description": "Render an expression as concrete syntax",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "render",
          "normalized": "ASTF a b-\u003eString",
          "package": "syntactic",
          "signature": "ASTF dom a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender a symbol given a list of rendered arguments\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "renderArgs",
          "package": "syntactic",
          "signature": "[String] -\u003e dom sig -\u003e String",
          "source": "src/Language-Syntactic-Interpretation-Render.html#renderArgs",
          "type": "method"
        },
        "index": {
          "description": "Render symbol given list of rendered arguments",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "renderArgs",
          "normalized": "[String]-\u003ea b-\u003eString",
          "package": "syntactic",
          "partial": "Args",
          "signature": "[String]-\u003edom sig-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:renderArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a symbol as a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "renderSym",
          "package": "syntactic",
          "signature": "dom sig -\u003e String",
          "source": "src/Language-Syntactic-Interpretation-Render.html#renderSym",
          "type": "method"
        },
        "index": {
          "description": "Show symbol as String",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "renderSym",
          "normalized": "a b-\u003eString",
          "package": "syntactic",
          "partial": "Sym",
          "signature": "dom sig-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:renderSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a syntax tree using ASCII art\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "showAST",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e String",
          "source": "src/Language-Syntactic-Interpretation-Render.html#showAST",
          "type": "function"
        },
        "index": {
          "description": "Show syntax tree using ASCII art",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "showAST",
          "normalized": "ASTF a b-\u003eString",
          "package": "syntactic",
          "partial": "AST",
          "signature": "ASTF dom a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:showAST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an expression to a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e of strings\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "stringTree",
          "package": "syntactic",
          "signature": "ASTF dom a -\u003e Tree String",
          "source": "src/Language-Syntactic-Interpretation-Render.html#stringTree",
          "type": "function"
        },
        "index": {
          "description": "Convert an expression to Tree of strings",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "stringTree",
          "normalized": "ASTF a b-\u003eTree String",
          "package": "syntactic",
          "partial": "Tree",
          "signature": "ASTF dom a-\u003eTree String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:stringTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a symbol to a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e given a list of argument trees\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "stringTreeSym",
          "package": "syntactic",
          "signature": "[Tree String] -\u003e dom a -\u003e Tree String",
          "source": "src/Language-Syntactic-Interpretation-Render.html#stringTreeSym",
          "type": "method"
        },
        "index": {
          "description": "Convert symbol to Tree given list of argument trees",
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "stringTreeSym",
          "normalized": "[Tree String]-\u003ea b-\u003eTree String",
          "package": "syntactic",
          "partial": "Tree Sym",
          "signature": "[Tree String]-\u003edom a-\u003eTree String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:stringTreeSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "writeHtmlAST",
          "package": "syntactic",
          "signature": "FilePath -\u003e ASTF sym a -\u003e IO ()",
          "source": "src/Language-Syntactic-Interpretation-Render.html#writeHtmlAST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Render",
          "module": "Language.Syntactic.Interpretation.Render",
          "name": "writeHtmlAST",
          "normalized": "FilePath-\u003eASTF a b-\u003eIO()",
          "package": "syntactic",
          "partial": "Html AST",
          "signature": "FilePath-\u003eASTF sym a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Render.html#v:writeHtmlAST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDefault implementations of some interpretation functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Semantics",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html",
          "type": "module"
        },
        "index": {
          "description": "Default implementations of some interpretation functions",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Semantics",
          "package": "syntactic",
          "partial": "Semantics",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of expressions that can be treated as constructs\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Semantic",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#Semantic",
          "type": "class"
        },
        "index": {
          "description": "Class of expressions that can be treated as constructs",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Semantic",
          "package": "syntactic",
          "partial": "Semantic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#t:Semantic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA representation of a syntactic construct as a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e and an evaluation\n function. It is not meant to be used as a syntactic symbol in an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e. Its\n only purpose is to provide the default implementations of functions like\n \u003ccode\u003e\u003ca\u003eequal\u003c/a\u003e\u003c/code\u003e via the \u003ccode\u003e\u003ca\u003eSemantic\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Semantics",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#Semantics",
          "type": "data"
        },
        "index": {
          "description": "representation of syntactic construct as String and an evaluation function It is not meant to be used as syntactic symbol in an AST Its only purpose is to provide the default implementations of functions like equal via the Semantic class",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Semantics",
          "package": "syntactic",
          "partial": "Semantics",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#t:Semantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Sem",
          "package": "syntactic",
          "signature": "String -\u003e Denotation a -\u003e Semantics a",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#Semantics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "Sem",
          "normalized": "String-\u003eDenotation a-\u003eSemantics a",
          "package": "syntactic",
          "partial": "Sem",
          "signature": "String-\u003eDenotation a-\u003eSemantics a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:Sem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation of \u003ccode\u003e\u003ca\u003eequal\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "equalDefault",
          "package": "syntactic",
          "signature": "expr a -\u003e expr b -\u003e Bool",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#equalDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation of equal",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "equalDefault",
          "normalized": "a b-\u003ea c-\u003eBool",
          "package": "syntactic",
          "partial": "Default",
          "signature": "expr a-\u003eexpr b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:equalDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation of \u003ccode\u003e\u003ca\u003eevaluate\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "evaluateDefault",
          "package": "syntactic",
          "signature": "expr a -\u003e Denotation a",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#evaluateDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation of evaluate",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "evaluateDefault",
          "normalized": "a b-\u003eDenotation b",
          "package": "syntactic",
          "partial": "Default",
          "signature": "expr a-\u003eDenotation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:evaluateDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation of \u003ccode\u003e\u003ca\u003eexprHash\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "exprHashDefault",
          "package": "syntactic",
          "signature": "expr a -\u003e Hash",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#exprHashDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation of exprHash",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "exprHashDefault",
          "normalized": "a b-\u003eHash",
          "package": "syntactic",
          "partial": "Hash Default",
          "signature": "expr a-\u003eHash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:exprHashDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation of \u003ccode\u003e\u003ca\u003erenderArgs\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "renderArgsDefault",
          "package": "syntactic",
          "signature": "[String] -\u003e expr a -\u003e String",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#renderArgsDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation of renderArgs",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "renderArgsDefault",
          "normalized": "[String]-\u003ea b-\u003eString",
          "package": "syntactic",
          "partial": "Args Default",
          "signature": "[String]-\u003eexpr a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:renderArgsDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation of \u003ccode\u003e\u003ca\u003erenderSym\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "renderSymDefault",
          "package": "syntactic",
          "signature": "expr a -\u003e String",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#renderSymDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation of renderSym",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "renderSymDefault",
          "normalized": "a b-\u003eString",
          "package": "syntactic",
          "partial": "Sym Default",
          "signature": "expr a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:renderSymDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semanticEval",
          "package": "syntactic",
          "signature": "Denotation a",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#Semantics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semanticEval",
          "package": "syntactic",
          "partial": "Eval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:semanticEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive instances for \u003ccode\u003e\u003ca\u003eSemantic\u003c/a\u003e\u003c/code\u003e related classes\n (\u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eRender\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eStringTree\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eEval\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semanticInstances",
          "package": "syntactic",
          "signature": "Name -\u003e DecsQ",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#semanticInstances",
          "type": "function"
        },
        "index": {
          "description": "Derive instances for Semantic related classes Equality Render StringTree Eval",
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semanticInstances",
          "normalized": "Name-\u003eDecsQ",
          "package": "syntactic",
          "partial": "Instances",
          "signature": "Name-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:semanticInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semanticName",
          "package": "syntactic",
          "signature": "String",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#Semantics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semanticName",
          "package": "syntactic",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:semanticName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semantics",
          "package": "syntactic",
          "signature": "expr a -\u003e Semantics a",
          "source": "src/Language-Syntactic-Interpretation-Semantics.html#semantics",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Interpretation Semantics",
          "module": "Language.Syntactic.Interpretation.Semantics",
          "name": "semantics",
          "normalized": "a b-\u003eSemantics b",
          "package": "syntactic",
          "signature": "expr a-\u003eSemantics a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Interpretation-Semantics.html#v:semantics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation and manipulation of abstract syntax graphs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "Graph",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html",
          "type": "module"
        },
        "index": {
          "description": "Representation and manipulation of abstract syntax graphs",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "Graph",
          "package": "syntactic",
          "partial": "Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Abstract Syntax Graph\"\n\u003c/p\u003e\u003cp\u003eA representation of a syntax tree with explicit sharing. An \u003ccode\u003e\u003ca\u003eASG\u003c/a\u003e\u003c/code\u003e is valid if\n and only if \u003ccode\u003e\u003ca\u003einlineAll\u003c/a\u003e\u003c/code\u003e succeeds (and the \u003ccode\u003e\u003ca\u003enumNodes\u003c/a\u003e\u003c/code\u003e field is correct).\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "ASG",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#ASG",
          "type": "data"
        },
        "index": {
          "description": "Abstract Syntax Graph representation of syntax tree with explicit sharing An ASG is valid if and only if inlineAll succeeds and the numNodes field is correct",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "ASG",
          "package": "syntactic",
          "partial": "ASG",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:ASG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "EqEnv",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#EqEnv",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "EqEnv",
          "package": "syntactic",
          "partial": "Eq Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:EqEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePlaceholder for a syntax tree\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "Node",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#Node",
          "type": "data"
        },
        "index": {
          "description": "Placeholder for syntax tree",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "Node",
          "package": "syntactic",
          "partial": "Node",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeDomain",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#NodeDomain",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeDomain",
          "package": "syntactic",
          "partial": "Node Domain",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:NodeDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeEnv",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#NodeEnv",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeEnv",
          "package": "syntactic",
          "partial": "Node Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:NodeEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironment for alpha-equivalence\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeEqEnv",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#NodeEqEnv",
          "type": "class"
        },
        "index": {
          "description": "Environment for alpha-equivalence",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeEqEnv",
          "package": "syntactic",
          "partial": "Node Eq Env",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:NodeEqEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNode identifier\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeId",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#NodeId",
          "type": "newtype"
        },
        "index": {
          "description": "Node identifier",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeId",
          "package": "syntactic",
          "partial": "Node Id",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:NodeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePattern functor representation of an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003eNode\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "SyntaxPF",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Graph.html#SyntaxPF",
          "type": "data"
        },
        "index": {
          "description": "Pattern functor representation of an AST with Node",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "SyntaxPF",
          "package": "syntactic",
          "partial": "Syntax PF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#t:SyntaxPF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "ASG",
          "package": "syntactic",
          "signature": "ASG",
          "source": "src/Language-Syntactic-Sharing-Graph.html#ASG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "ASG",
          "package": "syntactic",
          "partial": "ASG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:ASG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "AppPF",
          "package": "syntactic",
          "signature": "a -\u003e a -\u003e SyntaxPF dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#SyntaxPF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "AppPF",
          "normalized": "a-\u003ea-\u003eSyntaxPF b a",
          "package": "syntactic",
          "partial": "App PF",
          "signature": "a-\u003ea-\u003eSyntaxPF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:AppPF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "DomPF",
          "package": "syntactic",
          "signature": "dom b -\u003e SyntaxPF dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#SyntaxPF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "DomPF",
          "normalized": "a b-\u003eSyntaxPF a c",
          "package": "syntactic",
          "partial": "Dom PF",
          "signature": "dom b-\u003eSyntaxPF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:DomPF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "Node",
          "package": "syntactic",
          "signature": "NodeId -\u003e Node (Full a)",
          "source": "src/Language-Syntactic-Sharing-Graph.html#Node",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "Node",
          "normalized": "NodeId-\u003eNode(Full a)",
          "package": "syntactic",
          "partial": "Node",
          "signature": "NodeId-\u003eNode(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeId",
          "package": "syntactic",
          "signature": "NodeId",
          "source": "src/Language-Syntactic-Sharing-Graph.html#NodeId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodeId",
          "package": "syntactic",
          "partial": "Node Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:NodeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodePF",
          "package": "syntactic",
          "signature": "NodeId -\u003e a -\u003e SyntaxPF dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#SyntaxPF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "NodePF",
          "normalized": "NodeId-\u003ea-\u003eSyntaxPF b a",
          "package": "syntactic",
          "partial": "Node PF",
          "signature": "NodeId-\u003ea-\u003eSyntaxPF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:NodePF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommon sub-expression elimination based on alpha-equivalence\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "cse",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e ASG dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#cse",
          "type": "function"
        },
        "index": {
          "description": "Common sub-expression elimination based on alpha-equivalence",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "cse",
          "normalized": "ASG a b-\u003eASG a b",
          "package": "syntactic",
          "signature": "ASG dom a-\u003eASG dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:cse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint syntax graph using ASCII art\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "drawASG",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e IO ()",
          "source": "src/Language-Syntactic-Sharing-Graph.html#drawASG",
          "type": "function"
        },
        "index": {
          "description": "Print syntax graph using ASCII art",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "drawASG",
          "normalized": "ASG a b-\u003eIO()",
          "package": "syntactic",
          "partial": "ASG",
          "signature": "ASG dom a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:drawASG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFolding over a graph\n\u003c/p\u003e\u003cp\u003eThe user provides a function to fold a single constructor (an \"algebra\").\n The result contains the result of folding the whole graph as well as the\n result of each internal node, represented both as an array and an association\n list. Each node is processed exactly once.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "foldGraph",
          "package": "syntactic",
          "signature": "forall dom a b.  (SyntaxPF dom b -\u003e b) -\u003e ASG dom a -\u003e (b, (Array NodeId b, [(NodeId, b)]))",
          "source": "src/Language-Syntactic-Sharing-Graph.html#foldGraph",
          "type": "function"
        },
        "index": {
          "description": "Folding over graph The user provides function to fold single constructor an algebra The result contains the result of folding the whole graph as well as the result of each internal node represented both as an array and an association list Each node is processed exactly once",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "foldGraph",
          "normalized": "a b c d(SyntaxPF b e-\u003ee)-\u003eASG b c-\u003e(e,(Array NodeId e,[(NodeId,e)]))",
          "package": "syntactic",
          "partial": "Graph",
          "signature": "forall dom a b.(SyntaxPF dom b-\u003eb)-\u003eASG dom a-\u003e(b,(Array NodeId b,[(NodeId,b)]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:foldGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMapping from node id to sub-expression\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "graphNodes",
          "package": "syntactic",
          "signature": "[(NodeId, ASTSAT (NodeDomain dom))]",
          "source": "src/Language-Syntactic-Sharing-Graph.html#ASG",
          "type": "function"
        },
        "index": {
          "description": "Mapping from node id to sub-expression",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "graphNodes",
          "normalized": "[(NodeId,ASTSAT(NodeDomain a))]",
          "package": "syntactic",
          "partial": "Nodes",
          "signature": "[(NodeId,ASTSAT(NodeDomain dom))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:graphNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a table (both array and list representation) of hash values for\n each node\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "hashNodes",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e (Array NodeId Hash, [(NodeId, Hash)])",
          "source": "src/Language-Syntactic-Sharing-Graph.html#hashNodes",
          "type": "function"
        },
        "index": {
          "description": "Compute table both array and list representation of hash values for each node",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "hashNodes",
          "normalized": "ASG a b-\u003e(Array NodeId Hash,[(NodeId,Hash)])",
          "package": "syntactic",
          "partial": "Nodes",
          "signature": "ASG dom a-\u003e(Array NodeId Hash,[(NodeId,Hash)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:hashNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eASG\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e by inlining all nodes\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "inlineAll",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e ASTF dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#inlineAll",
          "type": "function"
        },
        "index": {
          "description": "Convert an ASG to an AST by inlining all nodes",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "inlineAll",
          "normalized": "ASG a b-\u003eASTF a b",
          "package": "syntactic",
          "partial": "All",
          "signature": "ASG dom a-\u003eASTF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:inlineAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInline all nodes that are not shared\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "inlineSingle",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e ASG dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#inlineSingle",
          "type": "function"
        },
        "index": {
          "description": "Inline all nodes that are not shared",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "inlineSingle",
          "normalized": "ASG a b-\u003eASG a b",
          "package": "syntactic",
          "partial": "Single",
          "signature": "ASG dom a-\u003eASG dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:inlineSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "modNodeEqEnv",
          "package": "syntactic",
          "signature": "(NodeEnv dom (Sat dom) -\u003e NodeEnv dom (Sat dom)) -\u003e a -\u003e a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#modNodeEqEnv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "modNodeEqEnv",
          "normalized": "(NodeEnv a(Sat a)-\u003eNodeEnv a(Sat a))-\u003eb-\u003eb",
          "package": "syntactic",
          "partial": "Node Eq Env",
          "signature": "(NodeEnv dom(Sat dom)-\u003eNodeEnv dom(Sat dom))-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:modNodeEqEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the child nodes of each node in an expression. The child nodes of a\n node \u003ccode\u003en\u003c/code\u003e are the first nodes along all paths from \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "nodeChildren",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e [(NodeId, [NodeId])]",
          "source": "src/Language-Syntactic-Sharing-Graph.html#nodeChildren",
          "type": "function"
        },
        "index": {
          "description": "Find the child nodes of each node in an expression The child nodes of node are the first nodes along all paths from",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "nodeChildren",
          "normalized": "ASG a b-\u003e[(NodeId,[NodeId])]",
          "package": "syntactic",
          "partial": "Children",
          "signature": "ASG dom a-\u003e[(NodeId,[NodeId])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:nodeChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "nodeInteger",
          "package": "syntactic",
          "signature": "Integer",
          "source": "src/Language-Syntactic-Sharing-Graph.html#NodeId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "nodeInteger",
          "package": "syntactic",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:nodeInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove duplicate nodes from a graph. The function only looks at the\n \u003ccode\u003e\u003ca\u003eNodeId\u003c/a\u003e\u003c/code\u003e of each node. The \u003ccode\u003e\u003ca\u003enumNodes\u003c/a\u003e\u003c/code\u003e field is updated accordingly.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "nubNodes",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e ASG dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#nubNodes",
          "type": "function"
        },
        "index": {
          "description": "Remove duplicate nodes from graph The function only looks at the NodeId of each node The numNodes field is updated accordingly",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "nubNodes",
          "normalized": "ASG a b-\u003eASG a b",
          "package": "syntactic",
          "partial": "Nodes",
          "signature": "ASG dom a-\u003eASG dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:nubNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTotal number of nodes\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "numNodes",
          "package": "syntactic",
          "signature": "NodeId",
          "source": "src/Language-Syntactic-Sharing-Graph.html#ASG",
          "type": "function"
        },
        "index": {
          "description": "Total number of nodes",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "numNodes",
          "package": "syntactic",
          "partial": "Nodes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:numNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount the number of occurrences of each node in an expression\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "occurrences",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e Array NodeId Int",
          "source": "src/Language-Syntactic-Sharing-Graph.html#occurrences",
          "type": "function"
        },
        "index": {
          "description": "Count the number of occurrences of each node in an expression",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "occurrences",
          "normalized": "ASG a b-\u003eArray NodeId Int",
          "package": "syntactic",
          "signature": "ASG dom a-\u003eArray NodeId Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:occurrences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions the nodes such that two nodes are in the same sub-list if and\n only if they are alpha-equivalent.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "partitionNodes",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e [[NodeId]]",
          "source": "src/Language-Syntactic-Sharing-Graph.html#partitionNodes",
          "type": "function"
        },
        "index": {
          "description": "Partitions the nodes such that two nodes are in the same sub-list if and only if they are alpha-equivalent",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "partitionNodes",
          "normalized": "ASG a b-\u003e[[NodeId]]",
          "package": "syntactic",
          "partial": "Nodes",
          "signature": "ASG dom a-\u003e[[NodeId]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:partitionNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "prjNodeEqEnv",
          "package": "syntactic",
          "signature": "a -\u003e NodeEnv dom (Sat dom)",
          "source": "src/Language-Syntactic-Sharing-Graph.html#prjNodeEqEnv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "prjNodeEqEnv",
          "normalized": "a-\u003eNodeEnv b(Sat b)",
          "package": "syntactic",
          "partial": "Node Eq Env",
          "signature": "a-\u003eNodeEnv dom(Sat dom)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:prjNodeEqEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReindex the nodes according to the given index mapping. The number of nodes\n is unchanged, so if the index mapping is not 1:1, the resulting graph will\n contain duplicates.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "reindexNodes",
          "package": "syntactic",
          "signature": "(NodeId -\u003e NodeId) -\u003e ASG dom a -\u003e ASG dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#reindexNodes",
          "type": "function"
        },
        "index": {
          "description": "Reindex the nodes according to the given index mapping The number of nodes is unchanged so if the index mapping is not the resulting graph will contain duplicates",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "reindexNodes",
          "normalized": "(NodeId-\u003eNodeId)-\u003eASG a b-\u003eASG a b",
          "package": "syntactic",
          "partial": "Nodes",
          "signature": "(NodeId-\u003eNodeId)-\u003eASG dom a-\u003eASG dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:reindexNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the node identifiers in an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e using the supplied reindexing\n function\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "reindexNodesAST",
          "package": "syntactic",
          "signature": "(NodeId -\u003e NodeId) -\u003e AST (NodeDomain dom) a -\u003e AST (NodeDomain dom) a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#reindexNodesAST",
          "type": "function"
        },
        "index": {
          "description": "Update the node identifiers in an AST using the supplied reindexing function",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "reindexNodesAST",
          "normalized": "(NodeId-\u003eNodeId)-\u003eAST(NodeDomain a)b-\u003eAST(NodeDomain a)b",
          "package": "syntactic",
          "partial": "Nodes AST",
          "signature": "(NodeId-\u003eNodeId)-\u003eAST(NodeDomain dom)a-\u003eAST(NodeDomain dom)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:reindexNodesAST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReindex the nodes to be in the range \u003ccode\u003e[0 .. l-1]\u003c/code\u003e, where \u003ccode\u003el\u003c/code\u003e is the number\n of nodes in the graph\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "reindexNodesFrom0",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e ASG dom a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#reindexNodesFrom0",
          "type": "function"
        },
        "index": {
          "description": "Reindex the nodes to be in the range l-1 where is the number of nodes in the graph",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "reindexNodesFrom0",
          "normalized": "ASG a b-\u003eASG a b",
          "package": "syntactic",
          "partial": "Nodes From",
          "signature": "ASG dom a-\u003eASG dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:reindexNodesFrom0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow syntax graph using ASCII art\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "showASG",
          "package": "syntactic",
          "signature": "ASG dom a -\u003e String",
          "source": "src/Language-Syntactic-Sharing-Graph.html#showASG",
          "type": "function"
        },
        "index": {
          "description": "Show syntax graph using ASCII art",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "showASG",
          "normalized": "ASG a b-\u003eString",
          "package": "syntactic",
          "partial": "ASG",
          "signature": "ASG dom a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:showASG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "showNode",
          "package": "syntactic",
          "signature": "NodeId -\u003e String",
          "source": "src/Language-Syntactic-Sharing-Graph.html#showNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "showNode",
          "normalized": "NodeId-\u003eString",
          "package": "syntactic",
          "partial": "Node",
          "signature": "NodeId-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:showNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTop-level expression\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "topExpression",
          "package": "syntactic",
          "signature": "ASTF (NodeDomain dom) a",
          "source": "src/Language-Syntactic-Sharing-Graph.html#ASG",
          "type": "function"
        },
        "index": {
          "description": "Top-level expression",
          "hierarchy": "Language Syntactic Sharing Graph",
          "module": "Language.Syntactic.Sharing.Graph",
          "name": "topExpression",
          "package": "syntactic",
          "partial": "Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Graph.html#v:topExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReifying the sharing in an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis module is based on the paper \u003cem\u003eType-Safe Observable Sharing in Haskell\u003c/em\u003e\n (Andy Gill, 2009, \u003ca\u003ehttp://dx.doi.org/10.1145/1596638.1596653\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Sharing.Reify",
          "name": "Reify",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Reify.html",
          "type": "module"
        },
        "index": {
          "description": "Reifying the sharing in an AST This module is based on the paper Type-Safe Observable Sharing in Haskell Andy Gill http dx.doi.org",
          "hierarchy": "Language Syntactic Sharing Reify",
          "module": "Language.Syntactic.Sharing.Reify",
          "name": "Reify",
          "package": "syntactic",
          "partial": "Reify",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Reify.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a syntax tree to a sharing-preserving graph\n\u003c/p\u003e\u003cp\u003eThis function is not referentially transparent (hence the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e). However, it\n is well-behaved in the sense that the worst thing that could happen is that\n sharing is lost. It is not possible to get false sharing.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Reify",
          "name": "reifyGraph",
          "package": "syntactic",
          "signature": "(forall a.  ASTF dom a -\u003e Bool)-\u003e ASTF dom a-\u003e IO (ASG dom a)",
          "type": "function"
        },
        "index": {
          "description": "Convert syntax tree to sharing-preserving graph This function is not referentially transparent hence the IO However it is well-behaved in the sense that the worst thing that could happen is that sharing is lost It is not possible to get false sharing",
          "hierarchy": "Language Syntactic Sharing Reify",
          "module": "Language.Syntactic.Sharing.Reify",
          "name": "reifyGraph",
          "normalized": "(a b ASTF c d-\u003eBool)-\u003eASTF c d-\u003eIO(ASG c d)",
          "package": "syntactic",
          "partial": "Graph",
          "signature": "(forall a. ASTF dom a-\u003eBool)-\u003eASTF dom a-\u003eIO(ASG dom a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Reify.html#v:reifyGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is similar to \u003ca\u003eLanguage.Syntactic.Sharing.Reify\u003c/a\u003e, but operates\n on \u003ccode\u003e\u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eHODomain\u003c/a\u003e\u003c/code\u003e dom p)\u003c/code\u003e rather than a general \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e. The reason for\n having this module is that when using \u003ccode\u003e\u003ca\u003eHODomain\u003c/a\u003e\u003c/code\u003e, it is important to do\n simultaneous sharing analysis and \u003ccode\u003e\u003ca\u003eHOLambda\u003c/a\u003e\u003c/code\u003e reification. Obviously we cannot\n do sharing analysis first (using\n \u003ccode\u003e\u003ca\u003ereifyGraph\u003c/a\u003e\u003c/code\u003e from\n \u003ca\u003eLanguage.Syntactic.Sharing.Reify\u003c/a\u003e), since it needs to be able to look inside\n \u003ccode\u003e\u003ca\u003eHOLambda\u003c/a\u003e\u003c/code\u003e. On the other hand, if we did \u003ccode\u003e\u003ca\u003eHOLambda\u003c/a\u003e\u003c/code\u003e reification first (using\n \u003ccode\u003e\u003ca\u003ereify\u003c/a\u003e\u003c/code\u003e), we would destroy the sharing.\n\u003c/p\u003e\u003cp\u003eThis module is based on the paper \u003cem\u003eType-Safe Observable Sharing in Haskell\u003c/em\u003e\n (Andy Gill, 2009, \u003ca\u003ehttp://dx.doi.org/10.1145/1596638.1596653\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Sharing.ReifyHO",
          "name": "ReifyHO",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-ReifyHO.html",
          "type": "module"
        },
        "index": {
          "description": "This module is similar to Language.Syntactic.Sharing.Reify but operates on AST HODomain dom rather than general AST The reason for having this module is that when using HODomain it is important to do simultaneous sharing analysis and HOLambda reification Obviously we cannot do sharing analysis first using reifyGraph from Language.Syntactic.Sharing.Reify since it needs to be able to look inside HOLambda On the other hand if we did HOLambda reification first using reify we would destroy the sharing This module is based on the paper Type-Safe Observable Sharing in Haskell Andy Gill http dx.doi.org",
          "hierarchy": "Language Syntactic Sharing ReifyHO",
          "module": "Language.Syntactic.Sharing.ReifyHO",
          "name": "ReifyHO",
          "package": "syntactic",
          "partial": "Reify HO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-ReifyHO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReifying an n-ary syntactic function to a sharing-preserving graph\n\u003c/p\u003e\u003cp\u003eThis function is not referentially transparent (hence the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e). However, it\n is well-behaved in the sense that the worst thing that could happen is that\n sharing is lost. It is not possible to get false sharing.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.ReifyHO",
          "name": "reifyGraph",
          "package": "syntactic",
          "signature": "(forall a.  ASTF (HODomain dom p pVar) a -\u003e Bool)-\u003e a-\u003e IO (ASG (FODomain dom p pVar) (Internal a), VarId)",
          "type": "function"
        },
        "index": {
          "description": "Reifying an n-ary syntactic function to sharing-preserving graph This function is not referentially transparent hence the IO However it is well-behaved in the sense that the worst thing that could happen is that sharing is lost It is not possible to get false sharing",
          "hierarchy": "Language Syntactic Sharing ReifyHO",
          "module": "Language.Syntactic.Sharing.ReifyHO",
          "name": "reifyGraph",
          "normalized": "(a b ASTF(HODomain c d e)f-\u003eBool)-\u003ef-\u003eIO(ASG(FODomain c d e)(Internal f),VarId)",
          "package": "syntactic",
          "partial": "Graph",
          "signature": "(forall a. ASTF(HODomain dom p pVar)a-\u003eBool)-\u003ea-\u003eIO(ASG(FODomain dom p pVar)(Internal a),VarId)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-ReifyHO.html#v:reifyGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a syntax tree to a sharing-preserving graph\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.ReifyHO",
          "name": "reifyGraphTop",
          "package": "syntactic",
          "signature": "(forall a.  ASTF (HODomain dom p pVar) a -\u003e Bool) -\u003e ASTF (HODomain dom p pVar) a -\u003e IO (ASG (FODomain dom p pVar) a, VarId)",
          "source": "src/Language-Syntactic-Sharing-ReifyHO.html#reifyGraphTop",
          "type": "function"
        },
        "index": {
          "description": "Convert syntax tree to sharing-preserving graph",
          "hierarchy": "Language Syntactic Sharing ReifyHO",
          "module": "Language.Syntactic.Sharing.ReifyHO",
          "name": "reifyGraphTop",
          "normalized": "(a b ASTF(HODomain c d e)f-\u003eBool)-\u003eASTF(HODomain c d e)f-\u003eIO(ASG(FODomain c d e)f,VarId)",
          "package": "syntactic",
          "partial": "Graph Top",
          "signature": "(forall a. ASTF(HODomain dom p pVar)a-\u003eBool)-\u003eASTF(HODomain dom p pVar)a-\u003eIO(ASG(FODomain dom p pVar)a,VarId)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-ReifyHO.html#v:reifyGraphTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple code motion transformation performing common sub-expression elimination and variable\n hoisting. Note that the implementation is very inefficient.\n\u003c/p\u003e\u003cp\u003eThe code is based on an implementation by Gergely D&#233;vai.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "SimpleCodeMotion",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html",
          "type": "module"
        },
        "index": {
          "description": "Simple code motion transformation performing common sub-expression elimination and variable hoisting Note that the implementation is very inefficient The code is based on an implementation by Gergely vai",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "SimpleCodeMotion",
          "package": "syntactic",
          "partial": "Simple Code Motion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterface for injecting binding constructs\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "InjDict",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#InjDict",
          "type": "data"
        },
        "index": {
          "description": "Interface for injecting binding constructs",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "InjDict",
          "package": "syntactic",
          "partial": "Inj Dict",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#t:InjDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function that, if possible, returns an \u003ccode\u003e\u003ca\u003eInjDict\u003c/a\u003e\u003c/code\u003e for sharing a specific sub-expression. The\n first argument is the expression to be shared, and the second argument the expression in which it\n will be shared.\n\u003c/p\u003e\u003cp\u003eThis function makes the caller of \u003ccode\u003e\u003ca\u003ecodeMotion\u003c/a\u003e\u003c/code\u003e responsible for making sure that the necessary\n type constraints are fulfilled (otherwise \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is returned). It also makes it possible to\n transfer information, e.g. from the shared expression to the introduced variable.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "MkInjDict",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#MkInjDict",
          "type": "type"
        },
        "index": {
          "description": "function that if possible returns an InjDict for sharing specific sub-expression The first argument is the expression to be shared and the second argument the expression in which it will be shared This function makes the caller of codeMotion responsible for making sure that the necessary type constraints are fulfilled otherwise Nothing is returned It also makes it possible to transfer information e.g from the shared expression to the introduced variable",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "MkInjDict",
          "package": "syntactic",
          "partial": "Mk Inj Dict",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#t:MkInjDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterface for projecting binding constructs\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "PrjDict",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#PrjDict",
          "type": "data"
        },
        "index": {
          "description": "Interface for projecting binding constructs",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "PrjDict",
          "package": "syntactic",
          "partial": "Prj Dict",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#t:PrjDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "InjDict",
          "package": "syntactic",
          "signature": "InjDict",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#InjDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "InjDict",
          "package": "syntactic",
          "partial": "Inj Dict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:InjDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "PrjDict",
          "package": "syntactic",
          "signature": "PrjDict",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#PrjDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "PrjDict",
          "package": "syntactic",
          "partial": "Prj Dict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:PrjDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform common sub-expression elimination and variable hoisting\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "codeMotion",
          "package": "syntactic",
          "signature": "(forall c.  ASTF dom c -\u003e Bool)-\u003e PrjDict dom-\u003e MkInjDict dom-\u003e ASTF dom a-\u003e State VarId (ASTF dom a)",
          "type": "function"
        },
        "index": {
          "description": "Perform common sub-expression elimination and variable hoisting",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "codeMotion",
          "normalized": "(a b ASTF c d-\u003eBool)-\u003ePrjDict c-\u003eMkInjDict c-\u003eASTF c e-\u003eState VarId(ASTF c e)",
          "package": "syntactic",
          "partial": "Motion",
          "signature": "(forall c. ASTF dom c-\u003eBool)-\u003ePrjDict dom-\u003eMkInjDict dom-\u003eASTF dom a-\u003eState VarId(ASTF dom a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:codeMotion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "injLambda",
          "package": "syntactic",
          "signature": "VarId -\u003e dom (b :-\u003e Full (a -\u003e b))",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#InjDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "injLambda",
          "normalized": "VarId-\u003ea(b-\u003eFull(c-\u003eb))",
          "package": "syntactic",
          "partial": "Lambda",
          "signature": "VarId-\u003edom(b-\u003eFull(a-\u003eb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:injLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "injLet",
          "package": "syntactic",
          "signature": "dom (a :-\u003e ((a -\u003e b) :-\u003e Full b))",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#InjDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "injLet",
          "normalized": "a(b-\u003e((b-\u003ec)-\u003eFull c))",
          "package": "syntactic",
          "partial": "Let",
          "signature": "dom(a-\u003e((a-\u003eb)-\u003eFull b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:injLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "injVariable",
          "package": "syntactic",
          "signature": "VarId -\u003e dom (Full a)",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#InjDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "injVariable",
          "normalized": "VarId-\u003ea(Full b)",
          "package": "syntactic",
          "partial": "Variable",
          "signature": "VarId-\u003edom(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:injVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eMkInjDict\u003c/a\u003e\u003c/code\u003e implementation for \u003ccode\u003e\u003ca\u003eFODomain\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe supplied function determines whether or not an expression can be shared by returning a\n witness that the type of the expression satisfies the predicate \u003ccode\u003epVar\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "mkInjDictFO",
          "package": "syntactic",
          "signature": "(forall a.  ASTF (FODomain dom Typeable pVar) a -\u003e Maybe (Dict (pVar a))) -\u003e (forall b.  ASTF (FODomain dom Typeable pVar) b -\u003e Bool) -\u003e MkInjDict (FODomain dom Typeable pVar)",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#mkInjDictFO",
          "type": "function"
        },
        "index": {
          "description": "An MkInjDict implementation for FODomain The supplied function determines whether or not an expression can be shared by returning witness that the type of the expression satisfies the predicate pVar",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "mkInjDictFO",
          "normalized": "(a b ASTF(FODomain c Typeable d)e-\u003eMaybe(Dict(d e)))-\u003e(a f ASTF(FODomain c Typeable d)g-\u003eBool)-\u003eMkInjDict(FODomain c Typeable d)",
          "package": "syntactic",
          "partial": "Inj Dict FO",
          "signature": "(forall a. ASTF(FODomain dom Typeable pVar)a-\u003eMaybe(Dict(pVar a)))-\u003e(forall b. ASTF(FODomain dom Typeable pVar)b-\u003eBool)-\u003eMkInjDict(FODomain dom Typeable pVar)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:mkInjDictFO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003ePrjDict\u003c/a\u003e\u003c/code\u003e implementation for \u003ccode\u003e\u003ca\u003eFODomain\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "prjDictFO",
          "package": "syntactic",
          "signature": "forall dom p pVar.  PrjDict (FODomain dom p pVar)",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#prjDictFO",
          "type": "function"
        },
        "index": {
          "description": "PrjDict implementation for FODomain",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "prjDictFO",
          "package": "syntactic",
          "partial": "Dict FO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:prjDictFO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "prjLambda",
          "package": "syntactic",
          "signature": "forall sig.  dom sig -\u003e Maybe VarId",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#PrjDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "prjLambda",
          "normalized": "a b c d-\u003eMaybe VarId",
          "package": "syntactic",
          "partial": "Lambda",
          "signature": "forall sig. dom sig-\u003eMaybe VarId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:prjLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "prjVariable",
          "package": "syntactic",
          "signature": "forall sig.  dom sig -\u003e Maybe VarId",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#PrjDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "prjVariable",
          "normalized": "a b c d-\u003eMaybe VarId",
          "package": "syntactic",
          "partial": "Variable",
          "signature": "forall sig. dom sig-\u003eMaybe VarId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:prjVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ereify\u003c/a\u003e\u003c/code\u003e but with common sub-expression elimination and variable hoisting\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "reifySmart",
          "package": "syntactic",
          "signature": "(forall c.  ASTF (FODomain dom p pVar) c -\u003e Bool) -\u003e MkInjDict (FODomain dom p pVar) -\u003e a -\u003e ASTF (FODomain dom p pVar) (Internal a)",
          "source": "src/Language-Syntactic-Sharing-SimpleCodeMotion.html#reifySmart",
          "type": "function"
        },
        "index": {
          "description": "Like reify but with common sub-expression elimination and variable hoisting",
          "hierarchy": "Language Syntactic Sharing SimpleCodeMotion",
          "module": "Language.Syntactic.Sharing.SimpleCodeMotion",
          "name": "reifySmart",
          "normalized": "(a b ASTF(FODomain c d e)f-\u003eBool)-\u003eMkInjDict(FODomain c d e)-\u003eg-\u003eASTF(FODomain c d e)(Internal g)",
          "package": "syntactic",
          "partial": "Smart",
          "signature": "(forall c. ASTF(FODomain dom p pVar)c-\u003eBool)-\u003eMkInjDict(FODomain dom p pVar)-\u003ea-\u003eASTF(FODomain dom p pVar)(Internal a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-SimpleCodeMotion.html#v:reifySmart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "StableName",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-StableName.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "StableName",
          "package": "syntactic",
          "partial": "Stable Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA hash table from \u003ccode\u003e\u003ca\u003eStName\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eNodeId\u003c/a\u003e\u003c/code\u003e (with \u003ccode\u003e\u003ca\u003ehash\u003c/a\u003e\u003c/code\u003e as the hashing\n function). I.e. it is assumed that the \u003ccode\u003e\u003ca\u003eStName\u003c/a\u003e\u003c/code\u003es at each entry all have the\n same hash, and that this number is equal to the entry's key.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "History",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-StableName.html#History",
          "type": "type"
        },
        "index": {
          "description": "hash table from StName to NodeId with hash as the hashing function I.e it is assumed that the StName at each entry all have the same hash and that this number is equal to the entry key",
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "History",
          "package": "syntactic",
          "partial": "History",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#t:History"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eStableName\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e(c (Full a))\u003c/code\u003e with hidden result type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "StName",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-StableName.html#StName",
          "type": "data"
        },
        "index": {
          "description": "StableName of Full with hidden result type",
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "StName",
          "package": "syntactic",
          "partial": "St Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#t:StName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "StName",
          "package": "syntactic",
          "signature": "StableName (c (Full a)) -\u003e StName c",
          "source": "src/Language-Syntactic-Sharing-StableName.html#StName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "StName",
          "normalized": "StableName(a(Full b))-\u003eStName a",
          "package": "syntactic",
          "partial": "St Name",
          "signature": "StableName(c(Full a))-\u003eStName c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#v:StName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a fresh identifier from the given supply\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "fresh",
          "package": "syntactic",
          "signature": "IORef a -\u003e m a",
          "source": "src/Language-Syntactic-Sharing-StableName.html#fresh",
          "type": "function"
        },
        "index": {
          "description": "Return fresh identifier from the given supply",
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "fresh",
          "normalized": "IORef a-\u003eb a",
          "package": "syntactic",
          "signature": "IORef a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#v:fresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "hash",
          "package": "syntactic",
          "signature": "StName c -\u003e Int",
          "source": "src/Language-Syntactic-Sharing-StableName.html#hash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "hash",
          "normalized": "StName a-\u003eInt",
          "package": "syntactic",
          "signature": "StName c-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#v:hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a name in the history\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "lookHistory",
          "package": "syntactic",
          "signature": "History c -\u003e StName c -\u003e Maybe NodeId",
          "source": "src/Language-Syntactic-Sharing-StableName.html#lookHistory",
          "type": "function"
        },
        "index": {
          "description": "Lookup name in the history",
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "lookHistory",
          "normalized": "History a-\u003eStName a-\u003eMaybe NodeId",
          "package": "syntactic",
          "partial": "History",
          "signature": "History c-\u003eStName c-\u003eMaybe NodeId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#v:lookHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert the name into the history\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "remember",
          "package": "syntactic",
          "signature": "StName c -\u003e NodeId -\u003e History c -\u003e History c",
          "source": "src/Language-Syntactic-Sharing-StableName.html#remember",
          "type": "function"
        },
        "index": {
          "description": "Insert the name into the history",
          "hierarchy": "Language Syntactic Sharing StableName",
          "module": "Language.Syntactic.Sharing.StableName",
          "name": "remember",
          "normalized": "StName a-\u003eNodeId-\u003eHistory a-\u003eHistory a",
          "package": "syntactic",
          "signature": "StName c-\u003eNodeId-\u003eHistory c-\u003eHistory c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-StableName.html#v:remember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome utility functions used by the other modules\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "Utils",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "Some utility functions used by the other modules",
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "Utils",
          "package": "syntactic",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifference list\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "DList",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sharing-Utils.html#DList",
          "type": "type"
        },
        "index": {
          "description": "Difference list",
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "DList",
          "package": "syntactic",
          "partial": "DList",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#t:DList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount the number of occurrences of each element in the list. The result is\n an array mapping each element to its number of occurrences.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "count",
          "package": "syntactic",
          "signature": "(a, a)-\u003e [a]-\u003e Array a Int",
          "type": "function"
        },
        "index": {
          "description": "Count the number of occurrences of each element in the list The result is an array mapping each element to its number of occurrences",
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "count",
          "normalized": "(a,a)-\u003e[a]-\u003eArray a Int",
          "package": "syntactic",
          "signature": "(a,a)-\u003e[a]-\u003eArray a Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty list\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "empty",
          "package": "syntactic",
          "signature": "DList a",
          "source": "src/Language-Syntactic-Sharing-Utils.html#empty",
          "type": "function"
        },
        "index": {
          "description": "Empty list",
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "empty",
          "package": "syntactic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "fromDList",
          "package": "syntactic",
          "signature": "DList a -\u003e [a]",
          "source": "src/Language-Syntactic-Sharing-Utils.html#fromDList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "fromDList",
          "normalized": "DList a-\u003e[a]",
          "package": "syntactic",
          "partial": "DList",
          "signature": "DList a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#v:fromDList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions the list such that two elements are in the same sub-list if and\n only if they satisfy the equivalence check. The complexity is O(n^2).\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "fullPartition",
          "package": "syntactic",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Language-Syntactic-Sharing-Utils.html#fullPartition",
          "type": "function"
        },
        "index": {
          "description": "Partitions the list such that two elements are in the same sub-list if and only if they satisfy the equivalence check The complexity is",
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "fullPartition",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "syntactic",
          "partial": "Partition",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#v:fullPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list \u003ccode\u003eis\u003c/code\u003e of unique natural numbers, returns a function that maps\n each number in \u003ccode\u003eis\u003c/code\u003e to a unique number in the range \u003ccode\u003e[0 .. length is-1]\u003c/code\u003e. The\n complexity is O(\u003ccode\u003emaximum is\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "reindex",
          "package": "syntactic",
          "signature": "[a] -\u003e a -\u003e a",
          "source": "src/Language-Syntactic-Sharing-Utils.html#reindex",
          "type": "function"
        },
        "index": {
          "description": "Given list is of unique natural numbers returns function that maps each number in is to unique number in the range length is-1 The complexity is maximum is",
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "reindex",
          "normalized": "[a]-\u003ea-\u003ea",
          "package": "syntactic",
          "signature": "[a]-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#v:reindex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingleton list\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "single",
          "package": "syntactic",
          "signature": "a -\u003e DList a",
          "source": "src/Language-Syntactic-Sharing-Utils.html#single",
          "type": "function"
        },
        "index": {
          "description": "Singleton list",
          "hierarchy": "Language Syntactic Sharing Utils",
          "module": "Language.Syntactic.Sharing.Utils",
          "name": "single",
          "normalized": "a-\u003eDList a",
          "package": "syntactic",
          "signature": "a-\u003eDList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sharing-Utils.html#v:single"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Syntactic sugar\"\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Sugar",
          "name": "Sugar",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sugar.html",
          "type": "module"
        },
        "index": {
          "description": "Syntactic sugar",
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "Sugar",
          "package": "syntactic",
          "partial": "Sugar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is usually assumed that \u003ccode\u003e(\u003ccode\u003e\u003ca\u003edesugar\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003esugar\u003c/a\u003e\u003c/code\u003e a))\u003c/code\u003e has the same meaning\n as \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sugar",
          "name": "Syntactic",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sugar.html#Syntactic",
          "type": "class"
        },
        "index": {
          "description": "It is usually assumed that desugar sugar has the same meaning as",
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "Syntactic",
          "package": "syntactic",
          "partial": "Syntactic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#t:Syntactic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eN-ary syntactic functions\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003edesugarN\u003c/a\u003e\u003c/code\u003e has any type of the form:\n\u003c/p\u003e\u003cpre\u003e desugarN ::\n     ( Syntactic a\n     , Syntactic b\n     , ...\n     , Syntactic x\n     , Domain a ~ dom\n     , Domain b ~ dom\n     , ...\n     , Domain x ~ dom\n     ) =\u003e (a -\u003e b -\u003e ... -\u003e x)\n       -\u003e (  ASTF dom (Internal a)\n          -\u003e ASTF dom (Internal b)\n          -\u003e ...\n          -\u003e ASTF dom (Internal x)\n          )\n\u003c/pre\u003e\u003cp\u003e...and vice versa for \u003ccode\u003e\u003ca\u003esugarN\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sugar",
          "name": "SyntacticN",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Sugar.html#SyntacticN",
          "type": "class"
        },
        "index": {
          "description": "N-ary syntactic functions desugarN has any type of the form desugarN Syntactic Syntactic Syntactic Domain dom Domain dom Domain dom ASTF dom Internal ASTF dom Internal ASTF dom Internal and vice versa for sugarN",
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "SyntacticN",
          "package": "syntactic",
          "partial": "Syntactic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#t:SyntacticN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sugar",
          "name": "desugar",
          "package": "syntactic",
          "signature": "a -\u003e ASTF (Domain a) (Internal a)",
          "source": "src/Language-Syntactic-Sugar.html#desugar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "desugar",
          "normalized": "a-\u003eASTF(Domain a)(Internal a)",
          "package": "syntactic",
          "signature": "a-\u003eASTF(Domain a)(Internal a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#v:desugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sugar",
          "name": "desugarN",
          "package": "syntactic",
          "signature": "a -\u003e internal",
          "source": "src/Language-Syntactic-Sugar.html#desugarN",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "desugarN",
          "normalized": "a-\u003eb",
          "package": "syntactic",
          "signature": "a-\u003einternal",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#v:desugarN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyntactic type casting\n\u003c/p\u003e",
          "module": "Language.Syntactic.Sugar",
          "name": "resugar",
          "package": "syntactic",
          "signature": "a -\u003e b",
          "source": "src/Language-Syntactic-Sugar.html#resugar",
          "type": "function"
        },
        "index": {
          "description": "Syntactic type casting",
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "resugar",
          "normalized": "a-\u003eb",
          "package": "syntactic",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#v:resugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sugar",
          "name": "sugar",
          "package": "syntactic",
          "signature": "ASTF (Domain a) (Internal a) -\u003e a",
          "source": "src/Language-Syntactic-Sugar.html#sugar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "sugar",
          "normalized": "ASTF(Domain a)(Internal a)-\u003ea",
          "package": "syntactic",
          "signature": "ASTF(Domain a)(Internal a)-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#v:sugar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Sugar",
          "name": "sugarN",
          "package": "syntactic",
          "signature": "internal -\u003e a",
          "source": "src/Language-Syntactic-Sugar.html#sugarN",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "sugarN",
          "normalized": "a-\u003eb",
          "package": "syntactic",
          "signature": "internal-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#v:sugarN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Sugared\" symbol application\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003esugarSym\u003c/a\u003e\u003c/code\u003e has any type of the form:\n\u003c/p\u003e\u003cpre\u003e sugarSym ::\n     ( expr :\u003c: AST dom\n     , Syntactic a dom\n     , Syntactic b dom\n     , ...\n     , Syntactic x dom\n     ) =\u003e expr (Internal a :-\u003e Internal b :-\u003e ... :-\u003e Full (Internal x))\n       -\u003e (a -\u003e b -\u003e ... -\u003e x)\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Sugar",
          "name": "sugarSym",
          "package": "syntactic",
          "signature": "sym sig -\u003e c",
          "source": "src/Language-Syntactic-Sugar.html#sugarSym",
          "type": "function"
        },
        "index": {
          "description": "Sugared symbol application sugarSym has any type of the form sugarSym expr AST dom Syntactic dom Syntactic dom Syntactic dom expr Internal Internal Full Internal",
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "sugarSym",
          "normalized": "a b-\u003ec",
          "package": "syntactic",
          "partial": "Sym",
          "signature": "sym sig-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#v:sugarSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Sugared\" symbol application\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003esugarSymC\u003c/a\u003e\u003c/code\u003e has any type of the form:\n\u003c/p\u003e\u003cpre\u003e sugarSymC ::\n     ( InjectC expr (AST dom) (Internal x)\n     , Syntactic a dom\n     , Syntactic b dom\n     , ...\n     , Syntactic x dom\n     ) =\u003e expr (Internal a :-\u003e Internal b :-\u003e ... :-\u003e Full (Internal x))\n       -\u003e (a -\u003e b -\u003e ... -\u003e x)\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Sugar",
          "name": "sugarSymC",
          "package": "syntactic",
          "signature": "sym sig -\u003e c",
          "source": "src/Language-Syntactic-Sugar.html#sugarSymC",
          "type": "function"
        },
        "index": {
          "description": "Sugared symbol application sugarSymC has any type of the form sugarSymC InjectC expr AST dom Internal Syntactic dom Syntactic dom Syntactic dom expr Internal Internal Full Internal",
          "hierarchy": "Language Syntactic Sugar",
          "module": "Language.Syntactic.Sugar",
          "name": "sugarSymC",
          "normalized": "a b-\u003ec",
          "package": "syntactic",
          "partial": "Sym",
          "signature": "sym sig-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Sugar.html#v:sugarSymC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneric representation of typed syntax trees\n\u003c/p\u003e\u003cp\u003eFor details, see: A Generic Abstract Syntax Model for Embedded Languages\n (ICFP 2012, \u003ca\u003ehttp://www.cse.chalmers.se/~emax/documents/axelsson2012generic.pdf\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "Syntax",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html",
          "type": "module"
        },
        "index": {
          "description": "Generic representation of typed syntax trees For details see Generic Abstract Syntax Model for Embedded Languages ICFP http www.cse.chalmers.se emax documents axelsson2012generic.pdf",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "Syntax",
          "package": "syntactic",
          "partial": "Syntax",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirect sum of two symbol domains\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": ":+:",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#%3A%2B%3A",
          "type": "data"
        },
        "index": {
          "description": "Direct sum of two symbol domains",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": ":+:",
          "package": "syntactic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature of a partially applied (or unapplied) symbol\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": ":-\u003e",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#%3A-%3E",
          "type": "newtype"
        },
        "index": {
          "description": "Signature of partially applied or unapplied symbol",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": ":-\u003e",
          "package": "syntactic",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t::-45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymbol subsumption\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": ":\u003c:",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#%3A%3C%3A",
          "type": "class"
        },
        "index": {
          "description": "Symbol subsumption",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": ":\u003c:",
          "package": "syntactic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric abstract syntax tree, parameterized by a symbol domain\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e(\u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e dom (a \u003ccode\u003e\u003ca\u003e:-\u003e\u003c/a\u003e\u003c/code\u003e b))\u003c/code\u003e represents a partially applied (or unapplied)\n symbol, missing at least one argument, while \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e dom (\u003ccode\u003e\u003ca\u003eFull\u003c/a\u003e\u003c/code\u003e a))\u003c/code\u003e\n represents a fully applied symbol, i.e. a complete syntax tree.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "AST",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#AST",
          "type": "data"
        },
        "index": {
          "description": "Generic abstract syntax tree parameterized by symbol domain AST dom represents partially applied or unapplied symbol missing at least one argument while AST dom Full represents fully applied symbol i.e complete syntax tree",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "AST",
          "package": "syntactic",
          "partial": "AST",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t:AST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFully applied abstract syntax tree\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "ASTF",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#ASTF",
          "type": "type"
        },
        "index": {
          "description": "Fully applied abstract syntax tree",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "ASTF",
          "package": "syntactic",
          "partial": "ASTF",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t:ASTF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for the type-level recursion needed by \u003ccode\u003e\u003ca\u003eappSym\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "ApplySym",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#ApplySym",
          "type": "class"
        },
        "index": {
          "description": "Class for the type-level recursion needed by appSym",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "ApplySym",
          "package": "syntactic",
          "partial": "Apply Sym",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t:ApplySym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result type of a symbol with the given signature\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "DenResult",
          "package": "syntactic",
          "signature": "DenResult",
          "type": "function"
        },
        "index": {
          "description": "The result type of symbol with the given signature",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "DenResult",
          "package": "syntactic",
          "partial": "Den Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t:DenResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSignature of a fully applied symbol\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "Full",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#Full",
          "type": "newtype"
        },
        "index": {
          "description": "Signature of fully applied symbol",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "Full",
          "package": "syntactic",
          "partial": "Full",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t:Full"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymbol projection\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "Project",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Syntax.html#Project",
          "type": "class"
        },
        "index": {
          "description": "Symbol projection",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "Project",
          "package": "syntactic",
          "partial": "Project",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#t:Project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": ":$",
          "package": "syntactic",
          "signature": "AST dom (a :-\u003e sig) -\u003e AST dom (Full a) -\u003e AST dom sig",
          "source": "src/Language-Syntactic-Syntax.html#AST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": ":$",
          "normalized": "AST a(b-\u003ec)-\u003eAST a(Full b)-\u003eAST a c",
          "package": "syntactic",
          "signature": "AST dom(a-\u003esig)-\u003eAST dom(Full a)-\u003eAST dom sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v::-36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": "Full",
          "package": "syntactic",
          "signature": "Full",
          "source": "src/Language-Syntactic-Syntax.html#Full",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "Full",
          "package": "syntactic",
          "partial": "Full",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:Full"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": "InjL",
          "package": "syntactic",
          "signature": "dom1 a -\u003e (dom1 :+: dom2) a",
          "source": "src/Language-Syntactic-Syntax.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "InjL",
          "normalized": "a b-\u003e(a a)b",
          "package": "syntactic",
          "partial": "Inj",
          "signature": "dom a-\u003e(dom dom)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:InjL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": "InjR",
          "package": "syntactic",
          "signature": "dom2 a -\u003e (dom1 :+: dom2) a",
          "source": "src/Language-Syntactic-Syntax.html#%3A%2B%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "InjR",
          "normalized": "a b-\u003e(a a)b",
          "package": "syntactic",
          "partial": "Inj",
          "signature": "dom a-\u003e(dom dom)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:InjR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": "Partial",
          "package": "syntactic",
          "signature": "Partial (a -\u003e sig)",
          "source": "src/Language-Syntactic-Syntax.html#%3A-%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "Partial",
          "normalized": "Partial(a-\u003eb)",
          "package": "syntactic",
          "partial": "Partial",
          "signature": "Partial(a-\u003esig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:Partial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": "Sym",
          "package": "syntactic",
          "signature": "dom sig -\u003e AST dom sig",
          "source": "src/Language-Syntactic-Syntax.html#AST",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "Sym",
          "normalized": "a b-\u003eAST a b",
          "package": "syntactic",
          "partial": "Sym",
          "signature": "dom sig-\u003eAST dom sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:Sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric symbol application\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eappSym\u003c/a\u003e\u003c/code\u003e has any type of the form:\n\u003c/p\u003e\u003cpre\u003e appSym :: (expr :\u003c: AST dom)\n     =\u003e expr (a :-\u003e b :-\u003e ... :-\u003e Full x)\n     -\u003e (ASTF dom a -\u003e ASTF dom b -\u003e ... -\u003e ASTF dom x)\n\u003c/pre\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "appSym",
          "package": "syntactic",
          "signature": "sym sig -\u003e f",
          "source": "src/Language-Syntactic-Syntax.html#appSym",
          "type": "function"
        },
        "index": {
          "description": "Generic symbol application appSym has any type of the form appSym expr AST dom expr Full ASTF dom ASTF dom ASTF dom",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "appSym",
          "normalized": "a b-\u003ec",
          "package": "syntactic",
          "partial": "Sym",
          "signature": "sym sig-\u003ef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:appSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": "appSym'",
          "package": "syntactic",
          "signature": "AST dom sig -\u003e f",
          "source": "src/Language-Syntactic-Syntax.html#appSym%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "appSym'",
          "normalized": "AST a b-\u003ec",
          "package": "syntactic",
          "partial": "Sym'",
          "signature": "AST dom sig-\u003ef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:appSym-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInjection from \u003ccode\u003esub\u003c/code\u003e to \u003ccode\u003esup\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "inj",
          "package": "syntactic",
          "signature": "sub a -\u003e sup a",
          "source": "src/Language-Syntactic-Syntax.html#inj",
          "type": "method"
        },
        "index": {
          "description": "Injection from sub to sup",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "inj",
          "normalized": "a b-\u003ec b",
          "package": "syntactic",
          "signature": "sub a-\u003esup a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:inj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartial projection from \u003ccode\u003esup\u003c/code\u003e to \u003ccode\u003esub\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "prj",
          "package": "syntactic",
          "signature": "sup a -\u003e Maybe (sub a)",
          "source": "src/Language-Syntactic-Syntax.html#prj",
          "type": "method"
        },
        "index": {
          "description": "Partial projection from sup to sub",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "prj",
          "normalized": "a b-\u003eMaybe(c b)",
          "package": "syntactic",
          "signature": "sup a-\u003eMaybe(sub a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:prj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjection to a specific symbol type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "prjP",
          "package": "syntactic",
          "signature": "P sub -\u003e sup sig -\u003e Maybe (sub sig)",
          "source": "src/Language-Syntactic-Syntax.html#prjP",
          "type": "function"
        },
        "index": {
          "description": "Projection to specific symbol type",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "prjP",
          "normalized": "P a-\u003eb c-\u003eMaybe(a c)",
          "package": "syntactic",
          "signature": "P sub-\u003esup sig-\u003eMaybe(sub sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:prjP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Syntax",
          "name": "result",
          "package": "syntactic",
          "signature": "a",
          "source": "src/Language-Syntactic-Syntax.html#Full",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "result",
          "package": "syntactic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount the number of symbols in an expression\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "size",
          "package": "syntactic",
          "signature": "AST dom sig -\u003e Int",
          "source": "src/Language-Syntactic-Syntax.html#size",
          "type": "function"
        },
        "index": {
          "description": "Count the number of symbols in an expression",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "size",
          "normalized": "AST a b-\u003eInt",
          "package": "syntactic",
          "signature": "AST dom sig-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstrain a symbol to a specific type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Syntax",
          "name": "symType",
          "package": "syntactic",
          "signature": "P sym -\u003e sym sig -\u003e sym sig",
          "source": "src/Language-Syntactic-Syntax.html#symType",
          "type": "function"
        },
        "index": {
          "description": "Constrain symbol to specific type",
          "hierarchy": "Language Syntactic Syntax",
          "module": "Language.Syntactic.Syntax",
          "name": "symType",
          "normalized": "P a-\u003ea b-\u003ea b",
          "package": "syntactic",
          "partial": "Type",
          "signature": "P sym-\u003esym sig-\u003esym sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Syntax.html#v:symType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneric traversals of \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e terms\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "Traversal",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Traversal.html",
          "type": "module"
        },
        "index": {
          "description": "Generic traversals of AST terms",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "Traversal",
          "package": "syntactic",
          "partial": "Traversal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbol arguments\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "Args",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Traversal.html#Args",
          "type": "data"
        },
        "index": {
          "description": "List of symbol arguments",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "Args",
          "package": "syntactic",
          "partial": "Args",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#t:Args"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCan be used to make an arbitrary type constructor indexed by \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eFull\u003c/a\u003e\u003c/code\u003e a)\u003c/code\u003e.\n This is useful as the type constructor parameter of \u003ccode\u003e\u003ca\u003eArgs\u003c/a\u003e\u003c/code\u003e. That is, use\n\u003c/p\u003e\u003cpre\u003e Args (WrapFull c) ...\n\u003c/pre\u003e\u003cp\u003einstead of\n\u003c/p\u003e\u003cpre\u003e Args c ...\n\u003c/pre\u003e\u003cp\u003eif \u003ccode\u003ec\u003c/code\u003e is not indexed by \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eFull\u003c/a\u003e\u003c/code\u003e a)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "WrapFull",
          "package": "syntactic",
          "source": "src/Language-Syntactic-Traversal.html#WrapFull",
          "type": "data"
        },
        "index": {
          "description": "Can be used to make an arbitrary type constructor indexed by Full This is useful as the type constructor parameter of Args That is use Args WrapFull instead of Args if is not indexed by Full",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "WrapFull",
          "package": "syntactic",
          "partial": "Wrap Full",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#t:WrapFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Traversal",
          "name": ":*",
          "package": "syntactic",
          "signature": "c (Full a) -\u003e Args c sig -\u003e Args c (a :-\u003e sig)",
          "source": "src/Language-Syntactic-Traversal.html#Args",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": ":*",
          "normalized": "a(Full b)-\u003eArgs a c-\u003eArgs a(b-\u003ec)",
          "package": "syntactic",
          "signature": "c(Full a)-\u003eArgs c sig-\u003eArgs c(a-\u003esig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v::-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Traversal",
          "name": "Nil",
          "package": "syntactic",
          "signature": "Args c (Full a)",
          "source": "src/Language-Syntactic-Traversal.html#Args",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "Nil",
          "package": "syntactic",
          "partial": "Nil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:Nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Traversal",
          "name": "WrapFull",
          "package": "syntactic",
          "signature": "c a -\u003e WrapFull c (Full a)",
          "source": "src/Language-Syntactic-Traversal.html#WrapFull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "WrapFull",
          "normalized": "a b-\u003eWrapFull a(Full b)",
          "package": "syntactic",
          "partial": "Wrap Full",
          "signature": "c a-\u003eWrapFull c(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:WrapFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a (partially applied) symbol to a list of argument terms\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "appArgs",
          "package": "syntactic",
          "signature": "AST dom sig -\u003e Args (AST dom) sig -\u003e ASTF dom (DenResult sig)",
          "source": "src/Language-Syntactic-Traversal.html#appArgs",
          "type": "function"
        },
        "index": {
          "description": "Apply partially applied symbol to list of argument terms",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "appArgs",
          "normalized": "AST a b-\u003eArgs(AST a)b-\u003eASTF a(DenResult b)",
          "package": "syntactic",
          "partial": "Args",
          "signature": "AST dom sig-\u003eArgs(AST dom)sig-\u003eASTF dom(DenResult sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:appArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a transformation top-down over an expression (corresponds to\n \u003ccode\u003eeverywhere'\u003c/code\u003e in Scrap Your Boilerplate)\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "everywhereDown",
          "package": "syntactic",
          "signature": "(forall a.  ASTF dom a -\u003e ASTF dom a) -\u003e forall a.  ASTF dom a -\u003e ASTF dom a",
          "source": "src/Language-Syntactic-Traversal.html#everywhereDown",
          "type": "function"
        },
        "index": {
          "description": "Apply transformation top-down over an expression corresponds to everywhere in Scrap Your Boilerplate",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "everywhereDown",
          "normalized": "(a b ASTF c d-\u003eASTF c d)-\u003ea b ASTF c d-\u003eASTF c d",
          "package": "syntactic",
          "partial": "Down",
          "signature": "(forall a. ASTF dom a-\u003eASTF dom a)-\u003eforall a. ASTF dom a-\u003eASTF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:everywhereDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a transformation bottom-up over an expression (corresponds to\n \u003ccode\u003eeverywhere\u003c/code\u003e in Scrap Your Boilerplate)\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "everywhereUp",
          "package": "syntactic",
          "signature": "(forall a.  ASTF dom a -\u003e ASTF dom a) -\u003e forall a.  ASTF dom a -\u003e ASTF dom a",
          "source": "src/Language-Syntactic-Traversal.html#everywhereUp",
          "type": "function"
        },
        "index": {
          "description": "Apply transformation bottom-up over an expression corresponds to everywhere in Scrap Your Boilerplate",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "everywhereUp",
          "normalized": "(a b ASTF c d-\u003eASTF c d)-\u003ea b ASTF c d-\u003eASTF c d",
          "package": "syntactic",
          "partial": "Up",
          "signature": "(forall a. ASTF dom a-\u003eASTF dom a)-\u003eforall a. ASTF dom a-\u003eASTF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:everywhereUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e using an \u003ccode\u003e\u003ca\u003eArgs\u003c/a\u003e\u003c/code\u003e list to hold the results of sub-terms\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "fold",
          "package": "syntactic",
          "signature": "forall dom c.  (forall sig.  dom sig -\u003e Args c sig -\u003e c (Full (DenResult sig))) -\u003e forall a.  ASTF dom a -\u003e c (Full a)",
          "source": "src/Language-Syntactic-Traversal.html#fold",
          "type": "function"
        },
        "index": {
          "description": "Fold an AST using an Args list to hold the results of sub-terms",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "fold",
          "normalized": "a b c(a d b e-\u003eArgs f e-\u003ef(Full(DenResult e)))-\u003ea g ASTF b h-\u003ef(Full h)",
          "package": "syntactic",
          "signature": "forall dom c.(forall sig. dom sig-\u003eArgs c sig-\u003ec(Full(DenResult sig)))-\u003eforall a. ASTF dom a-\u003ec(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over all immediate sub-terms, collecting the results in a\n list (corresponds to the function with the same name in Scrap Your\n Boilerplate)\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "gmapQ",
          "package": "syntactic",
          "signature": "forall dom b.  (forall a.  ASTF dom a -\u003e b) -\u003e forall a.  ASTF dom a -\u003e [b]",
          "source": "src/Language-Syntactic-Traversal.html#gmapQ",
          "type": "function"
        },
        "index": {
          "description": "Map function over all immediate sub-terms collecting the results in list corresponds to the function with the same name in Scrap Your Boilerplate",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "gmapQ",
          "normalized": "a b c(a d ASTF b e-\u003ef)-\u003ea d ASTF b e-\u003e[f]",
          "package": "syntactic",
          "signature": "forall dom b.(forall a. ASTF dom a-\u003eb)-\u003eforall a. ASTF dom a-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:gmapQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over all immediate sub-terms (corresponds to the function\n with the same name in Scrap Your Boilerplate)\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "gmapT",
          "package": "syntactic",
          "signature": "forall dom.  (forall a.  ASTF dom a -\u003e ASTF dom a) -\u003e forall a.  ASTF dom a -\u003e ASTF dom a",
          "source": "src/Language-Syntactic-Traversal.html#gmapT",
          "type": "function"
        },
        "index": {
          "description": "Map function over all immediate sub-terms corresponds to the function with the same name in Scrap Your Boilerplate",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "gmapT",
          "normalized": "a b(a c ASTF d e-\u003eASTF d e)-\u003ea c ASTF d e-\u003eASTF d e",
          "package": "syntactic",
          "signature": "forall dom.(forall a. ASTF dom a-\u003eASTF dom a)-\u003eforall a. ASTF dom a-\u003eASTF dom a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:gmapT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over an \u003ccode\u003e\u003ca\u003eArgs\u003c/a\u003e\u003c/code\u003e list and collect the results in an ordinary\n list\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "listArgs",
          "package": "syntactic",
          "signature": "(forall a.  c (Full a) -\u003e b) -\u003e Args c sig -\u003e [b]",
          "source": "src/Language-Syntactic-Traversal.html#listArgs",
          "type": "function"
        },
        "index": {
          "description": "Map function over an Args list and collect the results in an ordinary list",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "listArgs",
          "normalized": "(a b c(Full d)-\u003ee)-\u003eArgs c f-\u003e[e]",
          "package": "syntactic",
          "partial": "Args",
          "signature": "(forall a. c(Full a)-\u003eb)-\u003eArgs c sig-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:listArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e using a list to hold the results of sub-terms\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "listFold",
          "package": "syntactic",
          "signature": "forall dom b.  (forall sig.  dom sig -\u003e [b] -\u003e b) -\u003e forall a.  ASTF dom a -\u003e b",
          "source": "src/Language-Syntactic-Traversal.html#listFold",
          "type": "function"
        },
        "index": {
          "description": "Fold an AST using list to hold the results of sub-terms",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "listFold",
          "normalized": "a b c(a d b e-\u003e[f]-\u003ef)-\u003ea g ASTF b h-\u003ef",
          "package": "syntactic",
          "partial": "Fold",
          "signature": "forall dom b.(forall sig. dom sig-\u003e[b]-\u003eb)-\u003eforall a. ASTF dom a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:listFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over an \u003ccode\u003e\u003ca\u003eArgs\u003c/a\u003e\u003c/code\u003e list\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "mapArgs",
          "package": "syntactic",
          "signature": "(forall a.  c1 (Full a) -\u003e c2 (Full a)) -\u003e forall sig.  Args c1 sig -\u003e Args c2 sig",
          "source": "src/Language-Syntactic-Traversal.html#mapArgs",
          "type": "function"
        },
        "index": {
          "description": "Map function over an Args list",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "mapArgs",
          "normalized": "(a b c(Full d)-\u003ec(Full d))-\u003ea e Args c f-\u003eArgs c f",
          "package": "syntactic",
          "partial": "Args",
          "signature": "(forall a. c(Full a)-\u003ec(Full a))-\u003eforall sig. Args c sig-\u003eArgs c sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:mapArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap an applicative function over an \u003ccode\u003e\u003ca\u003eArgs\u003c/a\u003e\u003c/code\u003e list\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "mapArgsA",
          "package": "syntactic",
          "signature": "(forall a.  c1 (Full a) -\u003e f (c2 (Full a))) -\u003e forall sig.  Args c1 sig -\u003e f (Args c2 sig)",
          "source": "src/Language-Syntactic-Traversal.html#mapArgsA",
          "type": "function"
        },
        "index": {
          "description": "Map an applicative function over an Args list",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "mapArgsA",
          "normalized": "(a b c(Full d)-\u003ee(c(Full d)))-\u003ea f Args c g-\u003ee(Args c g)",
          "package": "syntactic",
          "partial": "Args",
          "signature": "(forall a. c(Full a)-\u003ef(c(Full a)))-\u003eforall sig. Args c sig-\u003ef(Args c sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:mapArgsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a monadic function over an \u003ccode\u003e\u003ca\u003eArgs\u003c/a\u003e\u003c/code\u003e list\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "mapArgsM",
          "package": "syntactic",
          "signature": "(forall a.  c1 (Full a) -\u003e m (c2 (Full a))) -\u003e forall sig.  Args c1 sig -\u003e m (Args c2 sig)",
          "source": "src/Language-Syntactic-Traversal.html#mapArgsM",
          "type": "function"
        },
        "index": {
          "description": "Map monadic function over an Args list",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "mapArgsM",
          "normalized": "(a b c(Full d)-\u003ee(c(Full d)))-\u003ea f Args c g-\u003ee(Args c g)",
          "package": "syntactic",
          "partial": "Args",
          "signature": "(forall a. c(Full a)-\u003em(c(Full a)))-\u003eforall sig. Args c sig-\u003em(Args c sig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:mapArgsM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Pattern match\" on an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e using a function that gets direct access to\n the top-most symbol and its sub-trees\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "match",
          "package": "syntactic",
          "signature": "dom sig -\u003e Args (AST dom) sig -\u003e c (Full a)) -\u003e ASTF dom a -\u003e c (Full a)",
          "source": "src/Language-Syntactic-Traversal.html#match",
          "type": "function"
        },
        "index": {
          "description": "Pattern match on an AST using function that gets direct access to the top-most symbol and its sub-trees",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "match",
          "normalized": "a b-\u003eArgs(AST a)b-\u003ec(Full d))-\u003eASTF a d-\u003ec(Full d)",
          "package": "syntactic",
          "signature": "dom sig-\u003eArgs(AST dom)sig-\u003ec(Full a))-\u003eASTF dom a-\u003ec(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e where the result is a transformed syntax tree,\n wrapped in a type constructor \u003ccode\u003ec\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "matchTrans",
          "package": "syntactic",
          "signature": "dom sig -\u003e Args (AST dom) sig -\u003e c (ASTF dom' a)) -\u003e ASTF dom a -\u003e c (ASTF dom' a)",
          "source": "src/Language-Syntactic-Traversal.html#matchTrans",
          "type": "function"
        },
        "index": {
          "description": "version of match where the result is transformed syntax tree wrapped in type constructor",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "matchTrans",
          "normalized": "a b-\u003eArgs(AST a)b-\u003ec(ASTF d e))-\u003eASTF a e-\u003ec(ASTF d e)",
          "package": "syntactic",
          "partial": "Trans",
          "signature": "dom sig-\u003eArgs(AST dom)sig-\u003ec(ASTF dom' a))-\u003eASTF dom a-\u003ec(ASTF dom' a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:matchTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Please use \u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "query",
          "package": "syntactic",
          "signature": "dom sig -\u003e Args (AST dom) sig -\u003e c (Full a)) -\u003e ASTF dom a -\u003e c (Full a)",
          "source": "src/Language-Syntactic-Traversal.html#query",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Please use match instead",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "query",
          "normalized": "a b-\u003eArgs(AST a)b-\u003ec(Full d))-\u003eASTF a d-\u003ec(Full d)",
          "package": "syntactic",
          "signature": "dom sig-\u003eArgs(AST dom)sig-\u003ec(Full a))-\u003eASTF dom a-\u003ec(Full a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:query"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimplified version of \u003ccode\u003e\u003ca\u003efold\u003c/a\u003e\u003c/code\u003e for situations where all intermediate results\n have the same type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "simpleFold",
          "package": "syntactic",
          "signature": "forall dom b.  (forall sig.  dom sig -\u003e Args (Const b) sig -\u003e b) -\u003e forall a.  ASTF dom a -\u003e b",
          "source": "src/Language-Syntactic-Traversal.html#simpleFold",
          "type": "function"
        },
        "index": {
          "description": "Simplified version of fold for situations where all intermediate results have the same type",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "simpleFold",
          "normalized": "a b c(a d b e-\u003eArgs(Const f)e-\u003ef)-\u003ea g ASTF b h-\u003ef",
          "package": "syntactic",
          "partial": "Fold",
          "signature": "forall dom b.(forall sig. dom sig-\u003eArgs(Const b)sig-\u003eb)-\u003eforall a. ASTF dom a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:simpleFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e with a simpler result type\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "simpleMatch",
          "package": "syntactic",
          "signature": "dom sig -\u003e Args (AST dom) sig -\u003e b) -\u003e ASTF dom a -\u003e b",
          "source": "src/Language-Syntactic-Traversal.html#simpleMatch",
          "type": "function"
        },
        "index": {
          "description": "version of match with simpler result type",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "simpleMatch",
          "normalized": "a b-\u003eArgs(AST a)b-\u003ec)-\u003eASTF a d-\u003ec",
          "package": "syntactic",
          "partial": "Match",
          "signature": "dom sig-\u003eArgs(AST dom)sig-\u003eb)-\u003eASTF dom a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:simpleMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eAST\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Syntactic.Traversal",
          "name": "toTree",
          "package": "syntactic",
          "signature": "forall dom a b.  (forall sig.  dom sig -\u003e b) -\u003e ASTF dom a -\u003e Tree b",
          "source": "src/Language-Syntactic-Traversal.html#toTree",
          "type": "function"
        },
        "index": {
          "description": "Convert an AST to Tree",
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "toTree",
          "normalized": "a b c d(a e b f-\u003eg)-\u003eASTF b c-\u003eTree g",
          "package": "syntactic",
          "partial": "Tree",
          "signature": "forall dom a b.(forall sig. dom sig-\u003eb)-\u003eASTF dom a-\u003eTree b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:toTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Syntactic.Traversal",
          "name": "unwrapFull",
          "package": "syntactic",
          "signature": "c a",
          "source": "src/Language-Syntactic-Traversal.html#WrapFull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Syntactic Traversal",
          "module": "Language.Syntactic.Traversal",
          "name": "unwrapFull",
          "package": "syntactic",
          "partial": "Full",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic-Traversal.html#v:unwrapFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe basic parts of the syntactic library\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Syntactic",
          "name": "Syntactic",
          "package": "syntactic",
          "source": "src/Language-Syntactic.html",
          "type": "module"
        },
        "index": {
          "description": "The basic parts of the syntactic library",
          "hierarchy": "Language Syntactic",
          "module": "Language.Syntactic",
          "name": "Syntactic",
          "package": "syntactic",
          "partial": "Syntactic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactic/docs/Language-Syntactic.html#"
      }
    }
  ]
]