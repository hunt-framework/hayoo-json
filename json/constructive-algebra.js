[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "constructive-algebra"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe elliptic curve y^2 = 1 - x^4 in Q[x,y].\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.EllipticCurve",
          "name": "EllipticCurve",
          "package": "constructive-algebra",
          "source": "src/Algebra-EllipticCurve.html",
          "type": "module"
        },
        "index": {
          "description": "The elliptic curve in",
          "hierarchy": "Algebra EllipticCurve",
          "module": "Algebra.EllipticCurve",
          "name": "EllipticCurve",
          "package": "constructive-algebra",
          "partial": "Elliptic Curve",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-EllipticCurve.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe elliptic curve y^2=1-x^4 over Q[x,y].\n\u003c/p\u003e",
          "module": "Algebra.EllipticCurve",
          "name": "EllipticCurve",
          "package": "constructive-algebra",
          "source": "src/Algebra-EllipticCurve.html#EllipticCurve",
          "type": "newtype"
        },
        "index": {
          "description": "The elliptic curve over",
          "hierarchy": "Algebra EllipticCurve",
          "module": "Algebra.EllipticCurve",
          "name": "EllipticCurve",
          "package": "constructive-algebra",
          "partial": "Elliptic Curve",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-EllipticCurve.html#t:EllipticCurve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.EllipticCurve",
          "name": "C",
          "package": "constructive-algebra",
          "signature": "C (Qx, Qx)",
          "source": "src/Algebra-EllipticCurve.html#EllipticCurve",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra EllipticCurve",
          "module": "Algebra.EllipticCurve",
          "name": "C",
          "normalized": "C(Qx,Qx)",
          "package": "constructive-algebra",
          "signature": "C(Qx,Qx)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-EllipticCurve.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe field of rational functions is the field of fractions of k[x].\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "FieldOfRationalFunctions",
          "package": "constructive-algebra",
          "source": "src/Algebra-FieldOfRationalFunctions.html",
          "type": "module"
        },
        "index": {
          "description": "The field of rational functions is the field of fractions of",
          "hierarchy": "Algebra FieldOfRationalFunctions",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "FieldOfRationalFunctions",
          "package": "constructive-algebra",
          "partial": "Field Of Rational Functions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-FieldOfRationalFunctions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField of rational functions.\n\u003c/p\u003e",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "FieldOfRationalFunctions",
          "package": "constructive-algebra",
          "source": "src/Algebra-FieldOfRationalFunctions.html#FieldOfRationalFunctions",
          "type": "type"
        },
        "index": {
          "description": "Field of rational functions",
          "hierarchy": "Algebra FieldOfRationalFunctions",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "FieldOfRationalFunctions",
          "package": "constructive-algebra",
          "partial": "Field Of Rational Functions",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-FieldOfRationalFunctions.html#t:FieldOfRationalFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe field of fraction of Q[x].\n\u003c/p\u003e",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "QX",
          "package": "constructive-algebra",
          "source": "src/Algebra-FieldOfRationalFunctions.html#QX",
          "type": "type"
        },
        "index": {
          "description": "The field of fraction of",
          "hierarchy": "Algebra FieldOfRationalFunctions",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "QX",
          "package": "constructive-algebra",
          "partial": "QX",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-FieldOfRationalFunctions.html#t:QX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "toQX",
          "package": "constructive-algebra",
          "signature": "Qx -\u003e QX",
          "source": "src/Algebra-FieldOfRationalFunctions.html#toQX",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra FieldOfRationalFunctions",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "toQX",
          "normalized": "Qx-\u003eQX",
          "package": "constructive-algebra",
          "partial": "QX",
          "signature": "Qx-\u003eQX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-FieldOfRationalFunctions.html#v:toQX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "toQx",
          "package": "constructive-algebra",
          "signature": "QX -\u003e Qx",
          "source": "src/Algebra-FieldOfRationalFunctions.html#toQx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra FieldOfRationalFunctions",
          "module": "Algebra.FieldOfRationalFunctions",
          "name": "toQx",
          "normalized": "QX-\u003eQx",
          "package": "constructive-algebra",
          "partial": "Qx",
          "signature": "QX-\u003eQx",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-FieldOfRationalFunctions.html#v:toQx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFinitely generated ideals in commutative rings.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Ideal",
          "name": "Ideal",
          "package": "constructive-algebra",
          "source": "src/Algebra-Ideal.html",
          "type": "module"
        },
        "index": {
          "description": "Finitely generated ideals in commutative rings",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "Ideal",
          "package": "constructive-algebra",
          "partial": "Ideal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdeals characterized by their list of generators.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "Ideal",
          "package": "constructive-algebra",
          "source": "src/Algebra-Ideal.html#Ideal",
          "type": "data"
        },
        "index": {
          "description": "Ideals characterized by their list of generators",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "Ideal",
          "package": "constructive-algebra",
          "partial": "Ideal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#t:Ideal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ideal",
          "name": "Id",
          "package": "constructive-algebra",
          "signature": "Id [a]",
          "source": "src/Algebra-Ideal.html#Ideal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "Id",
          "normalized": "Id[a]",
          "package": "constructive-algebra",
          "partial": "Id",
          "signature": "Id[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition of ideals.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "addId",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Ideal a -\u003e Ideal a",
          "source": "src/Algebra-Ideal.html#addId",
          "type": "function"
        },
        "index": {
          "description": "Addition of ideals",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "addId",
          "normalized": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "package": "constructive-algebra",
          "partial": "Id",
          "signature": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:addId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate the ideal at a certain point.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "eval",
          "package": "constructive-algebra",
          "signature": "a -\u003e Ideal a -\u003e a",
          "source": "src/Algebra-Ideal.html#eval",
          "type": "function"
        },
        "index": {
          "description": "Evaluate the ideal at certain point",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "eval",
          "normalized": "a-\u003eIdeal a-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003eIdeal a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ideal",
          "name": "fromId",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e [a]",
          "source": "src/Algebra-Ideal.html#fromId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "fromId",
          "normalized": "Ideal a-\u003e[a]",
          "package": "constructive-algebra",
          "partial": "Id",
          "signature": "Ideal a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:fromId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if an ideal is principal.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "isPrincipal",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Bool",
          "source": "src/Algebra-Ideal.html#isPrincipal",
          "type": "function"
        },
        "index": {
          "description": "Test if an ideal is principal",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "isPrincipal",
          "normalized": "Ideal a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Principal",
          "signature": "Ideal a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:isPrincipal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if an operations compute the correct ideal. \nThe operation should give a witness that the comuted ideal contains\nthe same elements.\n\u003c/p\u003e\u003cp\u003eIf [ x_1, ..., x_n ] `op` [ y_1, ..., y_m ] = [ z_1, ..., z_l ]\n\u003c/p\u003e\u003cp\u003eThen the witness should give that\n\u003c/p\u003e\u003cp\u003ez_k = a_k1 * x_1 + ... + a_kn * x_n\n    = b_k1 * y_1 + ... + b_km * y_m\n\u003c/p\u003e\u003cp\u003eThis is used to check that the intersection computed is correct.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "isSameIdeal",
          "package": "constructive-algebra",
          "signature": "(Ideal a -\u003e Ideal a -\u003e (Ideal a, [[a]], [[a]])) -\u003e Ideal a -\u003e Ideal a -\u003e Bool",
          "source": "src/Algebra-Ideal.html#isSameIdeal",
          "type": "function"
        },
        "index": {
          "description": "Test if an operations compute the correct ideal The operation should give witness that the comuted ideal contains the same elements If op Then the witness should give that k1 kn k1 km This is used to check that the intersection computed is correct",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "isSameIdeal",
          "normalized": "(Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]]))-\u003eIdeal a-\u003eIdeal a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Same Ideal",
          "signature": "(Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]]))-\u003eIdeal a-\u003eIdeal a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:isSameIdeal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication of ideals.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "mulId",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Ideal a -\u003e Ideal a",
          "source": "src/Algebra-Ideal.html#mulId",
          "type": "function"
        },
        "index": {
          "description": "Multiplication of ideals",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "mulId",
          "normalized": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "package": "constructive-algebra",
          "partial": "Id",
          "signature": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:mulId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe zero ideal.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "zeroIdeal",
          "package": "constructive-algebra",
          "signature": "Ideal a",
          "source": "src/Algebra-Ideal.html#zeroIdeal",
          "type": "function"
        },
        "index": {
          "description": "The zero ideal",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "zeroIdeal",
          "package": "constructive-algebra",
          "partial": "Ideal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:zeroIdeal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute witnesses for two lists for the zero ideal. This is used when \n computing the intersection of two ideals.\n\u003c/p\u003e",
          "module": "Algebra.Ideal",
          "name": "zeroIdealWitnesses",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e [a] -\u003e (Ideal a, [[a]], [[a]])",
          "source": "src/Algebra-Ideal.html#zeroIdealWitnesses",
          "type": "function"
        },
        "index": {
          "description": "Compute witnesses for two lists for the zero ideal This is used when computing the intersection of two ideals",
          "hierarchy": "Algebra Ideal",
          "module": "Algebra.Ideal",
          "name": "zeroIdealWitnesses",
          "normalized": "[a]-\u003e[a]-\u003e(Ideal a,[[a]],[[a]])",
          "package": "constructive-algebra",
          "partial": "Ideal Witnesses",
          "signature": "[a]-\u003e[a]-\u003e(Ideal a,[[a]],[[a]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Ideal.html#v:zeroIdealWitnesses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA small simple matrix library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Matrix",
          "name": "Matrix",
          "package": "constructive-algebra",
          "source": "src/Algebra-Matrix.html",
          "type": "module"
        },
        "index": {
          "description": "small simple matrix library",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "Matrix",
          "package": "constructive-algebra",
          "partial": "Matrix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrices\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "Matrix",
          "package": "constructive-algebra",
          "source": "src/Algebra-Matrix.html#Matrix",
          "type": "newtype"
        },
        "index": {
          "description": "Matrices",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "Matrix",
          "package": "constructive-algebra",
          "partial": "Matrix",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRow vectors\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "Vector",
          "package": "constructive-algebra",
          "source": "src/Algebra-Matrix.html#Vector",
          "type": "newtype"
        },
        "index": {
          "description": "Row vectors",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "Vector",
          "package": "constructive-algebra",
          "partial": "Vector",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "(!!!)",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e (Int, Int) -\u003e a",
          "source": "src/Algebra-Matrix.html#%21%21%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "(!!!) !!!",
          "normalized": "Matrix a-\u003e(Int,Int)-\u003ea",
          "package": "constructive-algebra",
          "signature": "Matrix a-\u003e(Int,Int)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:-33--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "M",
          "package": "constructive-algebra",
          "signature": "M [Vector r]",
          "source": "src/Algebra-Matrix.html#Matrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "M",
          "normalized": "M[Vector a]",
          "package": "constructive-algebra",
          "signature": "M[Vector r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "Vec",
          "package": "constructive-algebra",
          "signature": "Vec [r]",
          "source": "src/Algebra-Matrix.html#Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "Vec",
          "normalized": "Vec[a]",
          "package": "constructive-algebra",
          "partial": "Vec",
          "signature": "Vec[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:Vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "addCol",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Vector a -\u003e Int -\u003e Matrix a",
          "source": "src/Algebra-Matrix.html#addCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "addCol",
          "normalized": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "Col",
          "signature": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:addCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix addition.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "addM",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e Matrix r -\u003e Matrix r",
          "source": "src/Algebra-Matrix.html#addM",
          "type": "function"
        },
        "index": {
          "description": "Matrix addition",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "addM",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Matrix r-\u003eMatrix r-\u003eMatrix r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:addM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "addRow",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Vector a -\u003e Int -\u003e Matrix a",
          "source": "src/Algebra-Matrix.html#addRow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "addRow",
          "normalized": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "Row",
          "signature": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:addRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the dimension of a matrix.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "dimension",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e (Int, Int)",
          "source": "src/Algebra-Matrix.html#dimension",
          "type": "function"
        },
        "index": {
          "description": "Compute the dimension of matrix",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "dimension",
          "normalized": "Matrix a-\u003e(Int,Int)",
          "package": "constructive-algebra",
          "signature": "Matrix r-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "findPivot",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e (Int, Int) -\u003e Maybe (a, Int)",
          "source": "src/Algebra-Matrix.html#findPivot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "findPivot",
          "normalized": "Matrix a-\u003e(Int,Int)-\u003eMaybe(a,Int)",
          "package": "constructive-algebra",
          "partial": "Pivot",
          "signature": "Matrix a-\u003e(Int,Int)-\u003eMaybe(a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:findPivot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute row echelon form of a system Ax=b.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "forwardElim",
          "package": "constructive-algebra",
          "signature": "(Matrix a, Vector a) -\u003e (Matrix a, Vector a)",
          "source": "src/Algebra-Matrix.html#forwardElim",
          "type": "function"
        },
        "index": {
          "description": "Compute row echelon form of system Ax",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "forwardElim",
          "normalized": "(Matrix a,Vector a)-\u003e(Matrix a,Vector a)",
          "package": "constructive-algebra",
          "partial": "Elim",
          "signature": "(Matrix a,Vector a)-\u003e(Matrix a,Vector a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:forwardElim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGauss-Jordan elimination: Given A and B solve Ax=B.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "gaussElim",
          "package": "constructive-algebra",
          "signature": "(Matrix a, Vector a) -\u003e (Matrix a, Vector a)",
          "source": "src/Algebra-Matrix.html#gaussElim",
          "type": "function"
        },
        "index": {
          "description": "Gauss-Jordan elimination Given and solve Ax",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "gaussElim",
          "normalized": "(Matrix a,Vector a)-\u003e(Matrix a,Vector a)",
          "package": "constructive-algebra",
          "partial": "Elim",
          "signature": "(Matrix a,Vector a)-\u003e(Matrix a,Vector a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:gaussElim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "gaussElimCorrect",
          "package": "constructive-algebra",
          "signature": "(Matrix a, Vector a) -\u003e Property",
          "source": "src/Algebra-Matrix.html#gaussElimCorrect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "gaussElimCorrect",
          "normalized": "(Matrix a,Vector a)-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Elim Correct",
          "signature": "(Matrix a,Vector a)-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:gaussElimCorrect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a nxn identity matrix.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "identity",
          "package": "constructive-algebra",
          "signature": "Int -\u003e Matrix r",
          "source": "src/Algebra-Matrix.html#identity",
          "type": "function"
        },
        "index": {
          "description": "Construct nxn identity matrix",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "identity",
          "normalized": "Int-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Int-\u003eMatrix r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "isSquareMatrix",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e Bool",
          "source": "src/Algebra-Matrix.html#isSquareMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "isSquareMatrix",
          "normalized": "Matrix a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Square Matrix",
          "signature": "Matrix r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:isSquareMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "lengthVec",
          "package": "constructive-algebra",
          "signature": "Vector r -\u003e Int",
          "source": "src/Algebra-Matrix.html#lengthVec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "lengthVec",
          "normalized": "Vector a-\u003eInt",
          "package": "constructive-algebra",
          "partial": "Vec",
          "signature": "Vector r-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:lengthVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a mxn matrix.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "matrix",
          "package": "constructive-algebra",
          "signature": "[[r]] -\u003e Matrix r",
          "source": "src/Algebra-Matrix.html#matrix",
          "type": "function"
        },
        "index": {
          "description": "Construct mxn matrix",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "matrix",
          "normalized": "[[a]]-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "[[r]]-\u003eMatrix r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "matrixToVector",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e Vector r",
          "source": "src/Algebra-Matrix.html#matrixToVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "matrixToVector",
          "normalized": "Matrix a-\u003eVector a",
          "package": "constructive-algebra",
          "partial": "To Vector",
          "signature": "Matrix r-\u003eVector r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:matrixToVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix multiplication.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "mulM",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e Matrix r -\u003e Matrix r",
          "source": "src/Algebra-Matrix.html#mulM",
          "type": "function"
        },
        "index": {
          "description": "Matrix multiplication",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "mulM",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Matrix r-\u003eMatrix r-\u003eMatrix r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:mulM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "pivot",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e a -\u003e Int -\u003e Int -\u003e Matrix a",
          "source": "src/Algebra-Matrix.html#pivot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "pivot",
          "normalized": "Matrix a-\u003ea-\u003eInt-\u003eInt-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Matrix a-\u003ea-\u003eInt-\u003eInt-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:pivot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "propLeftIdentity",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e Bool",
          "source": "src/Algebra-Matrix.html#propLeftIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "propLeftIdentity",
          "normalized": "Matrix a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Left Identity",
          "signature": "Matrix r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:propLeftIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "propRightIdentity",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e Bool",
          "source": "src/Algebra-Matrix.html#propRightIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "propRightIdentity",
          "normalized": "Matrix a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Right Identity",
          "signature": "Matrix r-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:propRightIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a row in a matrix.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "scale",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Int -\u003e a -\u003e Matrix a",
          "source": "src/Algebra-Matrix.html#scale",
          "type": "function"
        },
        "index": {
          "description": "Scale row in matrix",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "scale",
          "normalized": "Matrix a-\u003eInt-\u003ea-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Matrix a-\u003eInt-\u003ea-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "subCol",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Vector a -\u003e Int -\u003e Matrix a",
          "source": "src/Algebra-Matrix.html#subCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "subCol",
          "normalized": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "Col",
          "signature": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:subCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "subRow",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Vector a -\u003e Int -\u003e Matrix a",
          "source": "src/Algebra-Matrix.html#subRow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "subRow",
          "normalized": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "Row",
          "signature": "Matrix a-\u003eVector a-\u003eInt-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:subRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap two rows of a matrix.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "swap",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Int -\u003e Int -\u003e Matrix a",
          "source": "src/Algebra-Matrix.html#swap",
          "type": "function"
        },
        "index": {
          "description": "Swap two rows of matrix",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "swap",
          "normalized": "Matrix a-\u003eInt-\u003eInt-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Matrix a-\u003eInt-\u003eInt-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose a matrix.\n\u003c/p\u003e",
          "module": "Algebra.Matrix",
          "name": "transpose",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e Matrix r",
          "source": "src/Algebra-Matrix.html#transpose",
          "type": "function"
        },
        "index": {
          "description": "Transpose matrix",
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "transpose",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Matrix r-\u003eMatrix r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "unM",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e [Vector r]",
          "source": "src/Algebra-Matrix.html#unM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "unM",
          "normalized": "Matrix a-\u003e[Vector a]",
          "package": "constructive-algebra",
          "signature": "Matrix r-\u003e[Vector r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:unM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "unMVec",
          "package": "constructive-algebra",
          "signature": "Matrix r -\u003e [[r]]",
          "source": "src/Algebra-Matrix.html#unMVec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "unMVec",
          "normalized": "Matrix a-\u003e[[a]]",
          "package": "constructive-algebra",
          "partial": "MVec",
          "signature": "Matrix r-\u003e[[r]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:unMVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "unVec",
          "package": "constructive-algebra",
          "signature": "Vector r -\u003e [r]",
          "source": "src/Algebra-Matrix.html#unVec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "unVec",
          "normalized": "Vector a-\u003e[a]",
          "package": "constructive-algebra",
          "partial": "Vec",
          "signature": "Vector r-\u003e[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:unVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Matrix",
          "name": "vectorToMatrix",
          "package": "constructive-algebra",
          "signature": "Vector r -\u003e Matrix r",
          "source": "src/Algebra-Matrix.html#vectorToMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Matrix",
          "module": "Algebra.Matrix",
          "name": "vectorToMatrix",
          "normalized": "Vector a-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "To Matrix",
          "signature": "Vector r-\u003eMatrix r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Matrix.html#v:vectorToMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpecification of principal localization matrices used in the coherence \n proof of Prufer domains. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.PLM",
          "name": "PLM",
          "package": "constructive-algebra",
          "source": "src/Algebra-PLM.html",
          "type": "module"
        },
        "index": {
          "description": "Specification of principal localization matrices used in the coherence proof of Prufer domains",
          "hierarchy": "Algebra PLM",
          "module": "Algebra.PLM",
          "name": "PLM",
          "package": "constructive-algebra",
          "partial": "PLM",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-PLM.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrincipal localization matrices for ideals are computable in Bezout domains.\n\u003c/p\u003e",
          "module": "Algebra.PLM",
          "name": "computePLM_B",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Matrix a",
          "source": "src/Algebra-PLM.html#computePLM_B",
          "type": "function"
        },
        "index": {
          "description": "Principal localization matrices for ideals are computable in Bezout domains",
          "hierarchy": "Algebra PLM",
          "module": "Algebra.PLM",
          "name": "computePLM_B",
          "normalized": "Ideal a-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "PLM",
          "signature": "Ideal a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-PLM.html#v:computePLM_B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA principal localization matrix for an ideal (x1,...,xn) is a matrix such \nthat:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The sum of the diagonal should equal 1.\n\u003c/li\u003e\u003cli\u003e For all i, j, l in {1..n}: a_lj * x_i = a_li * x_j\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Algebra.PLM",
          "name": "propPLM",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Matrix a -\u003e Bool",
          "source": "src/Algebra-PLM.html#propPLM",
          "type": "function"
        },
        "index": {
          "description": "principal localization matrix for an ideal x1 xn is matrix such that The sum of the diagonal should equal For all in lj li",
          "hierarchy": "Algebra PLM",
          "module": "Algebra.PLM",
          "name": "propPLM",
          "normalized": "Ideal a-\u003eMatrix a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "PLM",
          "signature": "Ideal a-\u003eMatrix a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-PLM.html#v:propPLM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation of rational numbers as the field of fractions of Z.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Q",
          "name": "Q",
          "package": "constructive-algebra",
          "source": "src/Algebra-Q.html",
          "type": "module"
        },
        "index": {
          "description": "Representation of rational numbers as the field of fractions of",
          "hierarchy": "Algebra Q",
          "module": "Algebra.Q",
          "name": "Q",
          "package": "constructive-algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Q.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQ is the field of fractions of Z.\n\u003c/p\u003e",
          "module": "Algebra.Q",
          "name": "Q",
          "package": "constructive-algebra",
          "source": "src/Algebra-Q.html#Q",
          "type": "type"
        },
        "index": {
          "description": "is the field of fractions of",
          "hierarchy": "Algebra Q",
          "module": "Algebra.Q",
          "name": "Q",
          "package": "constructive-algebra",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Q.html#t:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Q",
          "name": "toQ",
          "package": "constructive-algebra",
          "signature": "Z -\u003e Q",
          "source": "src/Algebra-Q.html#toQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Q",
          "module": "Algebra.Q",
          "name": "toQ",
          "normalized": "Z-\u003eQ",
          "package": "constructive-algebra",
          "signature": "Z-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Q.html#v:toQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Q",
          "name": "toZ",
          "package": "constructive-algebra",
          "signature": "Q -\u003e Z",
          "source": "src/Algebra-Q.html#toZ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Q",
          "module": "Algebra.Q",
          "name": "toZ",
          "normalized": "Q-\u003eZ",
          "package": "constructive-algebra",
          "signature": "Q-\u003eZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Q.html#v:toZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation of Bezout domains. That is non-Noetherian analogues of\n principal ideal domains. This means that all finitely generated ideals are\n principal.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "BezoutDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-BezoutDomain.html",
          "type": "module"
        },
        "index": {
          "description": "Representation of Bezout domains That is non-Noetherian analogues of principal ideal domains This means that all finitely generated ideals are principal",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "BezoutDomain",
          "package": "constructive-algebra",
          "partial": "Bezout Domain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBezout domains\n\u003c/p\u003e\u003cp\u003eHas a Bezout function which given a and b give g, a1, b1, x and y such that:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e g = gcd(a,b)\n\u003c/li\u003e\u003cli\u003e a = g * a1 and b = g * b1\n\u003c/li\u003e\u003cli\u003e g = a * x + b * y\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "BezoutDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-BezoutDomain.html#BezoutDomain",
          "type": "class"
        },
        "index": {
          "description": "Bezout domains Has Bezout function which given and give a1 b1 and such that gcd a1 and b1",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "BezoutDomain",
          "package": "constructive-algebra",
          "partial": "Bezout Domain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#t:BezoutDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.BezoutDomain",
          "name": "bezout",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (a, a, a, a, a)",
          "source": "src/Algebra-Structures-BezoutDomain.html#bezout",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "bezout",
          "normalized": "a-\u003ea-\u003e(a,a,a,a,a)",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003e(a,a,a,a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:bezout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChinese remainder theorem\n\u003c/p\u003e\u003cp\u003eGiven a_1,...,a_n and m_1,...,m_n such that gcd(m_i,m_j) = 1.\n Let m = m_1*...*m_n compute a such that:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e a = a_i (mod m_i)\n\u003c/li\u003e\u003cli\u003e If b is such that b = a_i (mod m_i) then a = b (mod m)\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eThe function return (a,m).\n\u003c/p\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "crt",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e [a] -\u003e (a, a)",
          "source": "src/Algebra-Structures-BezoutDomain.html#crt",
          "type": "function"
        },
        "index": {
          "description": "Chinese remainder theorem Given and such that gcd Let compute such that mod If is such that mod then mod The function return",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "crt",
          "normalized": "[a]-\u003e[a]-\u003e(a,a)",
          "package": "constructive-algebra",
          "signature": "[a]-\u003e[a]-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:crt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.BezoutDomain",
          "name": "gcdB",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-BezoutDomain.html#gcdB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "gcdB",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:gcdB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersection without witness.\n\u003c/p\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "intersectionB",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Ideal a -\u003e Ideal a",
          "source": "src/Algebra-Structures-BezoutDomain.html#intersectionB",
          "type": "function"
        },
        "index": {
          "description": "Intersection without witness",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "intersectionB",
          "normalized": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "package": "constructive-algebra",
          "signature": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:intersectionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersection of ideals with witness.\n\u003c/p\u003e\u003cp\u003eIf one of the ideals is the zero ideal then the intersection is the zero\n ideal.\n\u003c/p\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "intersectionBWitness",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Ideal a -\u003e (Ideal a, [[a]], [[a]])",
          "source": "src/Algebra-Structures-BezoutDomain.html#intersectionBWitness",
          "type": "function"
        },
        "index": {
          "description": "Intersection of ideals with witness If one of the ideals is the zero ideal then the intersection is the zero ideal",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "intersectionBWitness",
          "normalized": "Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]])",
          "package": "constructive-algebra",
          "partial": "BWitness",
          "signature": "Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:intersectionBWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.BezoutDomain",
          "name": "propBezoutDomain",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-BezoutDomain.html#propBezoutDomain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "propBezoutDomain",
          "normalized": "a-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Bezout Domain",
          "signature": "a-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:propBezoutDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest that the generated ideal generate the same elements as the given.\n\u003c/p\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "propIsSameIdeal",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Bool",
          "source": "src/Algebra-Structures-BezoutDomain.html#propIsSameIdeal",
          "type": "function"
        },
        "index": {
          "description": "Test that the generated ideal generate the same elements as the given",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "propIsSameIdeal",
          "normalized": "Ideal a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Is Same Ideal",
          "signature": "Ideal a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:propIsSameIdeal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest that the generated ideal is principal.\n\u003c/p\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "propToPrincipal",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Bool",
          "source": "src/Algebra-Structures-BezoutDomain.html#propToPrincipal",
          "type": "function"
        },
        "index": {
          "description": "Test that the generated ideal is principal",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "propToPrincipal",
          "normalized": "Ideal a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "To Principal",
          "signature": "Ideal a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:propToPrincipal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoherence of Bezout domains.\n\u003c/p\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "solveB",
          "package": "constructive-algebra",
          "signature": "Vector a -\u003e Matrix a",
          "source": "src/Algebra-Structures-BezoutDomain.html#solveB",
          "type": "function"
        },
        "index": {
          "description": "Coherence of Bezout domains",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "solveB",
          "normalized": "Vector a-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Vector a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:solveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a principal ideal from another ideal. Also give witness that the\nprincipal ideal is equal to the first ideal.\n\u003c/p\u003e\u003cp\u003etoPrincipal \u003ca_1,...,a_n\u003e = (\u003ca\u003e,u_i,v_i)\n  where\n\u003c/p\u003e\u003cp\u003esum (u_i * a_i) = a\n\u003c/p\u003e\u003cp\u003ea_i = v_i * a\n\u003c/p\u003e",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "toPrincipal",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e (Ideal a, [a], [a])",
          "source": "src/Algebra-Structures-BezoutDomain.html#toPrincipal",
          "type": "function"
        },
        "index": {
          "description": "Compute principal ideal from another ideal Also give witness that the principal ideal is equal to the first ideal toPrincipal where sum",
          "hierarchy": "Algebra Structures BezoutDomain",
          "module": "Algebra.Structures.BezoutDomain",
          "name": "toPrincipal",
          "normalized": "Ideal a-\u003e(Ideal a,[a],[a])",
          "package": "constructive-algebra",
          "partial": "Principal",
          "signature": "Ideal a-\u003e(Ideal a,[a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-BezoutDomain.html#v:toPrincipal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation of coherent rings. Traditionally a ring is coherent if every\n finitely generated ideal is finitely presented. This means that it is\n possible to solve homogenous linear equations in them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "Coherent",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Coherent.html",
          "type": "module"
        },
        "index": {
          "description": "Representation of coherent rings Traditionally ring is coherent if every finitely generated ideal is finitely presented This means that it is possible to solve homogenous linear equations in them",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "Coherent",
          "package": "constructive-algebra",
          "partial": "Coherent",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefinition of coherent rings.\n\u003c/p\u003e\u003cp\u003eWe say that R is coherent iff for any M, we can find L such that ML=0 and\n\u003c/p\u003e\u003cp\u003eMX=0   \u003c-\u003e  exists Y. X=LY\n\u003c/p\u003e\u003cp\u003ethat is, iff we can generate the solutions of any linear homogeous system\n of equations.\n\u003c/p\u003e\u003cp\u003eThe main point here is that ML=0, it is not clear how to represent the\n equivalence in Haskell. This would probably be possible in type theory.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "Coherent",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Coherent.html#Coherent",
          "type": "class"
        },
        "index": {
          "description": "Definition of coherent rings We say that is coherent iff for any we can find such that ML and MX exists LY that is iff we can generate the solutions of any linear homogeous system of equations The main point here is that ML it is not clear how to represent the equivalence in Haskell This would probably be possible in type theory",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "Coherent",
          "package": "constructive-algebra",
          "partial": "Coherent",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#t:Coherent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest that the second matrix is a solution to the first.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "isSolution",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Matrix a -\u003e Bool",
          "source": "src/Algebra-Structures-Coherent.html#isSolution",
          "type": "function"
        },
        "index": {
          "description": "Test that the second matrix is solution to the first",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "isSolution",
          "normalized": "Matrix a-\u003eMatrix a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Solution",
          "signature": "Matrix a-\u003eMatrix a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:isSolution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Coherent",
          "name": "propCoherent",
          "package": "constructive-algebra",
          "signature": "Vector a -\u003e Bool",
          "source": "src/Algebra-Structures-Coherent.html#propCoherent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "propCoherent",
          "normalized": "Vector a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Coherent",
          "signature": "Vector a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:propCoherent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Coherent",
          "name": "propSolveGeneral",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Vector a -\u003e Property",
          "source": "src/Algebra-Structures-Coherent.html#propSolveGeneral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "propSolveGeneral",
          "normalized": "Matrix a-\u003eVector a-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Solve General",
          "signature": "Matrix a-\u003eVector a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:propSolveGeneral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Coherent",
          "name": "propSolveGeneralEquation",
          "package": "constructive-algebra",
          "signature": "Vector a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-Coherent.html#propSolveGeneralEquation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "propSolveGeneralEquation",
          "normalized": "Vector a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Solve General Equation",
          "signature": "Vector a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:propSolveGeneralEquation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest that the solution of an MxN system is in fact a solution of the system\n\u003c/p\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "propSolveMxN",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Bool",
          "source": "src/Algebra-Structures-Coherent.html#propSolveMxN",
          "type": "function"
        },
        "index": {
          "description": "Test that the solution of an MxN system is in fact solution of the system",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "propSolveMxN",
          "normalized": "Matrix a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Solve Mx",
          "signature": "Matrix a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:propSolveMxN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Coherent",
          "name": "solve",
          "package": "constructive-algebra",
          "signature": "Vector a -\u003e Matrix a",
          "source": "src/Algebra-Structures-Coherent.html#solve",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "solve",
          "normalized": "Vector a-\u003eMatrix a",
          "package": "constructive-algebra",
          "signature": "Vector a-\u003eMatrix a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:solve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolves general linear systems of the kind AX = B.\n\u003c/p\u003e\u003cp\u003eA is given as a matrix and B is given as a row vector (it should be column\n vector).\n\u003c/p\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "solveGeneral",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Vector a -\u003e Maybe (Matrix a, Matrix a)",
          "source": "src/Algebra-Structures-Coherent.html#solveGeneral",
          "type": "function"
        },
        "index": {
          "description": "Solves general linear systems of the kind AX is given as matrix and is given as row vector it should be column vector",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "solveGeneral",
          "normalized": "Matrix a-\u003eVector a-\u003eMaybe(Matrix a,Matrix a)",
          "package": "constructive-algebra",
          "partial": "General",
          "signature": "Matrix a-\u003eVector a-\u003eMaybe(Matrix a,Matrix a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:solveGeneral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrongly discrete coherent rings.\n\u003c/p\u003e\u003cp\u003eIf the ring is strongly discrete and coherent then we can solve arbitrary\n equations of the type AX=b.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "solveGeneralEquation",
          "package": "constructive-algebra",
          "signature": "Vector a -\u003e a -\u003e Maybe (Matrix a)",
          "source": "src/Algebra-Structures-Coherent.html#solveGeneralEquation",
          "type": "function"
        },
        "index": {
          "description": "Strongly discrete coherent rings If the ring is strongly discrete and coherent then we can solve arbitrary equations of the type AX",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "solveGeneralEquation",
          "normalized": "Vector a-\u003ea-\u003eMaybe(Matrix a)",
          "package": "constructive-algebra",
          "partial": "General Equation",
          "signature": "Vector a-\u003ea-\u003eMaybe(Matrix a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:solveGeneralEquation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolves a system of equations.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "solveMxN",
          "package": "constructive-algebra",
          "signature": "Matrix a -\u003e Matrix a",
          "source": "src/Algebra-Structures-Coherent.html#solveMxN",
          "type": "function"
        },
        "index": {
          "description": "Solves system of equations",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "solveMxN",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "Mx",
          "signature": "Matrix a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:solveMxN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntersection computable -\u003e Coherence.\n\u003c/p\u003e\u003cp\u003eProof that if there is an algorithm to compute a f.g. set of generators for\n the intersection of two f.g. ideals then the ring is coherent.\n\u003c/p\u003e\u003cp\u003eTakes the vector to solve, [x1,...,xn], and a function (int) that computes\n the intersection of two ideals.\n\u003c/p\u003e\u003cp\u003eIf [ x_1, ..., x_n ] `int` [ y_1, ..., y_m ] = [ z_1, ..., z_l ]\n\u003c/p\u003e\u003cp\u003ethen int should give witnesses us and vs such that:\n\u003c/p\u003e\u003cp\u003ez_k = n_k1 * x_1 + ... + u_kn * x_n = u_k1 * y_1 + ... + n_km * y_m\n\u003c/p\u003e",
          "module": "Algebra.Structures.Coherent",
          "name": "solveWithIntersection",
          "package": "constructive-algebra",
          "signature": "Vector a -\u003e (Ideal a -\u003e Ideal a -\u003e (Ideal a, [[a]], [[a]])) -\u003e Matrix a",
          "source": "src/Algebra-Structures-Coherent.html#solveWithIntersection",
          "type": "function"
        },
        "index": {
          "description": "Intersection computable Coherence Proof that if there is an algorithm to compute f.g set of generators for the intersection of two f.g ideals then the ring is coherent Takes the vector to solve x1 xn and function int that computes the intersection of two ideals If int then int should give witnesses us and vs such that k1 kn k1 km",
          "hierarchy": "Algebra Structures Coherent",
          "module": "Algebra.Structures.Coherent",
          "name": "solveWithIntersection",
          "normalized": "Vector a-\u003e(Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]]))-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "With Intersection",
          "signature": "Vector a-\u003e(Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]]))-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Coherent.html#v:solveWithIntersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStructure for commutative rings. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.CommutativeRing",
          "name": "CommutativeRing",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-CommutativeRing.html",
          "type": "module"
        },
        "index": {
          "description": "Structure for commutative rings",
          "hierarchy": "Algebra Structures CommutativeRing",
          "module": "Algebra.Structures.CommutativeRing",
          "name": "CommutativeRing",
          "package": "constructive-algebra",
          "partial": "Commutative Ring",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-CommutativeRing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefinition of commutative rings.\n\u003c/p\u003e",
          "module": "Algebra.Structures.CommutativeRing",
          "name": "CommutativeRing",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-CommutativeRing.html#CommutativeRing",
          "type": "class"
        },
        "index": {
          "description": "Definition of commutative rings",
          "hierarchy": "Algebra Structures CommutativeRing",
          "module": "Algebra.Structures.CommutativeRing",
          "name": "CommutativeRing",
          "package": "constructive-algebra",
          "partial": "Commutative Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-CommutativeRing.html#t:CommutativeRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecification of commutative rings. Test that multiplication is \n commutative and that it satisfies the ring axioms.\n\u003c/p\u003e",
          "module": "Algebra.Structures.CommutativeRing",
          "name": "propCommutativeRing",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-CommutativeRing.html#propCommutativeRing",
          "type": "function"
        },
        "index": {
          "description": "Specification of commutative rings Test that multiplication is commutative and that it satisfies the ring axioms",
          "hierarchy": "Algebra Structures CommutativeRing",
          "module": "Algebra.Structures.CommutativeRing",
          "name": "propCommutativeRing",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Commutative Ring",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-CommutativeRing.html#v:propCommutativeRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.CommutativeRing",
          "name": "propMulComm",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-CommutativeRing.html#propMulComm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures CommutativeRing",
          "module": "Algebra.Structures.CommutativeRing",
          "name": "propMulComm",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Mul Comm",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-CommutativeRing.html#v:propMulComm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation of Euclidean domains. That is integral domains with an\n Euclidean functions and decidable division.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-EuclideanDomain.html",
          "type": "module"
        },
        "index": {
          "description": "Representation of Euclidean domains That is integral domains with an Euclidean functions and decidable division",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "constructive-algebra",
          "partial": "Euclidean Domain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEuclidean domains\n\u003c/p\u003e\u003cp\u003eGiven a and b compute (q,r) such that a = bq + r and r = 0 || norm r \u003c norm b.\n Where norm is the Euclidean function.\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-EuclideanDomain.html#EuclideanDomain",
          "type": "class"
        },
        "index": {
          "description": "Euclidean domains Given and compute such that bq and norm norm Where norm is the Euclidean function",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "constructive-algebra",
          "partial": "Euclidean Domain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#t:EuclideanDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "divides",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-EuclideanDomain.html#divides",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "divides",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:divides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Euclidean algorithm for calculating the GCD of a and b.\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "euclidAlg",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-EuclideanDomain.html#euclidAlg",
          "type": "function"
        },
        "index": {
          "description": "The Euclidean algorithm for calculating the GCD of and",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "euclidAlg",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "partial": "Alg",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:euclidAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe extended Euclidean algorithm.\n\u003c/p\u003e\u003cp\u003eComputes x and y in ax + by = gcd(a,b).\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "extendedEuclidAlg",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Algebra-Structures-EuclideanDomain.html#extendedEuclidAlg",
          "type": "function"
        },
        "index": {
          "description": "The extended Euclidean algorithm Computes and in ax by gcd",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "extendedEuclidAlg",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "constructive-algebra",
          "partial": "Euclid Alg",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:extendedEuclidAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized Euclidean algorithm to compute GCD of a list of elements.\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "genEuclidAlg",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Structures-EuclideanDomain.html#genEuclidAlg",
          "type": "function"
        },
        "index": {
          "description": "Generalized Euclidean algorithm to compute GCD of list of elements",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "genEuclidAlg",
          "normalized": "[a]-\u003ea",
          "package": "constructive-algebra",
          "partial": "Euclid Alg",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:genEuclidAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized extended Euclidean algorithm.\n\u003c/p\u003e\u003cp\u003eSolves a_1 x_1 + ... + a_n x_n = gcd (a_1,...,a_n)\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "genExtendedEuclidAlg",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e [a]",
          "source": "src/Algebra-Structures-EuclideanDomain.html#genExtendedEuclidAlg",
          "type": "function"
        },
        "index": {
          "description": "Generalized extended Euclidean algorithm Solves gcd",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "genExtendedEuclidAlg",
          "normalized": "[a]-\u003e[a]",
          "package": "constructive-algebra",
          "partial": "Extended Euclid Alg",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:genExtendedEuclidAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized lowest common multiple to compute lcm of a list of elements.\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "genLcmE",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Structures-EuclideanDomain.html#genLcmE",
          "type": "function"
        },
        "index": {
          "description": "Generalized lowest common multiple to compute lcm of list of elements",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "genLcmE",
          "normalized": "[a]-\u003ea",
          "package": "constructive-algebra",
          "partial": "Lcm",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:genLcmE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLowest common multiple, (a*b)/gcd(a,b).\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "lcmE",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-EuclideanDomain.html#lcmE",
          "type": "function"
        },
        "index": {
          "description": "Lowest common multiple gcd",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "lcmE",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:lcmE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "modulo",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-EuclideanDomain.html#modulo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "modulo",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:modulo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "norm",
          "package": "constructive-algebra",
          "signature": "a -\u003e Integer",
          "source": "src/Algebra-Structures-EuclideanDomain.html#norm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "norm",
          "normalized": "a-\u003eInteger",
          "package": "constructive-algebra",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "propEuclideanDomain",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-EuclideanDomain.html#propEuclideanDomain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "propEuclideanDomain",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Euclidean Domain",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:propEuclideanDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck both that |a| \u003ca\u003e= |ab| and |a| \u003c/a\u003e= 0 for all a,b.\n\u003c/p\u003e",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "propNorm",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-EuclideanDomain.html#propNorm",
          "type": "function"
        },
        "index": {
          "description": "Check both that ab and for all",
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "propNorm",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Norm",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:propNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "propQuotRem",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-EuclideanDomain.html#propQuotRem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "propQuotRem",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Quot Rem",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:propQuotRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "quotient",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-EuclideanDomain.html#quotient",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "quotient",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:quotient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "quotientRemainder",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Algebra-Structures-EuclideanDomain.html#quotientRemainder",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures EuclideanDomain",
          "module": "Algebra.Structures.EuclideanDomain",
          "name": "quotientRemainder",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "constructive-algebra",
          "partial": "Remainder",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-EuclideanDomain.html#v:quotientRemainder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStructure of rings with explicit units. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "ExplicitUnits",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-ExplicitUnits.html",
          "type": "module"
        },
        "index": {
          "description": "Structure of rings with explicit units",
          "hierarchy": "Algebra Structures ExplicitUnits",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "ExplicitUnits",
          "package": "constructive-algebra",
          "partial": "Explicit Units",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-ExplicitUnits.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA ring has explicit units if there is a function that can test if an\n element is invertible and if this is the case give the inverse. \n\u003c/p\u003e",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "ExplicitUnits",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-ExplicitUnits.html#ExplicitUnits",
          "type": "class"
        },
        "index": {
          "description": "ring has explicit units if there is function that can test if an element is invertible and if this is the case give the inverse",
          "hierarchy": "Algebra Structures ExplicitUnits",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "ExplicitUnits",
          "package": "constructive-algebra",
          "partial": "Explicit Units",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-ExplicitUnits.html#t:ExplicitUnits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest for associatedness, i.e. a ~ b iff a | b /\\ b | a.\n\u003c/p\u003e",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "(~=)",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-ExplicitUnits.html#~%3D",
          "type": "function"
        },
        "index": {
          "description": "Test for associatedness i.e iff",
          "hierarchy": "Algebra Structures ExplicitUnits",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "(~=) ~=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-ExplicitUnits.html#v:-126--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecidable units is sufficient to decide divisibility in GCD domains. \n\u003c/p\u003e",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "(%|)",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-ExplicitUnits.html#%25%7C",
          "type": "function"
        },
        "index": {
          "description": "Decidable units is sufficient to decide divisibility in GCD domains",
          "hierarchy": "Algebra Structures ExplicitUnits",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "(%|) %|",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-ExplicitUnits.html#v:-37--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn element is a unit if it is invertible. \n\u003c/p\u003e",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "isUnit",
          "package": "constructive-algebra",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Structures-ExplicitUnits.html#isUnit",
          "type": "function"
        },
        "index": {
          "description": "An element is unit if it is invertible",
          "hierarchy": "Algebra Structures ExplicitUnits",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "isUnit",
          "normalized": "a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Unit",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-ExplicitUnits.html#v:isUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "propUnit",
          "package": "constructive-algebra",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Structures-ExplicitUnits.html#propUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures ExplicitUnits",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "propUnit",
          "normalized": "a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Unit",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-ExplicitUnits.html#v:propUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "unit",
          "package": "constructive-algebra",
          "signature": "a -\u003e Maybe a",
          "source": "src/Algebra-Structures-ExplicitUnits.html#unit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures ExplicitUnits",
          "module": "Algebra.Structures.ExplicitUnits",
          "name": "unit",
          "normalized": "a-\u003eMaybe a",
          "package": "constructive-algebra",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-ExplicitUnits.html#v:unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStructure for fields.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.Field",
          "name": "Field",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Field.html",
          "type": "module"
        },
        "index": {
          "description": "Structure for fields",
          "hierarchy": "Algebra Structures Field",
          "module": "Algebra.Structures.Field",
          "name": "Field",
          "package": "constructive-algebra",
          "partial": "Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Field.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefinition of fields.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Field",
          "name": "Field",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Field.html#Field",
          "type": "class"
        },
        "index": {
          "description": "Definition of fields",
          "hierarchy": "Algebra Structures Field",
          "module": "Algebra.Structures.Field",
          "name": "Field",
          "package": "constructive-algebra",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Field.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivision\n\u003c/p\u003e",
          "module": "Algebra.Structures.Field",
          "name": "(\u003c/\u003e)",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-Field.html#%3C%2F%3E",
          "type": "function"
        },
        "index": {
          "description": "Division",
          "hierarchy": "Algebra Structures Field",
          "module": "Algebra.Structures.Field",
          "name": "(\u003c/\u003e) \u003c/\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Field.html#v:-60--47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Field",
          "name": "inv",
          "package": "constructive-algebra",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Structures-Field.html#inv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures Field",
          "module": "Algebra.Structures.Field",
          "name": "inv",
          "normalized": "a-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Field.html#v:inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecification of fields. Test that the multiplicative inverses behave as \n expected and that it satisfies the axioms of integral domains.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Field",
          "name": "propField",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-Field.html#propField",
          "type": "function"
        },
        "index": {
          "description": "Specification of fields Test that the multiplicative inverses behave as expected and that it satisfies the axioms of integral domains",
          "hierarchy": "Algebra Structures Field",
          "module": "Algebra.Structures.Field",
          "name": "propField",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Field",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Field.html#v:propField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Field",
          "name": "propMulInv",
          "package": "constructive-algebra",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Structures-Field.html#propMulInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Field",
          "module": "Algebra.Structures.Field",
          "name": "propMulInv",
          "normalized": "a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Mul Inv",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Field.html#v:propMulInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe field of fractions over a GCD domain. The reason that it is an GCD \n domain is that we only want to work over reduced quotients.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "FieldOfFractions",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-FieldOfFractions.html",
          "type": "module"
        },
        "index": {
          "description": "The field of fractions over GCD domain The reason that it is an GCD domain is that we only want to work over reduced quotients",
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "FieldOfFractions",
          "package": "constructive-algebra",
          "partial": "Field Of Fractions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField of fractions\n\u003c/p\u003e",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "FieldOfFractions",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-FieldOfFractions.html#FieldOfFractions",
          "type": "newtype"
        },
        "index": {
          "description": "Field of fractions",
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "FieldOfFractions",
          "package": "constructive-algebra",
          "partial": "Field Of Fractions",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#t:FieldOfFractions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "F",
          "package": "constructive-algebra",
          "signature": "F (a, a)",
          "source": "src/Algebra-Structures-FieldOfFractions.html#FieldOfFractions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "F",
          "normalized": "F(a,a)",
          "package": "constructive-algebra",
          "signature": "F(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#v:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "denominator",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a -\u003e a",
          "source": "src/Algebra-Structures-FieldOfFractions.html#denominator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "denominator",
          "normalized": "FieldOfFractions a-\u003ea",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#v:denominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a value from the field of fractions. This is only possible if the\n divisor is one.\n\u003c/p\u003e",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "fromFieldOfFractions",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a -\u003e a",
          "source": "src/Algebra-Structures-FieldOfFractions.html#fromFieldOfFractions",
          "type": "function"
        },
        "index": {
          "description": "Extract value from the field of fractions This is only possible if the divisor is one",
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "fromFieldOfFractions",
          "normalized": "FieldOfFractions a-\u003ea",
          "package": "constructive-algebra",
          "partial": "Field Of Fractions",
          "signature": "FieldOfFractions a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#v:fromFieldOfFractions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "numerator",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a -\u003e a",
          "source": "src/Algebra-Structures-FieldOfFractions.html#numerator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "numerator",
          "normalized": "FieldOfFractions a-\u003ea",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#v:numerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "propReduce",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a -\u003e Property",
          "source": "src/Algebra-Structures-FieldOfFractions.html#propReduce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "propReduce",
          "normalized": "FieldOfFractions a-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Reduce",
          "signature": "FieldOfFractions a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#v:propReduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReduce an element.\n\u003c/p\u003e",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "reduce",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a -\u003e FieldOfFractions a",
          "source": "src/Algebra-Structures-FieldOfFractions.html#reduce",
          "type": "function"
        },
        "index": {
          "description": "Reduce an element",
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "reduce",
          "normalized": "FieldOfFractions a-\u003eFieldOfFractions a",
          "package": "constructive-algebra",
          "signature": "FieldOfFractions a-\u003eFieldOfFractions a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#v:reduce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmbed a value in the field of fractions.\n\u003c/p\u003e",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "toFieldOfFractions",
          "package": "constructive-algebra",
          "signature": "a -\u003e FieldOfFractions a",
          "source": "src/Algebra-Structures-FieldOfFractions.html#toFieldOfFractions",
          "type": "function"
        },
        "index": {
          "description": "Embed value in the field of fractions",
          "hierarchy": "Algebra Structures FieldOfFractions",
          "module": "Algebra.Structures.FieldOfFractions",
          "name": "toFieldOfFractions",
          "normalized": "a-\u003eFieldOfFractions a",
          "package": "constructive-algebra",
          "partial": "Field Of Fractions",
          "signature": "a-\u003eFieldOfFractions a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-FieldOfFractions.html#v:toFieldOfFractions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGreatest common divisor (GCD) domains. \n\u003c/p\u003e\u003cp\u003eGCD domains are integral domains in which every pair of nonzero elements \n have a greatest common divisor. They can also be characterized as \n non-Noetherian analogues of unique factorization domains.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.GCDDomain",
          "name": "GCDDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-GCDDomain.html",
          "type": "module"
        },
        "index": {
          "description": "Greatest common divisor GCD domains GCD domains are integral domains in which every pair of nonzero elements have greatest common divisor They can also be characterized as non-Noetherian analogues of unique factorization domains",
          "hierarchy": "Algebra Structures GCDDomain",
          "module": "Algebra.Structures.GCDDomain",
          "name": "GCDDomain",
          "package": "constructive-algebra",
          "partial": "GCDDomain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-GCDDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGCD domains\n\u003c/p\u003e",
          "module": "Algebra.Structures.GCDDomain",
          "name": "GCDDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-GCDDomain.html#GCDDomain",
          "type": "class"
        },
        "index": {
          "description": "GCD domains",
          "hierarchy": "Algebra Structures GCDDomain",
          "module": "Algebra.Structures.GCDDomain",
          "name": "GCDDomain",
          "package": "constructive-algebra",
          "partial": "GCDDomain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-GCDDomain.html#t:GCDDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute gcd(a,b) = (g,x,y) such that g = gcd(a,b) and\n   a = gx\n   b = gy\n and a, b /= 0\n\u003c/p\u003e",
          "module": "Algebra.Structures.GCDDomain",
          "name": "gcd'",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (a, a, a)",
          "source": "src/Algebra-Structures-GCDDomain.html#gcd%27",
          "type": "method"
        },
        "index": {
          "description": "Compute gcd such that gcd and gx gy and",
          "hierarchy": "Algebra Structures GCDDomain",
          "module": "Algebra.Structures.GCDDomain",
          "name": "gcd'",
          "normalized": "a-\u003ea-\u003e(a,a,a)",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003e(a,a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-GCDDomain.html#v:gcd-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.GCDDomain",
          "name": "ggcd",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Structures-GCDDomain.html#ggcd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures GCDDomain",
          "module": "Algebra.Structures.GCDDomain",
          "name": "ggcd",
          "normalized": "[a]-\u003ea",
          "package": "constructive-algebra",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-GCDDomain.html#v:ggcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.GCDDomain",
          "name": "propGCD",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-GCDDomain.html#propGCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures GCDDomain",
          "module": "Algebra.Structures.GCDDomain",
          "name": "propGCD",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "GCD",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-GCDDomain.html#v:propGCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecification of GCD domains. They are integral domains in which every \n pair of nonzero elements have a greatest common divisor.\n\u003c/p\u003e",
          "module": "Algebra.Structures.GCDDomain",
          "name": "propGCDDomain",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-GCDDomain.html#propGCDDomain",
          "type": "function"
        },
        "index": {
          "description": "Specification of GCD domains They are integral domains in which every pair of nonzero elements have greatest common divisor",
          "hierarchy": "Algebra Structures GCDDomain",
          "module": "Algebra.Structures.GCDDomain",
          "name": "propGCDDomain",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "GCDDomain",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-GCDDomain.html#v:propGCDDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "Group",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Group.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "Group",
          "package": "constructive-algebra",
          "partial": "Group",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbelian groups:\n\u003c/p\u003e",
          "module": "Algebra.Structures.Group",
          "name": "AbelianGroup",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Group.html#AbelianGroup",
          "type": "class"
        },
        "index": {
          "description": "Abelian groups",
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "AbelianGroup",
          "package": "constructive-algebra",
          "partial": "Abelian Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#t:AbelianGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "Group",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Group.html#Group",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "Group",
          "package": "constructive-algebra",
          "partial": "Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#t:Group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "(\u003c+\u003e)",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-Group.html#%3C%2B%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "neg",
          "package": "constructive-algebra",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Structures-Group.html#neg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "neg",
          "normalized": "a-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "propAbelianGroup",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-Group.html#propAbelianGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "propAbelianGroup",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Abelian Group",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:propAbelianGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "propAssoc",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-Group.html#propAssoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "propAssoc",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Assoc",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:propAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "propComm",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-Group.html#propComm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "propComm",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Comm",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:propComm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "propGroup",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-Group.html#propGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "propGroup",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Group",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:propGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "propId",
          "package": "constructive-algebra",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Structures-Group.html#propId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "propId",
          "normalized": "a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Id",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:propId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "propInv",
          "package": "constructive-algebra",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Structures-Group.html#propInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "propInv",
          "normalized": "a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Inv",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:propInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "sumGroup",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Structures-Group.html#sumGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "sumGroup",
          "normalized": "[a]-\u003ea",
          "package": "constructive-algebra",
          "partial": "Group",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:sumGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Group",
          "name": "zero",
          "package": "constructive-algebra",
          "signature": "a",
          "source": "src/Algebra-Structures-Group.html#zero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures Group",
          "module": "Algebra.Structures.Group",
          "name": "zero",
          "package": "constructive-algebra",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Group.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.IntegralDomain",
          "name": "IntegralDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-IntegralDomain.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Structures IntegralDomain",
          "module": "Algebra.Structures.IntegralDomain",
          "name": "IntegralDomain",
          "package": "constructive-algebra",
          "partial": "Integral Domain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-IntegralDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefinition of integral domains.\n\u003c/p\u003e",
          "module": "Algebra.Structures.IntegralDomain",
          "name": "IntegralDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-IntegralDomain.html#IntegralDomain",
          "type": "class"
        },
        "index": {
          "description": "Definition of integral domains",
          "hierarchy": "Algebra Structures IntegralDomain",
          "module": "Algebra.Structures.IntegralDomain",
          "name": "IntegralDomain",
          "package": "constructive-algebra",
          "partial": "Integral Domain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-IntegralDomain.html#t:IntegralDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecification of integral domains. Test that there are no zero-divisors\n and that it satisfies the axioms of commutative rings.\n\u003c/p\u003e",
          "module": "Algebra.Structures.IntegralDomain",
          "name": "propIntegralDomain",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-IntegralDomain.html#propIntegralDomain",
          "type": "function"
        },
        "index": {
          "description": "Specification of integral domains Test that there are no zero-divisors and that it satisfies the axioms of commutative rings",
          "hierarchy": "Algebra Structures IntegralDomain",
          "module": "Algebra.Structures.IntegralDomain",
          "name": "propIntegralDomain",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Integral Domain",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-IntegralDomain.html#v:propIntegralDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.IntegralDomain",
          "name": "propZeroDivisors",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-IntegralDomain.html#propZeroDivisors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures IntegralDomain",
          "module": "Algebra.Structures.IntegralDomain",
          "name": "propZeroDivisors",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Zero Divisors",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-IntegralDomain.html#v:propZeroDivisors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eR-modules. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.Module",
          "name": "Module",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Module.html",
          "type": "module"
        },
        "index": {
          "description": "R-modules",
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "Module",
          "package": "constructive-algebra",
          "partial": "Module",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModule over a commutative ring r.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Module",
          "name": "Module",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Module.html#Module",
          "type": "class"
        },
        "index": {
          "description": "Module over commutative ring",
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "Module",
          "package": "constructive-algebra",
          "partial": "Module",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScalar multiplication.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Module",
          "name": "(*\u003e)",
          "package": "constructive-algebra",
          "signature": "r -\u003e m -\u003e m",
          "source": "src/Algebra-Structures-Module.html#%2A%3E",
          "type": "method"
        },
        "index": {
          "description": "Scalar multiplication",
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "(*\u003e) *\u003e",
          "normalized": "a-\u003eb-\u003eb",
          "package": "constructive-algebra",
          "signature": "r-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSince the ring is commutative we can turn the scalar multiplication around.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Module",
          "name": "(\u003c*)",
          "package": "constructive-algebra",
          "signature": "m -\u003e r -\u003e m",
          "source": "src/Algebra-Structures-Module.html#%3C%2A",
          "type": "function"
        },
        "index": {
          "description": "Since the ring is commutative we can turn the scalar multiplication around",
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "(\u003c*) \u003c*",
          "normalized": "a-\u003eb-\u003ea",
          "package": "constructive-algebra",
          "signature": "m-\u003er-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Module",
          "name": "propModule",
          "package": "constructive-algebra",
          "signature": "r -\u003e r -\u003e m -\u003e m -\u003e Property",
          "source": "src/Algebra-Structures-Module.html#propModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "propModule",
          "normalized": "a-\u003ea-\u003eb-\u003eb-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Module",
          "signature": "r-\u003er-\u003em-\u003em-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#v:propModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Module",
          "name": "propScalarAdd",
          "package": "constructive-algebra",
          "signature": "r -\u003e r -\u003e m -\u003e Bool",
          "source": "src/Algebra-Structures-Module.html#propScalarAdd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "propScalarAdd",
          "normalized": "a-\u003ea-\u003eb-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Scalar Add",
          "signature": "r-\u003er-\u003em-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#v:propScalarAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Module",
          "name": "propScalarAssoc",
          "package": "constructive-algebra",
          "signature": "r -\u003e r -\u003e m -\u003e Bool",
          "source": "src/Algebra-Structures-Module.html#propScalarAssoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "propScalarAssoc",
          "normalized": "a-\u003ea-\u003eb-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Scalar Assoc",
          "signature": "r-\u003er-\u003em-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#v:propScalarAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.Module",
          "name": "propScalarMul",
          "package": "constructive-algebra",
          "signature": "r -\u003e m -\u003e m -\u003e Bool",
          "source": "src/Algebra-Structures-Module.html#propScalarMul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures Module",
          "module": "Algebra.Structures.Module",
          "name": "propScalarMul",
          "normalized": "a-\u003eb-\u003eb-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Scalar Mul",
          "signature": "r-\u003em-\u003em-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Module.html#v:propScalarMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePrufer domains are non-Noetherian analogues of Dedekind domains. That is\n integral domains in which every finitely generated ideal is invertible. This \n implementation is mainly based on:\n\u003c/p\u003e\u003cp\u003ehttp://hlombardi.free.fr/liens/salouThesis.pdf\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "PruferDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-PruferDomain.html",
          "type": "module"
        },
        "index": {
          "description": "Prufer domains are non-Noetherian analogues of Dedekind domains That is integral domains in which every finitely generated ideal is invertible This implementation is mainly based on http hlombardi.free.fr liens salouThesis.pdf",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "PruferDomain",
          "package": "constructive-algebra",
          "partial": "Prufer Domain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a and b it computes u, v and we such that:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e au = bv\n\u003c/li\u003e\u003cli\u003e b(1-u) = aw\n\u003c/li\u003e\u003c/ol\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "PruferDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-PruferDomain.html#PruferDomain",
          "type": "class"
        },
        "index": {
          "description": "Given and it computes and we such that au bv aw",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "PruferDomain",
          "package": "constructive-algebra",
          "partial": "Prufer Domain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#t:PruferDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.PruferDomain",
          "name": "calcUVW",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (a, a, a)",
          "source": "src/Algebra-Structures-PruferDomain.html#calcUVW",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "calcUVW",
          "normalized": "a-\u003ea-\u003e(a,a,a)",
          "package": "constructive-algebra",
          "partial": "UVW",
          "signature": "a-\u003ea-\u003e(a,a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:calcUVW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlternative characterization of Prufer domains, given a and b compute u, v, \n w, t such that:\n\u003c/p\u003e\u003cp\u003eua = vb && wa  = tb && u+t = 1\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "calcUVWT",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (a, a, a, a)",
          "source": "src/Algebra-Structures-PruferDomain.html#calcUVWT",
          "type": "function"
        },
        "index": {
          "description": "Alternative characterization of Prufer domains given and compute such that ua vb wa tb",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "calcUVWT",
          "normalized": "a-\u003ea-\u003e(a,a,a,a)",
          "package": "constructive-algebra",
          "partial": "UVWT",
          "signature": "a-\u003ea-\u003e(a,a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:calcUVWT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBezout domain -\u003e Prufer domain\n\u003c/p\u003e\u003cp\u003eProof that all Bezout domains are Prufer domains.\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "calcUVW_B",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (a, a, a)",
          "source": "src/Algebra-Structures-PruferDomain.html#calcUVW_B",
          "type": "function"
        },
        "index": {
          "description": "Bezout domain Prufer domain Proof that all Bezout domains are Prufer domains",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "calcUVW_B",
          "normalized": "a-\u003ea-\u003e(a,a,a)",
          "package": "constructive-algebra",
          "partial": "UVW",
          "signature": "a-\u003ea-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:calcUVW_B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a principal localization matrix for an ideal in a Prufer domain.\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "computePLM_PD",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Matrix a",
          "source": "src/Algebra-Structures-PruferDomain.html#computePLM_PD",
          "type": "function"
        },
        "index": {
          "description": "Compute principal localization matrix for an ideal in Prufer domain",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "computePLM_PD",
          "normalized": "Ideal a-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "PLM PD",
          "signature": "Ideal a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:computePLM_PD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGo back to the original definition.\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "fromUVWTtoUVW",
          "package": "constructive-algebra",
          "signature": "(a, a, a, a) -\u003e (a, a, a)",
          "source": "src/Algebra-Structures-PruferDomain.html#fromUVWTtoUVW",
          "type": "function"
        },
        "index": {
          "description": "Go back to the original definition",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "fromUVWTtoUVW",
          "normalized": "(a,a,a,a)-\u003e(a,a,a)",
          "package": "constructive-algebra",
          "partial": "UVWTto UVW",
          "signature": "(a,a,a,a)-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:fromUVWTtoUVW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.PruferDomain",
          "name": "intersectionPD",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Ideal a -\u003e Ideal a",
          "source": "src/Algebra-Structures-PruferDomain.html#intersectionPD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "intersectionPD",
          "normalized": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "package": "constructive-algebra",
          "partial": "PD",
          "signature": "Ideal a-\u003eIdeal a-\u003eIdeal a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:intersectionPD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the intersection of I and J by:\n\u003c/p\u003e\u003cp\u003e(I \\cap J)(I + J) = IJ  =\u003e (I \\cap J)(I + J)(I + J)' = IJ(I + J)'\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "intersectionPDWitness",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Ideal a -\u003e (Ideal a, [[a]], [[a]])",
          "source": "src/Algebra-Structures-PruferDomain.html#intersectionPDWitness",
          "type": "function"
        },
        "index": {
          "description": "Compute the intersection of and by cap IJ cap IJ",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "intersectionPDWitness",
          "normalized": "Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]])",
          "package": "constructive-algebra",
          "partial": "PDWitness",
          "signature": "Ideal a-\u003eIdeal a-\u003e(Ideal a,[[a]],[[a]])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:intersectionPDWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdeal inversion. Given I compute J such that IJ is principal.\n Uses the principal localization matrix for the ideal.\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "invertIdeal",
          "package": "constructive-algebra",
          "signature": "Ideal a -\u003e Ideal a",
          "source": "src/Algebra-Structures-PruferDomain.html#invertIdeal",
          "type": "function"
        },
        "index": {
          "description": "Ideal inversion Given compute such that IJ is principal Uses the principal localization matrix for the ideal",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "invertIdeal",
          "normalized": "Ideal a-\u003eIdeal a",
          "package": "constructive-algebra",
          "partial": "Ideal",
          "signature": "Ideal a-\u003eIdeal a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:invertIdeal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProperty specifying that:\n au = bv and b(1-u) = aw\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "propCalcUVW",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-PruferDomain.html#propCalcUVW",
          "type": "function"
        },
        "index": {
          "description": "Property specifying that au bv and aw",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "propCalcUVW",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Calc UVW",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:propCalcUVW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.PruferDomain",
          "name": "propCalcUVWT",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Structures-PruferDomain.html#propCalcUVWT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "propCalcUVWT",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Calc UVWT",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:propCalcUVWT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.PruferDomain",
          "name": "propPruferDomain",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-PruferDomain.html#propPruferDomain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "propPruferDomain",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Prufer Domain",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:propPruferDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoherence of Prufer domains.\n\u003c/p\u003e",
          "module": "Algebra.Structures.PruferDomain",
          "name": "solvePD",
          "package": "constructive-algebra",
          "signature": "Vector a -\u003e Matrix a",
          "source": "src/Algebra-Structures-PruferDomain.html#solvePD",
          "type": "function"
        },
        "index": {
          "description": "Coherence of Prufer domains",
          "hierarchy": "Algebra Structures PruferDomain",
          "module": "Algebra.Structures.PruferDomain",
          "name": "solvePD",
          "normalized": "Vector a-\u003eMatrix a",
          "package": "constructive-algebra",
          "partial": "PD",
          "signature": "Vector a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-PruferDomain.html#v:solvePD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe representation of the ring structure.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "Ring",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Ring.html",
          "type": "module"
        },
        "index": {
          "description": "The representation of the ring structure",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "Ring",
          "package": "constructive-algebra",
          "partial": "Ring",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefinition of rings.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "Ring",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-Ring.html#Ring",
          "type": "class"
        },
        "index": {
          "description": "Definition of rings",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "Ring",
          "package": "constructive-algebra",
          "partial": "Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#t:Ring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c*\u003e)",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-Ring.html#%3C%2A%3E",
          "type": "method"
        },
        "index": {
          "description": "Multiplication",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c+\u003e)",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-Ring.html#%3C%2B%3E",
          "type": "method"
        },
        "index": {
          "description": "Addition",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtraction\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c-\u003e)",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Structures-Ring.html#%3C-%3E",
          "type": "function"
        },
        "index": {
          "description": "Subtraction",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c-\u003e) \u003c-\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:-60--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponentiation\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c^\u003e)",
          "package": "constructive-algebra",
          "signature": "a -\u003e Integer -\u003e a",
          "source": "src/Algebra-Structures-Ring.html#%3C%5E%3E",
          "type": "function"
        },
        "index": {
          "description": "Exponentiation",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "(\u003c^\u003e) \u003c^\u003e",
          "normalized": "a-\u003eInteger-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003eInteger-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:-60--94--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute additive inverse\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "neg",
          "package": "constructive-algebra",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Structures-Ring.html#neg",
          "type": "method"
        },
        "index": {
          "description": "Compute additive inverse",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "neg",
          "normalized": "a-\u003ea",
          "package": "constructive-algebra",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe multiplicative identity\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "one",
          "package": "constructive-algebra",
          "signature": "a",
          "source": "src/Algebra-Structures-Ring.html#one",
          "type": "method"
        },
        "index": {
          "description": "The multiplicative identity",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "one",
          "package": "constructive-algebra",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduct\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "productRing",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Structures-Ring.html#productRing",
          "type": "function"
        },
        "index": {
          "description": "Product",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "productRing",
          "normalized": "[a]-\u003ea",
          "package": "constructive-algebra",
          "partial": "Ring",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:productRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition is associative.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propAddAssoc",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propAddAssoc",
          "type": "function"
        },
        "index": {
          "description": "Addition is associative",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propAddAssoc",
          "normalized": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Add Assoc",
          "signature": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propAddAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition is commutative.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propAddComm",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propAddComm",
          "type": "function"
        },
        "index": {
          "description": "Addition is commutative",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propAddComm",
          "normalized": "a-\u003ea-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Add Comm",
          "signature": "a-\u003ea-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propAddComm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZero is the additive identity.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propAddIdentity",
          "package": "constructive-algebra",
          "signature": "a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propAddIdentity",
          "type": "function"
        },
        "index": {
          "description": "Zero is the additive identity",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propAddIdentity",
          "normalized": "a-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Add Identity",
          "signature": "a-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propAddIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegation give the additive inverse.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propAddInv",
          "package": "constructive-algebra",
          "signature": "a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propAddInv",
          "type": "function"
        },
        "index": {
          "description": "Negation give the additive inverse",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propAddInv",
          "normalized": "a-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Add Inv",
          "signature": "a-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propAddInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication is left-ditributive over addition.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propLeftDist",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propLeftDist",
          "type": "function"
        },
        "index": {
          "description": "Multiplication is left-ditributive over addition",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propLeftDist",
          "normalized": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Left Dist",
          "signature": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propLeftDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication is associative.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propMulAssoc",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propMulAssoc",
          "type": "function"
        },
        "index": {
          "description": "Multiplication is associative",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propMulAssoc",
          "normalized": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Mul Assoc",
          "signature": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propMulAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne is the multiplicative identity.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propMulIdentity",
          "package": "constructive-algebra",
          "signature": "a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propMulIdentity",
          "type": "function"
        },
        "index": {
          "description": "One is the multiplicative identity",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propMulIdentity",
          "normalized": "a-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Mul Identity",
          "signature": "a-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propMulIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication is right-distributive over addition.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propRightDist",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e (Bool, String)",
          "source": "src/Algebra-Structures-Ring.html#propRightDist",
          "type": "function"
        },
        "index": {
          "description": "Multiplication is right-distributive over addition",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propRightDist",
          "normalized": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "package": "constructive-algebra",
          "partial": "Right Dist",
          "signature": "a-\u003ea-\u003ea-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propRightDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecification of rings. Test that the arguments satisfy the ring axioms.\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "propRing",
          "package": "constructive-algebra",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Structures-Ring.html#propRing",
          "type": "function"
        },
        "index": {
          "description": "Specification of rings Test that the arguments satisfy the ring axioms",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "propRing",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Ring",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:propRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSummation\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "sumRing",
          "package": "constructive-algebra",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Structures-Ring.html#sumRing",
          "type": "function"
        },
        "index": {
          "description": "Summation",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "sumRing",
          "normalized": "[a]-\u003ea",
          "package": "constructive-algebra",
          "partial": "Ring",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:sumRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe additive identity\n\u003c/p\u003e",
          "module": "Algebra.Structures.Ring",
          "name": "zero",
          "package": "constructive-algebra",
          "signature": "a",
          "source": "src/Algebra-Structures-Ring.html#zero",
          "type": "method"
        },
        "index": {
          "description": "The additive identity",
          "hierarchy": "Algebra Structures Ring",
          "module": "Algebra.Structures.Ring",
          "name": "zero",
          "package": "constructive-algebra",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-Ring.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "StronglyDiscrete",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-StronglyDiscrete.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Structures StronglyDiscrete",
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "StronglyDiscrete",
          "package": "constructive-algebra",
          "partial": "Strongly Discrete",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-StronglyDiscrete.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrongly discrete rings\n\u003c/p\u003e\u003cp\u003eA ring is called strongly discrete if ideal membership is decidable.\n Nothing correspond to that x is not in the ideal and Just is the witness.\n Examples include all Bezout domains and polynomial rings.\n\u003c/p\u003e",
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "StronglyDiscrete",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-StronglyDiscrete.html#StronglyDiscrete",
          "type": "class"
        },
        "index": {
          "description": "Strongly discrete rings ring is called strongly discrete if ideal membership is decidable Nothing correspond to that is not in the ideal and Just is the witness Examples include all Bezout domains and polynomial rings",
          "hierarchy": "Algebra Structures StronglyDiscrete",
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "StronglyDiscrete",
          "package": "constructive-algebra",
          "partial": "Strongly Discrete",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-StronglyDiscrete.html#t:StronglyDiscrete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "member",
          "package": "constructive-algebra",
          "signature": "a -\u003e Ideal a -\u003e Maybe [a]",
          "source": "src/Algebra-Structures-StronglyDiscrete.html#member",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Structures StronglyDiscrete",
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "member",
          "normalized": "a-\u003eIdeal a-\u003eMaybe[a]",
          "package": "constructive-algebra",
          "signature": "a-\u003eIdeal a-\u003eMaybe[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-StronglyDiscrete.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest that the witness is actually a witness that the element is in the \n ideal.\n\u003c/p\u003e",
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "propStronglyDiscrete",
          "package": "constructive-algebra",
          "signature": "a -\u003e Ideal a -\u003e Bool",
          "source": "src/Algebra-Structures-StronglyDiscrete.html#propStronglyDiscrete",
          "type": "function"
        },
        "index": {
          "description": "Test that the witness is actually witness that the element is in the ideal",
          "hierarchy": "Algebra Structures StronglyDiscrete",
          "module": "Algebra.Structures.StronglyDiscrete",
          "name": "propStronglyDiscrete",
          "normalized": "a-\u003eIdeal a-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Strongly Discrete",
          "signature": "a-\u003eIdeal a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Structures-StronglyDiscrete.html#v:propStronglyDiscrete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType level characters. Used for representing the variable name in \n univariate polynomials.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.TypeChar.Char",
          "name": "Char",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html",
          "type": "module"
        },
        "index": {
          "description": "Type level characters Used for representing the variable name in univariate polynomials",
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "Char",
          "package": "constructive-algebra",
          "partial": "Char",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "A",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#A",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "A",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "A_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#A_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "A_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:A_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "B",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#B",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "B",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "B_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#B_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "B_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:B_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "C",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#C",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "C",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "C_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#C_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "C_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:C_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "D",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#D",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "D",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "D_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#D_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "D_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:D_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "E",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#E",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "E",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "E_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#E_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "E_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:E_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "F",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#F",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "F",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:F"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "F_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#F_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "F_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:F_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "G",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#G",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "G",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "G_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#G_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "G_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:G_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "H",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#H",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "H",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "H_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#H_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "H_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:H_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "I",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#I",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "I",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "I_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#I_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "I_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:I_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "J",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#J",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "J",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:J"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "J_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#J_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "J_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:J_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "K",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#K",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "K",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "K_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#K_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "K_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:K_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "L",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#L",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "L",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "L_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#L_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "L_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:L_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "M",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#M",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "M",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "M_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#M_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "M_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:M_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "N",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#N",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "N",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:N"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "N_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#N_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "N_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:N_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "O",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#O",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "O",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:O"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "O_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#O_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "O_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:O_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "P",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#P",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "P",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "P_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#P_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "P_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:P_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "Q",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#Q",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "Q",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "Q_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#Q_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "Q_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:Q_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "R",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#R",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "R",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "R_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#R_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "R_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:R_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "S",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#S",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "S",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "S_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#S_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "S_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:S_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "T",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "T",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "T_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#T_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "T_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:T_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "U",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#U",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "U",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "U_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#U_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "U_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:U_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "V",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#V",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "V",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "V_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#V_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "V_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:V_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "W",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#W",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "W",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "W_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#W_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "W_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:W_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "X",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#X",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "X",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "X_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#X_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "X_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:X_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "Y",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#Y",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "Y",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "Y_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#Y_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "Y_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:Y_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "Z",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#Z",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "Z",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.TypeChar.Char",
          "name": "Z_",
          "package": "constructive-algebra",
          "source": "src/Algebra-TypeChar-Char.html#Z_",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra TypeChar Char",
          "module": "Algebra.TypeChar.Char",
          "name": "Z_",
          "package": "constructive-algebra",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-TypeChar-Char.html#t:Z_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnivariate polynomials parametrised by the variable name.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.UPoly",
          "name": "UPoly",
          "package": "constructive-algebra",
          "source": "src/Algebra-UPoly.html",
          "type": "module"
        },
        "index": {
          "description": "Univariate polynomials parametrised by the variable name",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "UPoly",
          "package": "constructive-algebra",
          "partial": "UPoly",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUseful shorthand for Q[x].\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "Qx",
          "package": "constructive-algebra",
          "source": "src/Algebra-UPoly.html#Qx",
          "type": "type"
        },
        "index": {
          "description": "Useful shorthand for",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "Qx",
          "package": "constructive-algebra",
          "partial": "Qx",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#t:Qx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePolynomials over a commutative ring, indexed by a phantom type x that\n denote the name of the variable that the polynomial is over. For example\n UPoly Q X_ is Q[x] and UPoly Q T_ is Q[t].\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "UPoly",
          "package": "constructive-algebra",
          "source": "src/Algebra-UPoly.html#UPoly",
          "type": "newtype"
        },
        "index": {
          "description": "Polynomials over commutative ring indexed by phantom type that denote the name of the variable that the polynomial is over For example UPoly is and UPoly is",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "UPoly",
          "package": "constructive-algebra",
          "partial": "UPoly",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#t:UPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.UPoly",
          "name": "UP",
          "package": "constructive-algebra",
          "signature": "UP [r]",
          "source": "src/Algebra-UPoly.html#UPoly",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "UP",
          "normalized": "UP[a]",
          "package": "constructive-algebra",
          "partial": "UP",
          "signature": "UP[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:UP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the content of a polynomial, i.e. the gcd of the coefficients.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "cont",
          "package": "constructive-algebra",
          "signature": "UPoly a x -\u003e a",
          "source": "src/Algebra-UPoly.html#cont",
          "type": "function"
        },
        "index": {
          "description": "Compute the content of polynomial i.e the gcd of the coefficients",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "cont",
          "normalized": "UPoly a b-\u003ea",
          "package": "constructive-algebra",
          "signature": "UPoly a x-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:cont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe degree of the polynomial.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "deg",
          "package": "constructive-algebra",
          "signature": "UPoly r x -\u003e Integer",
          "source": "src/Algebra-UPoly.html#deg",
          "type": "function"
        },
        "index": {
          "description": "The degree of the polynomial",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "deg",
          "normalized": "UPoly a b-\u003eInteger",
          "package": "constructive-algebra",
          "signature": "UPoly r x-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:deg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormal derivative of polynomials in k[x].\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "deriv",
          "package": "constructive-algebra",
          "signature": "UPoly r x -\u003e UPoly r x",
          "source": "src/Algebra-UPoly.html#deriv",
          "type": "function"
        },
        "index": {
          "description": "Formal derivative of polynomials in",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "deriv",
          "normalized": "UPoly a b-\u003eUPoly a b",
          "package": "constructive-algebra",
          "signature": "UPoly r x-\u003eUPoly r x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:deriv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGauss lemma says that if p and q are polynomials over a GCD domain then\n cont(pq) = cont(p) * cont(q).\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "gaussLemma",
          "package": "constructive-algebra",
          "signature": "UPoly a x -\u003e UPoly a x -\u003e Property",
          "source": "src/Algebra-UPoly.html#gaussLemma",
          "type": "function"
        },
        "index": {
          "description": "Gauss lemma says that if and are polynomials over GCD domain then cont pq cont cont",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "gaussLemma",
          "normalized": "UPoly a b-\u003eUPoly a b-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "Lemma",
          "signature": "UPoly a x-\u003eUPoly a x-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:gaussLemma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProof that if A is a GCD domain then A[x] also is a GCD domain. This also\n computes witnesses that the computed GCD divides the given polynomials.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "gcdUPolyWitness",
          "package": "constructive-algebra",
          "signature": "UPoly a x -\u003e UPoly a x -\u003e (UPoly a x, UPoly a x, UPoly a x)",
          "source": "src/Algebra-UPoly.html#gcdUPolyWitness",
          "type": "function"
        },
        "index": {
          "description": "Proof that if is GCD domain then also is GCD domain This also computes witnesses that the computed GCD divides the given polynomials",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "gcdUPolyWitness",
          "normalized": "UPoly a b-\u003eUPoly a b-\u003e(UPoly a b,UPoly a b,UPoly a b)",
          "package": "constructive-algebra",
          "partial": "UPoly Witness",
          "signature": "UPoly a x-\u003eUPoly a x-\u003e(UPoly a x,UPoly a x,UPoly a x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:gcdUPolyWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf all coefficients are relatively prime then the polynomial is primitive.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "isPrimitive",
          "package": "constructive-algebra",
          "signature": "UPoly a x -\u003e Bool",
          "source": "src/Algebra-UPoly.html#isPrimitive",
          "type": "function"
        },
        "index": {
          "description": "If all coefficients are relatively prime then the polynomial is primitive",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "isPrimitive",
          "normalized": "UPoly a b-\u003eBool",
          "package": "constructive-algebra",
          "partial": "Primitive",
          "signature": "UPoly a x-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:isPrimitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the leading term of a polynomial.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "lt",
          "package": "constructive-algebra",
          "signature": "UPoly r x -\u003e r",
          "source": "src/Algebra-UPoly.html#lt",
          "type": "function"
        },
        "index": {
          "description": "Compute the leading term of polynomial",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "lt",
          "normalized": "UPoly a b-\u003ea",
          "package": "constructive-algebra",
          "signature": "UPoly r x-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake an element of the ring and the degree of the desired monomial, for\n example: monomial 3 7 = 3x^7\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "monomial",
          "package": "constructive-algebra",
          "signature": "r -\u003e Integer -\u003e UPoly r x",
          "source": "src/Algebra-UPoly.html#monomial",
          "type": "function"
        },
        "index": {
          "description": "Take an element of the ring and the degree of the desired monomial for example monomial",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "monomial",
          "normalized": "a-\u003eInteger-\u003eUPoly a b",
          "package": "constructive-algebra",
          "signature": "r-\u003eInteger-\u003eUPoly r x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.UPoly",
          "name": "propToPrimitive",
          "package": "constructive-algebra",
          "signature": "UPoly (FieldOfFractions a) x -\u003e Property",
          "source": "src/Algebra-UPoly.html#propToPrimitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "propToPrimitive",
          "normalized": "UPoly(FieldOfFractions a)b-\u003eProperty",
          "package": "constructive-algebra",
          "partial": "To Primitive",
          "signature": "UPoly(FieldOfFractions a)x-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:propToPrimitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare free decomposition of a polynomial.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "sqfr",
          "package": "constructive-algebra",
          "signature": "UPoly k x -\u003e UPoly k x",
          "source": "src/Algebra-UPoly.html#sqfr",
          "type": "function"
        },
        "index": {
          "description": "Square free decomposition of polynomial",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "sqfr",
          "normalized": "UPoly a b-\u003eUPoly a b",
          "package": "constructive-algebra",
          "signature": "UPoly k x-\u003eUPoly k x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:sqfr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistinct power factorization, aka square free decomposition\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "sqfrDec",
          "package": "constructive-algebra",
          "signature": "UPoly k x -\u003e [UPoly k x]",
          "source": "src/Algebra-UPoly.html#sqfrDec",
          "type": "function"
        },
        "index": {
          "description": "Distinct power factorization aka square free decomposition",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "sqfrDec",
          "normalized": "UPoly a b-\u003e[UPoly a b]",
          "package": "constructive-algebra",
          "partial": "Dec",
          "signature": "UPoly k x-\u003e[UPoly k x]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:sqfrDec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLemma 4.2: Given a polynomial p in K[x] where K=Quot(A) we can find c in K\n and q primitive in A[x] such that p = cq.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "toPrimitive",
          "package": "constructive-algebra",
          "signature": "UPoly (FieldOfFractions a) x -\u003e (FieldOfFractions a, UPoly a x)",
          "source": "src/Algebra-UPoly.html#toPrimitive",
          "type": "function"
        },
        "index": {
          "description": "Lemma Given polynomial in where Quot we can find in and primitive in such that cq",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "toPrimitive",
          "normalized": "UPoly(FieldOfFractions a)b-\u003e(FieldOfFractions a,UPoly a b)",
          "package": "constructive-algebra",
          "partial": "Primitive",
          "signature": "UPoly(FieldOfFractions a)x-\u003e(FieldOfFractions a,UPoly a x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:toPrimitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake a list and construct a polynomial by removing all zeroes in the end.\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "toUPoly",
          "package": "constructive-algebra",
          "signature": "[r] -\u003e UPoly r x",
          "source": "src/Algebra-UPoly.html#toUPoly",
          "type": "function"
        },
        "index": {
          "description": "Take list and construct polynomial by removing all zeroes in the end",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "toUPoly",
          "normalized": "[a]-\u003eUPoly a b",
          "package": "constructive-algebra",
          "partial": "UPoly",
          "signature": "[r]-\u003eUPoly r x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:toUPoly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe variable x in Q[x].\n\u003c/p\u003e",
          "module": "Algebra.UPoly",
          "name": "x",
          "package": "constructive-algebra",
          "signature": "Qx",
          "source": "src/Algebra-UPoly.html#x",
          "type": "function"
        },
        "index": {
          "description": "The variable in",
          "hierarchy": "Algebra UPoly",
          "module": "Algebra.UPoly",
          "name": "x",
          "package": "constructive-algebra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-UPoly.html#v:x"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Z",
          "name": "Z",
          "package": "constructive-algebra",
          "source": "src/Algebra-Z.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Z",
          "module": "Algebra.Z",
          "name": "Z",
          "package": "constructive-algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Z.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefinition of integral domains.\n\u003c/p\u003e",
          "module": "Algebra.Z",
          "name": "IntegralDomain",
          "package": "constructive-algebra",
          "source": "src/Algebra-Structures-IntegralDomain.html#IntegralDomain",
          "type": "class"
        },
        "index": {
          "description": "Definition of integral domains",
          "hierarchy": "Algebra Z",
          "module": "Algebra.Z",
          "name": "IntegralDomain",
          "package": "constructive-algebra",
          "partial": "Integral Domain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Z.html#t:IntegralDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym for integers.\n\u003c/p\u003e",
          "module": "Algebra.Z",
          "name": "Z",
          "package": "constructive-algebra",
          "source": "src/Algebra-Z.html#Z",
          "type": "type"
        },
        "index": {
          "description": "Type synonym for integers",
          "hierarchy": "Algebra Z",
          "module": "Algebra.Z",
          "name": "Z",
          "package": "constructive-algebra",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Z.html#t:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProof that Z[sqrt(-5)] is a Prufer domain. This implies that it is \n possible to solve systems of equations over Z[sqrt(-5)].\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.ZSqrt5",
          "name": "ZSqrt5",
          "package": "constructive-algebra",
          "source": "src/Algebra-ZSqrt5.html",
          "type": "module"
        },
        "index": {
          "description": "Proof that sqrt is Prufer domain This implies that it is possible to solve systems of equations over sqrt",
          "hierarchy": "Algebra ZSqrt5",
          "module": "Algebra.ZSqrt5",
          "name": "ZSqrt5",
          "package": "constructive-algebra",
          "partial": "ZSqrt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-ZSqrt5.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZ[sqrt(-5)] is a pair such that (a,b) = a + b*sqrt(-5)\n\u003c/p\u003e",
          "module": "Algebra.ZSqrt5",
          "name": "ZSqrt5",
          "package": "constructive-algebra",
          "source": "src/Algebra-ZSqrt5.html#ZSqrt5",
          "type": "newtype"
        },
        "index": {
          "description": "sqrt is pair such that sqrt",
          "hierarchy": "Algebra ZSqrt5",
          "module": "Algebra.ZSqrt5",
          "name": "ZSqrt5",
          "package": "constructive-algebra",
          "partial": "ZSqrt",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-ZSqrt5.html#t:ZSqrt5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ZSqrt5",
          "name": "ZSqrt5",
          "package": "constructive-algebra",
          "signature": "ZSqrt5 (Z, Z)",
          "source": "src/Algebra-ZSqrt5.html#ZSqrt5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra ZSqrt5",
          "module": "Algebra.ZSqrt5",
          "name": "ZSqrt5",
          "normalized": "ZSqrt(Z,Z)",
          "package": "constructive-algebra",
          "partial": "ZSqrt",
          "signature": "ZSqrt(Z,Z)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-ZSqrt5.html#v:ZSqrt5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIntegers modulo n parametrised by the n. This also has type-level primality\n testing used for instantiating integral domain and field type classes. The\n primality testing is very slow, but it seem to be working fine for relatively\n small numbers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Zn",
          "name": "Zn",
          "package": "constructive-algebra",
          "source": "src/Algebra-Zn.html",
          "type": "module"
        },
        "index": {
          "description": "Integers modulo parametrised by the This also has type-level primality testing used for instantiating integral domain and field type classes The primality testing is very slow but it seem to be working fine for relatively small numbers",
          "hierarchy": "Algebra Zn",
          "module": "Algebra.Zn",
          "name": "Zn",
          "package": "constructive-algebra",
          "partial": "Zn",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Zn.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Zn",
          "name": "Z3",
          "package": "constructive-algebra",
          "source": "src/Algebra-Zn.html#Z3",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algebra Zn",
          "module": "Algebra.Zn",
          "name": "Z3",
          "package": "constructive-algebra",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Zn.html#t:Z3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe phantom type n represents which modulo to work in.\n\u003c/p\u003e",
          "module": "Algebra.Zn",
          "name": "Zn",
          "package": "constructive-algebra",
          "source": "src/Algebra-Zn.html#Zn",
          "type": "newtype"
        },
        "index": {
          "description": "The phantom type represents which modulo to work in",
          "hierarchy": "Algebra Zn",
          "module": "Algebra.Zn",
          "name": "Zn",
          "package": "constructive-algebra",
          "partial": "Zn",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Zn.html#t:Zn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Zn",
          "name": "Zn",
          "package": "constructive-algebra",
          "signature": "Zn Integer",
          "source": "src/Algebra-Zn.html#Zn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Zn",
          "module": "Algebra.Zn",
          "name": "Zn",
          "package": "constructive-algebra",
          "partial": "Zn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/constructive-algebra/docs/Algebra-Zn.html#v:Zn"
      }
    }
  ]
]