[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "numeric-prelude"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Absolute",
          "name": "Absolute",
          "package": "numeric-prelude",
          "source": "src/Algebra-Absolute.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Absolute",
          "module": "Algebra.Absolute",
          "name": "Absolute",
          "package": "numeric-prelude",
          "partial": "Absolute",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Absolute.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the type class of a ring with a notion of an absolute value,\nsatisfying the laws\n\u003c/p\u003e\u003cpre\u003e                        a * b === b * a\n   a /= 0  =\u003e  abs (signum a) === 1\n             abs a * signum a === a\n\u003c/pre\u003e\u003cp\u003eMinimal definition: \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the type is in the \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e class\nwe expect \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eabsOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003esignumOrd\u003c/a\u003e\u003c/code\u003e\nand we expect the following laws to hold:\n\u003c/p\u003e\u003cpre\u003e      a + (max b c) === max (a+b) (a+c)\n   negate (max b c) === min (negate b) (negate c)\n      a * (max b c) === max (a*b) (a*c) where a \u003e= 0\n           absOrd a === max a (-a)\n\u003c/pre\u003e\u003cp\u003eIf the type is \u003ccode\u003eZeroTestable\u003c/code\u003e, then it should hold\n\u003c/p\u003e\u003cpre\u003e  isZero a  ===  signum a == signum (negate a)\n\u003c/pre\u003e\u003cp\u003eWe do not require \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e as superclass\nsince we also want to have \u003ca\u003eNumber.Complex\u003c/a\u003e as instance.\nWe also do not require \u003ccode\u003eZeroTestable\u003c/code\u003e as superclass,\nbecause we like to have expressions of foreign languages\nto be instances (cf. embedded domain specific language approach, EDSL),\nas well as function types.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e for complex numbers alone may have an inappropriate type,\nbecause it does not reflect that the absolute value is a real number.\nYou might prefer \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e.\nThis type class is intended for unifying algorithms\nthat work for both real and complex numbers.\nNote the similarity to \u003ca\u003eAlgebra.Units\u003c/a\u003e:\n\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e plays the role of \u003ccode\u003estdAssociate\u003c/code\u003e\nand \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e plays the role of \u003ccode\u003estdUnit\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eActually, since \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e can be defined using \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003enegate\u003c/a\u003e\u003c/code\u003e\nwe could relax the superclasses to \u003ccode\u003eAdditive\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e\nif his class would only contain \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Algebra.Absolute",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Absolute.html#C",
          "type": "class"
        },
        "index": {
          "description": "This is the type class of ring with notion of an absolute value satisfying the laws abs signum abs signum Minimal definition abs signum If the type is in the Ord class we expect abs absOrd and signum signumOrd and we expect the following laws to hold max max negate max min negate negate max max where absOrd max If the type is ZeroTestable then it should hold isZero signum signum negate We do not require Ord as superclass since we also want to have Number.Complex as instance We also do not require ZeroTestable as superclass because we like to have expressions of foreign languages to be instances cf embedded domain specific language approach EDSL as well as function types abs for complex numbers alone may have an inappropriate type because it does not reflect that the absolute value is real number You might prefer magnitude This type class is intended for unifying algorithms that work for both real and complex numbers Note the similarity to Algebra.Units abs plays the role of stdAssociate and signum plays the role of stdUnit Actually since abs can be defined using max and negate we could relax the superclasses to Additive and Ord if his class would only contain signum",
          "hierarchy": "Algebra Absolute",
          "module": "Algebra.Absolute",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Absolute.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Absolute",
          "name": "abs",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Absolute.html#abs",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Absolute",
          "module": "Algebra.Absolute",
          "name": "abs",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Absolute.html#v:abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Absolute",
          "name": "absOrd",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Absolute.html#absOrd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Absolute",
          "module": "Algebra.Absolute",
          "name": "absOrd",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Ord",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Absolute.html#v:absOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Absolute",
          "name": "signum",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Absolute.html#signum",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Absolute",
          "module": "Algebra.Absolute",
          "name": "signum",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Absolute.html#v:signum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Absolute",
          "name": "signumOrd",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Absolute.html#signumOrd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Absolute",
          "module": "Algebra.Absolute",
          "name": "signumOrd",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Ord",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Absolute.html#v:signumOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "Additive",
          "package": "numeric-prelude",
          "source": "src/Algebra-Additive.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "Additive",
          "package": "numeric-prelude",
          "partial": "Additive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdditive a encapsulates the notion of a commutative group, specified\nby the following laws:\n\u003c/p\u003e\u003cpre\u003e\n          a + b === b + a\n    (a + b) + c === a + (b + c)\n       zero + a === a\n   a + negate a === 0\n\u003c/pre\u003e\u003cp\u003eTypical examples include integers, dollars, and vectors.\n\u003c/p\u003e\u003cp\u003eMinimal definition: \u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ezero\u003c/a\u003e\u003c/code\u003e, and (\u003ccode\u003e\u003ca\u003enegate\u003c/a\u003e\u003c/code\u003e or '(-)')\n\u003c/p\u003e",
          "module": "Algebra.Additive",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Additive.html#C",
          "type": "class"
        },
        "index": {
          "description": "Additive encapsulates the notion of commutative group specified by the following laws zero negate Typical examples include integers dollars and vectors Minimal definition zero and negate or",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd and subtract elements\n\u003c/p\u003e",
          "module": "Algebra.Additive",
          "name": "(+)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Additive.html#%2B",
          "type": "method"
        },
        "index": {
          "description": "add and subtract elements",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "(+) +",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e addPair :: (Additive.C a, Additive.C b) =\u003e (a,b) -\u003e (a,b) -\u003e (a,b)\n addPair = Elem.run2 $ Elem.with (,) \u003c*\u003e.+  fst \u003c*\u003e.+  snd\n\u003c/pre\u003e",
          "module": "Algebra.Additive",
          "name": "(\u003c*\u003e.+)",
          "package": "numeric-prelude",
          "signature": "T (v, v) (x -\u003e a) -\u003e (v -\u003e x) -\u003e T (v, v) a",
          "source": "src/Algebra-Additive.html#%3C%2A%3E.%2B",
          "type": "function"
        },
        "index": {
          "description": "addPair Additive.C Additive.C addPair Elem.run2 Elem.with fst snd",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "(\u003c*\u003e.+) \u003c*\u003e.+",
          "normalized": "T(a,a)(b-\u003ec)-\u003e(a-\u003eb)-\u003eT(a,a)c",
          "package": "numeric-prelude",
          "signature": "T(v,v)(x-\u003ea)-\u003e(v-\u003ex)-\u003eT(v,v)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:-60--42--62-.-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "(\u003c*\u003e.-)",
          "package": "numeric-prelude",
          "signature": "T (v, v) (x -\u003e a) -\u003e (v -\u003e x) -\u003e T (v, v) a",
          "source": "src/Algebra-Additive.html#%3C%2A%3E.-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "(\u003c*\u003e.-) \u003c*\u003e.-",
          "normalized": "T(a,a)(b-\u003ec)-\u003e(a-\u003eb)-\u003eT(a,a)c",
          "package": "numeric-prelude",
          "signature": "T(v,v)(x-\u003ea)-\u003e(v-\u003ex)-\u003eT(v,v)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:-60--42--62-.-45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "(\u003c*\u003e.-$)",
          "package": "numeric-prelude",
          "signature": "T v (x -\u003e a) -\u003e (v -\u003e x) -\u003e T v a",
          "source": "src/Algebra-Additive.html#%3C%2A%3E.-%24",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "(\u003c*\u003e.-$) \u003c*\u003e.-$",
          "normalized": "T a(b-\u003ec)-\u003e(a-\u003eb)-\u003eT a c",
          "package": "numeric-prelude",
          "signature": "T v(x-\u003ea)-\u003e(v-\u003ex)-\u003eT v a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:-60--42--62-.-45--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstead of baking the add operation into the element function,\nwe could use higher rank types\nand pass a generic \u003ccode\u003euncurry (+)\u003c/code\u003e to the run function.\nWe do not do so in order to stay Haskell 98\nat least for parts of NumericPrelude.\n\u003c/p\u003e",
          "module": "Algebra.Additive",
          "name": "elementAdd",
          "package": "numeric-prelude",
          "signature": "(v -\u003e x) -\u003e T (v, v) x",
          "source": "src/Algebra-Additive.html#elementAdd",
          "type": "function"
        },
        "index": {
          "description": "Instead of baking the add operation into the element function we could use higher rank types and pass generic uncurry to the run function We do not do so in order to stay Haskell at least for parts of NumericPrelude",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "elementAdd",
          "normalized": "(a-\u003eb)-\u003eT(a,a)b",
          "package": "numeric-prelude",
          "partial": "Add",
          "signature": "(v-\u003ex)-\u003eT(v,v)x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:elementAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "elementNeg",
          "package": "numeric-prelude",
          "signature": "(v -\u003e x) -\u003e T v x",
          "source": "src/Algebra-Additive.html#elementNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "elementNeg",
          "normalized": "(a-\u003eb)-\u003eT a b",
          "package": "numeric-prelude",
          "partial": "Neg",
          "signature": "(v-\u003ex)-\u003eT v x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:elementNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "elementSub",
          "package": "numeric-prelude",
          "signature": "(v -\u003e x) -\u003e T (v, v) x",
          "source": "src/Algebra-Additive.html#elementSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "elementSub",
          "normalized": "(a-\u003eb)-\u003eT(a,a)b",
          "package": "numeric-prelude",
          "partial": "Sub",
          "signature": "(v-\u003ex)-\u003eT(v,v)x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:elementSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einverse with respect to \u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Additive",
          "name": "negate",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Additive.html#negate",
          "type": "method"
        },
        "index": {
          "description": "inverse with respect to",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "negate",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "propAssociative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Additive.html#propAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "propAssociative",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Associative",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:propAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "propCommutative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Additive.html#propCommutative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "propCommutative",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Commutative",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:propCommutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "propIdentity",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Additive.html#propIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "propIdentity",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Identity",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:propIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "propInverse",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Additive.html#propInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "propInverse",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Inverse",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:propInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esubtract\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e(-)\u003c/code\u003e with swapped operand order.\nThis is the operand order which will be needed in most cases\nof partial application.\n\u003c/p\u003e",
          "module": "[\"Algebra.Additive\",\"NumericPrelude.Numeric\"]",
          "name": "subtract",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Additive.html#subtract",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:subtract\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:subtract\"]"
        },
        "index": {
          "description": "subtract is with swapped operand order This is the operand order which will be needed in most cases of partial application",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "subtract",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:subtract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum up all elements of a list.\nAn empty list yields zero.\n\u003c/p\u003e\u003cp\u003eThis function is inappropriate for number types like Peano.\nMaybe we should make \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e a method of Additive.\nThis would also make \u003ccode\u003elengthLeft\u003c/code\u003e and \u003ccode\u003elengthRight\u003c/code\u003e superfluous.\n\u003c/p\u003e",
          "module": "[\"Algebra.Additive\",\"NumericPrelude.Numeric\"]",
          "name": "sum",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Additive.html#sum",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:sum\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:sum\"]"
        },
        "index": {
          "description": "Sum up all elements of list An empty list yields zero This function is inappropriate for number types like Peano Maybe we should make sum method of Additive This would also make lengthLeft and lengthRight superfluous",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "sum",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum up all elements of a non-empty list.\nThis avoids including a zero which is useful for types\nwhere no universal zero is available.\n\u003c/p\u003e",
          "module": "[\"Algebra.Additive\",\"NumericPrelude.Numeric\"]",
          "name": "sum1",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Additive.html#sum1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:sum1\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:sum1\"]"
        },
        "index": {
          "description": "Sum up all elements of non-empty list This avoids including zero which is useful for types where no universal zero is available",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "sum1",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:sum1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum the operands in an order,\nsuch that the dependencies are minimized.\nDoes this have a measurably effect on speed?\n\u003c/p\u003e\u003cp\u003eRequires associativity.\n\u003c/p\u003e",
          "module": "Algebra.Additive",
          "name": "sumNestedAssociative",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Additive.html#sumNestedAssociative",
          "type": "function"
        },
        "index": {
          "description": "Sum the operands in an order such that the dependencies are minimized Does this have measurably effect on speed Requires associativity",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "sumNestedAssociative",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Nested Associative",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:sumNestedAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Additive",
          "name": "sumNestedCommutative",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Additive.html#sumNestedCommutative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "sumNestedCommutative",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Nested Commutative",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:sumNestedCommutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ezero element of the vector space\n\u003c/p\u003e",
          "module": "Algebra.Additive",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-Additive.html#zero",
          "type": "method"
        },
        "index": {
          "description": "zero element of the vector space",
          "hierarchy": "Algebra Additive",
          "module": "Algebra.Additive",
          "name": "zero",
          "package": "numeric-prelude",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Additive.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "Algebraic",
          "package": "numeric-prelude",
          "source": "src/Algebra-Algebraic.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "Algebraic",
          "package": "numeric-prelude",
          "partial": "Algebraic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal implementation: \u003ccode\u003e\u003ca\u003eroot\u003c/a\u003e\u003c/code\u003e or '(^/)'. \n\u003c/p\u003e",
          "module": "Algebra.Algebraic",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Algebraic.html#C",
          "type": "class"
        },
        "index": {
          "description": "Minimal implementation root or",
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "(^/)",
          "package": "numeric-prelude",
          "signature": "a -\u003e Rational -\u003e a",
          "source": "src/Algebra-Algebraic.html#%5E%2F",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "(^/) ^/",
          "normalized": "a-\u003eRational-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003eRational-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:-94--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "genericRoot",
          "package": "numeric-prelude",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Algebra-Algebraic.html#genericRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "genericRoot",
          "normalized": "a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "partial": "Root",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:genericRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "power",
          "package": "numeric-prelude",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Algebra-Algebraic.html#power",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "power",
          "normalized": "a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "propPowerCascade",
          "package": "numeric-prelude",
          "signature": "a -\u003e Rational -\u003e Rational -\u003e Bool",
          "source": "src/Algebra-Algebraic.html#propPowerCascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "propPowerCascade",
          "normalized": "a-\u003eRational-\u003eRational-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Power Cascade",
          "signature": "a-\u003eRational-\u003eRational-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:propPowerCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "propPowerDistributive",
          "package": "numeric-prelude",
          "signature": "Rational -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Algebraic.html#propPowerDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "propPowerDistributive",
          "normalized": "Rational-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Power Distributive",
          "signature": "Rational-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:propPowerDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "propPowerProduct",
          "package": "numeric-prelude",
          "signature": "a -\u003e Rational -\u003e Rational -\u003e Bool",
          "source": "src/Algebra-Algebraic.html#propPowerProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "propPowerProduct",
          "normalized": "a-\u003eRational-\u003eRational-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Power Product",
          "signature": "a-\u003eRational-\u003eRational-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:propPowerProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "propSqrSqrt",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Algebraic.html#propSqrSqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "propSqrSqrt",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Sqr Sqrt",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:propSqrSqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "root",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e a -\u003e a",
          "source": "src/Algebra-Algebraic.html#root",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "root",
          "normalized": "Integer-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "Integer-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Algebraic",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Algebraic.html#sqrt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Algebraic",
          "module": "Algebra.Algebraic",
          "name": "sqrt",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Algebraic.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Differential",
          "name": "Differential",
          "package": "numeric-prelude",
          "source": "src/Algebra-Differential.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Differential",
          "module": "Algebra.Differential",
          "name": "Differential",
          "package": "numeric-prelude",
          "partial": "Differential",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Differential.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003edifferentiate\u003c/a\u003e\u003c/code\u003e is a general differentation operation\nIt must fulfill the Leibnitz condition\n\u003c/p\u003e\u003cpre\u003e   differentiate (x * y) == differentiate x * y + x * differentiate y\n\u003c/pre\u003e\u003cp\u003eUnfortunately, this scheme cannot be easily extended to more than two variables,\ne.g. \u003ca\u003eMathObj.PowerSeries2\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Algebra.Differential",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Differential.html#C",
          "type": "class"
        },
        "index": {
          "description": "differentiate is general differentation operation It must fulfill the Leibnitz condition differentiate differentiate differentiate Unfortunately this scheme cannot be easily extended to more than two variables e.g MathObj.PowerSeries2",
          "hierarchy": "Algebra Differential",
          "module": "Algebra.Differential",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Differential.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Differential",
          "name": "differentiate",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Differential.html#differentiate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Differential",
          "module": "Algebra.Differential",
          "name": "differentiate",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Differential.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWe already have the dynamically checked physical units\nprovided by \u003ca\u003eNumber.Physical\u003c/a\u003e\nand the statically checked ones of the \u003ccode\u003edimensional\u003c/code\u003e package of Buckwalter,\nwhich require multi-parameter type classes with functional dependencies.\n\u003c/p\u003e\u003cp\u003eHere we provide a poor man's approach:\nThe units are presented by type terms.\nThere is no canonical form and thus the type checker\ncan not automatically check for equal units.\nHowever, if two unit terms represent the same unit,\nthen you can tell the type checker to rewrite one into the other.\n\u003c/p\u003e\u003cp\u003eYou can add more dimensions by introducing more types of class \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis approach is not entirely safe\nbecause you can write your own flawed rewrite rules.\nIt is however more safe than with no units at all.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.DimensionTerm",
          "name": "DimensionTerm",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html",
          "type": "module"
        },
        "index": {
          "description": "We already have the dynamically checked physical units provided by Number.Physical and the statically checked ones of the dimensional package of Buckwalter which require multi-parameter type classes with functional dependencies Here we provide poor man approach The units are presented by type terms There is no canonical form and thus the type checker can not automatically check for equal units However if two unit terms represent the same unit then you can tell the type checker to rewrite one into the other You can add more dimensions by introducing more types of class This approach is not entirely safe because you can write your own flawed rewrite rules It is however more safe than with no units at all",
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "DimensionTerm",
          "package": "numeric-prelude",
          "partial": "Dimension Term",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Angle",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Angle",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Angle",
          "package": "numeric-prelude",
          "partial": "Angle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Charge",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Charge",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Charge",
          "package": "numeric-prelude",
          "partial": "Charge",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Charge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Frequency",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Frequency",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Frequency",
          "package": "numeric-prelude",
          "partial": "Frequency",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Frequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Information",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Information",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Information",
          "package": "numeric-prelude",
          "partial": "Information",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Information"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class allows defining instances that are exclusively for \u003ccode\u003e\u003ca\u003eScalar\u003c/a\u003e\u003c/code\u003e dimension.\nYou won't want to define instances by yourself.\n\u003c/p\u003e",
          "module": "Algebra.DimensionTerm",
          "name": "IsScalar",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#IsScalar",
          "type": "class"
        },
        "index": {
          "description": "This class allows defining instances that are exclusively for Scalar dimension You won want to define instances by yourself",
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "IsScalar",
          "package": "numeric-prelude",
          "partial": "Is Scalar",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:IsScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Length",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Length",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Length",
          "package": "numeric-prelude",
          "partial": "Length",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Mass",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Mass",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Mass",
          "package": "numeric-prelude",
          "partial": "Mass",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Mul",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Mul",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Mul",
          "package": "numeric-prelude",
          "partial": "Mul",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Recip",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Recip",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Recip",
          "package": "numeric-prelude",
          "partial": "Recip",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Scalar",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Scalar",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Scalar",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Sqr",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Sqr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Sqr",
          "package": "numeric-prelude",
          "partial": "Sqr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Sqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Temperature",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Temperature",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Temperature",
          "package": "numeric-prelude",
          "partial": "Temperature",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Temperature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Time",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Time",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Time",
          "package": "numeric-prelude",
          "partial": "Time",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Voltage",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#Voltage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Voltage",
          "package": "numeric-prelude",
          "partial": "Voltage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:Voltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "VoltageAnalytical",
          "package": "numeric-prelude",
          "source": "src/Algebra-DimensionTerm.html#VoltageAnalytical",
          "type": "type"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "VoltageAnalytical",
          "package": "numeric-prelude",
          "partial": "Voltage Analytical",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#t:VoltageAnalytical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "(%*%)",
          "package": "numeric-prelude",
          "signature": "a -\u003e b -\u003e Mul a b",
          "source": "src/Algebra-DimensionTerm.html#%25%2A%25",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "(%*%) %*%",
          "normalized": "a-\u003eb-\u003eMul a b",
          "package": "numeric-prelude",
          "signature": "a-\u003eb-\u003eMul a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:-37--42--37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "(%/%)",
          "package": "numeric-prelude",
          "signature": "a -\u003e b -\u003e Mul a (Recip b)",
          "source": "src/Algebra-DimensionTerm.html#%25%2F%25",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "(%/%) %/%",
          "normalized": "a-\u003eb-\u003eMul a(Recip b)",
          "package": "numeric-prelude",
          "signature": "a-\u003eb-\u003eMul a(Recip b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:-37--47--37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Angle",
          "package": "numeric-prelude",
          "signature": "Angle",
          "source": "src/Algebra-DimensionTerm.html#Angle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Angle",
          "package": "numeric-prelude",
          "partial": "Angle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Charge",
          "package": "numeric-prelude",
          "signature": "Charge",
          "source": "src/Algebra-DimensionTerm.html#Charge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Charge",
          "package": "numeric-prelude",
          "partial": "Charge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Charge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Information",
          "package": "numeric-prelude",
          "signature": "Information",
          "source": "src/Algebra-DimensionTerm.html#Information",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Information",
          "package": "numeric-prelude",
          "partial": "Information",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Information"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Length",
          "package": "numeric-prelude",
          "signature": "Length",
          "source": "src/Algebra-DimensionTerm.html#Length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Length",
          "package": "numeric-prelude",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Mass",
          "package": "numeric-prelude",
          "signature": "Mass",
          "source": "src/Algebra-DimensionTerm.html#Mass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Mass",
          "package": "numeric-prelude",
          "partial": "Mass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Mul",
          "package": "numeric-prelude",
          "signature": "Mul",
          "source": "src/Algebra-DimensionTerm.html#Mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Mul",
          "package": "numeric-prelude",
          "partial": "Mul",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Recip",
          "package": "numeric-prelude",
          "signature": "Recip",
          "source": "src/Algebra-DimensionTerm.html#Recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Recip",
          "package": "numeric-prelude",
          "partial": "Recip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Scalar",
          "package": "numeric-prelude",
          "signature": "Scalar",
          "source": "src/Algebra-DimensionTerm.html#Scalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Scalar",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Temperature",
          "package": "numeric-prelude",
          "signature": "Temperature",
          "source": "src/Algebra-DimensionTerm.html#Temperature",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Temperature",
          "package": "numeric-prelude",
          "partial": "Temperature",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Temperature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Time",
          "package": "numeric-prelude",
          "signature": "Time",
          "source": "src/Algebra-DimensionTerm.html#Time",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Time",
          "package": "numeric-prelude",
          "partial": "Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "Voltage",
          "package": "numeric-prelude",
          "signature": "Voltage",
          "source": "src/Algebra-DimensionTerm.html#Voltage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "Voltage",
          "package": "numeric-prelude",
          "partial": "Voltage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:Voltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "angle",
          "package": "numeric-prelude",
          "signature": "Angle",
          "source": "src/Algebra-DimensionTerm.html#angle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "angle",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Algebra-DimensionTerm.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "applyLeftMul",
          "package": "numeric-prelude",
          "signature": "(u0 -\u003e u1) -\u003e Mul u0 v -\u003e Mul u1 v",
          "source": "src/Algebra-DimensionTerm.html#applyLeftMul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "applyLeftMul",
          "normalized": "(a-\u003ea)-\u003eMul a b-\u003eMul a b",
          "package": "numeric-prelude",
          "partial": "Left Mul",
          "signature": "(u-\u003eu)-\u003eMul u v-\u003eMul u v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:applyLeftMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "applyRecip",
          "package": "numeric-prelude",
          "signature": "(u0 -\u003e u1) -\u003e Recip u0 -\u003e Recip u1",
          "source": "src/Algebra-DimensionTerm.html#applyRecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "applyRecip",
          "normalized": "(a-\u003ea)-\u003eRecip a-\u003eRecip a",
          "package": "numeric-prelude",
          "partial": "Recip",
          "signature": "(u-\u003eu)-\u003eRecip u-\u003eRecip u",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:applyRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "applyRightMul",
          "package": "numeric-prelude",
          "signature": "(u0 -\u003e u1) -\u003e Mul v u0 -\u003e Mul v u1",
          "source": "src/Algebra-DimensionTerm.html#applyRightMul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "applyRightMul",
          "normalized": "(a-\u003ea)-\u003eMul b a-\u003eMul b a",
          "package": "numeric-prelude",
          "partial": "Right Mul",
          "signature": "(u-\u003eu)-\u003eMul v u-\u003eMul v u",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:applyRightMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "associateLeft",
          "package": "numeric-prelude",
          "signature": "Mul u0 (Mul u1 u2) -\u003e Mul (Mul u0 u1) u2",
          "source": "src/Algebra-DimensionTerm.html#associateLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "associateLeft",
          "normalized": "Mul a(Mul a a)-\u003eMul(Mul a a)a",
          "package": "numeric-prelude",
          "partial": "Left",
          "signature": "Mul u(Mul u u)-\u003eMul(Mul u u)u",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:associateLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "associateRight",
          "package": "numeric-prelude",
          "signature": "Mul (Mul u0 u1) u2 -\u003e Mul u0 (Mul u1 u2)",
          "source": "src/Algebra-DimensionTerm.html#associateRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "associateRight",
          "normalized": "Mul(Mul a a)a-\u003eMul a(Mul a a)",
          "package": "numeric-prelude",
          "partial": "Right",
          "signature": "Mul(Mul u u)u-\u003eMul u(Mul u u)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:associateRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "cancelLeft",
          "package": "numeric-prelude",
          "signature": "Mul (Recip u) u -\u003e Scalar",
          "source": "src/Algebra-DimensionTerm.html#cancelLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "cancelLeft",
          "normalized": "Mul(Recip a)a-\u003eScalar",
          "package": "numeric-prelude",
          "partial": "Left",
          "signature": "Mul(Recip u)u-\u003eScalar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:cancelLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "cancelRight",
          "package": "numeric-prelude",
          "signature": "Mul u (Recip u) -\u003e Scalar",
          "source": "src/Algebra-DimensionTerm.html#cancelRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "cancelRight",
          "normalized": "Mul a(Recip a)-\u003eScalar",
          "package": "numeric-prelude",
          "partial": "Right",
          "signature": "Mul u(Recip u)-\u003eScalar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:cancelRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "charge",
          "package": "numeric-prelude",
          "signature": "Charge",
          "source": "src/Algebra-DimensionTerm.html#charge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "charge",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:charge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "commute",
          "package": "numeric-prelude",
          "signature": "Mul u0 u1 -\u003e Mul u1 u0",
          "source": "src/Algebra-DimensionTerm.html#commute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "commute",
          "normalized": "Mul a a-\u003eMul a a",
          "package": "numeric-prelude",
          "signature": "Mul u u-\u003eMul u u",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:commute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "doubleRecip",
          "package": "numeric-prelude",
          "signature": "u -\u003e Recip (Recip u)",
          "source": "src/Algebra-DimensionTerm.html#doubleRecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "doubleRecip",
          "normalized": "a-\u003eRecip(Recip a)",
          "package": "numeric-prelude",
          "partial": "Recip",
          "signature": "u-\u003eRecip(Recip u)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:doubleRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "frequency",
          "package": "numeric-prelude",
          "signature": "Frequency",
          "source": "src/Algebra-DimensionTerm.html#frequency",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "frequency",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:frequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "fromScalar",
          "package": "numeric-prelude",
          "signature": "Scalar -\u003e dim",
          "source": "src/Algebra-DimensionTerm.html#fromScalar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "fromScalar",
          "normalized": "Scalar-\u003ea",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "Scalar-\u003edim",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:fromScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "identityLeft",
          "package": "numeric-prelude",
          "signature": "Mul Scalar u -\u003e u",
          "source": "src/Algebra-DimensionTerm.html#identityLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "identityLeft",
          "normalized": "Mul Scalar a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Left",
          "signature": "Mul Scalar u-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:identityLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "identityRight",
          "package": "numeric-prelude",
          "signature": "Mul u Scalar -\u003e u",
          "source": "src/Algebra-DimensionTerm.html#identityRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "identityRight",
          "normalized": "Mul a Scalar-\u003ea",
          "package": "numeric-prelude",
          "partial": "Right",
          "signature": "Mul u Scalar-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:identityRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "information",
          "package": "numeric-prelude",
          "signature": "Information",
          "source": "src/Algebra-DimensionTerm.html#information",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "information",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:information"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "invertRecip",
          "package": "numeric-prelude",
          "signature": "Recip (Recip u) -\u003e u",
          "source": "src/Algebra-DimensionTerm.html#invertRecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "invertRecip",
          "normalized": "Recip(Recip a)-\u003ea",
          "package": "numeric-prelude",
          "partial": "Recip",
          "signature": "Recip(Recip u)-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:invertRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "length",
          "package": "numeric-prelude",
          "signature": "Length",
          "source": "src/Algebra-DimensionTerm.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "length",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "mass",
          "package": "numeric-prelude",
          "signature": "Mass",
          "source": "src/Algebra-DimensionTerm.html#mass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "mass",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "a -\u003e b -\u003e Mul a b",
          "source": "src/Algebra-DimensionTerm.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "mul",
          "normalized": "a-\u003eb-\u003eMul a b",
          "package": "numeric-prelude",
          "signature": "a-\u003eb-\u003eMul a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "mulRecip",
          "package": "numeric-prelude",
          "signature": "Mul (Recip u0) (Recip u1) -\u003e Recip (Mul u0 u1)",
          "source": "src/Algebra-DimensionTerm.html#mulRecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "mulRecip",
          "normalized": "Mul(Recip a)(Recip a)-\u003eRecip(Mul a a)",
          "package": "numeric-prelude",
          "partial": "Recip",
          "signature": "Mul(Recip u)(Recip u)-\u003eRecip(Mul u u)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:mulRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "noValue",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-DimensionTerm.html#noValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "noValue",
          "package": "numeric-prelude",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:noValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "packVoltage",
          "package": "numeric-prelude",
          "signature": "VoltageAnalytical -\u003e Voltage",
          "source": "src/Algebra-DimensionTerm.html#packVoltage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "packVoltage",
          "normalized": "VoltageAnalytical-\u003eVoltage",
          "package": "numeric-prelude",
          "partial": "Voltage",
          "signature": "VoltageAnalytical-\u003eVoltage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:packVoltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "a -\u003e Recip a",
          "source": "src/Algebra-DimensionTerm.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "recip",
          "normalized": "a-\u003eRecip a",
          "package": "numeric-prelude",
          "signature": "a-\u003eRecip a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "recipMul",
          "package": "numeric-prelude",
          "signature": "Recip (Mul u0 u1) -\u003e Mul (Recip u0) (Recip u1)",
          "source": "src/Algebra-DimensionTerm.html#recipMul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "recipMul",
          "normalized": "Recip(Mul a a)-\u003eMul(Recip a)(Recip a)",
          "package": "numeric-prelude",
          "partial": "Mul",
          "signature": "Recip(Mul u u)-\u003eMul(Recip u)(Recip u)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:recipMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "recipScalar",
          "package": "numeric-prelude",
          "signature": "Recip Scalar -\u003e Scalar",
          "source": "src/Algebra-DimensionTerm.html#recipScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "recipScalar",
          "normalized": "Recip Scalar-\u003eScalar",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "Recip Scalar-\u003eScalar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:recipScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "scalar",
          "package": "numeric-prelude",
          "signature": "Scalar",
          "source": "src/Algebra-DimensionTerm.html#scalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "scalar",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "temperature",
          "package": "numeric-prelude",
          "signature": "Temperature",
          "source": "src/Algebra-DimensionTerm.html#temperature",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "temperature",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:temperature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "time",
          "package": "numeric-prelude",
          "signature": "Time",
          "source": "src/Algebra-DimensionTerm.html#time",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "time",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "toScalar",
          "package": "numeric-prelude",
          "signature": "dim -\u003e Scalar",
          "source": "src/Algebra-DimensionTerm.html#toScalar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "toScalar",
          "normalized": "a-\u003eScalar",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "dim-\u003eScalar",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:toScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "unpackVoltage",
          "package": "numeric-prelude",
          "signature": "Voltage -\u003e VoltageAnalytical",
          "source": "src/Algebra-DimensionTerm.html#unpackVoltage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "unpackVoltage",
          "normalized": "Voltage-\u003eVoltageAnalytical",
          "package": "numeric-prelude",
          "partial": "Voltage",
          "signature": "Voltage-\u003eVoltageAnalytical",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:unpackVoltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DimensionTerm",
          "name": "voltage",
          "package": "numeric-prelude",
          "signature": "Voltage",
          "source": "src/Algebra-DimensionTerm.html#voltage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra DimensionTerm",
          "module": "Algebra.DimensionTerm",
          "name": "voltage",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DimensionTerm.html#v:voltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DivisibleSpace",
          "name": "DivisibleSpace",
          "package": "numeric-prelude",
          "source": "src/Algebra-DivisibleSpace.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra DivisibleSpace",
          "module": "Algebra.DivisibleSpace",
          "name": "DivisibleSpace",
          "package": "numeric-prelude",
          "partial": "Divisible Space",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DivisibleSpace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivisibleSpace is used for free one-dimensional vector spaces.  It\nsatisfies\n\u003c/p\u003e\u003cpre\u003e  (a \u003c/\u003e b) *\u003e b = a\n\u003c/pre\u003e\u003cp\u003eExamples include dollars and kilometers.\n\u003c/p\u003e",
          "module": "Algebra.DivisibleSpace",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-DivisibleSpace.html#C",
          "type": "class"
        },
        "index": {
          "description": "DivisibleSpace is used for free one-dimensional vector spaces It satisfies Examples include dollars and kilometers",
          "hierarchy": "Algebra DivisibleSpace",
          "module": "Algebra.DivisibleSpace",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DivisibleSpace.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.DivisibleSpace",
          "name": "(\u003c/\u003e)",
          "package": "numeric-prelude",
          "signature": "b -\u003e b -\u003e a",
          "source": "src/Algebra-DivisibleSpace.html#%3C%2F%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra DivisibleSpace",
          "module": "Algebra.DivisibleSpace",
          "name": "(\u003c/\u003e) \u003c/\u003e",
          "normalized": "a-\u003ea-\u003eb",
          "package": "numeric-prelude",
          "signature": "b-\u003eb-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-DivisibleSpace.html#v:-60--47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Field",
          "name": "Field",
          "package": "numeric-prelude",
          "source": "src/Algebra-Field.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "Field",
          "package": "numeric-prelude",
          "partial": "Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField again corresponds to a commutative ring.\nDivision is partially defined and satisfies\n\u003c/p\u003e\u003cpre\u003e    not (isZero b)  ==\u003e  (a * b) / b === a\n    not (isZero a)  ==\u003e  a * recip a === one\n\u003c/pre\u003e\u003cp\u003ewhen it is defined. \nTo safely call division,\nthe program must take type-specific action;\ne.g., the following is appropriate in many cases:\n\u003c/p\u003e\u003cpre\u003e safeRecip :: (Integral a, Eq a, Field.C a) =\u003e a -\u003e Maybe a\n safeRecip x =\n     let (q,r) = one `divMod` x\n     in  toMaybe (isZero r) q\n\u003c/pre\u003e\u003cp\u003eTypical examples include rationals, the real numbers,\nand rational functions (ratios of polynomial functions).\nAn instance should be typically declared\nonly if most elements are invertible.\n\u003c/p\u003e\u003cp\u003eActually, we have also used this type class for non-fields\ncontaining lots of units,\ne.g. residue classes with respect to non-primes and power series.\nSo the restriction \u003ccode\u003enot (isZero a)\u003c/code\u003e must be better \u003ccode\u003eisUnit a\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal definition: \u003ccode\u003e\u003ca\u003erecip\u003c/a\u003e\u003c/code\u003e or (\u003ccode\u003e\u003ca\u003e/\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Algebra.Field",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Field.html#C",
          "type": "class"
        },
        "index": {
          "description": "Field again corresponds to commutative ring Division is partially defined and satisfies not isZero not isZero recip one when it is defined To safely call division the program must take type-specific action e.g the following is appropriate in many cases safeRecip Integral Eq Field.C Maybe safeRecip let one divMod in toMaybe isZero Typical examples include rationals the real numbers and rational functions ratios of polynomial functions An instance should be typically declared only if most elements are invertible Actually we have also used this type class for non-fields containing lots of units e.g residue classes with respect to non-primes and power series So the restriction not isZero must be better isUnit Minimal definition recip or",
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Field",
          "name": "(/)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Field.html#%2F",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "(/) /",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:-47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Field",
          "name": "(^-)",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer -\u003e a",
          "source": "src/Algebra-Field.html#%5E-",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "(^-) ^-",
          "normalized": "a-\u003eInteger-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003eInteger-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:-94--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNeeded to work around shortcomings in GHC.\n\u003c/p\u003e",
          "module": "[\"Algebra.Field\",\"NumericPrelude.Numeric\"]",
          "name": "fromRational",
          "package": "numeric-prelude",
          "signature": "Rational -\u003e a",
          "source": "src/Algebra-Field.html#fromRational",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:fromRational\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:fromRational\"]"
        },
        "index": {
          "description": "Needed to work around shortcomings in GHC",
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "fromRational",
          "normalized": "Rational-\u003ea",
          "package": "numeric-prelude",
          "partial": "Rational",
          "signature": "Rational-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:fromRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Field",
          "name": "fromRational'",
          "package": "numeric-prelude",
          "signature": "Rational -\u003e a",
          "source": "src/Algebra-Field.html#fromRational%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "fromRational'",
          "normalized": "Rational-\u003ea",
          "package": "numeric-prelude",
          "partial": "Rational'",
          "signature": "Rational-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:fromRational-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe restriction on the divisor should be \u003ccode\u003eisUnit a\u003c/code\u003e instead of \u003ccode\u003enot (isZero a)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Field",
          "name": "propDivision",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Property",
          "source": "src/Algebra-Field.html#propDivision",
          "type": "function"
        },
        "index": {
          "description": "the restriction on the divisor should be isUnit instead of not isZero",
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "propDivision",
          "normalized": "a-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Division",
          "signature": "a-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:propDivision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Field",
          "name": "propReciprocal",
          "package": "numeric-prelude",
          "signature": "a -\u003e Property",
          "source": "src/Algebra-Field.html#propReciprocal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "propReciprocal",
          "normalized": "a-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Reciprocal",
          "signature": "a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:propReciprocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Field",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Field.html#recip",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Field",
          "module": "Algebra.Field",
          "name": "recip",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Field.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "FloatingPoint",
          "package": "numeric-prelude",
          "source": "src/Algebra-FloatingPoint.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "FloatingPoint",
          "package": "numeric-prelude",
          "partial": "Floating Point",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCounterpart of \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e but with NumericPrelude superclass.\n\u003c/p\u003e",
          "module": "Algebra.FloatingPoint",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-FloatingPoint.html#C",
          "type": "class"
        },
        "index": {
          "description": "Counterpart of RealFloat but with NumericPrelude superclass",
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "decode",
          "package": "numeric-prelude",
          "signature": "a -\u003e (Integer, Int)",
          "source": "src/Algebra-FloatingPoint.html#decode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "decode",
          "normalized": "a-\u003e(Integer,Int)",
          "package": "numeric-prelude",
          "signature": "a-\u003e(Integer,Int)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "digits",
          "package": "numeric-prelude",
          "signature": "a -\u003e Int",
          "source": "src/Algebra-FloatingPoint.html#digits",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "digits",
          "normalized": "a-\u003eInt",
          "package": "numeric-prelude",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:digits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "encode",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Int -\u003e a",
          "source": "src/Algebra-FloatingPoint.html#encode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "encode",
          "normalized": "Integer-\u003eInt-\u003ea",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInt-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "exponent",
          "package": "numeric-prelude",
          "signature": "a -\u003e Int",
          "source": "src/Algebra-FloatingPoint.html#exponent",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "exponent",
          "normalized": "a-\u003eInt",
          "package": "numeric-prelude",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:exponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "isDenormalized",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-FloatingPoint.html#isDenormalized",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "isDenormalized",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Denormalized",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:isDenormalized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "isIEEE",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-FloatingPoint.html#isIEEE",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "isIEEE",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "IEEE",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:isIEEE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "isInfinite",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-FloatingPoint.html#isInfinite",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "isInfinite",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Infinite",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:isInfinite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "isNaN",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-FloatingPoint.html#isNaN",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "isNaN",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Na",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:isNaN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "isNegativeZero",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-FloatingPoint.html#isNegativeZero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "isNegativeZero",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Negative Zero",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:isNegativeZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "radix",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer",
          "source": "src/Algebra-FloatingPoint.html#radix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "radix",
          "normalized": "a-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:radix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "range",
          "package": "numeric-prelude",
          "signature": "a -\u003e (Int, Int)",
          "source": "src/Algebra-FloatingPoint.html#range",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "range",
          "normalized": "a-\u003e(Int,Int)",
          "package": "numeric-prelude",
          "signature": "a-\u003e(Int,Int)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "Int -\u003e a -\u003e a",
          "source": "src/Algebra-FloatingPoint.html#scale",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "scale",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "Int-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.FloatingPoint",
          "name": "significand",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-FloatingPoint.html#significand",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra FloatingPoint",
          "module": "Algebra.FloatingPoint",
          "name": "significand",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-FloatingPoint.html#v:significand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn alternative type class for Ord\nwhich allows an ordering for dictionaries like \u003ca\u003eData.Map\u003c/a\u003e and \u003ca\u003eData.Set\u003c/a\u003e\nindependently from the ordering with respect to a magnitude.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Indexable",
          "name": "Indexable",
          "package": "numeric-prelude",
          "source": "src/Algebra-Indexable.html",
          "type": "module"
        },
        "index": {
          "description": "An alternative type class for Ord which allows an ordering for dictionaries like Data.Map and Data.Set independently from the ordering with respect to magnitude",
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "Indexable",
          "package": "numeric-prelude",
          "partial": "Indexable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefinition of an alternative ordering of objects\nindependent from a notion of magnitude.\nFor an application see \u003ca\u003eMathObj.PartialFraction\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Algebra.Indexable",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Indexable.html#C",
          "type": "class"
        },
        "index": {
          "description": "Definition of an alternative ordering of objects independent from notion of magnitude For an application see MathObj.PartialFraction",
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap an indexable object such that it can be used in \u003ca\u003eData.Map\u003c/a\u003e and \u003ca\u003eData.Set\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Algebra.Indexable",
          "name": "ToOrd",
          "package": "numeric-prelude",
          "source": "src/Algebra-Indexable.html#ToOrd",
          "type": "data"
        },
        "index": {
          "description": "Wrap an indexable object such that it can be used in Data.Map and Data.Set",
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "ToOrd",
          "package": "numeric-prelude",
          "partial": "To Ord",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#t:ToOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Indexable",
          "name": "compare",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Ordering",
          "source": "src/Algebra-Indexable.html#compare",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "compare",
          "normalized": "a-\u003ea-\u003eOrdering",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#v:compare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Indexable",
          "name": "fromOrd",
          "package": "numeric-prelude",
          "signature": "ToOrd a -\u003e a",
          "source": "src/Algebra-Indexable.html#fromOrd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "fromOrd",
          "normalized": "ToOrd a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Ord",
          "signature": "ToOrd a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#v:fromOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e implementation from a wrapped object.\n\u003c/p\u003e",
          "module": "Algebra.Indexable",
          "name": "liftCompare",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b) -\u003e a -\u003e a -\u003e Ordering",
          "source": "src/Algebra-Indexable.html#liftCompare",
          "type": "function"
        },
        "index": {
          "description": "Lift compare implementation from wrapped object",
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "liftCompare",
          "normalized": "(a-\u003eb)-\u003ea-\u003ea-\u003eOrdering",
          "package": "numeric-prelude",
          "partial": "Compare",
          "signature": "(a-\u003eb)-\u003ea-\u003ea-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#v:liftCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the type has already an \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instance\nit is certainly the most easiest to define \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e\nto be equal to \u003ccode\u003eOrd\u003c/code\u003e's \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Algebra.Indexable",
          "name": "ordCompare",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Ordering",
          "source": "src/Algebra-Indexable.html#ordCompare",
          "type": "function"
        },
        "index": {
          "description": "If the type has already an Ord instance it is certainly the most easiest to define compare to be equal to Ord compare",
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "ordCompare",
          "normalized": "a-\u003ea-\u003eOrdering",
          "package": "numeric-prelude",
          "partial": "Compare",
          "signature": "a-\u003ea-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#v:ordCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Indexable",
          "name": "toOrd",
          "package": "numeric-prelude",
          "signature": "a -\u003e ToOrd a",
          "source": "src/Algebra-Indexable.html#toOrd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Indexable",
          "module": "Algebra.Indexable",
          "name": "toOrd",
          "normalized": "a-\u003eToOrd a",
          "package": "numeric-prelude",
          "partial": "Ord",
          "signature": "a-\u003eToOrd a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Indexable.html#v:toOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "IntegralDomain",
          "package": "numeric-prelude",
          "source": "src/Algebra-IntegralDomain.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "IntegralDomain",
          "package": "numeric-prelude",
          "partial": "Integral Domain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eIntegralDomain\u003c/code\u003e corresponds to a commutative ring,\nwhere \u003ccode\u003ea \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e picks a canonical element\nof the equivalence class of \u003ccode\u003ea\u003c/code\u003e in the ideal generated by \u003ccode\u003eb\u003c/code\u003e.\n\u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e satisfy the laws\n\u003c/p\u003e\u003cpre\u003e                         a * b === b * a\n (a `div` b) * b + (a `mod` b) === a\n               (a+k*b) `mod` b === a `mod` b\n                     0 `mod` b === 0\n\u003c/pre\u003e\u003cp\u003eTypical examples of \u003ccode\u003eIntegralDomain\u003c/code\u003e include integers and\npolynomials over a field.\nNote that for a field, there is a canonical instance\ndefined by the above rules; e.g.,\n\u003c/p\u003e\u003cpre\u003e instance IntegralDomain.C Rational where\n     divMod a b =\n        if isZero b\n          then (undefined,a)\n          else (a\\/b,0)\n\u003c/pre\u003e\u003cp\u003eIt shall be noted, that \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edivMod\u003c/a\u003e\u003c/code\u003e have a parameter order\nwhich is unfortunate for partial application.\nBut it is adapted to mathematical conventions,\nwhere the operators are used in infix notation.\n\u003c/p\u003e\u003cp\u003eMinimal definition: \u003ccode\u003e\u003ca\u003edivMod\u003c/a\u003e\u003c/code\u003e or (\u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-IntegralDomain.html#C",
          "type": "class"
        },
        "index": {
          "description": "IntegralDomain corresponds to commutative ring where mod picks canonical element of the equivalence class of in the ideal generated by div and mod satisfy the laws div mod mod mod mod Typical examples of IntegralDomain include integers and polynomials over field Note that for field there is canonical instance defined by the above rules e.g instance IntegralDomain.C Rational where divMod if isZero then undefined else It shall be noted that div mod divMod have parameter order which is unfortunate for partial application But it is adapted to mathematical conventions where the operators are used in infix notation Minimal definition divMod or div and mod",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edecomposeVarPositional [b0,b1,b2,...] x\u003c/code\u003e\ndecomposes \u003ccode\u003ex\u003c/code\u003e into a positional representation with mixed bases\n\u003ccode\u003ex0 + b0*(x1 + b1*(x2 + b2*x3))\u003c/code\u003e\nE.g. \u003ccode\u003edecomposeVarPositional (repeat 10) 123 == [3,2,1]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "decomposeVarPositional",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a -\u003e [a]",
          "source": "src/Algebra-IntegralDomain.html#decomposeVarPositional",
          "type": "function"
        },
        "index": {
          "description": "decomposeVarPositional b0 b1 b2 decomposes into positional representation with mixed bases x0 b0 x1 b1 x2 b2 x3 E.g decomposeVarPositional repeat",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "decomposeVarPositional",
          "normalized": "[a]-\u003ea-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Var Positional",
          "signature": "[a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:decomposeVarPositional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "decomposeVarPositionalInf",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a -\u003e [a]",
          "source": "src/Algebra-IntegralDomain.html#decomposeVarPositionalInf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "decomposeVarPositionalInf",
          "normalized": "[a]-\u003ea-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Var Positional Inf",
          "signature": "[a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:decomposeVarPositionalInf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "div",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#div",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "div",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the result of the division, if divisible.\nOtherwise undefined.\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "divChecked",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#divChecked",
          "type": "function"
        },
        "index": {
          "description": "Returns the result of the division if divisible Otherwise undefined",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "divChecked",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Checked",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:divChecked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "divMod",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Algebra-IntegralDomain.html#divMod",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "divMod",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Mod",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:divMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllows division by zero.\nIf the divisor is zero, then the dividend is returned as remainder.\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "divModZero",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Algebra-IntegralDomain.html#divModZero",
          "type": "function"
        },
        "index": {
          "description": "Allows division by zero If the divisor is zero then the dividend is returned as remainder",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "divModZero",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Mod Zero",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:divModZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edivUp n m\u003c/code\u003e is similar to \u003ccode\u003ediv\u003c/code\u003e\nbut it rounds up the quotient,\nsuch that \u003ccode\u003edivUp n m * m = roundUp n m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "divUp",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#divUp",
          "type": "function"
        },
        "index": {
          "description": "divUp is similar to div but it rounds up the quotient such that divUp roundUp",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "divUp",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Up",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:divUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.IntegralDomain\",\"NumericPrelude.Numeric\"]",
          "name": "divides",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-IntegralDomain.html#divides",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:divides\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:divides\"]"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "divides",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:divides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.IntegralDomain\",\"NumericPrelude.Numeric\"]",
          "name": "even",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-IntegralDomain.html#even",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:even\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:even\"]"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "even",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:even"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.IntegralDomain\",\"NumericPrelude.Numeric\"]",
          "name": "odd",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-IntegralDomain.html#odd",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:odd\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:odd\"]"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "odd",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:odd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propInverse",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propInverse",
          "normalized": "a-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Inverse",
          "signature": "a-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propMultipleDiv",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propMultipleDiv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propMultipleDiv",
          "normalized": "a-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Multiple Div",
          "signature": "a-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propMultipleDiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propMultipleMod",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propMultipleMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propMultipleMod",
          "normalized": "a-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Multiple Mod",
          "signature": "a-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propMultipleMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propProjectAddition",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propProjectAddition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propProjectAddition",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Project Addition",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propProjectAddition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propProjectMultiplication",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propProjectMultiplication",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propProjectMultiplication",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Project Multiplication",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propProjectMultiplication"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propSameResidueClass",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propSameResidueClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propSameResidueClass",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Same Residue Class",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propSameResidueClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propUniqueRepresentative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propUniqueRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propUniqueRepresentative",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Unique Representative",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propUniqueRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "propZeroRepresentative",
          "package": "numeric-prelude",
          "signature": "a -\u003e Property",
          "source": "src/Algebra-IntegralDomain.html#propZeroRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "propZeroRepresentative",
          "normalized": "a-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Zero Representative",
          "signature": "a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:propZeroRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eroundDown n m\u003c/code\u003e rounds \u003ccode\u003en\u003c/code\u003e down to the next multiple of \u003ccode\u003em\u003c/code\u003e.\nThat is, \u003ccode\u003eroundDown n m\u003c/code\u003e is the greatest multiple of \u003ccode\u003em\u003c/code\u003e\nthat is at most \u003ccode\u003en\u003c/code\u003e.\nThe parameter order is consistent with \u003ccode\u003ediv\u003c/code\u003e and friends,\nbut maybe not useful for partial application.\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "roundDown",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#roundDown",
          "type": "function"
        },
        "index": {
          "description": "roundDown rounds down to the next multiple of That is roundDown is the greatest multiple of that is at most The parameter order is consistent with div and friends but maybe not useful for partial application",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "roundDown",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Down",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:roundDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eroundUp n m\u003c/code\u003e rounds \u003ccode\u003en\u003c/code\u003e up to the next multiple of \u003ccode\u003em\u003c/code\u003e.\nThat is, \u003ccode\u003eroundUp n m\u003c/code\u003e is the greatest multiple of \u003ccode\u003em\u003c/code\u003e\nthat is at most \u003ccode\u003en\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "roundUp",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#roundUp",
          "type": "function"
        },
        "index": {
          "description": "roundUp rounds up to the next multiple of That is roundUp is the greatest multiple of that is at most",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "roundUp",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Up",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:roundUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use divChecked instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eReturns the result of the division, if divisible.\nOtherwise undefined.\n\u003c/p\u003e",
          "module": "Algebra.IntegralDomain",
          "name": "safeDiv",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#safeDiv",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use divChecked instead Returns the result of the division if divisible Otherwise undefined",
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "safeDiv",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Div",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:safeDiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.IntegralDomain",
          "name": "sameResidueClass",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-IntegralDomain.html#sameResidueClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra IntegralDomain",
          "module": "Algebra.IntegralDomain",
          "name": "sameResidueClass",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Residue Class",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-IntegralDomain.html#v:sameResidueClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "Lattice",
          "package": "numeric-prelude",
          "source": "src/Algebra-Lattice.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "Lattice",
          "package": "numeric-prelude",
          "partial": "Lattice",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Lattice.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.Lattice\",\"NumericPrelude\"]",
          "name": "abs",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Lattice.html#abs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:abs\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude.html#v:abs\"]"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "abs",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.Lattice\",\"NumericPrelude\"]",
          "name": "max",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice.html#max",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:max\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude.html#v:max\"]"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "max",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.Lattice\",\"NumericPrelude\"]",
          "name": "min",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice.html#min",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:min\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude.html#v:min\"]"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "min",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "propDnAssociative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#propDnAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "propDnAssociative",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Dn Associative",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:propDnAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "propDnCommutative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#propDnCommutative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "propDnCommutative",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Dn Commutative",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:propDnCommutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "propDnUpDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#propDnUpDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "propDnUpDistributive",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Dn Up Distributive",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:propDnUpDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "propUpAssociative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#propUpAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "propUpAssociative",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Up Associative",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:propUpAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "propUpCommutative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#propUpCommutative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "propUpCommutative",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Up Commutative",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:propUpCommutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "propUpDnDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#propUpDnDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "propUpDnDistributive",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Up Dn Distributive",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:propUpDnDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "up",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice.html#up",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "up",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Lattice.html#v:up"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDefine common properties that can be used e.g. for automated tests.\nCf. to \u003ca\u003eTest.QuickCheck.Utils\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Laws",
          "name": "Laws",
          "package": "numeric-prelude",
          "source": "src/Algebra-Laws.html",
          "type": "module"
        },
        "index": {
          "description": "Define common properties that can be used e.g for automated tests Cf to Test.QuickCheck.Utils",
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "Laws",
          "package": "numeric-prelude",
          "partial": "Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "associative",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#associative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "associative",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:associative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "commutative",
          "package": "numeric-prelude",
          "signature": "(b -\u003e b -\u003e a) -\u003e b -\u003e b -\u003e Bool",
          "source": "src/Algebra-Laws.html#commutative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "commutative",
          "normalized": "(a-\u003ea-\u003eb)-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "(b-\u003eb-\u003ea)-\u003eb-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:commutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "homomorphism",
          "package": "numeric-prelude",
          "signature": "(b -\u003e a) -\u003e (b -\u003e b -\u003e b) -\u003e (a -\u003e a -\u003e a) -\u003e b -\u003e b -\u003e Bool",
          "source": "src/Algebra-Laws.html#homomorphism",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "homomorphism",
          "normalized": "(a-\u003eb)-\u003e(a-\u003ea-\u003ea)-\u003e(b-\u003eb-\u003eb)-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "(b-\u003ea)-\u003e(b-\u003eb-\u003eb)-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:homomorphism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "identity",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#identity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "identity",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "inverse",
          "package": "numeric-prelude",
          "signature": "(b -\u003e b -\u003e a) -\u003e (b -\u003e b) -\u003e a -\u003e b -\u003e Bool",
          "source": "src/Algebra-Laws.html#inverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "inverse",
          "normalized": "(a-\u003ea-\u003eb)-\u003e(a-\u003ea)-\u003eb-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "(b-\u003eb-\u003ea)-\u003e(b-\u003eb)-\u003ea-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "leftCascade",
          "package": "numeric-prelude",
          "signature": "(b -\u003e b -\u003e b) -\u003e (b -\u003e a -\u003e a) -\u003e a -\u003e b -\u003e b -\u003e Bool",
          "source": "src/Algebra-Laws.html#leftCascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "leftCascade",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(a-\u003eb-\u003eb)-\u003eb-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cascade",
          "signature": "(b-\u003eb-\u003eb)-\u003e(b-\u003ea-\u003ea)-\u003ea-\u003eb-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:leftCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "leftDistributive",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e a) -\u003e (a -\u003e a -\u003e a) -\u003e b -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#leftDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "leftDistributive",
          "normalized": "(a-\u003eb-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Distributive",
          "signature": "(a-\u003eb-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:leftDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "leftIdentity",
          "package": "numeric-prelude",
          "signature": "(b -\u003e a -\u003e a) -\u003e b -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#leftIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "leftIdentity",
          "normalized": "(a-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Identity",
          "signature": "(b-\u003ea-\u003ea)-\u003eb-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:leftIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "leftInverse",
          "package": "numeric-prelude",
          "signature": "(b -\u003e b -\u003e a) -\u003e (b -\u003e b) -\u003e a -\u003e b -\u003e Bool",
          "source": "src/Algebra-Laws.html#leftInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "leftInverse",
          "normalized": "(a-\u003ea-\u003eb)-\u003e(a-\u003ea)-\u003eb-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Inverse",
          "signature": "(b-\u003eb-\u003ea)-\u003e(b-\u003eb)-\u003ea-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:leftInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "leftZero",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#leftZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "leftZero",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Zero",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:leftZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "rightCascade",
          "package": "numeric-prelude",
          "signature": "(b -\u003e b -\u003e b) -\u003e (a -\u003e b -\u003e a) -\u003e a -\u003e b -\u003e b -\u003e Bool",
          "source": "src/Algebra-Laws.html#rightCascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "rightCascade",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(b-\u003ea-\u003eb)-\u003eb-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cascade",
          "signature": "(b-\u003eb-\u003eb)-\u003e(a-\u003eb-\u003ea)-\u003ea-\u003eb-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:rightCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "rightDistributive",
          "package": "numeric-prelude",
          "signature": "(b -\u003e a -\u003e a) -\u003e (a -\u003e a -\u003e a) -\u003e b -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#rightDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "rightDistributive",
          "normalized": "(a-\u003eb-\u003eb)-\u003e(b-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eb-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Distributive",
          "signature": "(b-\u003ea-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:rightDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "rightIdentity",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e a) -\u003e b -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#rightIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "rightIdentity",
          "normalized": "(a-\u003eb-\u003ea)-\u003eb-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Identity",
          "signature": "(a-\u003eb-\u003ea)-\u003eb-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:rightIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "rightInverse",
          "package": "numeric-prelude",
          "signature": "(b -\u003e b -\u003e a) -\u003e (b -\u003e b) -\u003e a -\u003e b -\u003e Bool",
          "source": "src/Algebra-Laws.html#rightInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "rightInverse",
          "normalized": "(a-\u003ea-\u003eb)-\u003e(a-\u003ea)-\u003eb-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Inverse",
          "signature": "(b-\u003eb-\u003ea)-\u003e(b-\u003eb)-\u003ea-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:rightInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "rightZero",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#rightZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "rightZero",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Zero",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:rightZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Laws",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Laws.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Laws",
          "module": "Algebra.Laws",
          "name": "zero",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Laws.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstraction of modules\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Module",
          "name": "Module",
          "package": "numeric-prelude",
          "source": "src/Algebra-Module.html",
          "type": "module"
        },
        "index": {
          "description": "Abstraction of modules",
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "Module",
          "package": "numeric-prelude",
          "partial": "Module",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Module over a ring satisfies:\n\u003c/p\u003e\u003cpre\u003e   a *\u003e (b + c) === a *\u003e b + a *\u003e c\n   (a * b) *\u003e c === a *\u003e (b *\u003e c)\n   (a + b) *\u003e c === a *\u003e c + b *\u003e c\n\u003c/pre\u003e",
          "module": "Algebra.Module",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Module.html#C",
          "type": "class"
        },
        "index": {
          "description": "Module over ring satisfies",
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escale a vector by a scalar\n\u003c/p\u003e",
          "module": "Algebra.Module",
          "name": "(*\u003e)",
          "package": "numeric-prelude",
          "signature": "a -\u003e v -\u003e v",
          "source": "src/Algebra-Module.html#%2A%3E",
          "type": "method"
        },
        "index": {
          "description": "scale vector by scalar",
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "(*\u003e) *\u003e",
          "normalized": "a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Module",
          "name": "(\u003c*\u003e.*\u003e)",
          "package": "numeric-prelude",
          "signature": "T (a, v) (x -\u003e c) -\u003e (v -\u003e x) -\u003e T (a, v) c",
          "source": "src/Algebra-Module.html#%3C%2A%3E.%2A%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "(\u003c*\u003e.*\u003e) \u003c*\u003e.*\u003e",
          "normalized": "T(a,b)(c-\u003ed)-\u003e(b-\u003ec)-\u003eT(a,b)d",
          "package": "numeric-prelude",
          "signature": "T(a,v)(x-\u003ec)-\u003e(v-\u003ex)-\u003eT(a,v)c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#v:-60--42--62-.-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function can be used to define any\n\u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e as a module over \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBetter move to \u003ca\u003eAlgebra.Additive\u003c/a\u003e?\n\u003c/p\u003e",
          "module": "Algebra.Module",
          "name": "integerMultiply",
          "package": "numeric-prelude",
          "signature": "a -\u003e v -\u003e v",
          "source": "src/Algebra-Module.html#integerMultiply",
          "type": "function"
        },
        "index": {
          "description": "This function can be used to define any as module over Integer Better move to Algebra.Additive",
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "integerMultiply",
          "normalized": "a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "partial": "Multiply",
          "signature": "a-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#v:integerMultiply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the linear combination of a list of vectors.\n\u003c/p\u003e\u003cp\u003eToDo:\nShould it use \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e ?\n\u003c/p\u003e",
          "module": "Algebra.Module",
          "name": "linearComb",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [v] -\u003e v",
          "source": "src/Algebra-Module.html#linearComb",
          "type": "function"
        },
        "index": {
          "description": "Compute the linear combination of list of vectors ToDo Should it use zipWith",
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "linearComb",
          "normalized": "[a]-\u003e[b]-\u003eb",
          "package": "numeric-prelude",
          "partial": "Comb",
          "signature": "[a]-\u003e[v]-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#v:linearComb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Module",
          "name": "propCascade",
          "package": "numeric-prelude",
          "signature": "v -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Module.html#propCascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "propCascade",
          "normalized": "a-\u003eb-\u003eb-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cascade",
          "signature": "v-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#v:propCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Module",
          "name": "propLeftDistributive",
          "package": "numeric-prelude",
          "signature": "v -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Module.html#propLeftDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "propLeftDistributive",
          "normalized": "a-\u003eb-\u003eb-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Left Distributive",
          "signature": "v-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#v:propLeftDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Module",
          "name": "propRightDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e v -\u003e v -\u003e Bool",
          "source": "src/Algebra-Module.html#propRightDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Module",
          "module": "Algebra.Module",
          "name": "propRightDistributive",
          "normalized": "a-\u003eb-\u003eb-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Right Distributive",
          "signature": "a-\u003ev-\u003ev-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Module.html#v:propRightDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstraction of bases of finite dimensional modules\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.ModuleBasis",
          "name": "ModuleBasis",
          "package": "numeric-prelude",
          "source": "src/Algebra-ModuleBasis.html",
          "type": "module"
        },
        "index": {
          "description": "Abstraction of bases of finite dimensional modules",
          "hierarchy": "Algebra ModuleBasis",
          "module": "Algebra.ModuleBasis",
          "name": "ModuleBasis",
          "package": "numeric-prelude",
          "partial": "Module Basis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ModuleBasis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt must hold:\n\u003c/p\u003e\u003cpre\u003e   Module.linearComb (flatten v `asTypeOf` [a]) (basis a) == v\n   dimension a v == length (flatten v `asTypeOf` [a])\n\u003c/pre\u003e",
          "module": "Algebra.ModuleBasis",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-ModuleBasis.html#C",
          "type": "class"
        },
        "index": {
          "description": "It must hold Module.linearComb flatten asTypeOf basis dimension length flatten asTypeOf",
          "hierarchy": "Algebra ModuleBasis",
          "module": "Algebra.ModuleBasis",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ModuleBasis.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebasis of the module with respect to the scalar type,\n         the result must be independent of argument, \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e should suffice. \n\u003c/p\u003e",
          "module": "Algebra.ModuleBasis",
          "name": "basis",
          "package": "numeric-prelude",
          "signature": "a -\u003e [v]",
          "source": "src/Algebra-ModuleBasis.html#basis",
          "type": "method"
        },
        "index": {
          "description": "basis of the module with respect to the scalar type the result must be independent of argument undefined should suffice",
          "hierarchy": "Algebra ModuleBasis",
          "module": "Algebra.ModuleBasis",
          "name": "basis",
          "normalized": "a-\u003e[b]",
          "package": "numeric-prelude",
          "signature": "a-\u003e[v]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ModuleBasis.html#v:basis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe size of the basis, should also work for undefined argument,\n         the result must be independent of argument, \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e should suffice. \n\u003c/p\u003e",
          "module": "Algebra.ModuleBasis",
          "name": "dimension",
          "package": "numeric-prelude",
          "signature": "a -\u003e v -\u003e Int",
          "source": "src/Algebra-ModuleBasis.html#dimension",
          "type": "method"
        },
        "index": {
          "description": "the size of the basis should also work for undefined argument the result must be independent of argument undefined should suffice",
          "hierarchy": "Algebra ModuleBasis",
          "module": "Algebra.ModuleBasis",
          "name": "dimension",
          "normalized": "a-\u003eb-\u003eInt",
          "package": "numeric-prelude",
          "signature": "a-\u003ev-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ModuleBasis.html#v:dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escale a vector by a scalar\n\u003c/p\u003e",
          "module": "Algebra.ModuleBasis",
          "name": "flatten",
          "package": "numeric-prelude",
          "signature": "v -\u003e [a]",
          "source": "src/Algebra-ModuleBasis.html#flatten",
          "type": "method"
        },
        "index": {
          "description": "scale vector by scalar",
          "hierarchy": "Algebra ModuleBasis",
          "module": "Algebra.ModuleBasis",
          "name": "flatten",
          "normalized": "a-\u003e[b]",
          "package": "numeric-prelude",
          "signature": "v-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ModuleBasis.html#v:flatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ModuleBasis",
          "name": "propDimension",
          "package": "numeric-prelude",
          "signature": "a -\u003e v -\u003e Bool",
          "source": "src/Algebra-ModuleBasis.html#propDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra ModuleBasis",
          "module": "Algebra.ModuleBasis",
          "name": "propDimension",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Dimension",
          "signature": "a-\u003ev-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ModuleBasis.html#v:propDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ModuleBasis",
          "name": "propFlatten",
          "package": "numeric-prelude",
          "signature": "a -\u003e v -\u003e Bool",
          "source": "src/Algebra-ModuleBasis.html#propFlatten",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra ModuleBasis",
          "module": "Algebra.ModuleBasis",
          "name": "propFlatten",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Flatten",
          "signature": "a-\u003ev-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ModuleBasis.html#v:propFlatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWill be used in order to generate type classes for generic algebras.\nAn algebra is a vector space that also is a monoid.\nShould we use the Monoid class from base library\ndespite its unfortunate method name \u003ccode\u003emappend\u003c/code\u003e?\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Monoid",
          "name": "Monoid",
          "package": "numeric-prelude",
          "source": "src/Algebra-Monoid.html",
          "type": "module"
        },
        "index": {
          "description": "Will be used in order to generate type classes for generic algebras An algebra is vector space that also is monoid Should we use the Monoid class from base library despite its unfortunate method name mappend",
          "hierarchy": "Algebra Monoid",
          "module": "Algebra.Monoid",
          "name": "Monoid",
          "package": "numeric-prelude",
          "partial": "Monoid",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Monoid.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe expect a monoid to adher to associativity and\nthe identity behaving decently.\nNothing more, really.\n\u003c/p\u003e",
          "module": "Algebra.Monoid",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Monoid.html#C",
          "type": "class"
        },
        "index": {
          "description": "We expect monoid to adher to associativity and the identity behaving decently Nothing more really",
          "hierarchy": "Algebra Monoid",
          "module": "Algebra.Monoid",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Monoid.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Monoid",
          "name": "(\u003c*\u003e)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Monoid.html#%3C%2A%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Monoid",
          "module": "Algebra.Monoid",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Monoid.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Monoid",
          "name": "cumulate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Monoid.html#cumulate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Monoid",
          "module": "Algebra.Monoid",
          "name": "cumulate",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Monoid.html#v:cumulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Monoid",
          "name": "idt",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-Monoid.html#idt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Monoid",
          "module": "Algebra.Monoid",
          "name": "idt",
          "package": "numeric-prelude",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Monoid.html#v:idt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA type class for non-negative numbers.\nProminent instances are \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e numbers.\nThis class cannot do any checks,\nbut it let you show to the user what arguments your function expects.\nThus you must define class instances with care.\nIn fact many standard functions (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e, '(!!)', ...)\nshould have this type class constraint.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.NonNegative",
          "name": "NonNegative",
          "package": "numeric-prelude",
          "source": "src/Algebra-NonNegative.html",
          "type": "module"
        },
        "index": {
          "description": "type class for non-negative numbers Prominent instances are and numbers This class cannot do any checks but it let you show to the user what arguments your function expects Thus you must define class instances with care In fact many standard functions take should have this type class constraint",
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "NonNegative",
          "package": "numeric-prelude",
          "partial": "Non Negative",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances of this class must ensure non-negative values.\nWe cannot enforce this by types, but the type class constraint \u003ccode\u003eNonNegative.C\u003c/code\u003e\navoids accidental usage of types which allow for negative numbers.\n\u003c/p\u003e\u003cp\u003eThe Monoid superclass contributes a zero and an addition.\n\u003c/p\u003e",
          "module": "Algebra.NonNegative",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-NonNegative.html#C",
          "type": "class"
        },
        "index": {
          "description": "Instances of this class must ensure non-negative values We cannot enforce this by types but the type class constraint NonNegative.C avoids accidental usage of types which allow for negative numbers The Monoid superclass contributes zero and an addition",
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003ex -| y == max 0 (x-y)\u003c/pre\u003e\u003cp\u003eThe default implementation is not efficient,\nbecause it compares the values and then subtracts, again, if safe.\n\u003ccode\u003emax 0 (x-y)\u003c/code\u003e is more elegant and efficient\nbut not possible in the general case,\nsince \u003ccode\u003ex-y\u003c/code\u003e may already yield a negative number.\n\u003c/p\u003e",
          "module": "Algebra.NonNegative",
          "name": "(-|)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-NonNegative.html#-%7C",
          "type": "function"
        },
        "index": {
          "description": "max x-y The default implementation is not efficient because it compares the values and then subtracts again if safe max x-y is more elegant and efficient but not possible in the general case since x-y may already yield negative number",
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "(-|) -|",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#v:-45--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.NonNegative",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-NonNegative.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "add",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esplit x y == (m,(b,d))\u003c/code\u003e means that\n   \u003ccode\u003eb == (x\u003c=y)\u003c/code\u003e,\n   \u003ccode\u003em == min x y\u003c/code\u003e,\n   \u003ccode\u003ed == max x y - min x y\u003c/code\u003e, that is \u003ccode\u003ed == abs(x-y)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWe have chosen this function as base function,\n   since it provides comparison and subtraction in one go,\n   which is important for replacing common structures like\n\u003c/p\u003e\u003cpre\u003e if x\u003c=y\n   then f(x-y)\n   else g(y-x)\n\u003c/pre\u003e\u003cp\u003ethat lead to a memory leak for peano numbers.\n   We have choosen the simple check \u003ccode\u003ex\u003c=y\u003c/code\u003e\n   instead of a full-blown \u003ccode\u003ecompare\u003c/code\u003e,\n   since we want \u003ccode\u003eZero \u003c= undefined\u003c/code\u003e for peano numbers.\n   Because of undefined values \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e is in general\n   not commutative in the sense\n\u003c/p\u003e\u003cpre\u003e let (m0,(b0,d0)) = split x y\n     (m1,(b1,d1)) = split y x\n in  m0==m1 && d0==d1\n\u003c/pre\u003e\u003cp\u003eThe result values are in the order\n   in which they are generated for Peano numbers.\n   We have chosen the nested pair instead of a triple\n   in order to prevent a memory leak\n   that occurs if you only use \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003ed\u003c/code\u003e and ignore \u003ccode\u003em\u003c/code\u003e.\n   This is demonstrated by test cases\n   Chunky.splitSpaceLeak3 and Chunky.splitSpaceLeak4.\n\u003c/p\u003e",
          "module": "Algebra.NonNegative",
          "name": "split",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, (Bool, a))",
          "source": "src/Algebra-NonNegative.html#split",
          "type": "method"
        },
        "index": {
          "description": "split means that min max min that is abs x-y We have chosen this function as base function since it provides comparison and subtraction in one go which is important for replacing common structures like if then x-y else y-x that lead to memory leak for peano numbers We have choosen the simple check instead of full-blown compare since we want Zero undefined for peano numbers Because of undefined values split is in general not commutative in the sense let m0 b0 d0 split m1 b1 d1 split in m0 m1 d0 d1 The result values are in the order in which they are generated for Peano numbers We have chosen the nested pair instead of triple in order to prevent memory leak that occurs if you only use and and ignore This is demonstrated by test cases Chunky.splitSpaceLeak3 and Chunky.splitSpaceLeak4",
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "split",
          "normalized": "a-\u003ea-\u003e(a,(Bool,a))",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003e(a,(Bool,a))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault implementation for wrapped types of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Algebra.NonNegative",
          "name": "splitDefault",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b) -\u003e (b -\u003e a) -\u003e a -\u003e a -\u003e (a, (Bool, a))",
          "source": "src/Algebra-NonNegative.html#splitDefault",
          "type": "function"
        },
        "index": {
          "description": "Default implementation for wrapped types of Ord and Num class",
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "splitDefault",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003ea-\u003ea-\u003e(a,(Bool,a))",
          "package": "numeric-prelude",
          "partial": "Default",
          "signature": "(a-\u003eb)-\u003e(b-\u003ea)-\u003ea-\u003ea-\u003e(a,(Bool,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#v:splitDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.NonNegative",
          "name": "sum",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-NonNegative.html#sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "sum",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.NonNegative",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-NonNegative.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra NonNegative",
          "module": "Algebra.NonNegative",
          "name": "zero",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NonNegative.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstraction of normed vector spaces\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "Euclidean",
          "package": "numeric-prelude",
          "source": "src/Algebra-NormedSpace-Euclidean.html",
          "type": "module"
        },
        "index": {
          "description": "Abstraction of normed vector spaces",
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "Euclidean",
          "package": "numeric-prelude",
          "partial": "Euclidean",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA vector space equipped with an Euclidean or a Hilbert norm.\n\u003c/p\u003e\u003cp\u003eMinimal definition:\n\u003ccode\u003e\u003ca\u003enorm\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-NormedSpace-Euclidean.html#C",
          "type": "class"
        },
        "index": {
          "description": "vector space equipped with an Euclidean or Hilbert norm Minimal definition norm",
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper class for \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e that does not need an algebraic type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal definition:\n\u003ccode\u003e\u003ca\u003enormSqr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "Sqr",
          "package": "numeric-prelude",
          "source": "src/Algebra-NormedSpace-Euclidean.html#Sqr",
          "type": "class"
        },
        "index": {
          "description": "Helper class for that does not need an algebraic type Minimal definition normSqr",
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "Sqr",
          "package": "numeric-prelude",
          "partial": "Sqr",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#t:Sqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "defltNorm",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-NormedSpace-Euclidean.html#defltNorm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "defltNorm",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Norm",
          "signature": "v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#v:defltNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEuclidean norm of a vector. \n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "norm",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-NormedSpace-Euclidean.html#norm",
          "type": "method"
        },
        "index": {
          "description": "Euclidean norm of vector",
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "norm",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "v-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare of the Euclidean norm of a vector.\n      This is sometimes easier to implement. \n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "normSqr",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-NormedSpace-Euclidean.html#normSqr",
          "type": "method"
        },
        "index": {
          "description": "Square of the Euclidean norm of vector This is sometimes easier to implement",
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "normSqr",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Sqr",
          "signature": "v-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#v:normSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault definition for \u003ccode\u003e\u003ca\u003enormSqr\u003c/a\u003e\u003c/code\u003e that is based on \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "normSqrFoldable",
          "package": "numeric-prelude",
          "signature": "f v -\u003e a",
          "source": "src/Algebra-NormedSpace-Euclidean.html#normSqrFoldable",
          "type": "function"
        },
        "index": {
          "description": "Default definition for normSqr that is based on Foldable class",
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "normSqrFoldable",
          "normalized": "a b-\u003ec",
          "package": "numeric-prelude",
          "partial": "Sqr Foldable",
          "signature": "f v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#v:normSqrFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault definition for \u003ccode\u003e\u003ca\u003enormSqr\u003c/a\u003e\u003c/code\u003e that is based on \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e class\nand the argument vector has at least one component.\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "normSqrFoldable1",
          "package": "numeric-prelude",
          "signature": "f v -\u003e a",
          "source": "src/Algebra-NormedSpace-Euclidean.html#normSqrFoldable1",
          "type": "function"
        },
        "index": {
          "description": "Default definition for normSqr that is based on Foldable class and the argument vector has at least one component",
          "hierarchy": "Algebra NormedSpace Euclidean",
          "module": "Algebra.NormedSpace.Euclidean",
          "name": "normSqrFoldable1",
          "normalized": "a b-\u003ec",
          "package": "numeric-prelude",
          "partial": "Sqr Foldable",
          "signature": "f v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Euclidean.html#v:normSqrFoldable1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstraction of normed vector spaces\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "Maximum",
          "package": "numeric-prelude",
          "source": "src/Algebra-NormedSpace-Maximum.html",
          "type": "module"
        },
        "index": {
          "description": "Abstraction of normed vector spaces",
          "hierarchy": "Algebra NormedSpace Maximum",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "Maximum",
          "package": "numeric-prelude",
          "partial": "Maximum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Maximum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.NormedSpace.Maximum",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-NormedSpace-Maximum.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algebra NormedSpace Maximum",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Maximum.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.NormedSpace.Maximum",
          "name": "norm",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-NormedSpace-Maximum.html#norm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra NormedSpace Maximum",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "norm",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "v-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Maximum.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault definition for \u003ccode\u003e\u003ca\u003enorm\u003c/a\u003e\u003c/code\u003e that is based on \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "normFoldable",
          "package": "numeric-prelude",
          "signature": "f v -\u003e a",
          "source": "src/Algebra-NormedSpace-Maximum.html#normFoldable",
          "type": "function"
        },
        "index": {
          "description": "Default definition for norm that is based on Foldable class",
          "hierarchy": "Algebra NormedSpace Maximum",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "normFoldable",
          "normalized": "a b-\u003ec",
          "package": "numeric-prelude",
          "partial": "Foldable",
          "signature": "f v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Maximum.html#v:normFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault definition for \u003ccode\u003e\u003ca\u003enorm\u003c/a\u003e\u003c/code\u003e that is based on \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e class\nand the argument vector has at least one component.\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "normFoldable1",
          "package": "numeric-prelude",
          "signature": "f v -\u003e a",
          "source": "src/Algebra-NormedSpace-Maximum.html#normFoldable1",
          "type": "function"
        },
        "index": {
          "description": "Default definition for norm that is based on Foldable class and the argument vector has at least one component",
          "hierarchy": "Algebra NormedSpace Maximum",
          "module": "Algebra.NormedSpace.Maximum",
          "name": "normFoldable1",
          "normalized": "a b-\u003ec",
          "package": "numeric-prelude",
          "partial": "Foldable",
          "signature": "f v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Maximum.html#v:normFoldable1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstraction of normed vector spaces\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.NormedSpace.Sum",
          "name": "Sum",
          "package": "numeric-prelude",
          "source": "src/Algebra-NormedSpace-Sum.html",
          "type": "module"
        },
        "index": {
          "description": "Abstraction of normed vector spaces",
          "hierarchy": "Algebra NormedSpace Sum",
          "module": "Algebra.NormedSpace.Sum",
          "name": "Sum",
          "package": "numeric-prelude",
          "partial": "Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Sum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe super class is only needed to state the laws\n  \u003ccode\u003e\n     v == zero        ==   norm v == zero\n     norm (scale x v) ==   abs x * norm v\n     norm (u+v)       \u003c=   norm u + norm v\n  \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Sum",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-NormedSpace-Sum.html#C",
          "type": "class"
        },
        "index": {
          "description": "The super class is only needed to state the laws zero norm zero norm scale abs norm norm norm norm",
          "hierarchy": "Algebra NormedSpace Sum",
          "module": "Algebra.NormedSpace.Sum",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Sum.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.NormedSpace.Sum",
          "name": "norm",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-NormedSpace-Sum.html#norm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra NormedSpace Sum",
          "module": "Algebra.NormedSpace.Sum",
          "name": "norm",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "v-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Sum.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault definition for \u003ccode\u003e\u003ca\u003enorm\u003c/a\u003e\u003c/code\u003e that is based on \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Sum",
          "name": "normFoldable",
          "package": "numeric-prelude",
          "signature": "f v -\u003e a",
          "source": "src/Algebra-NormedSpace-Sum.html#normFoldable",
          "type": "function"
        },
        "index": {
          "description": "Default definition for norm that is based on Foldable class",
          "hierarchy": "Algebra NormedSpace Sum",
          "module": "Algebra.NormedSpace.Sum",
          "name": "normFoldable",
          "normalized": "a b-\u003ec",
          "package": "numeric-prelude",
          "partial": "Foldable",
          "signature": "f v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Sum.html#v:normFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault definition for \u003ccode\u003e\u003ca\u003enorm\u003c/a\u003e\u003c/code\u003e that is based on \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e class\nand the argument vector has at least one component.\n\u003c/p\u003e",
          "module": "Algebra.NormedSpace.Sum",
          "name": "normFoldable1",
          "package": "numeric-prelude",
          "signature": "f v -\u003e a",
          "source": "src/Algebra-NormedSpace-Sum.html#normFoldable1",
          "type": "function"
        },
        "index": {
          "description": "Default definition for norm that is based on Foldable class and the argument vector has at least one component",
          "hierarchy": "Algebra NormedSpace Sum",
          "module": "Algebra.NormedSpace.Sum",
          "name": "normFoldable1",
          "normalized": "a b-\u003ec",
          "package": "numeric-prelude",
          "partial": "Foldable",
          "signature": "f v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-NormedSpace-Sum.html#v:normFoldable1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThere are several types of numbers\nwhere a subset of numbers can be considered as set of scalars.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e A '(Complex.T Double)' value can be converted to \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e if the imaginary part is zero.\n\u003c/li\u003e\u003cli\u003e A value with physical units can be converted to a scalar if there is no unit. \n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOf course this can be cascaded,\ne.g. a complex number with physical units can be converted to a scalar\nif there is both no imaginary part and no unit.\n\u003c/p\u003e\u003cp\u003eThis is somewhat similar to the multi-type classes NormedMax.C and friends.\n\u003c/p\u003e\u003cp\u003eI hesitate to define an instance for lists\nto avoid the mess known of MatLab.\nBut if you have an application where you think\nyou need this instance definitely\nI'll think about that, again.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.OccasionallyScalar",
          "name": "OccasionallyScalar",
          "package": "numeric-prelude",
          "source": "src/Algebra-OccasionallyScalar.html",
          "type": "module"
        },
        "index": {
          "description": "There are several types of numbers where subset of numbers can be considered as set of scalars Complex.T Double value can be converted to Double if the imaginary part is zero value with physical units can be converted to scalar if there is no unit Of course this can be cascaded e.g complex number with physical units can be converted to scalar if there is both no imaginary part and no unit This is somewhat similar to the multi-type classes NormedMax.C and friends hesitate to define an instance for lists to avoid the mess known of MatLab But if you have an application where you think you need this instance definitely ll think about that again",
          "hierarchy": "Algebra OccasionallyScalar",
          "module": "Algebra.OccasionallyScalar",
          "name": "OccasionallyScalar",
          "package": "numeric-prelude",
          "partial": "Occasionally Scalar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-OccasionallyScalar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.OccasionallyScalar",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-OccasionallyScalar.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algebra OccasionallyScalar",
          "module": "Algebra.OccasionallyScalar",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-OccasionallyScalar.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.OccasionallyScalar",
          "name": "fromScalar",
          "package": "numeric-prelude",
          "signature": "a -\u003e v",
          "source": "src/Algebra-OccasionallyScalar.html#fromScalar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra OccasionallyScalar",
          "module": "Algebra.OccasionallyScalar",
          "name": "fromScalar",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "a-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-OccasionallyScalar.html#v:fromScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.OccasionallyScalar",
          "name": "toMaybeScalar",
          "package": "numeric-prelude",
          "signature": "v -\u003e Maybe a",
          "source": "src/Algebra-OccasionallyScalar.html#toMaybeScalar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra OccasionallyScalar",
          "module": "Algebra.OccasionallyScalar",
          "name": "toMaybeScalar",
          "normalized": "a-\u003eMaybe b",
          "package": "numeric-prelude",
          "partial": "Maybe Scalar",
          "signature": "v-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-OccasionallyScalar.html#v:toMaybeScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.OccasionallyScalar",
          "name": "toScalar",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-OccasionallyScalar.html#toScalar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra OccasionallyScalar",
          "module": "Algebra.OccasionallyScalar",
          "name": "toScalar",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "v-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-OccasionallyScalar.html#v:toScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.OccasionallyScalar",
          "name": "toScalarDefault",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-OccasionallyScalar.html#toScalarDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra OccasionallyScalar",
          "module": "Algebra.OccasionallyScalar",
          "name": "toScalarDefault",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Scalar Default",
          "signature": "v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-OccasionallyScalar.html#v:toScalarDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.OccasionallyScalar",
          "name": "toScalarShow",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/Algebra-OccasionallyScalar.html#toScalarShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra OccasionallyScalar",
          "module": "Algebra.OccasionallyScalar",
          "name": "toScalarShow",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Scalar Show",
          "signature": "v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-OccasionallyScalar.html#v:toScalarShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "PrincipalIdealDomain",
          "package": "numeric-prelude",
          "source": "src/Algebra-PrincipalIdealDomain.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "PrincipalIdealDomain",
          "package": "numeric-prelude",
          "partial": "Principal Ideal Domain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA principal ideal domain is a ring in which every ideal\n(the set of multiples of some generating set of elements)\nis principal:\nThat is,\nevery element can be written as the multiple of some generating element.\n\u003ccode\u003egcd a b\u003c/code\u003e gives a generator for the ideal generated by \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e.\nThe algorithm above works whenever \u003ccode\u003emod x y\u003c/code\u003e is smaller\n(in a suitable sense) than both \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e;\notherwise the algorithm may run forever.\n\u003c/p\u003e\u003cp\u003eLaws:\n\u003c/p\u003e\u003cpre\u003e   divides x (lcm x y)\n   x `gcd` (y `gcd` z) == (x `gcd` y) `gcd` z\n   gcd x y * z == gcd (x*z) (y*z)\n   gcd x y * lcm x y == x * y\n\u003c/pre\u003e\u003cp\u003e(etc: canonical)\n\u003c/p\u003e\u003cp\u003eMinimal definition:\n * nothing, if the standard Euclidean algorithm work\n * if \u003ccode\u003e\u003ca\u003eextendedGCD\u003c/a\u003e\u003c/code\u003e is implemented customly, \u003ccode\u003e\u003ca\u003egcd\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elcm\u003c/a\u003e\u003c/code\u003e make use of it\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-PrincipalIdealDomain.html#C",
          "type": "class"
        },
        "index": {
          "description": "principal ideal domain is ring in which every ideal the set of multiples of some generating set of elements is principal That is every element can be written as the multiple of some generating element gcd gives generator for the ideal generated by and The algorithm above works whenever mod is smaller in suitable sense than both and otherwise the algorithm may run forever Laws divides lcm gcd gcd gcd gcd gcd gcd gcd lcm etc canonical Minimal definition nothing if the standard Euclidean algorithm work if extendedGCD is implemented customly gcd and lcm make use of it",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNot efficient enough, because GCD/LCM is computed twice.\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "chineseRemainder",
          "package": "numeric-prelude",
          "signature": "(a, a) -\u003e (a, a) -\u003e Maybe (a, a)",
          "source": "src/Algebra-PrincipalIdealDomain.html#chineseRemainder",
          "type": "function"
        },
        "index": {
          "description": "Not efficient enough because GCD LCM is computed twice",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "chineseRemainder",
          "normalized": "(a,a)-\u003e(a,a)-\u003eMaybe(a,a)",
          "package": "numeric-prelude",
          "partial": "Remainder",
          "signature": "(a,a)-\u003e(a,a)-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:chineseRemainder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor \u003ccode\u003eJust (b,n) = chineseRemainder [(a0,m0), (a1,m1), ..., (an,mn)]\u003c/code\u003e\nand all \u003ccode\u003ex\u003c/code\u003e with \u003ccode\u003ex = b mod n\u003c/code\u003e the congruences\n\u003ccode\u003ex=a0 mod m0, x=a1 mod m1, ..., x=an mod mn\u003c/code\u003e\nare fulfilled.\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "chineseRemainderMulti",
          "package": "numeric-prelude",
          "signature": "[(a, a)] -\u003e Maybe (a, a)",
          "source": "src/Algebra-PrincipalIdealDomain.html#chineseRemainderMulti",
          "type": "function"
        },
        "index": {
          "description": "For Just chineseRemainder a0 m0 a1 m1 an mn and all with mod the congruences a0 mod m0 a1 mod m1 an mod mn are fulfilled",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "chineseRemainderMulti",
          "normalized": "[(a,a)]-\u003eMaybe(a,a)",
          "package": "numeric-prelude",
          "partial": "Remainder Multi",
          "signature": "[(a,a)]-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:chineseRemainderMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "coprime",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#coprime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "coprime",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:coprime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant with small coefficients.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eJust (a,b) = diophantine z x y\u003c/code\u003e\nmeans\n\u003ccode\u003ea*x+b*y = z\u003c/code\u003e.\nIt is required that \u003ccode\u003egcd(y,z) \u003ccode\u003e\u003ca\u003edivides\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "diophantine",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Algebra-PrincipalIdealDomain.html#diophantine",
          "type": "function"
        },
        "index": {
          "description": "variant with small coefficients Just diophantine means It is required that gcd divides",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "diophantine",
          "normalized": "a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:diophantine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ediophantine\u003c/a\u003e\u003c/code\u003e, but \u003ccode\u003ea\u003c/code\u003e is minimal\nwith respect to the measure function of the Euclidean algorithm.\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "diophantineMin",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Algebra-PrincipalIdealDomain.html#diophantineMin",
          "type": "function"
        },
        "index": {
          "description": "Like diophantine but is minimal with respect to the measure function of the Euclidean algorithm",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "diophantineMin",
          "normalized": "a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "package": "numeric-prelude",
          "partial": "Min",
          "signature": "a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:diophantineMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "diophantineMulti",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Algebra-PrincipalIdealDomain.html#diophantineMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "diophantineMulti",
          "normalized": "a-\u003e[a]-\u003eMaybe[a]",
          "package": "numeric-prelude",
          "partial": "Multi",
          "signature": "a-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:diophantineMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.PrincipalIdealDomain\",\"NumericPrelude.Numeric\"]",
          "name": "euclid",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e a",
          "source": "src/Algebra-PrincipalIdealDomain.html#euclid",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:euclid\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:euclid\"]"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "euclid",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:euclid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.PrincipalIdealDomain\",\"NumericPrelude.Numeric\"]",
          "name": "extendedEuclid",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e (a, a)) -\u003e a -\u003e a -\u003e (a, (a, a))",
          "source": "src/Algebra-PrincipalIdealDomain.html#extendedEuclid",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:extendedEuclid\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:extendedEuclid\"]"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "extendedEuclid",
          "normalized": "(a-\u003ea-\u003e(a,a))-\u003ea-\u003ea-\u003e(a,(a,a))",
          "package": "numeric-prelude",
          "partial": "Euclid",
          "signature": "(a-\u003ea-\u003e(a,a))-\u003ea-\u003ea-\u003e(a,(a,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:extendedEuclid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the greatest common divisor and\n    solve a respective Diophantine equation.\n\u003c/p\u003e\u003cpre\u003e   (g,(a,b)) = extendedGCD x y ==\u003e\n        g==a*x+b*y   &&  g == gcd x y\n\u003c/pre\u003e\u003cp\u003eTODO: This method is not appropriate for the PID class,\n          because there are rings like the one of the multivariate polynomials,\n          where for all x and y greatest common divisors of x and y exist,\n          but they cannot be represented as a linear combination of x and y.\n    TODO: The definition of extendedGCD does not return the canonical associate.\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "extendedGCD",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, (a, a))",
          "source": "src/Algebra-PrincipalIdealDomain.html#extendedGCD",
          "type": "method"
        },
        "index": {
          "description": "Compute the greatest common divisor and solve respective Diophantine equation extendedGCD gcd TODO This method is not appropriate for the PID class because there are rings like the one of the multivariate polynomials where for all and greatest common divisors of and exist but they cannot be represented as linear combination of and TODO The definition of extendedGCD does not return the canonical associate",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "extendedGCD",
          "normalized": "a-\u003ea-\u003e(a,(a,a))",
          "package": "numeric-prelude",
          "partial": "GCD",
          "signature": "a-\u003ea-\u003e(a,(a,a))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:extendedGCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the greatest common divisor for multiple numbers\nby repeated application of the two-operand-gcd.\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "extendedGCDMulti",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e (a, [a])",
          "source": "src/Algebra-PrincipalIdealDomain.html#extendedGCDMulti",
          "type": "function"
        },
        "index": {
          "description": "Compute the greatest common divisor for multiple numbers by repeated application of the two-operand-gcd",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "extendedGCDMulti",
          "normalized": "[a]-\u003e(a,[a])",
          "package": "numeric-prelude",
          "partial": "GCDMulti",
          "signature": "[a]-\u003e(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:extendedGCDMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Greatest Common Divisor is defined by:\n\u003c/p\u003e\u003cpre\u003e   gcd x y == gcd y x\n   divides z x && divides z y ==\u003e divides z (gcd x y)   (specification)\n   divides (gcd x y) x\n\u003c/pre\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "gcd",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-PrincipalIdealDomain.html#gcd",
          "type": "method"
        },
        "index": {
          "description": "The Greatest Common Divisor is defined by gcd gcd divides divides divides gcd specification divides gcd",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "gcd",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:gcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast common multiple\n\u003c/p\u003e",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "lcm",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-PrincipalIdealDomain.html#lcm",
          "type": "method"
        },
        "index": {
          "description": "Least common multiple",
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "lcm",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:lcm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propChineseRemainder",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e [a] -\u003e Property",
          "source": "src/Algebra-PrincipalIdealDomain.html#propChineseRemainder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propChineseRemainder",
          "normalized": "a-\u003ea-\u003e[a]-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Chinese Remainder",
          "signature": "a-\u003ea-\u003e[a]-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propChineseRemainder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantine",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propDiophantine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantine",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Diophantine",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propDiophantine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantineMin",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propDiophantineMin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantineMin",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Diophantine Min",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propDiophantineMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantineMulti",
          "package": "numeric-prelude",
          "signature": "[(a, a)] -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propDiophantineMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantineMulti",
          "normalized": "[(a,a)]-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Diophantine Multi",
          "signature": "[(a,a)]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propDiophantineMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantineMultiMin",
          "package": "numeric-prelude",
          "signature": "[(a, a)] -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propDiophantineMultiMin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDiophantineMultiMin",
          "normalized": "[(a,a)]-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Diophantine Multi Min",
          "signature": "[(a,a)]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propDiophantineMultiMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDivisibleGCD",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propDivisibleGCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDivisibleGCD",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Divisible GCD",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propDivisibleGCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDivisibleLCM",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propDivisibleLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propDivisibleLCM",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Divisible LCM",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propDivisibleLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propExtendedGCDMulti",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propExtendedGCDMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propExtendedGCDMulti",
          "normalized": "[a]-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Extended GCDMulti",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propExtendedGCDMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDAssociative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propGCDAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDAssociative",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "GCDAssociative",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propGCDAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDCommutative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propGCDCommutative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDCommutative",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "GCDCommutative",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propGCDCommutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDDiophantine",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propGCDDiophantine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDDiophantine",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "GCDDiophantine",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propGCDDiophantine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDHomogeneous",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propGCDHomogeneous",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDHomogeneous",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "GCDHomogeneous",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propGCDHomogeneous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDIdentity",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propGCDIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCDIdentity",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "GCDIdentity",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propGCDIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCD_LCM",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PrincipalIdealDomain.html#propGCD_LCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propGCD_LCM",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "GCD LCM",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propGCD_LCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propMaximalDivisor",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-PrincipalIdealDomain.html#propMaximalDivisor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra PrincipalIdealDomain",
          "module": "Algebra.PrincipalIdealDomain",
          "name": "propMaximalDivisor",
          "normalized": "a-\u003ea-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Maximal Divisor",
          "signature": "a-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-PrincipalIdealDomain.html#v:propMaximalDivisor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealField",
          "name": "RealField",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealField.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra RealField",
          "module": "Algebra.RealField",
          "name": "RealField",
          "package": "numeric-prelude",
          "partial": "Real Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealField.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient class for common types\nthat both form a field and have a notion of ordering by magnitude.\n\u003c/p\u003e",
          "module": "Algebra.RealField",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealField.html#C",
          "type": "class"
        },
        "index": {
          "description": "This is convenient class for common types that both form field and have notion of ordering by magnitude",
          "hierarchy": "Algebra RealField",
          "module": "Algebra.RealField",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealField.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGenerally before using \u003ccode\u003e\u003ca\u003equot\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erem\u003c/a\u003e\u003c/code\u003e, think twice.\nIn most cases \u003ccode\u003e\u003ca\u003edivMod\u003c/a\u003e\u003c/code\u003e and friends are the right choice,\nbecause they fulfill more of the wanted properties.\nOn some systems \u003ccode\u003e\u003ca\u003equot\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erem\u003c/a\u003e\u003c/code\u003e are more efficient\nand if you only use positive numbers, you may be happy with them.\nBut we cannot warrant the efficiency advantage.\n\u003c/p\u003e\u003cp\u003eSee also:\nDaan Leijen: Division and Modulus for Computer Scientists\n\u003ca\u003ehttp://www.cs.uu.nl/%7Edaan/download/papers/divmodnote-letter.pdf\u003c/a\u003e,\n\u003ca\u003ehttp://www.haskell.org/pipermail/haskell-cafe/2007-August/030394.html\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.RealIntegral",
          "name": "RealIntegral",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealIntegral.html",
          "type": "module"
        },
        "index": {
          "description": "Generally before using quot and rem think twice In most cases divMod and friends are the right choice because they fulfill more of the wanted properties On some systems quot and rem are more efficient and if you only use positive numbers you may be happy with them But we cannot warrant the efficiency advantage See also Daan Leijen Division and Modulus for Computer Scientists http www.cs.uu.nl Edaan download papers divmodnote-letter.pdf http www.haskell.org pipermail haskell-cafe August html",
          "hierarchy": "Algebra RealIntegral",
          "module": "Algebra.RealIntegral",
          "name": "RealIntegral",
          "package": "numeric-prelude",
          "partial": "Real Integral",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealIntegral.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemember that \u003ccode\u003e\u003ca\u003edivMod\u003c/a\u003e\u003c/code\u003e does not specify exactly what \u003ccode\u003ea \u003ccode\u003e\u003ca\u003equot\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e should be,\nmainly because there is no sensible way to define it in general.\nFor an instance of \u003ccode\u003eAlgebra.RealIntegral.C a\u003c/code\u003e,\nit is expected that \u003ccode\u003ea \u003ccode\u003e\u003ca\u003equot\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e will round towards 0 and\n\u003ccode\u003ea \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e will round towards minus infinity.\n\u003c/p\u003e\u003cp\u003eMinimal definition: nothing required\n\u003c/p\u003e",
          "module": "Algebra.RealIntegral",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealIntegral.html#C",
          "type": "class"
        },
        "index": {
          "description": "Remember that divMod does not specify exactly what quot should be mainly because there is no sensible way to define it in general For an instance of Algebra.RealIntegral.C it is expected that quot will round towards and div will round towards minus infinity Minimal definition nothing required",
          "hierarchy": "Algebra RealIntegral",
          "module": "Algebra.RealIntegral",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealIntegral.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealIntegral",
          "name": "quot",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-RealIntegral.html#quot",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealIntegral",
          "module": "Algebra.RealIntegral",
          "name": "quot",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealIntegral.html#v:quot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealIntegral",
          "name": "quotRem",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Algebra-RealIntegral.html#quotRem",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealIntegral",
          "module": "Algebra.RealIntegral",
          "name": "quotRem",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Rem",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealIntegral.html#v:quotRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "RealRing",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealRing.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "RealRing",
          "package": "numeric-prelude",
          "partial": "Real Ring",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal complete definition:\n     \u003ccode\u003e\u003ca\u003esplitFraction\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThere are probably more laws, but some laws are\n\u003c/p\u003e\u003cpre\u003e splitFraction x === (fromInteger (floor x), fraction x)\n fromInteger (floor x) + fraction x === x\n floor x       \u003c= x       x \u003c  floor x + 1\n ceiling x - 1 \u003c  x       x \u003c= ceiling x\n 0 \u003c= fraction x          fraction x \u003c 1\n\u003c/pre\u003e\u003cpre\u003e               - ceiling x === floor (-x)\n                truncate x === signum x * floor (abs x)\n    ceiling (toRational x) === ceiling x :: Integer\n   truncate (toRational x) === truncate x :: Integer\n      floor (toRational x) === floor x :: Integer\n\u003c/pre\u003e\u003cp\u003eThe new function \u003ccode\u003e\u003ca\u003efraction\u003c/a\u003e\u003c/code\u003e doesn't return the integer part of the number.\nThis also removes a type ambiguity if the integer part is not needed.\n\u003c/p\u003e\u003cp\u003eMany people will associate rounding with fractional numbers,\nand thus they are surprised about the superclass being \u003ccode\u003eRing\u003c/code\u003e not \u003ccode\u003eField\u003c/code\u003e.\nThe reason is that all of these methods can be defined\nexclusively with functions from \u003ccode\u003eOrd\u003c/code\u003e and \u003ccode\u003eRing\u003c/code\u003e.\nThe implementations of \u003ccode\u003e\u003ca\u003egenericFloor\u003c/a\u003e\u003c/code\u003e and other functions demonstrate that.\nThey implement power-of-two-algorithms\nlike the one for finding the number of digits of an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\nin FixedPoint-fractions module.\nThey are even reasonably efficient.\n\u003c/p\u003e\u003cp\u003eI am still uncertain whether it was a good idea\nto add instances for \u003ccode\u003eInteger\u003c/code\u003e and friends,\nsince calling \u003ccode\u003efloor\u003c/code\u003e or \u003ccode\u003efraction\u003c/code\u003e on an integer may well indicate a bug.\nThe rounding functions are just the identity function\nand \u003ccode\u003e\u003ca\u003efraction\u003c/a\u003e\u003c/code\u003e is constant zero.\nHowever, I decided to associate our class with \u003ccode\u003eRing\u003c/code\u003e rather than \u003ccode\u003eField\u003c/code\u003e,\nafter I found myself using repeated subtraction and testing\nrather than just calling \u003ccode\u003efraction\u003c/code\u003e,\njust in order to get the constraint \u003ccode\u003e(Ring a, Ord a)\u003c/code\u003e\nthat was more general than \u003ccode\u003e(RealField a)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor the results of the rounding functions\nwe have chosen the constraint \u003ccode\u003eRing\u003c/code\u003e instead of \u003ccode\u003eToInteger\u003c/code\u003e,\nsince this is more flexible to use,\nbut it still signals to the user that only integral numbers can be returned.\nThis is so, because the plain \u003ccode\u003eRing\u003c/code\u003e class only provides\n\u003ccode\u003ezero\u003c/code\u003e, \u003ccode\u003eone\u003c/code\u003e and operations that allow to reach all natural numbers but not more.\n\u003c/p\u003e\u003cp\u003eAs an aside, let me note the similarities\nbetween \u003ccode\u003esplitFraction x\u003c/code\u003e and \u003ccode\u003edivMod x 1\u003c/code\u003e (if that were defined).\nIn particular, it might make sense to unify the rounding modes somehow.\n\u003c/p\u003e\u003cp\u003eThe new methods \u003ccode\u003e\u003ca\u003efraction\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esplitFraction\u003c/a\u003e\u003c/code\u003e\ndiffer from \u003ccode\u003e\u003ca\u003eproperFraction\u003c/a\u003e\u003c/code\u003e semantics.\nThey always round to \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e.\nThis means that the fraction is always non-negative and\nis always smaller than 1.\nThis is more useful in practice and\ncan be generalised to more than real numbers.\nSince every \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e denominator type\nsupports \u003ccode\u003e\u003ca\u003edivMod\u003c/a\u003e\u003c/code\u003e,\nevery \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e can provide \u003ccode\u003e\u003ca\u003efraction\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esplitFraction\u003c/a\u003e\u003c/code\u003e,\ne.g. fractions of polynomials.\nHowever the \u003ccode\u003eRing\u003c/code\u003e constraint for the ''integral'' part of \u003ccode\u003e\u003ca\u003esplitFraction\u003c/a\u003e\u003c/code\u003e\nis too weak in order to generate polynomials.\nAfter all, I am uncertain whether this would be useful or not.\n\u003c/p\u003e\u003cp\u003eCan there be a separate class for\n\u003ccode\u003e\u003ca\u003efraction\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esplitFraction\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e\nsince they do not need reals and their ordering?\n\u003c/p\u003e\u003cp\u003eWe might also add a round method,\nthat rounds 0.5 always up or always down.\nThis is much more efficient in inner loops\nand is acceptable or even preferable for many applications.\n\u003c/p\u003e",
          "module": "Algebra.RealRing",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealRing.html#C",
          "type": "class"
        },
        "index": {
          "description": "Minimal complete definition splitFraction or floor There are probably more laws but some laws are splitFraction fromInteger floor fraction fromInteger floor fraction floor floor ceiling ceiling fraction fraction ceiling floor truncate signum floor abs ceiling toRational ceiling Integer truncate toRational truncate Integer floor toRational floor Integer The new function fraction doesn return the integer part of the number This also removes type ambiguity if the integer part is not needed Many people will associate rounding with fractional numbers and thus they are surprised about the superclass being Ring not Field The reason is that all of these methods can be defined exclusively with functions from Ord and Ring The implementations of genericFloor and other functions demonstrate that They implement power-of-two-algorithms like the one for finding the number of digits of an Integer in FixedPoint-fractions module They are even reasonably efficient am still uncertain whether it was good idea to add instances for Integer and friends since calling floor or fraction on an integer may well indicate bug The rounding functions are just the identity function and fraction is constant zero However decided to associate our class with Ring rather than Field after found myself using repeated subtraction and testing rather than just calling fraction just in order to get the constraint Ring Ord that was more general than RealField For the results of the rounding functions we have chosen the constraint Ring instead of ToInteger since this is more flexible to use but it still signals to the user that only integral numbers can be returned This is so because the plain Ring class only provides zero one and operations that allow to reach all natural numbers but not more As an aside let me note the similarities between splitFraction and divMod if that were defined In particular it might make sense to unify the rounding modes somehow The new methods fraction and splitFraction differ from properFraction semantics They always round to floor This means that the fraction is always non-negative and is always smaller than This is more useful in practice and can be generalised to more than real numbers Since every denominator type supports divMod every can provide fraction and splitFraction e.g fractions of polynomials However the Ring constraint for the integral part of splitFraction is too weak in order to generate polynomials After all am uncertain whether this would be useful or not Can there be separate class for fraction splitFraction floor and ceiling since they do not need reals and their ordering We might also add round method that rounds always up or always down This is much more efficient in inner loops and is acceptable or even preferable for many applications",
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTODO: Should be moved to a continued fraction module. \n\u003c/p\u003e",
          "module": "[\"Algebra.RealRing\",\"NumericPrelude.Numeric\"]",
          "name": "approxRational",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Rational",
          "source": "src/Algebra-RealRing.html#approxRational",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:approxRational\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:approxRational\"]"
        },
        "index": {
          "description": "TODO Should be moved to continued fraction module",
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "approxRational",
          "normalized": "a-\u003ea-\u003eRational",
          "package": "numeric-prelude",
          "partial": "Rational",
          "signature": "a-\u003ea-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:approxRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "ceiling",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#ceiling",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "ceiling",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:ceiling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "ceilingInt",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Int) -\u003e (Int -\u003e a) -\u003e a -\u003e Int",
          "source": "src/Algebra-RealRing.html#ceilingInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "ceilingInt",
          "normalized": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:ceilingInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNeeds linear time with respect to the number of digits.\n\u003c/p\u003e\u003cp\u003eThis and other functions using OrderDecision\nlike \u003ccode\u003efloor\u003c/code\u003e where argument and result are the same\nmay be moved to a new module.\n\u003c/p\u003e",
          "module": "Algebra.RealRing",
          "name": "decisionPosFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-RealRing.html#decisionPosFraction",
          "type": "function"
        },
        "index": {
          "description": "Needs linear time with respect to the number of digits This and other functions using OrderDecision like floor where argument and result are the same may be moved to new module",
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "decisionPosFraction",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Pos Fraction",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:decisionPosFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "decisionPosFractionSqrTime",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-RealRing.html#decisionPosFractionSqrTime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "decisionPosFractionSqrTime",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Pos Fraction Sqr Time",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:decisionPosFractionSqrTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "fastSplitFraction",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Int) -\u003e (Int -\u003e a) -\u003e a -\u003e (b, a)",
          "source": "src/Algebra-RealRing.html#fastSplitFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "fastSplitFraction",
          "normalized": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003e(b,a)",
          "package": "numeric-prelude",
          "partial": "Split Fraction",
          "signature": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:fastSplitFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "fixFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-RealRing.html#fixFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "fixFraction",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Fraction",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:fixFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "fixSplitFraction",
          "package": "numeric-prelude",
          "signature": "(b, a) -\u003e (b, a)",
          "source": "src/Algebra-RealRing.html#fixSplitFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "fixSplitFraction",
          "normalized": "(a,b)-\u003e(a,b)",
          "package": "numeric-prelude",
          "partial": "Split Fraction",
          "signature": "(b,a)-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:fixSplitFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "floorInt",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Int) -\u003e (Int -\u003e a) -\u003e a -\u003e Int",
          "source": "src/Algebra-RealRing.html#floorInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "floorInt",
          "normalized": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:floorInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "fraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-RealRing.html#fraction",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "fraction",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:fraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericCeiling",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#genericCeiling",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericCeiling",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Ceiling",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericCeiling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe generic rounding functions need a number of operations\nproportional to the number of binary digits of the integer portion.\nIf operations like multiplication with two and comparison\nneed time proportional to the number of binary digits,\nthen the overall rounding requires quadratic time.\n\u003c/p\u003e",
          "module": "Algebra.RealRing",
          "name": "genericFloor",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#genericFloor",
          "type": "function"
        },
        "index": {
          "description": "The generic rounding functions need number of operations proportional to the number of binary digits of the integer portion If operations like multiplication with two and comparison need time proportional to the number of binary digits then the overall rounding requires quadratic time",
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericFloor",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Floor",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericFloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-RealRing.html#genericFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericFraction",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Fraction",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericHalfPosFloorDigits",
          "package": "numeric-prelude",
          "signature": "a -\u003e ((a, b), [Bool])",
          "source": "src/Algebra-RealRing.html#genericHalfPosFloorDigits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericHalfPosFloorDigits",
          "normalized": "a-\u003e((a,b),[Bool])",
          "package": "numeric-prelude",
          "partial": "Half Pos Floor Digits",
          "signature": "a-\u003e((a,b),[Bool])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericHalfPosFloorDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericPosCeiling",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#genericPosCeiling",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericPosCeiling",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Pos Ceiling",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericPosCeiling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericPosFloor",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#genericPosFloor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericPosFloor",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Pos Floor",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericPosFloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericPosFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-RealRing.html#genericPosFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericPosFraction",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Pos Fraction",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericPosFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericPosRound",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#genericPosRound",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericPosRound",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Pos Round",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericPosRound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericPosSplitFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e (b, a)",
          "source": "src/Algebra-RealRing.html#genericPosSplitFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericPosSplitFraction",
          "normalized": "a-\u003e(b,a)",
          "package": "numeric-prelude",
          "partial": "Pos Split Fraction",
          "signature": "a-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericPosSplitFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericRound",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#genericRound",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericRound",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Round",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericRound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericSplitFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e (b, a)",
          "source": "src/Algebra-RealRing.html#genericSplitFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericSplitFraction",
          "normalized": "a-\u003e(b,a)",
          "package": "numeric-prelude",
          "partial": "Split Fraction",
          "signature": "a-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericSplitFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "genericTruncate",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#genericTruncate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "genericTruncate",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Truncate",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:genericTruncate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "pairsOfPowersOfTwo",
          "package": "numeric-prelude",
          "signature": "[(a, b)]",
          "source": "src/Algebra-RealRing.html#pairsOfPowersOfTwo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "pairsOfPowersOfTwo",
          "normalized": "[(a,b)]",
          "package": "numeric-prelude",
          "partial": "Of Powers Of Two",
          "signature": "[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:pairsOfPowersOfTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "powersOfTwo",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/Algebra-RealRing.html#powersOfTwo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "powersOfTwo",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Of Two",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:powersOfTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "round",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#round",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "round",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:round"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "roundInt",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Int) -\u003e (Int -\u003e a) -\u003e a -\u003e Int",
          "source": "src/Algebra-RealRing.html#roundInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "roundInt",
          "normalized": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:roundInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function rounds to the closest integer.\nFor \u003ccode\u003efraction x == 0.5\u003c/code\u003e it rounds away from zero.\nThis function is not the result of an ingenious mathematical insight,\nbut is simply a kind of rounding that is the fastest\non IEEE floating point architectures.\n\u003c/p\u003e",
          "module": "Algebra.RealRing",
          "name": "roundSimple",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#roundSimple",
          "type": "function"
        },
        "index": {
          "description": "This function rounds to the closest integer For fraction it rounds away from zero This function is not the result of an ingenious mathematical insight but is simply kind of rounding that is the fastest on IEEE floating point architectures",
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "roundSimple",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Simple",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:roundSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "roundSimpleInt",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Int) -\u003e (Int -\u003e a) -\u003e a -\u003e Int",
          "source": "src/Algebra-RealRing.html#roundSimpleInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "roundSimpleInt",
          "normalized": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "package": "numeric-prelude",
          "partial": "Simple Int",
          "signature": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:roundSimpleInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "splitFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e (b, a)",
          "source": "src/Algebra-RealRing.html#splitFraction",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "splitFraction",
          "normalized": "a-\u003e(b,a)",
          "package": "numeric-prelude",
          "partial": "Fraction",
          "signature": "a-\u003e(b,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:splitFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "splitFractionInt",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Int) -\u003e (Int -\u003e a) -\u003e a -\u003e (Int, a)",
          "source": "src/Algebra-RealRing.html#splitFractionInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "splitFractionInt",
          "normalized": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003e(Int,a)",
          "package": "numeric-prelude",
          "partial": "Fraction Int",
          "signature": "(a-\u003eInt)-\u003e(Int-\u003ea)-\u003ea-\u003e(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:splitFractionInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealRing",
          "name": "truncate",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#truncate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealRing",
          "module": "Algebra.RealRing",
          "name": "truncate",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealRing.html#v:truncate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealTranscendental",
          "name": "RealTranscendental",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealTranscendental.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra RealTranscendental",
          "module": "Algebra.RealTranscendental",
          "name": "RealTranscendental",
          "package": "numeric-prelude",
          "partial": "Real Transcendental",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealTranscendental.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class collects all functions for _scalar_ floating point numbers.\nE.g. computing \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e for complex floating numbers makes certainly no sense.\n\u003c/p\u003e",
          "module": "Algebra.RealTranscendental",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-RealTranscendental.html#C",
          "type": "class"
        },
        "index": {
          "description": "This class collects all functions for scalar floating point numbers E.g computing atan2 for complex floating numbers makes certainly no sense",
          "hierarchy": "Algebra RealTranscendental",
          "module": "Algebra.RealTranscendental",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealTranscendental.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RealTranscendental",
          "name": "atan2",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-RealTranscendental.html#atan2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RealTranscendental",
          "module": "Algebra.RealTranscendental",
          "name": "atan2",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RealTranscendental.html#v:atan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RightModule",
          "name": "RightModule",
          "package": "numeric-prelude",
          "source": "src/Algebra-RightModule.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra RightModule",
          "module": "Algebra.RightModule",
          "name": "RightModule",
          "package": "numeric-prelude",
          "partial": "Right Module",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RightModule.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RightModule",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-RightModule.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algebra RightModule",
          "module": "Algebra.RightModule",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RightModule.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.RightModule",
          "name": "(\u003c*)",
          "package": "numeric-prelude",
          "signature": "b -\u003e a -\u003e b",
          "source": "src/Algebra-RightModule.html#%3C%2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra RightModule",
          "module": "Algebra.RightModule",
          "name": "(\u003c*) \u003c*",
          "normalized": "a-\u003eb-\u003ea",
          "package": "numeric-prelude",
          "signature": "b-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-RightModule.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "Ring",
          "package": "numeric-prelude",
          "source": "src/Algebra-Ring.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "Ring",
          "package": "numeric-prelude",
          "partial": "Ring",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRing encapsulates the mathematical structure\nof a (not necessarily commutative) ring, with the laws\n\u003c/p\u003e\u003cpre\u003e\n  a * (b * c) === (a * b) * c\n      one * a === a\n      a * one === a\n  a * (b + c) === a * b + a * c\n\u003c/pre\u003e\u003cp\u003eTypical examples include integers, polynomials, matrices, and quaternions.\n\u003c/p\u003e\u003cp\u003eMinimal definition: \u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e, (\u003ccode\u003e\u003ca\u003eone\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efromInteger\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Algebra.Ring",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Ring.html#C",
          "type": "class"
        },
        "index": {
          "description": "Ring encapsulates the mathematical structure of not necessarily commutative ring with the laws one one Typical examples include integers polynomials matrices and quaternions Minimal definition one or fromInteger",
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "(*)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Ring.html#%2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "(*) *",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe exponent has fixed type \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e in order\n    to avoid an arbitrarily limitted range of exponents,\n    but to reduce the need for the compiler to guess the type (default type).\n    In practice the exponent is most oftenly fixed, and is most oftenly \u003ccode\u003e2\u003c/code\u003e.\n    Fixed exponents can be optimized away and\n    thus the expensive computation of \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003es doesn't matter.\n    The previous solution used a \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e constrained type\n    and the exponent was converted to Integer before computation.\n    So the current solution is not less efficient.\n\u003c/p\u003e\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003e^\u003c/a\u003e\u003c/code\u003e with more flexibility is provided by \u003ccode\u003e\u003ca\u003eringPower\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Algebra.Ring",
          "name": "(^)",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer -\u003e a",
          "source": "src/Algebra-Ring.html#%5E",
          "type": "method"
        },
        "index": {
          "description": "The exponent has fixed type Integer in order to avoid an arbitrarily limitted range of exponents but to reduce the need for the compiler to guess the type default type In practice the exponent is most oftenly fixed and is most oftenly Fixed exponents can be optimized away and thus the expensive computation of Integer doesn matter The previous solution used constrained type and the exponent was converted to Integer before computation So the current solution is not less efficient variant of with more flexibility is provided by ringPower",
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "(^) ^",
          "normalized": "a-\u003eInteger-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003eInteger-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "fromInteger",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e a",
          "source": "src/Algebra-Ring.html#fromInteger",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "fromInteger",
          "normalized": "Integer-\u003ea",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "Integer-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "one",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-Ring.html#one",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "one",
          "package": "numeric-prelude",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.Ring\",\"NumericPrelude.Numeric\"]",
          "name": "product",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Ring.html#product",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:product\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:product\"]"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "product",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.Ring\",\"NumericPrelude.Numeric\"]",
          "name": "product1",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Ring.html#product1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:product1\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:product1\"]"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "product1",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:product1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propAssociative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Ring.html#propAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propAssociative",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Associative",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommutativity need not be satisfied by all instances of \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
          "module": "Algebra.Ring",
          "name": "propCommutative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Ring.html#propCommutative",
          "type": "function"
        },
        "index": {
          "description": "Commutativity need not be satisfied by all instances of",
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propCommutative",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Commutative",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propCommutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propLeftDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Ring.html#propLeftDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propLeftDistributive",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Left Distributive",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propLeftDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propLeftIdentity",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Ring.html#propLeftIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propLeftIdentity",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Left Identity",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propLeftIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propPowerCascade",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer -\u003e Integer -\u003e Property",
          "source": "src/Algebra-Ring.html#propPowerCascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propPowerCascade",
          "normalized": "a-\u003eInteger-\u003eInteger-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Power Cascade",
          "signature": "a-\u003eInteger-\u003eInteger-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propPowerCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propPowerDistributive",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e a -\u003e a -\u003e Property",
          "source": "src/Algebra-Ring.html#propPowerDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propPowerDistributive",
          "normalized": "Integer-\u003ea-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Power Distributive",
          "signature": "Integer-\u003ea-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propPowerDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propPowerProduct",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer -\u003e Integer -\u003e Property",
          "source": "src/Algebra-Ring.html#propPowerProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propPowerProduct",
          "normalized": "a-\u003eInteger-\u003eInteger-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Power Product",
          "signature": "a-\u003eInteger-\u003eInteger-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propPowerProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propRightDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Ring.html#propRightDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propRightDistributive",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Right Distributive",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propRightDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "propRightIdentity",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Ring.html#propRightIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "propRightIdentity",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Right Identity",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:propRightIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Ring",
          "name": "scalarProduct",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e a",
          "source": "src/Algebra-Ring.html#scalarProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "scalarProduct",
          "normalized": "[a]-\u003e[a]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Product",
          "signature": "[a]-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:scalarProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.Ring\",\"NumericPrelude.Numeric\"]",
          "name": "sqr",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Ring.html#sqr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:sqr\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:sqr\"]"
        },
        "index": {
          "hierarchy": "Algebra Ring",
          "module": "Algebra.Ring",
          "name": "sqr",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Ring.html#v:sqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ToInteger",
          "name": "ToInteger",
          "package": "numeric-prelude",
          "source": "src/Algebra-ToInteger.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra ToInteger",
          "module": "Algebra.ToInteger",
          "name": "ToInteger",
          "package": "numeric-prelude",
          "partial": "To Integer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe two classes \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e\nexist to allow convenient conversions,\nprimarily between the built-in types.\nThey should satisfy\n\u003c/p\u003e\u003cpre\u003e   fromInteger .  toInteger === id\n    toRational .  toInteger === toRational\n\u003c/pre\u003e\u003cp\u003eConversions must be lossless,\nthat is, they do not round in any way.\nFor rounding see \u003ca\u003eAlgebra.RealRing\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eI think that the RealIntegral superclass is too restrictive.\nNon-negative numbers are not a ring,\nbut can be easily converted to Integers.\n\u003c/p\u003e",
          "module": "Algebra.ToInteger",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-ToInteger.html#C",
          "type": "class"
        },
        "index": {
          "description": "The two classes and exist to allow convenient conversions primarily between the built-in types They should satisfy fromInteger toInteger id toRational toInteger toRational Conversions must be lossless that is they do not round in any way For rounding see Algebra.RealRing think that the RealIntegral superclass is too restrictive Non-negative numbers are not ring but can be easily converted to Integers",
          "hierarchy": "Algebra ToInteger",
          "module": "Algebra.ToInteger",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA prefix function of '(Algebra.Field.^-)'.\nIt has a generalised exponent.\n\u003c/p\u003e",
          "module": "[\"Algebra.ToInteger\",\"NumericPrelude.Numeric\"]",
          "name": "fieldPower",
          "package": "numeric-prelude",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Algebra-ToInteger.html#fieldPower",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#v:fieldPower\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:fieldPower\"]"
        },
        "index": {
          "description": "prefix function of Algebra.Field It has generalised exponent",
          "hierarchy": "Algebra ToInteger",
          "module": "Algebra.ToInteger",
          "name": "fieldPower",
          "normalized": "a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#v:fieldPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.ToInteger\",\"NumericPrelude.Numeric\"]",
          "name": "fromIntegral",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-ToInteger.html#fromIntegral",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#v:fromIntegral\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:fromIntegral\"]"
        },
        "index": {
          "hierarchy": "Algebra ToInteger",
          "module": "Algebra.ToInteger",
          "name": "fromIntegral",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Integral",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#v:fromIntegral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA prefix function of '(Algebra.Ring.^)'\nwith a parameter order that fits the needs of partial application\nand function composition.\nIt has generalised exponent.\n\u003c/p\u003e\u003cp\u003eSee: Argument order of \u003ccode\u003eexpNat\u003c/code\u003e on\n\u003ca\u003ehttp://www.haskell.org/pipermail/haskell-cafe/2006-September/018022.html\u003c/a\u003e\n\u003c/p\u003e",
          "module": "[\"Algebra.ToInteger\",\"NumericPrelude.Numeric\"]",
          "name": "ringPower",
          "package": "numeric-prelude",
          "signature": "b -\u003e a -\u003e a",
          "source": "src/Algebra-ToInteger.html#ringPower",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#v:ringPower\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:ringPower\"]"
        },
        "index": {
          "description": "prefix function of Algebra.Ring with parameter order that fits the needs of partial application and function composition It has generalised exponent See Argument order of expNat on http www.haskell.org pipermail haskell-cafe September html",
          "hierarchy": "Algebra ToInteger",
          "module": "Algebra.ToInteger",
          "name": "ringPower",
          "normalized": "a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#v:ringPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ToInteger",
          "name": "toInteger",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer",
          "source": "src/Algebra-ToInteger.html#toInteger",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra ToInteger",
          "module": "Algebra.ToInteger",
          "name": "toInteger",
          "normalized": "a-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToInteger.html#v:toInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ToRational",
          "name": "ToRational",
          "package": "numeric-prelude",
          "source": "src/Algebra-ToRational.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra ToRational",
          "module": "Algebra.ToRational",
          "name": "ToRational",
          "package": "numeric-prelude",
          "partial": "To Rational",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToRational.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class allows lossless conversion\nfrom any representation of a rational to the fixed \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e type.\n\"Lossless\" means - don't do any rounding.\nFor rounding see \u003ca\u003eAlgebra.RealRing\u003c/a\u003e.\nWith the instances for \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e\nwe acknowledge that these types actually represent rationals\nrather than (approximated) real numbers.\nHowever, this contradicts to the \u003ccode\u003e\u003ca\u003eTranscendental\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e\u003cp\u003eLaws that must be satisfied by instances:\n\u003c/p\u003e\u003cpre\u003e  fromRational' . toRational === id\n\u003c/pre\u003e",
          "module": "Algebra.ToRational",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-ToRational.html#C",
          "type": "class"
        },
        "index": {
          "description": "This class allows lossless conversion from any representation of rational to the fixed Rational type Lossless means don do any rounding For rounding see Algebra.RealRing With the instances for Float and Double we acknowledge that these types actually represent rationals rather than approximated real numbers However this contradicts to the Transcendental class Laws that must be satisfied by instances fromRational toRational id",
          "hierarchy": "Algebra ToRational",
          "module": "Algebra.ToRational",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToRational.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt should hold\n\u003c/p\u003e\u003cpre\u003e realToField = fromRational' . toRational\n\u003c/pre\u003e\u003cp\u003ebut it should be much more efficient for particular pairs of types,\nsuch as converting \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e.\nThis achieved by optimizer rules.\n\u003c/p\u003e",
          "module": "Algebra.ToRational",
          "name": "realToField",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-ToRational.html#realToField",
          "type": "function"
        },
        "index": {
          "description": "It should hold realToField fromRational toRational but it should be much more efficient for particular pairs of types such as converting Float to Double This achieved by optimizer rules",
          "hierarchy": "Algebra ToRational",
          "module": "Algebra.ToRational",
          "name": "realToField",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "To Field",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToRational.html#v:realToField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLossless conversion from any representation of a rational to \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.ToRational",
          "name": "toRational",
          "package": "numeric-prelude",
          "signature": "a -\u003e Rational",
          "source": "src/Algebra-ToRational.html#toRational",
          "type": "method"
        },
        "index": {
          "description": "Lossless conversion from any representation of rational to Rational",
          "hierarchy": "Algebra ToRational",
          "module": "Algebra.ToRational",
          "name": "toRational",
          "normalized": "a-\u003eRational",
          "package": "numeric-prelude",
          "partial": "Rational",
          "signature": "a-\u003eRational",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ToRational.html#v:toRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "Transcendental",
          "package": "numeric-prelude",
          "source": "src/Algebra-Transcendental.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "Transcendental",
          "package": "numeric-prelude",
          "partial": "Transcendental",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranscendental is the type of numbers supporting the elementary\ntranscendental functions.  Examples include real numbers, complex\nnumbers, and computable reals represented as a lazy list of rational\napproximations.\n\u003c/p\u003e\u003cp\u003eNote the default declaration for a superclass.  See the comments\nbelow, under \u003ca\u003eInstance declaractions for superclasses\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThe semantics of these operations are rather ill-defined because of\nbranch cuts, etc.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition:\n     pi, exp, log, sin, cos, asin, acos, atan\n\u003c/p\u003e",
          "module": "Algebra.Transcendental",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Transcendental.html#C",
          "type": "class"
        },
        "index": {
          "description": "Transcendental is the type of numbers supporting the elementary transcendental functions Examples include real numbers complex numbers and computable reals represented as lazy list of rational approximations Note the default declaration for superclass See the comments below under Instance declaractions for superclasses The semantics of these operations are rather ill-defined because of branch cuts etc Minimal complete definition pi exp log sin cos asin acos atan",
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Algebra.Transcendental\",\"NumericPrelude.Numeric\"]",
          "name": "(^?)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Transcendental.html#%5E%3F",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:-94--63-\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-94--63-\"]"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "(^?) ^?",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:-94--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "asin",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asin",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "asin",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:asin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "asinh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asinh",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "asinh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:asinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "exp",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#exp",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "exp",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "logBase",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Transcendental.html#logBase",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "logBase",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Base",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:logBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "pi",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-Transcendental.html#pi",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "pi",
          "package": "numeric-prelude",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propCosAngleSum",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propCosAngleSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propCosAngleSum",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cos Angle Sum",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propCosAngleSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propCosDoubleAngle",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propCosDoubleAngle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propCosDoubleAngle",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cos Double Angle",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propCosDoubleAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propCosPeriod",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propCosPeriod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propCosPeriod",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cos Period",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propCosPeriod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propCosSquare",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propCosSquare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propCosSquare",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cos Square",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propCosSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propExpLog",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propExpLog",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propExpLog",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Exp Log",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propExpLog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propExpLogPower",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propExpLogPower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propExpLogPower",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Exp Log Power",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propExpLogPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propExpNeg",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propExpNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propExpNeg",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Exp Neg",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propExpNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propExpProduct",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propExpProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propExpProduct",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Exp Product",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propExpProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propLogExp",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propLogExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propLogExp",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Log Exp",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propLogExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propLogRecip",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propLogRecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propLogRecip",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Log Recip",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propLogRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propLogSum",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propLogSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propLogSum",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Log Sum",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propLogSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propPowerCascade",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propPowerCascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propPowerCascade",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Power Cascade",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propPowerCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propPowerDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propPowerDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propPowerDistributive",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Power Distributive",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propPowerDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propPowerProduct",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propPowerProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propPowerProduct",
          "normalized": "a-\u003ea-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Power Product",
          "signature": "a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propPowerProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propSinAngleSum",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propSinAngleSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propSinAngleSum",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Sin Angle Sum",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propSinAngleSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propSinDoubleAngle",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propSinDoubleAngle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propSinDoubleAngle",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Sin Double Angle",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propSinDoubleAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propSinPeriod",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propSinPeriod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propSinPeriod",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Sin Period",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propSinPeriod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propSinSquare",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propSinSquare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propSinSquare",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Sin Square",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propSinSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propTanPeriod",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propTanPeriod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propTanPeriod",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Tan Period",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propTanPeriod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "propTrigonometricPythagoras",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Transcendental.html#propTrigonometricPythagoras",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "propTrigonometricPythagoras",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Trigonometric Pythagoras",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:propTrigonometricPythagoras"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "sin",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sin",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "sin",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Transcendental",
          "name": "sinh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sinh",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Transcendental",
          "module": "Algebra.Transcendental",
          "name": "sinh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Transcendental.html#v:sinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "Units",
          "package": "numeric-prelude",
          "source": "src/Algebra-Units.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "Units",
          "package": "numeric-prelude",
          "partial": "Units",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class lets us deal with the units in a ring.\n\u003ccode\u003e\u003ca\u003eisUnit\u003c/a\u003e\u003c/code\u003e tells whether an element is a unit.\nThe other operations let us canonically\nwrite an element as a unit times another element.\nTwo elements a, b of a ring R are _associates_ if a=b*u for a unit u.\nFor an element a, we want to write it as a=b*u where b is an associate of a.\nThe map (a-\u003eb) is called\n\u003ca\u003eStandardAssociate\u003c/a\u003e by Gap,\n\u003ca\u003eunitCanonical\u003c/a\u003e by Axiom,\nand \u003ca\u003ecanAssoc\u003c/a\u003e by DoCon.\nThe map (a-\u003eu) is called\n\u003ca\u003ecanInv\u003c/a\u003e by DoCon and\n\u003ca\u003eunitNormal(x).unit\u003c/a\u003e by Axiom.\n\u003c/p\u003e\u003cp\u003eThe laws are\n\u003c/p\u003e\u003cpre\u003e   stdAssociate x * stdUnit x === x\n     stdUnit x * stdUnitInv x === 1\n  isUnit u ==\u003e stdAssociate x === stdAssociate (x*u)\n\u003c/pre\u003e\u003cp\u003eCurrently some algorithms assume\n\u003c/p\u003e\u003cpre\u003e  stdAssociate(x*y) === stdAssociate x * stdAssociate y\n\u003c/pre\u003e\u003cp\u003eMinimal definition:\n   \u003ccode\u003e\u003ca\u003eisUnit\u003c/a\u003e\u003c/code\u003e and (\u003ccode\u003e\u003ca\u003estdUnit\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003estdUnitInv\u003c/a\u003e\u003c/code\u003e) and optionally \u003ccode\u003e\u003ca\u003estdAssociate\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Algebra.Units",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Units.html#C",
          "type": "class"
        },
        "index": {
          "description": "This class lets us deal with the units in ring isUnit tells whether an element is unit The other operations let us canonically write an element as unit times another element Two elements of ring are associates if for unit For an element we want to write it as where is an associate of The map is called StandardAssociate by Gap unitCanonical by Axiom and canAssoc by DoCon The map is called canInv by DoCon and unitNormal unit by Axiom The laws are stdAssociate stdUnit stdUnit stdUnitInv isUnit stdAssociate stdAssociate Currently some algorithms assume stdAssociate stdAssociate stdAssociate Minimal definition isUnit and stdUnit or stdUnitInv and optionally stdAssociate",
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "intAssociate",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Units.html#intAssociate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "intAssociate",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Associate",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:intAssociate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "intQuery",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Units.html#intQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "intQuery",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Query",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:intQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "intStandard",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Units.html#intStandard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "intStandard",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Standard",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:intStandard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "intStandardInverse",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Units.html#intStandardInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "intStandardInverse",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Standard Inverse",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:intStandardInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "isUnit",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Units.html#isUnit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "isUnit",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Unit",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:isUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrently some algorithms assume this property. \n\u003c/p\u003e",
          "module": "Algebra.Units",
          "name": "propAssociateProduct",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Units.html#propAssociateProduct",
          "type": "function"
        },
        "index": {
          "description": "Currently some algorithms assume this property",
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "propAssociateProduct",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Associate Product",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:propAssociateProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "propComposition",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Units.html#propComposition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "propComposition",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Composition",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:propComposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "propInverseUnit",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Units.html#propInverseUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "propInverseUnit",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Inverse Unit",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:propInverseUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "propUniqueAssociate",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e Property",
          "source": "src/Algebra-Units.html#propUniqueAssociate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "propUniqueAssociate",
          "normalized": "a-\u003ea-\u003eProperty",
          "package": "numeric-prelude",
          "partial": "Unique Associate",
          "signature": "a-\u003ea-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:propUniqueAssociate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Units",
          "name": "stdAssociate",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Units.html#stdAssociate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Units",
          "module": "Algebra.Units",
          "name": "stdAssociate",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Associate",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Units.html#v:stdAssociate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstraction of vectors\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Algebra.Vector",
          "name": "Vector",
          "package": "numeric-prelude",
          "source": "src/Algebra-Vector.html",
          "type": "module"
        },
        "index": {
          "description": "Abstraction of vectors",
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "Vector",
          "package": "numeric-prelude",
          "partial": "Vector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Module over a ring satisfies:\n\u003c/p\u003e\u003cpre\u003e   a *\u003e (b + c) === a *\u003e b + a *\u003e c\n   (a * b) *\u003e c === a *\u003e (b *\u003e c)\n   (a + b) *\u003e c === a *\u003e c + b *\u003e c\n\u003c/pre\u003e",
          "module": "Algebra.Vector",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-Vector.html#C",
          "type": "class"
        },
        "index": {
          "description": "Module over ring satisfies",
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe need a Haskell 98 type class\nwhich provides equality test for Vector type constructors.\n\u003c/p\u003e",
          "module": "Algebra.Vector",
          "name": "Eq",
          "package": "numeric-prelude",
          "source": "src/Algebra-Vector.html#Eq",
          "type": "class"
        },
        "index": {
          "description": "We need Haskell type class which provides equality test for Vector type constructors",
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "Eq",
          "package": "numeric-prelude",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#t:Eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escale a vector by a scalar\n\u003c/p\u003e",
          "module": "Algebra.Vector",
          "name": "(*\u003e)",
          "package": "numeric-prelude",
          "signature": "a -\u003e v a -\u003e v a",
          "source": "src/Algebra-Vector.html#%2A%3E",
          "type": "method"
        },
        "index": {
          "description": "scale vector by scalar",
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "(*\u003e) *\u003e",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "numeric-prelude",
          "signature": "a-\u003ev a-\u003ev a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd and subtract elements\n\u003c/p\u003e",
          "module": "Algebra.Vector",
          "name": "(\u003c+\u003e)",
          "package": "numeric-prelude",
          "signature": "v a -\u003e v a -\u003e v a",
          "source": "src/Algebra-Vector.html#%3C%2B%3E",
          "type": "method"
        },
        "index": {
          "description": "add and subtract elements",
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "numeric-prelude",
          "signature": "v a-\u003ev a-\u003ev a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Vector",
          "name": "eq",
          "package": "numeric-prelude",
          "signature": "v a -\u003e v a -\u003e Bool",
          "source": "src/Algebra-Vector.html#eq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "eq",
          "normalized": "a b-\u003ea b-\u003eBool",
          "package": "numeric-prelude",
          "signature": "v a-\u003ev a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Vector",
          "name": "functorScale",
          "package": "numeric-prelude",
          "signature": "a -\u003e v a -\u003e v a",
          "source": "src/Algebra-Vector.html#functorScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "functorScale",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "numeric-prelude",
          "partial": "Scale",
          "signature": "a-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:functorScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the linear combination of a list of vectors.\n\u003c/p\u003e",
          "module": "Algebra.Vector",
          "name": "linearComb",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [v a] -\u003e v a",
          "source": "src/Algebra-Vector.html#linearComb",
          "type": "function"
        },
        "index": {
          "description": "Compute the linear combination of list of vectors",
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "linearComb",
          "normalized": "[a]-\u003e[b a]-\u003eb a",
          "package": "numeric-prelude",
          "partial": "Comb",
          "signature": "[a]-\u003e[v a]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:linearComb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Vector",
          "name": "propCascade",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e v a -\u003e Bool",
          "source": "src/Algebra-Vector.html#propCascade",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "propCascade",
          "normalized": "a-\u003ea-\u003eb a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Cascade",
          "signature": "a-\u003ea-\u003ev a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:propCascade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Vector",
          "name": "propLeftDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e v a -\u003e Bool",
          "source": "src/Algebra-Vector.html#propLeftDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "propLeftDistributive",
          "normalized": "a-\u003ea-\u003eb a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Left Distributive",
          "signature": "a-\u003ea-\u003ev a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:propLeftDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Vector",
          "name": "propRightDistributive",
          "package": "numeric-prelude",
          "signature": "a -\u003e v a -\u003e v a -\u003e Bool",
          "source": "src/Algebra-Vector.html#propRightDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "propRightDistributive",
          "normalized": "a-\u003eb a-\u003eb a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Right Distributive",
          "signature": "a-\u003ev a-\u003ev a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:propRightDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ezero element of the vector space\n\u003c/p\u003e",
          "module": "Algebra.Vector",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "v a",
          "source": "src/Algebra-Vector.html#zero",
          "type": "method"
        },
        "index": {
          "description": "zero element of the vector space",
          "hierarchy": "Algebra Vector",
          "module": "Algebra.Vector",
          "name": "zero",
          "package": "numeric-prelude",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-Vector.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.VectorSpace",
          "name": "VectorSpace",
          "package": "numeric-prelude",
          "source": "src/Algebra-VectorSpace.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra VectorSpace",
          "module": "Algebra.VectorSpace",
          "name": "VectorSpace",
          "package": "numeric-prelude",
          "partial": "Vector Space",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-VectorSpace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.VectorSpace",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-VectorSpace.html#C",
          "type": "class"
        },
        "index": {
          "hierarchy": "Algebra VectorSpace",
          "module": "Algebra.VectorSpace",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-VectorSpace.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ZeroTestable",
          "name": "ZeroTestable",
          "package": "numeric-prelude",
          "source": "src/Algebra-ZeroTestable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra ZeroTestable",
          "module": "Algebra.ZeroTestable",
          "name": "ZeroTestable",
          "package": "numeric-prelude",
          "partial": "Zero Testable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ZeroTestable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaybe the naming should be according to Algebra.Unit:\nAlgebra.Zero as module name, and \u003ccode\u003equery\u003c/code\u003e as method name.\n\u003c/p\u003e",
          "module": "Algebra.ZeroTestable",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/Algebra-ZeroTestable.html#C",
          "type": "class"
        },
        "index": {
          "description": "Maybe the naming should be according to Algebra.Unit Algebra.Zero as module name and query as method name",
          "hierarchy": "Algebra ZeroTestable",
          "module": "Algebra.ZeroTestable",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ZeroTestable.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if a number is the zero element.\nThis test is not possible for all \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e types,\nsince e.g. a function type does not belong to Eq.\nisZero is possible for some types where (==zero) fails\nbecause there is no unique zero.\nExamples are\nvector (the length of the zero vector is unknown),\nphysical values (the unit of a zero quantity is unknown),\nresidue class (the modulus is unknown).\n\u003c/p\u003e",
          "module": "Algebra.ZeroTestable",
          "name": "defltIsZero",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-ZeroTestable.html#defltIsZero",
          "type": "function"
        },
        "index": {
          "description": "Checks if number is the zero element This test is not possible for all types since e.g function type does not belong to Eq isZero is possible for some types where zero fails because there is no unique zero Examples are vector the length of the zero vector is unknown physical values the unit of zero quantity is unknown residue class the modulus is unknown",
          "hierarchy": "Algebra ZeroTestable",
          "module": "Algebra.ZeroTestable",
          "name": "defltIsZero",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Is Zero",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ZeroTestable.html#v:defltIsZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.ZeroTestable",
          "name": "isZero",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-ZeroTestable.html#isZero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra ZeroTestable",
          "module": "Algebra.ZeroTestable",
          "name": "isZero",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Zero",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Algebra-ZeroTestable.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe generic case of a k-algebra generated by a monoid.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.Algebra",
          "name": "Algebra",
          "package": "numeric-prelude",
          "source": "src/MathObj-Algebra.html",
          "type": "module"
        },
        "index": {
          "description": "The generic case of k-algebra generated by monoid",
          "hierarchy": "MathObj Algebra",
          "module": "MathObj.Algebra",
          "name": "Algebra",
          "package": "numeric-prelude",
          "partial": "Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Algebra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Algebra",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Algebra.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "MathObj Algebra",
          "module": "MathObj.Algebra",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Algebra.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Algebra",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons (Map a b)",
          "source": "src/MathObj-Algebra.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Algebra",
          "module": "MathObj.Algebra",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Algebra.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Algebra",
          "name": "monomial",
          "package": "numeric-prelude",
          "signature": "a -\u003e b -\u003e T a b",
          "source": "src/MathObj-Algebra.html#monomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Algebra",
          "module": "MathObj.Algebra",
          "name": "monomial",
          "normalized": "a-\u003eb-\u003eT a b",
          "package": "numeric-prelude",
          "signature": "a-\u003eb-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Algebra.html#v:monomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Algebra",
          "name": "mulMonomial",
          "package": "numeric-prelude",
          "signature": "(a, b) -\u003e (a, b) -\u003e (a, b)",
          "source": "src/MathObj-Algebra.html#mulMonomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Algebra",
          "module": "MathObj.Algebra",
          "name": "mulMonomial",
          "normalized": "(a,b)-\u003e(a,b)-\u003e(a,b)",
          "package": "numeric-prelude",
          "partial": "Monomial",
          "signature": "(a,b)-\u003e(a,b)-\u003e(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Algebra.html#v:mulMonomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Algebra",
          "name": "zipWith",
          "package": "numeric-prelude",
          "signature": "(b -\u003e b -\u003e b) -\u003e T a b -\u003e T a b -\u003e T a b",
          "source": "src/MathObj-Algebra.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Algebra",
          "module": "MathObj.Algebra",
          "name": "zipWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT b a-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "partial": "With",
          "signature": "(b-\u003eb-\u003eb)-\u003eT a b-\u003eT a b-\u003eT a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Algebra.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDiscreteMap was originally intended as a type class\nthat unifies Map and Array.\nOne should be able to simply choose between\n - Map for sparse arrays\n - Array for full arrays.\n\u003c/p\u003e\u003cp\u003eHowever, the Edison package provides the class AssocX\nwhich already exists for that purpose.\n\u003c/p\u003e\u003cp\u003eCurrently I use this module for some numeric instances of Data.Map.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.DiscreteMap",
          "name": "DiscreteMap",
          "package": "numeric-prelude",
          "source": "src/MathObj-DiscreteMap.html",
          "type": "module"
        },
        "index": {
          "description": "DiscreteMap was originally intended as type class that unifies Map and Array One should be able to simply choose between Map for sparse arrays Array for full arrays However the Edison package provides the class AssocX which already exists for that purpose Currently use this module for some numeric instances of Data.Map",
          "hierarchy": "MathObj DiscreteMap",
          "module": "MathObj.DiscreteMap",
          "name": "DiscreteMap",
          "package": "numeric-prelude",
          "partial": "Discrete Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-DiscreteMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all zero values from the map.\n\u003c/p\u003e",
          "module": "MathObj.DiscreteMap",
          "name": "strip",
          "package": "numeric-prelude",
          "signature": "Map i v -\u003e Map i v",
          "source": "src/MathObj-DiscreteMap.html#strip",
          "type": "function"
        },
        "index": {
          "description": "Remove all zero values from the map",
          "hierarchy": "MathObj DiscreteMap",
          "module": "MathObj.DiscreteMap",
          "name": "strip",
          "normalized": "Map a b-\u003eMap a b",
          "package": "numeric-prelude",
          "signature": "Map i v-\u003eMap i v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-DiscreteMap.html#v:strip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePolynomials with negative and positive exponents.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "LaurentPolynomial",
          "package": "numeric-prelude",
          "source": "src/MathObj-LaurentPolynomial.html",
          "type": "module"
        },
        "index": {
          "description": "Polynomials with negative and positive exponents",
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "LaurentPolynomial",
          "package": "numeric-prelude",
          "partial": "Laurent Polynomial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePolynomial including negative exponents \n\u003c/p\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-LaurentPolynomial.html#T",
          "type": "data"
        },
        "index": {
          "description": "Polynomial including negative exponents",
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "(!)",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Int -\u003e a",
          "source": "src/MathObj-LaurentPolynomial.html#%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "(!) !",
          "normalized": "T a-\u003eInt-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-LaurentPolynomial.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "add",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "addShifted",
          "package": "numeric-prelude",
          "signature": "Int -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-LaurentPolynomial.html#addShifted",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "addShifted",
          "normalized": "Int-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Shifted",
          "signature": "Int-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:addShifted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd lists of numbers respecting a relative shift between the starts of the lists.\nThe shifts must be non-negative.\nThe list of relative shifts is one element shorter\nthan the list of summands.\nInfinitely many summands are permitted,\nprovided that runs of zero shifts are all finite.\n\u003c/p\u003e\u003cp\u003eWe could add the lists either with \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e or with \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e would be straightforward, but more time consuming (quadratic time)\nwhereas foldr is not so obvious but needs only linear time.\n\u003c/p\u003e\u003cp\u003e(stars denote the coefficients,\n frames denote what is contained in the interim results)\n\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e sums this way:\n\u003c/p\u003e\u003cpre\u003e | | | *******************************\n | | +--------------------------------\n | |          ************************\n | +----------------------------------\n |                        ************\n +------------------------------------\n\u003c/pre\u003e\u003cp\u003eI.e. \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e would use much time find the time differences\nby successive subtraction 1.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e mixes this way:\n\u003c/p\u003e\u003cpre\u003e     +--------------------------------\n     | *******************************\n     |      +-------------------------\n     |      | ************************\n     |      |           +-------------\n     |      |           | ************\n\u003c/pre\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "addShiftedMany",
          "package": "numeric-prelude",
          "signature": "[Int] -\u003e [[a]] -\u003e [a]",
          "source": "src/MathObj-LaurentPolynomial.html#addShiftedMany",
          "type": "function"
        },
        "index": {
          "description": "Add lists of numbers respecting relative shift between the starts of the lists The shifts must be non-negative The list of relative shifts is one element shorter than the list of summands Infinitely many summands are permitted provided that runs of zero shifts are all finite We could add the lists either with foldl or with foldr foldl would be straightforward but more time consuming quadratic time whereas foldr is not so obvious but needs only linear time stars denote the coefficients frames denote what is contained in the interim results foldl sums this way I.e foldl would use much time find the time differences by successive subtraction foldr mixes this way",
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "addShiftedMany",
          "normalized": "[Int]-\u003e[[a]]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Shifted Many",
          "signature": "[Int]-\u003e[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:addShiftedMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ep(exp(i&#183;x)) -\u003e conjugate(p(exp(i&#183;x)))\n\u003c/p\u003e\u003cp\u003eIf you interpret \u003ccode\u003e(p*)\u003c/code\u003e as a linear operator on the space of Laurent polynomials,\nthen \u003ccode\u003e(adjoint p *)\u003c/code\u003e is the adjoint operator.\n\u003c/p\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "adjoint",
          "package": "numeric-prelude",
          "signature": "T (T a) -\u003e T (T a)",
          "source": "src/MathObj-LaurentPolynomial.html#adjoint",
          "type": "function"
        },
        "index": {
          "description": "exp conjugate exp If you interpret as linear operator on the space of Laurent polynomials then adjoint is the adjoint operator",
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "adjoint",
          "normalized": "T(T a)-\u003eT(T a)",
          "package": "numeric-prelude",
          "signature": "T(T a)-\u003eT(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:adjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ep(z) -\u003e p(-z) \n\u003c/p\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "alternate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#alternate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "alternate",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:alternate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/MathObj-LaurentPolynomial.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "bounds",
          "package": "numeric-prelude",
          "signature": "T a -\u003e (Int, Int)",
          "source": "src/MathObj-LaurentPolynomial.html#bounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "bounds",
          "normalized": "T a-\u003e(Int,Int)",
          "package": "numeric-prelude",
          "signature": "T a-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "coeffs",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-LaurentPolynomial.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "coeffs",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:coeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "const",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#const",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "const",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "div",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#div",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "div",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "divExample",
          "package": "numeric-prelude",
          "signature": "T Rational",
          "source": "src/MathObj-LaurentPolynomial.html#divExample",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "divExample",
          "package": "numeric-prelude",
          "partial": "Example",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:divExample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTwo polynomials may be stored differently.\nThis function checks whether two values of type \u003ccode\u003eLaurentPolynomial\u003c/code\u003e\nactually represent the same polynomial.\n\u003c/p\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "equivalent",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e Bool",
          "source": "src/MathObj-LaurentPolynomial.html#equivalent",
          "type": "function"
        },
        "index": {
          "description": "Two polynomials may be stored differently This function checks whether two values of type LaurentPolynomial actually represent the same polynomial",
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "equivalent",
          "normalized": "T a-\u003eT a-\u003eBool",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:equivalent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "expon",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/MathObj-LaurentPolynomial.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "expon",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:expon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "fromCoeffs",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#fromCoeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "fromCoeffs",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Coeffs",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:fromCoeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "fromPolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#fromPolynomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "fromPolynomial",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:fromPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "fromPowerSeries",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#fromPowerSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "fromPowerSeries",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:fromPowerSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "fromShiftCoeffs",
          "package": "numeric-prelude",
          "signature": "Int -\u003e [a] -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#fromShiftCoeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "fromShiftCoeffs",
          "normalized": "Int-\u003e[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Shift Coeffs",
          "signature": "Int-\u003e[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:fromShiftCoeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "identical",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e Bool",
          "source": "src/MathObj-LaurentPolynomial.html#identical",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "identical",
          "normalized": "T a-\u003eT a-\u003eBool",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:identical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a Laurent polynomial has only the absolute term,\nthat is, it represents the constant polynomial.\n\u003c/p\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "isAbsolute",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Bool",
          "source": "src/MathObj-LaurentPolynomial.html#isAbsolute",
          "type": "function"
        },
        "index": {
          "description": "Check whether Laurent polynomial has only the absolute term that is it represents the constant polynomial",
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "isAbsolute",
          "normalized": "T a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Absolute",
          "signature": "T a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:isAbsolute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "mul",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "negate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "negate",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ep(z) -\u003e p(1/z) \n\u003c/p\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "reverse",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#reverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "reverse",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "series",
          "package": "numeric-prelude",
          "signature": "[T a] -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#series",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "series",
          "normalized": "[T a]-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[T a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:series"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "shift",
          "package": "numeric-prelude",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#shift",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "shift",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.LaurentPolynomial",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "sub",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: In order to avoid confusion with Polynomial.translate, use \u003ccode\u003e\u003ca\u003eshift\u003c/a\u003e\u003c/code\u003e instead\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.LaurentPolynomial",
          "name": "translate",
          "package": "numeric-prelude",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "src/MathObj-LaurentPolynomial.html#translate",
          "type": "function"
        },
        "index": {
          "description": "Deprecated In order to avoid confusion with Polynomial.translate use shift instead",
          "hierarchy": "MathObj LaurentPolynomial",
          "module": "MathObj.LaurentPolynomial",
          "name": "translate",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-LaurentPolynomial.html#v:translate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRoutines and abstractions for Matrices and\nbasic linear algebra over fields or rings.\n\u003c/p\u003e\u003cp\u003eWe stick to simple Int indices.\nAlthough advanced indices would be nice\ne.g. for matrices with sub-matrices,\nthis is not easily implemented since arrays\ndo only support a lower and an upper bound\nbut no additional parameters.\n\u003c/p\u003e\u003cp\u003eToDo:\n - Matrix inverse, determinant (see htam:Matrix)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.Matrix",
          "name": "Matrix",
          "package": "numeric-prelude",
          "source": "src/MathObj-Matrix.html",
          "type": "module"
        },
        "index": {
          "description": "Routines and abstractions for Matrices and basic linear algebra over fields or rings We stick to simple Int indices Although advanced indices would be nice e.g for matrices with sub-matrices this is not easily implemented since arrays do only support lower and an upper bound but no additional parameters ToDo Matrix inverse determinant see htam Matrix",
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "Matrix",
          "package": "numeric-prelude",
          "partial": "Matrix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "Dimension",
          "package": "numeric-prelude",
          "source": "src/MathObj-Matrix.html#Dimension",
          "type": "type"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "Dimension",
          "package": "numeric-prelude",
          "partial": "Dimension",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#t:Dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA matrix is a twodimensional array, indexed by integers.\n\u003c/p\u003e",
          "module": "MathObj.Matrix",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Matrix.html#T",
          "type": "data"
        },
        "index": {
          "description": "matrix is twodimensional array indexed by integers",
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "columns",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [[a]]",
          "source": "src/MathObj-Matrix.html#columns",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "columns",
          "normalized": "T a-\u003e[[a]]",
          "package": "numeric-prelude",
          "signature": "T a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:columns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "diagonal",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-Matrix.html#diagonal",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "diagonal",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:diagonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "dimension",
          "package": "numeric-prelude",
          "signature": "T a -\u003e (Dimension, Dimension)",
          "source": "src/MathObj-Matrix.html#dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "dimension",
          "normalized": "T a-\u003e(Dimension,Dimension)",
          "package": "numeric-prelude",
          "signature": "T a-\u003e(Dimension,Dimension)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "format",
          "package": "numeric-prelude",
          "signature": "T a -\u003e String",
          "source": "src/MathObj-Matrix.html#format",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "format",
          "normalized": "T a-\u003eString",
          "package": "numeric-prelude",
          "signature": "T a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:format"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "fromColumns",
          "package": "numeric-prelude",
          "signature": "Dimension -\u003e Dimension -\u003e [[a]] -\u003e T a",
          "source": "src/MathObj-Matrix.html#fromColumns",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "fromColumns",
          "normalized": "Dimension-\u003eDimension-\u003e[[a]]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Columns",
          "signature": "Dimension-\u003eDimension-\u003e[[a]]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:fromColumns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "fromList",
          "package": "numeric-prelude",
          "signature": "Dimension -\u003e Dimension -\u003e [a] -\u003e T a",
          "source": "src/MathObj-Matrix.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "fromList",
          "normalized": "Dimension-\u003eDimension-\u003e[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "List",
          "signature": "Dimension-\u003eDimension-\u003e[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "fromRows",
          "package": "numeric-prelude",
          "signature": "Dimension -\u003e Dimension -\u003e [[a]] -\u003e T a",
          "source": "src/MathObj-Matrix.html#fromRows",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "fromRows",
          "normalized": "Dimension-\u003eDimension-\u003e[[a]]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Rows",
          "signature": "Dimension-\u003eDimension-\u003e[[a]]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:fromRows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "index",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Dimension -\u003e Dimension -\u003e a",
          "source": "src/MathObj-Matrix.html#index",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "index",
          "normalized": "T a-\u003eDimension-\u003eDimension-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003eDimension-\u003eDimension-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "numColumns",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Dimension",
          "source": "src/MathObj-Matrix.html#numColumns",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "numColumns",
          "normalized": "T a-\u003eDimension",
          "package": "numeric-prelude",
          "partial": "Columns",
          "signature": "T a-\u003eDimension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:numColumns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "numRows",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Dimension",
          "source": "src/MathObj-Matrix.html#numRows",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "numRows",
          "normalized": "T a-\u003eDimension",
          "package": "numeric-prelude",
          "partial": "Rows",
          "signature": "T a-\u003eDimension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:numRows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "one",
          "package": "numeric-prelude",
          "signature": "Dimension -\u003e T a",
          "source": "src/MathObj-Matrix.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "one",
          "normalized": "Dimension-\u003eT a",
          "package": "numeric-prelude",
          "signature": "Dimension-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "random",
          "package": "numeric-prelude",
          "signature": "Dimension -\u003e Dimension -\u003e g -\u003e (T a, g)",
          "source": "src/MathObj-Matrix.html#random",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "random",
          "normalized": "Dimension-\u003eDimension-\u003ea-\u003e(T b,a)",
          "package": "numeric-prelude",
          "signature": "Dimension-\u003eDimension-\u003eg-\u003e(T a,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:random"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "randomR",
          "package": "numeric-prelude",
          "signature": "Dimension -\u003e Dimension -\u003e (a, a) -\u003e g -\u003e (T a, g)",
          "source": "src/MathObj-Matrix.html#randomR",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "randomR",
          "normalized": "Dimension-\u003eDimension-\u003e(a,a)-\u003eb-\u003e(T a,b)",
          "package": "numeric-prelude",
          "signature": "Dimension-\u003eDimension-\u003e(a,a)-\u003eg-\u003e(T a,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:randomR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "rows",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [[a]]",
          "source": "src/MathObj-Matrix.html#rows",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "rows",
          "normalized": "T a-\u003e[[a]]",
          "package": "numeric-prelude",
          "signature": "T a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:rows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/MathObj-Matrix.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "scale",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransposition of matrices is just transposition in the sense of Data.List.\n\u003c/p\u003e",
          "module": "MathObj.Matrix",
          "name": "transpose",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-Matrix.html#transpose",
          "type": "function"
        },
        "index": {
          "description": "Transposition of matrices is just transposition in the sense of Data.List",
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "transpose",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "Dimension -\u003e Dimension -\u003e T a",
          "source": "src/MathObj-Matrix.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "zero",
          "normalized": "Dimension-\u003eDimension-\u003eT a",
          "package": "numeric-prelude",
          "signature": "Dimension-\u003eDimension-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Matrix",
          "name": "zipWith",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e T b -\u003e T c",
          "source": "src/MathObj-Matrix.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Matrix",
          "module": "MathObj.Matrix",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "package": "numeric-prelude",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Matrix.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "Monoid",
          "package": "numeric-prelude",
          "source": "src/MathObj-Monoid.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "Monoid",
          "package": "numeric-prelude",
          "partial": "Monoid",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is only a monoid for non-negative numbers.\n\u003c/p\u003e\u003cpre\u003e idt \u003c*\u003e GCD (-2) = GCD 2\n\u003c/pre\u003e\u003cp\u003eThus, use this Monoid only for non-negative numbers!\n\u003c/p\u003e",
          "module": "MathObj.Monoid",
          "name": "GCD",
          "package": "numeric-prelude",
          "source": "src/MathObj-Monoid.html#GCD",
          "type": "newtype"
        },
        "index": {
          "description": "It is only monoid for non-negative numbers idt GCD GCD Thus use this Monoid only for non-negative numbers",
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "GCD",
          "package": "numeric-prelude",
          "partial": "GCD",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#t:GCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "LCM",
          "package": "numeric-prelude",
          "source": "src/MathObj-Monoid.html#LCM",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "LCM",
          "package": "numeric-prelude",
          "partial": "LCM",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#t:LCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eNothing\u003c/code\u003e is the smallest element.\n\u003c/p\u003e",
          "module": "MathObj.Monoid",
          "name": "Max",
          "package": "numeric-prelude",
          "source": "src/MathObj-Monoid.html#Max",
          "type": "newtype"
        },
        "index": {
          "description": "Nothing is the smallest element",
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "Max",
          "package": "numeric-prelude",
          "partial": "Max",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#t:Max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eNothing\u003c/code\u003e is the largest element.\n\u003c/p\u003e",
          "module": "MathObj.Monoid",
          "name": "Min",
          "package": "numeric-prelude",
          "source": "src/MathObj-Monoid.html#Min",
          "type": "newtype"
        },
        "index": {
          "description": "Nothing is the largest element",
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "Min",
          "package": "numeric-prelude",
          "partial": "Min",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#t:Min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "GCD",
          "package": "numeric-prelude",
          "signature": "GCD",
          "source": "src/MathObj-Monoid.html#GCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "GCD",
          "package": "numeric-prelude",
          "partial": "GCD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:GCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "LCM",
          "package": "numeric-prelude",
          "signature": "LCM",
          "source": "src/MathObj-Monoid.html#LCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "LCM",
          "package": "numeric-prelude",
          "partial": "LCM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:LCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "Max",
          "package": "numeric-prelude",
          "signature": "Max",
          "source": "src/MathObj-Monoid.html#Max",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "Max",
          "package": "numeric-prelude",
          "partial": "Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:Max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "Min",
          "package": "numeric-prelude",
          "signature": "Min",
          "source": "src/MathObj-Monoid.html#Min",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "Min",
          "package": "numeric-prelude",
          "partial": "Min",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:Min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "runGCD",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/MathObj-Monoid.html#GCD",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "runGCD",
          "package": "numeric-prelude",
          "partial": "GCD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:runGCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "runLCM",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/MathObj-Monoid.html#LCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "runLCM",
          "package": "numeric-prelude",
          "partial": "LCM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:runLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "runMax",
          "package": "numeric-prelude",
          "signature": "Maybe a",
          "source": "src/MathObj-Monoid.html#Max",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "runMax",
          "package": "numeric-prelude",
          "partial": "Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:runMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Monoid",
          "name": "runMin",
          "package": "numeric-prelude",
          "signature": "Maybe a",
          "source": "src/MathObj-Monoid.html#Min",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Monoid",
          "module": "MathObj.Monoid",
          "name": "runMin",
          "package": "numeric-prelude",
          "partial": "Min",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Monoid.html#v:runMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of partial fractions.\nUseful e.g. for fractions of integers and fractions of polynomials.\n\u003c/p\u003e\u003cp\u003eFor the considered ring the prime factorization must be unique.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.PartialFraction",
          "name": "PartialFraction",
          "package": "numeric-prelude",
          "source": "src/MathObj-PartialFraction.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of partial fractions Useful e.g for fractions of integers and fractions of polynomials For the considered ring the prime factorization must be unique",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "PartialFraction",
          "package": "numeric-prelude",
          "partial": "Partial Fraction",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eCons z (indexMapFromList [(x0,[y00,y01]), (x1,[y10]), (x2,[y20,y21,y22])])\u003c/code\u003e\nrepresents the partial fraction\n\u003ccode\u003ez + y00\u003cem\u003ex0 + y01\u003c/em\u003ex0^2 + y10\u003cem\u003ex1 + y20\u003c/em\u003ex2 + y21\u003cem\u003ex2^2 + y22\u003c/em\u003ex2^3\u003c/code\u003e\nThe denominators \u003ccode\u003ex0, x1, x2, ...\u003c/code\u003e must be irreducible,\nbut we can't check this in general.\nIt is also not enough to have relatively prime denominators,\nbecause when adding two partial fraction representations\nthere might concur denominators that have non-trivial common divisors.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-PartialFraction.html#T",
          "type": "data"
        },
        "index": {
          "description": "Cons indexMapFromList x0 y00 y01 x1 y10 x2 y20 y21 y22 represents the partial fraction y00 x0 y01 x0 y10 x1 y20 x2 y21 x2 y22 x2 The denominators x0 x1 x2 must be irreducible but we can check this in general It is also not enough to have relatively prime denominators because when adding two partial fraction representations there might concur denominators that have non-trivial common divisors",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons a (Map (ToOrd a) [a])",
          "source": "src/MathObj-PartialFraction.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "Cons",
          "normalized": "Cons a(Map(ToOrd a)[a])",
          "package": "numeric-prelude",
          "partial": "Cons",
          "signature": "Cons a(Map(ToOrd a)[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/MathObj-PartialFraction.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCf. Number.Positional\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "carryRipple",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e (a, [a])",
          "source": "src/MathObj-PartialFraction.html#carryRipple",
          "type": "function"
        },
        "index": {
          "description": "Cf Number.Positional",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "carryRipple",
          "normalized": "a-\u003e[a]-\u003e(a,[a])",
          "package": "numeric-prelude",
          "partial": "Ripple",
          "signature": "a-\u003e[a]-\u003e(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:carryRipple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efromFactoredFraction x y\u003c/code\u003e\ncomputes the partial fraction representation of \u003ccode\u003ey % product x\u003c/code\u003e,\nwhere the elements of \u003ccode\u003ex\u003c/code\u003e must be irreducible.\nThe function transforms the factors into their standard form\nwith respect to unit factors.\n\u003c/p\u003e\u003cp\u003eThere are more direct methods for special cases\nlike polynomials over rational numbers\nwhere the denominators are linear factors.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "fromFactoredFraction",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#fromFactoredFraction",
          "type": "function"
        },
        "index": {
          "description": "fromFactoredFraction computes the partial fraction representation of product where the elements of must be irreducible The function transforms the factors into their standard form with respect to unit factors There are more direct methods for special cases like polynomials over rational numbers where the denominators are linear factors",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "fromFactoredFraction",
          "normalized": "[a]-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Factored Fraction",
          "signature": "[a]-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:fromFactoredFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "fromFactoredFractionAlt",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#fromFactoredFractionAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "fromFactoredFractionAlt",
          "normalized": "[a]-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Factored Fraction Alt",
          "signature": "[a]-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:fromFactoredFractionAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnchecked construction.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "fromFractionSum",
          "package": "numeric-prelude",
          "signature": "a -\u003e [(a, [a])] -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#fromFractionSum",
          "type": "function"
        },
        "index": {
          "description": "Unchecked construction",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "fromFractionSum",
          "normalized": "a-\u003e[(a,[a])]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Fraction Sum",
          "signature": "a-\u003e[(a,[a])]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:fromFractionSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "fromValue",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#fromValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "fromValue",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Value",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:fromValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "hornerRev",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e a",
          "source": "src/MathObj-PartialFraction.html#hornerRev",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "hornerRev",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Rev",
          "signature": "a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:hornerRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "indexMapFromList",
          "package": "numeric-prelude",
          "signature": "[(a, b)] -\u003e Map (ToOrd a) b",
          "source": "src/MathObj-PartialFraction.html#indexMapFromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "indexMapFromList",
          "normalized": "[(a,b)]-\u003eMap(ToOrd a)b",
          "package": "numeric-prelude",
          "partial": "Map From List",
          "signature": "[(a,b)]-\u003eMap(ToOrd a)b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:indexMapFromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "indexMapMapWithKey",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e c) -\u003e Map (ToOrd a) b -\u003e Map (ToOrd a) c",
          "source": "src/MathObj-PartialFraction.html#indexMapMapWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "indexMapMapWithKey",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMap(ToOrd a)b-\u003eMap(ToOrd a)c",
          "package": "numeric-prelude",
          "partial": "Map Map With Key",
          "signature": "(a-\u003eb-\u003ec)-\u003eMap(ToOrd a)b-\u003eMap(ToOrd a)c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:indexMapMapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "indexMapToList",
          "package": "numeric-prelude",
          "signature": "Map (ToOrd a) b -\u003e [(a, b)]",
          "source": "src/MathObj-PartialFraction.html#indexMapToList",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "indexMapToList",
          "normalized": "Map(ToOrd a)b-\u003e[(a,b)]",
          "package": "numeric-prelude",
          "partial": "Map To List",
          "signature": "Map(ToOrd a)b-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:indexMapToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function on a specific element if it exists,\nand another function to the rest of the map.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "mapApplySplit",
          "package": "numeric-prelude",
          "signature": "a -\u003e (c -\u003e c -\u003e c) -\u003e (b -\u003e c) -\u003e (Map a b -\u003e Map a c) -\u003e Map a b -\u003e Map a c",
          "source": "src/MathObj-PartialFraction.html#mapApplySplit",
          "type": "function"
        },
        "index": {
          "description": "Apply function on specific element if it exists and another function to the rest of the map",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "mapApplySplit",
          "normalized": "a-\u003e(b-\u003eb-\u003eb)-\u003e(c-\u003eb)-\u003e(Map a c-\u003eMap a b)-\u003eMap a c-\u003eMap a b",
          "package": "numeric-prelude",
          "partial": "Apply Split",
          "signature": "a-\u003e(c-\u003ec-\u003ec)-\u003e(b-\u003ec)-\u003e(Map a b-\u003eMap a c)-\u003eMap a b-\u003eMap a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:mapApplySplit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "mul",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "mulFast",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#mulFast",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "mulFast",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Fast",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:mulFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransforms a product of two partial fractions\ninto a sum of two fractions.\nThe denominators must be at least relatively prime.\nSince \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e requires irreducible denominators,\nthese are also relatively prime.\n\u003c/p\u003e\u003cp\u003eExample: \u003ccode\u003emulFrac (1%6) (1%4)\u003c/code\u003e fails because of the common divisor \u003ccode\u003e2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "mulFrac",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e (a, a)",
          "source": "src/MathObj-PartialFraction.html#mulFrac",
          "type": "function"
        },
        "index": {
          "description": "Transforms product of two partial fractions into sum of two fractions The denominators must be at least relatively prime Since requires irreducible denominators these are also relatively prime Example mulFrac fails because of the common divisor",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "mulFrac",
          "normalized": "T a-\u003eT a-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Frac",
          "signature": "T a-\u003eT a-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:mulFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "mulFrac'",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e (T a, T a)",
          "source": "src/MathObj-PartialFraction.html#mulFrac%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "mulFrac'",
          "normalized": "T a-\u003eT a-\u003e(T a,T a)",
          "package": "numeric-prelude",
          "partial": "Frac'",
          "signature": "T a-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:mulFrac-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlso works if the operands share a non-trivial divisor.\nHowever the results are quite arbitrary.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "mulFracOverlap",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e ((T a, T a), T a)",
          "source": "src/MathObj-PartialFraction.html#mulFracOverlap",
          "type": "function"
        },
        "index": {
          "description": "Also works if the operands share non-trivial divisor However the results are quite arbitrary",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "mulFracOverlap",
          "normalized": "T a-\u003eT a-\u003e((T a,T a),T a)",
          "package": "numeric-prelude",
          "partial": "Frac Overlap",
          "signature": "T a-\u003eT a-\u003e((T a,T a),T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:mulFracOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWorks always but simply puts the product into the last fraction.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "mulFracStupid",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e ((T a, T a), T a)",
          "source": "src/MathObj-PartialFraction.html#mulFracStupid",
          "type": "function"
        },
        "index": {
          "description": "Works always but simply puts the product into the last fraction",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "mulFracStupid",
          "normalized": "T a-\u003eT a-\u003e((T a,T a),T a)",
          "package": "numeric-prelude",
          "partial": "Frac Stupid",
          "signature": "T a-\u003eT a-\u003e((T a,T a),T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:mulFracStupid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of denominators must contain equal elements.\nSorry for this hack.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "multiFromFraction",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a -\u003e (a, [a])",
          "source": "src/MathObj-PartialFraction.html#multiFromFraction",
          "type": "function"
        },
        "index": {
          "description": "The list of denominators must contain equal elements Sorry for this hack",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "multiFromFraction",
          "normalized": "[a]-\u003ea-\u003e(a,[a])",
          "package": "numeric-prelude",
          "partial": "From Fraction",
          "signature": "[a]-\u003ea-\u003e(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:multiFromFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e is not really necessary here and\nonly due to invokation of \u003ccode\u003e\u003ca\u003e%\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "multiToFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#multiToFraction",
          "type": "function"
        },
        "index": {
          "description": "is not really necessary here and only due to invokation of",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "multiToFraction",
          "normalized": "a-\u003e[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "To Fraction",
          "signature": "a-\u003e[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:multiToFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA normalization step which reduces all elements in sub-lists\nmodulo their denominators.\nZeros might be the result, that must be remove with \u003ccode\u003e\u003ca\u003eremoveZeros\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "normalizeModulo",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#normalizeModulo",
          "type": "function"
        },
        "index": {
          "description": "normalization step which reduces all elements in sub-lists modulo their denominators Zeros might be the result that must be remove with removeZeros",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "normalizeModulo",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Modulo",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:normalizeModulo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA normalization step which separates the integer part\nfrom the leading fraction of each sub-list.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "reduceHeads",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#reduceHeads",
          "type": "function"
        },
        "index": {
          "description": "normalization step which separates the integer part from the leading fraction of each sub-list",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "reduceHeads",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Heads",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:reduceHeads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove trailing zeros in sub-lists\nbecause if lists are converted to fractions by \u003ccode\u003e\u003ca\u003emultiToFraction\u003c/a\u003e\u003c/code\u003e\nwe must be sure that the denominator of the (cancelled) fraction\nis indeed the stored power of the irreducible denominator.\nOtherwise \u003ccode\u003e\u003ca\u003emulFrac\u003c/a\u003e\u003c/code\u003e leads to wrong results.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "removeZeros",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#removeZeros",
          "type": "function"
        },
        "index": {
          "description": "Remove trailing zeros in sub-lists because if lists are converted to fractions by multiToFraction we must be sure that the denominator of the cancelled fraction is indeed the stored power of the irreducible denominator Otherwise mulFrac leads to wrong results",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "removeZeros",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Zeros",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:removeZeros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpects an irreducible denominator as associate in standard form.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "scaleFrac",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#scaleFrac",
          "type": "function"
        },
        "index": {
          "description": "Expects an irreducible denominator as associate in standard form",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "scaleFrac",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Frac",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:scaleFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "scaleInt",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#scaleInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "scaleInt",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:scaleInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e is not really necessary here and\nonly due to invokation of \u003ccode\u003e\u003ca\u003etoFraction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.PartialFraction",
          "name": "toFactoredFraction",
          "package": "numeric-prelude",
          "signature": "T a -\u003e ([a], a)",
          "source": "src/MathObj-PartialFraction.html#toFactoredFraction",
          "type": "function"
        },
        "index": {
          "description": "is not really necessary here and only due to invokation of toFraction",
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "toFactoredFraction",
          "normalized": "T a-\u003e([a],a)",
          "package": "numeric-prelude",
          "partial": "Factored Fraction",
          "signature": "T a-\u003e([a],a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:toFactoredFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "toFraction",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#toFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "toFraction",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Fraction",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:toFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "toFractionSum",
          "package": "numeric-prelude",
          "signature": "T a -\u003e (a, [(a, [a])])",
          "source": "src/MathObj-PartialFraction.html#toFractionSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "toFractionSum",
          "normalized": "T a-\u003e(a,[(a,[a])])",
          "package": "numeric-prelude",
          "partial": "Fraction Sum",
          "signature": "T a-\u003e(a,[(a,[a])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:toFractionSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PartialFraction",
          "name": "zipWith",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e ([a] -\u003e [a] -\u003e [a]) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PartialFraction.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PartialFraction",
          "module": "MathObj.PartialFraction",
          "name": "zipWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PartialFraction.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-CycleList-Check.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe shall make a little bit of a hack here, enabling us to use additive\nor multiplicative syntax for groups as we wish by simply instantiating\nNum with both operations corresponding to the group operation of the\npermutation group we're studying\n\u003c/p\u003e\u003cp\u003eThere are quite a few way we could represent elements of permutation\ngroups: the images in a row, a list of the cycles, et.c. All of these\ndiffer highly in how complex various operations end up being.\n\u003c/p\u003e",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Cycle",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-CycleList-Check.html#Cycle",
          "type": "newtype"
        },
        "index": {
          "description": "We shall make little bit of hack here enabling us to use additive or multiplicative syntax for groups as we wish by simply instantiating Num with both operations corresponding to the group operation of the permutation group we re studying There are quite few way we could represent elements of permutation groups the images in row list of the cycles et.c All of these differ highly in how complex various operations end up being",
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Cycle",
          "package": "numeric-prelude",
          "partial": "Cycle",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#t:Cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-CycleList-Check.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-Permutation-CycleList-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Cycle",
          "package": "numeric-prelude",
          "signature": "Cycle",
          "source": "src/MathObj-Permutation-CycleList-Check.html#Cycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "Cycle",
          "package": "numeric-prelude",
          "partial": "Cycle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:Cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "closure",
          "package": "numeric-prelude",
          "signature": "[T i] -\u003e [T i]",
          "source": "src/MathObj-Permutation-CycleList-Check.html#closure",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "closure",
          "normalized": "[T a]-\u003e[T a]",
          "package": "numeric-prelude",
          "signature": "[T i]-\u003e[T i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:closure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "cycle",
          "package": "numeric-prelude",
          "signature": "[i]",
          "source": "src/MathObj-Permutation-CycleList-Check.html#Cycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "cycle",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "cycles",
          "package": "numeric-prelude",
          "signature": "[Cycle i]",
          "source": "src/MathObj-Permutation-CycleList-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "cycles",
          "normalized": "[Cycle a]",
          "package": "numeric-prelude",
          "signature": "[Cycle i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:cycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "errIncompat",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/MathObj-Permutation-CycleList-Check.html#errIncompat",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "errIncompat",
          "package": "numeric-prelude",
          "partial": "Incompat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:errIncompat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes not check whether the input values are in range.\n\u003c/p\u003e",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "fromCycles",
          "package": "numeric-prelude",
          "signature": "(i, i) -\u003e [[i]] -\u003e T i",
          "source": "src/MathObj-Permutation-CycleList-Check.html#fromCycles",
          "type": "function"
        },
        "index": {
          "description": "Does not check whether the input values are in range",
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "fromCycles",
          "normalized": "(a,a)-\u003e[[a]]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Cycles",
          "signature": "(i,i)-\u003e[[i]]-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:fromCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "fromTable",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i",
          "source": "src/MathObj-Permutation-CycleList-Check.html#fromTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "fromTable",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Table",
          "signature": "T i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:fromTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "liftCmpTable2",
          "package": "numeric-prelude",
          "signature": "(T i -\u003e T i -\u003e a) -\u003e T i -\u003e T i -\u003e a",
          "source": "src/MathObj-Permutation-CycleList-Check.html#liftCmpTable2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "liftCmpTable2",
          "normalized": "(T a-\u003eT a-\u003eb)-\u003eT a-\u003eT a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Cmp Table",
          "signature": "(T i-\u003eT i-\u003ea)-\u003eT i-\u003eT i-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:liftCmpTable2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "liftTable2",
          "package": "numeric-prelude",
          "signature": "(T i -\u003e T i -\u003e T i) -\u003e T i -\u003e T i -\u003e T i",
          "source": "src/MathObj-Permutation-CycleList-Check.html#liftTable2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "liftTable2",
          "normalized": "(T a-\u003eT a-\u003eT a)-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Table",
          "signature": "(T i-\u003eT i-\u003eT i)-\u003eT i-\u003eT i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:liftTable2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "range",
          "package": "numeric-prelude",
          "signature": "(i, i)",
          "source": "src/MathObj-Permutation-CycleList-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "range",
          "normalized": "(a,a)",
          "package": "numeric-prelude",
          "signature": "(i,i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "toCycles",
          "package": "numeric-prelude",
          "signature": "T i -\u003e [[i]]",
          "source": "src/MathObj-Permutation-CycleList-Check.html#toCycles",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "toCycles",
          "normalized": "T a-\u003e[[a]]",
          "package": "numeric-prelude",
          "partial": "Cycles",
          "signature": "T i-\u003e[[i]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:toCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "toTable",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i",
          "source": "src/MathObj-Permutation-CycleList-Check.html#toTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList Check",
          "module": "MathObj.Permutation.CycleList.Check",
          "name": "toTable",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Table",
          "signature": "T i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList-Check.html#v:toTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePermutation of Integers represented by cycles.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.Permutation.CycleList",
          "name": "CycleList",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-CycleList.html",
          "type": "module"
        },
        "index": {
          "description": "Permutation of Integers represented by cycles",
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "CycleList",
          "package": "numeric-prelude",
          "partial": "Cycle List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "Cycle",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-CycleList.html#Cycle",
          "type": "type"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "Cycle",
          "package": "numeric-prelude",
          "partial": "Cycle",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#t:Cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-CycleList.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "T",
          "package": "numeric-prelude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight (left?) group action on the Integers.\nClose to, but not the same as the module action in Algebra.Module.\n\u003c/p\u003e",
          "module": "MathObj.Permutation.CycleList",
          "name": "(*\u003e)",
          "package": "numeric-prelude",
          "signature": "T i -\u003e i -\u003e i",
          "source": "src/MathObj-Permutation-CycleList.html#%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "Right left group action on the Integers Close to but not the same as the module action in Algebra.Module",
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "(*\u003e) *\u003e",
          "normalized": "T a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "T i-\u003ei-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "choose",
          "package": "numeric-prelude",
          "signature": "Set a -\u003e Maybe a",
          "source": "src/MathObj-Permutation-CycleList.html#choose",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "choose",
          "normalized": "Set a-\u003eMaybe a",
          "package": "numeric-prelude",
          "signature": "Set a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleAction",
          "package": "numeric-prelude",
          "signature": "[i] -\u003e i -\u003e i",
          "source": "src/MathObj-Permutation-CycleList.html#cycleAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleAction",
          "normalized": "[a]-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Action",
          "signature": "[i]-\u003ei-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:cycleAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleLeftAction",
          "package": "numeric-prelude",
          "signature": "Cycle i -\u003e i -\u003e i",
          "source": "src/MathObj-Permutation-CycleList.html#cycleLeftAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleLeftAction",
          "normalized": "Cycle a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Left Action",
          "signature": "Cycle i-\u003ei-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:cycleLeftAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleOrbit",
          "package": "numeric-prelude",
          "signature": "Cycle i -\u003e i -\u003e [i]",
          "source": "src/MathObj-Permutation-CycleList.html#cycleOrbit",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleOrbit",
          "normalized": "Cycle a-\u003ea-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Orbit",
          "signature": "Cycle i-\u003ei-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:cycleOrbit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleRightAction",
          "package": "numeric-prelude",
          "signature": "i -\u003e Cycle i -\u003e i",
          "source": "src/MathObj-Permutation-CycleList.html#cycleRightAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "cycleRightAction",
          "normalized": "a-\u003eCycle a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Right Action",
          "signature": "i-\u003eCycle i-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:cycleRightAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "cyclesOrbit",
          "package": "numeric-prelude",
          "signature": "T i -\u003e i -\u003e [i]",
          "source": "src/MathObj-Permutation-CycleList.html#cyclesOrbit",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "cyclesOrbit",
          "normalized": "T a-\u003ea-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Orbit",
          "signature": "T i-\u003ei-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:cyclesOrbit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "fromFunction",
          "package": "numeric-prelude",
          "signature": "(i, i) -\u003e (i -\u003e i) -\u003e T i",
          "source": "src/MathObj-Permutation-CycleList.html#fromFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "fromFunction",
          "normalized": "(a,a)-\u003e(a-\u003ea)-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Function",
          "signature": "(i,i)-\u003e(i-\u003ei)-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:fromFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "inverse",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i",
          "source": "src/MathObj-Permutation-CycleList.html#inverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "inverse",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "isEssential",
          "package": "numeric-prelude",
          "signature": "Cycle i -\u003e Bool",
          "source": "src/MathObj-Permutation-CycleList.html#isEssential",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "isEssential",
          "normalized": "Cycle a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Essential",
          "signature": "Cycle i-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:isEssential"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "keepEssentials",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i",
          "source": "src/MathObj-Permutation-CycleList.html#keepEssentials",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "keepEssentials",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Essentials",
          "signature": "T i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:keepEssentials"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "orbit",
          "package": "numeric-prelude",
          "signature": "(i -\u003e i) -\u003e i -\u003e [i]",
          "source": "src/MathObj-Permutation-CycleList.html#orbit",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "orbit",
          "normalized": "(a-\u003ea)-\u003ea-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(i-\u003ei)-\u003ei-\u003e[i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:orbit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecandidates for Utility ?\n\u003c/p\u003e",
          "module": "MathObj.Permutation.CycleList",
          "name": "takeUntilRepetition",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Permutation-CycleList.html#takeUntilRepetition",
          "type": "function"
        },
        "index": {
          "description": "candidates for Utility",
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "takeUntilRepetition",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Until Repetition",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:takeUntilRepetition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.CycleList",
          "name": "takeUntilRepetitionSlow",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Permutation-CycleList.html#takeUntilRepetitionSlow",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation CycleList",
          "module": "MathObj.Permutation.CycleList",
          "name": "takeUntilRepetitionSlow",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Until Repetition Slow",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-CycleList.html#v:takeUntilRepetitionSlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "Table",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-Table.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "Table",
          "package": "numeric-prelude",
          "partial": "Table",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation-Table.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "T",
          "package": "numeric-prelude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtremely na&#239;ve algorithm\nto generate a list of all elements in a group.\nShould be replaced by a Schreier-Sims system\nif this code is ever used for anything bigger than .. say ..\ngroups of order 512 or so.\n\u003c/p\u003e",
          "module": "MathObj.Permutation.Table",
          "name": "choose",
          "package": "numeric-prelude",
          "signature": "Set a -\u003e Maybe (a, Set a)",
          "source": "src/MathObj-Permutation-Table.html#choose",
          "type": "function"
        },
        "index": {
          "description": "Extremely na ve algorithm to generate list of all elements in group Should be replaced by Schreier-Sims system if this code is ever used for anything bigger than say groups of order or so",
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "choose",
          "normalized": "Set a-\u003eMaybe(a,Set a)",
          "package": "numeric-prelude",
          "signature": "Set a-\u003eMaybe(a,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "closure",
          "package": "numeric-prelude",
          "signature": "[T i] -\u003e [T i]",
          "source": "src/MathObj-Permutation-Table.html#closure",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "closure",
          "normalized": "[T a]-\u003e[T a]",
          "package": "numeric-prelude",
          "signature": "[T i]-\u003e[T i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:closure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "closureSlow",
          "package": "numeric-prelude",
          "signature": "[T i] -\u003e [T i]",
          "source": "src/MathObj-Permutation-Table.html#closureSlow",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "closureSlow",
          "normalized": "[T a]-\u003e[T a]",
          "package": "numeric-prelude",
          "partial": "Slow",
          "signature": "[T i]-\u003e[T i]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:closureSlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "compose",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i -\u003e T i",
          "source": "src/MathObj-Permutation-Table.html#compose",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "compose",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T i-\u003eT i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "cycle",
          "package": "numeric-prelude",
          "signature": "[i] -\u003e T i -\u003e T i",
          "source": "src/MathObj-Permutation-Table.html#cycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "cycle",
          "normalized": "[a]-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[i]-\u003eT i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "fromCycles",
          "package": "numeric-prelude",
          "signature": "(i, i) -\u003e [[i]] -\u003e T i",
          "source": "src/MathObj-Permutation-Table.html#fromCycles",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "fromCycles",
          "normalized": "(a,a)-\u003e[[a]]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Cycles",
          "signature": "(i,i)-\u003e[[i]]-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:fromCycles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "fromFunction",
          "package": "numeric-prelude",
          "signature": "(i, i) -\u003e (i -\u003e i) -\u003e T i",
          "source": "src/MathObj-Permutation-Table.html#fromFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "fromFunction",
          "normalized": "(a,a)-\u003e(a-\u003ea)-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Function",
          "signature": "(i,i)-\u003e(i-\u003ei)-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:fromFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "fromPermutation",
          "package": "numeric-prelude",
          "signature": "p i -\u003e T i",
          "source": "src/MathObj-Permutation-Table.html#fromPermutation",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "fromPermutation",
          "normalized": "a b-\u003eT b",
          "package": "numeric-prelude",
          "partial": "Permutation",
          "signature": "p i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:fromPermutation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "identity",
          "package": "numeric-prelude",
          "signature": "(i, i) -\u003e T i",
          "source": "src/MathObj-Permutation-Table.html#identity",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "identity",
          "normalized": "(a,a)-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(i,i)-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "inverse",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i",
          "source": "src/MathObj-Permutation-Table.html#inverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "inverse",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation.Table",
          "name": "toFunction",
          "package": "numeric-prelude",
          "signature": "T i -\u003e i -\u003e i",
          "source": "src/MathObj-Permutation-Table.html#toFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Permutation Table",
          "module": "MathObj.Permutation.Table",
          "name": "toFunction",
          "normalized": "T a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Function",
          "signature": "T i-\u003ei-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation-Table.html#v:toFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cul\u003e\u003cli\u003e**\nSeems to be a candidate for Algebra directory.\nAlgebra.PermutationGroup ?\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "MathObj.Permutation",
          "name": "Permutation",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation.html",
          "type": "module"
        },
        "index": {
          "description": "Seems to be candidate for Algebra directory Algebra.PermutationGroup",
          "hierarchy": "MathObj Permutation",
          "module": "MathObj.Permutation",
          "name": "Permutation",
          "package": "numeric-prelude",
          "partial": "Permutation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are quite a few way we could represent elements of permutation\ngroups: the images in a row, a list of the cycles, et.c. All of these\ndiffer highly in how complex various operations end up being.\n\u003c/p\u003e",
          "module": "MathObj.Permutation",
          "name": "C",
          "package": "numeric-prelude",
          "source": "src/MathObj-Permutation.html#C",
          "type": "class"
        },
        "index": {
          "description": "There are quite few way we could represent elements of permutation groups the images in row list of the cycles et.c All of these differ highly in how complex various operations end up being",
          "hierarchy": "MathObj Permutation",
          "module": "MathObj.Permutation",
          "name": "C",
          "package": "numeric-prelude",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation",
          "name": "apply",
          "package": "numeric-prelude",
          "signature": "p i -\u003e i -\u003e i",
          "source": "src/MathObj-Permutation.html#apply",
          "type": "method"
        },
        "index": {
          "hierarchy": "MathObj Permutation",
          "module": "MathObj.Permutation",
          "name": "apply",
          "normalized": "a b-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "signature": "p i-\u003ei-\u003ei",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation",
          "name": "domain",
          "package": "numeric-prelude",
          "signature": "p i -\u003e (i, i)",
          "source": "src/MathObj-Permutation.html#domain",
          "type": "method"
        },
        "index": {
          "hierarchy": "MathObj Permutation",
          "module": "MathObj.Permutation",
          "name": "domain",
          "normalized": "a b-\u003e(b,b)",
          "package": "numeric-prelude",
          "signature": "p i-\u003e(i,i)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation.html#v:domain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Permutation",
          "name": "inverse",
          "package": "numeric-prelude",
          "signature": "p i -\u003e p i",
          "source": "src/MathObj-Permutation.html#inverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "MathObj Permutation",
          "module": "MathObj.Permutation",
          "name": "inverse",
          "normalized": "a b-\u003ea b",
          "package": "numeric-prelude",
          "signature": "p i-\u003ep i",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Permutation.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements polynomial functions on plain lists.\nWe use such functions in order to implement methods of other datatypes.\n\u003c/p\u003e\u003cp\u003eThe module organization differs from that of \u003ccode\u003eResidueClass\u003c/code\u003e:\nHere the \u003ccode\u003ePolynomial\u003c/code\u003e module exports the type\nthat fits to the NumericPrelude type classes,\nwhereas in \u003ccode\u003eResidueClass\u003c/code\u003e the sub-modules export various flavors of them.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.Polynomial.Core",
          "name": "Core",
          "package": "numeric-prelude",
          "source": "src/MathObj-Polynomial-Core.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements polynomial functions on plain lists We use such functions in order to implement methods of other datatypes The module organization differs from that of ResidueClass Here the Polynomial module exports the type that fits to the NumericPrelude type classes whereas in ResidueClass the sub-modules export various flavors of them",
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "Core",
          "package": "numeric-prelude",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "add",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "alternate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#alternate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "alternate",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:alternate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "collinear",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/MathObj-Polynomial-Core.html#collinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "collinear",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:collinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "differentiate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#differentiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "differentiate",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "divMod",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e ([a], [a])",
          "source": "src/MathObj-Polynomial-Core.html#divMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "divMod",
          "normalized": "[a]-\u003e[a]-\u003e([a],[a])",
          "package": "numeric-prelude",
          "partial": "Mod",
          "signature": "[a]-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:divMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "divModRev",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e ([a], [a])",
          "source": "src/MathObj-Polynomial-Core.html#divModRev",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "divModRev",
          "normalized": "[a]-\u003e[a]-\u003e([a],[a])",
          "package": "numeric-prelude",
          "partial": "Mod Rev",
          "signature": "[a]-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:divModRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "equal",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/MathObj-Polynomial-Core.html#equal",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "equal",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHorner's scheme for evaluating a polynomial in a ring.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial.Core",
          "name": "horner",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e a",
          "source": "src/MathObj-Polynomial-Core.html#horner",
          "type": "function"
        },
        "index": {
          "description": "Horner scheme for evaluating polynomial in ring",
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "horner",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:horner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "hornerArgVector",
          "package": "numeric-prelude",
          "signature": "v -\u003e [a] -\u003e v",
          "source": "src/MathObj-Polynomial-Core.html#hornerArgVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "hornerArgVector",
          "normalized": "a-\u003e[b]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Arg Vector",
          "signature": "v-\u003e[a]-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:hornerArgVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHorner's scheme for evaluating a polynomial in a module.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial.Core",
          "name": "hornerCoeffVector",
          "package": "numeric-prelude",
          "signature": "a -\u003e [v] -\u003e v",
          "source": "src/MathObj-Polynomial-Core.html#hornerCoeffVector",
          "type": "function"
        },
        "index": {
          "description": "Horner scheme for evaluating polynomial in module",
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "hornerCoeffVector",
          "normalized": "a-\u003e[b]-\u003eb",
          "package": "numeric-prelude",
          "partial": "Coeff Vector",
          "signature": "a-\u003e[v]-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:hornerCoeffVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "integrate",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#integrate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "integrate",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:integrate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntegrates if it is possible to represent the integrated polynomial\nin the given ring.\nOtherwise undefined coefficients occur.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial.Core",
          "name": "integrateInt",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#integrateInt",
          "type": "function"
        },
        "index": {
          "description": "Integrates if it is possible to represent the integrated polynomial in the given ring Otherwise undefined coefficients occur",
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "integrateInt",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:integrateInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emul\u003c/a\u003e\u003c/code\u003e is fast if the second argument is a short polynomial,\n\u003ccode\u003e\u003ca\u003e**\u003c/a\u003e\u003c/code\u003e relies on that fact.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial.Core",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#mul",
          "type": "function"
        },
        "index": {
          "description": "mul is fast if the second argument is short polynomial relies on that fact",
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "mul",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "mulLinearFactor",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#mulLinearFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "mulLinearFactor",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Linear Factor",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:mulLinearFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "mulShear",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#mulShear",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "mulShear",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Shear",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:mulShear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "mulShearTranspose",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#mulShearTranspose",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "mulShearTranspose",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Shear Transpose",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:mulShearTranspose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "negate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "negate",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt's also helpful to put a polynomial in canonical form.\n\u003ccode\u003e\u003ca\u003enormalize\u003c/a\u003e\u003c/code\u003e strips leading coefficients that are zero.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial.Core",
          "name": "normalize",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#normalize",
          "type": "function"
        },
        "index": {
          "description": "It also helpful to put polynomial in canonical form normalize strips leading coefficients that are zero",
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "normalize",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "progression",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-Polynomial-Core.html#progression",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "progression",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:progression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "scale",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply by the variable, used internally.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial.Core",
          "name": "shift",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#shift",
          "type": "function"
        },
        "index": {
          "description": "Multiply by the variable used internally",
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "shift",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "stdUnit",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/MathObj-Polynomial-Core.html#stdUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "stdUnit",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Unit",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:stdUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "sub",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "tensorProduct",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [[a]]",
          "source": "src/MathObj-Polynomial-Core.html#tensorProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "tensorProduct",
          "normalized": "[a]-\u003e[a]-\u003e[[a]]",
          "package": "numeric-prelude",
          "partial": "Product",
          "signature": "[a]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:tensorProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "tensorProductAlt",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [[a]]",
          "source": "src/MathObj-Polynomial-Core.html#tensorProductAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "tensorProductAlt",
          "normalized": "[a]-\u003e[a]-\u003e[[a]]",
          "package": "numeric-prelude",
          "partial": "Product Alt",
          "signature": "[a]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:tensorProductAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial.Core",
          "name": "unShift",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-Polynomial-Core.html#unShift",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial Core",
          "module": "MathObj.Polynomial.Core",
          "name": "unShift",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Shift",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial-Core.html#v:unShift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePolynomials and rational functions in a single indeterminate.\nPolynomials are represented by a list of coefficients.\nAll non-zero coefficients are listed, but there may be extra '0's at the end.\n\u003c/p\u003e\u003cp\u003eUsage:\nSay you have the ring of \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e numbers\nand you want to add a transcendental element \u003ccode\u003ex\u003c/code\u003e,\nthat is an element, which does not allow for simplifications.\nMore precisely, for all positive integer exponents \u003ccode\u003en\u003c/code\u003e\nthe power \u003ccode\u003ex^n\u003c/code\u003e cannot be rewritten as a sum of powers with smaller exponents.\nThe element \u003ccode\u003ex\u003c/code\u003e must be represented by the polynomial \u003ccode\u003e[0,1]\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIn principle, you can have more than one transcendental element\nby using polynomials whose coefficients are polynomials as well.\nHowever, most algorithms on multi-variate polynomials\nprefer a different (sparse) representation,\nwhere the ordering of elements is not so fixed.\n\u003c/p\u003e\u003cp\u003eIf you want division, you need \u003ca\u003eNumber.Ratio\u003c/a\u003es\nof polynomials with coefficients from a \u003ca\u003eAlgebra.Field\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eYou can also compute with an algebraic element,\nthat is an element which satisfies an algebraic equation like\n\u003ccode\u003ex^3-x-1==0\u003c/code\u003e.\nActually, powers of \u003ccode\u003ex\u003c/code\u003e with exponents above \u003ccode\u003e3\u003c/code\u003e can be simplified,\nsince it holds \u003ccode\u003ex^3==x+1\u003c/code\u003e.\nYou can perform these computations with \u003ca\u003eNumber.ResidueClass\u003c/a\u003e of polynomials,\nwhere the divisor is the polynomial equation that determines \u003ccode\u003ex\u003c/code\u003e.\nIf the polynomial is irreducible\n(in our case \u003ccode\u003ex^3-x-1\u003c/code\u003e cannot be written as a non-trivial product)\nthen the residue classes also allow unrestricted division\n(except by zero, of course).\nThat is, using residue classes of polynomials\nyou can work with roots of polynomial equations\nwithout representing them by radicals\n(powers with fractional exponents).\nIt is well-known, that roots of polynomials of degree above 4\nmay not be representable by radicals.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.Polynomial",
          "name": "Polynomial",
          "package": "numeric-prelude",
          "source": "src/MathObj-Polynomial.html",
          "type": "module"
        },
        "index": {
          "description": "Polynomials and rational functions in single indeterminate Polynomials are represented by list of coefficients All non-zero coefficients are listed but there may be extra at the end Usage Say you have the ring of Integer numbers and you want to add transcendental element that is an element which does not allow for simplifications More precisely for all positive integer exponents the power cannot be rewritten as sum of powers with smaller exponents The element must be represented by the polynomial In principle you can have more than one transcendental element by using polynomials whose coefficients are polynomials as well However most algorithms on multi-variate polynomials prefer different sparse representation where the ordering of elements is not so fixed If you want division you need Number.Ratio of polynomials with coefficients from Algebra.Field You can also compute with an algebraic element that is an element which satisfies an algebraic equation like x-1 Actually powers of with exponents above can be simplified since it holds You can perform these computations with Number.ResidueClass of polynomials where the divisor is the polynomial equation that determines If the polynomial is irreducible in our case x-1 cannot be written as non-trivial product then the residue classes also allow unrestricted division except by zero of course That is using residue classes of polynomials you can work with roots of polynomial equations without representing them by radicals powers with fractional exponents It is well-known that roots of polynomials of degree above may not be representable by radicals",
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "Polynomial",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Polynomial.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "coeffs",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [a]",
          "source": "src/MathObj-Polynomial.html#coeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "coeffs",
          "normalized": "T a-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:coeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "collinear",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e Bool",
          "source": "src/MathObj-Polynomial.html#collinear",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "collinear",
          "normalized": "T a-\u003eT a-\u003eBool",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:collinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ecompose\u003c/a\u003e\u003c/code\u003e is the functional composition of polynomials.\n\u003c/p\u003e\u003cp\u003eIt fulfills\n  \u003ccode\u003e eval x . eval y == eval (compose x y) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "MathObj.Polynomial",
          "name": "compose",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-Polynomial.html#compose",
          "type": "function"
        },
        "index": {
          "description": "compose is the functional composition of polynomials It fulfills eval eval eval compose",
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "compose",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "const",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/MathObj-Polynomial.html#const",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "const",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "degree",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Maybe Int",
          "source": "src/MathObj-Polynomial.html#degree",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "degree",
          "normalized": "T a-\u003eMaybe Int",
          "package": "numeric-prelude",
          "signature": "T a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:degree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "dilate",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/MathObj-Polynomial.html#dilate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "dilate",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:dilate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "evaluate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a -\u003e a",
          "source": "src/MathObj-Polynomial.html#evaluate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "evaluate",
          "normalized": "T a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:evaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere the argument is a vector,\nfor example the coefficients are complex numbers or square matrices\nand the coefficents are reals.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial",
          "name": "evaluateArgVector",
          "package": "numeric-prelude",
          "signature": "T a -\u003e v -\u003e v",
          "source": "src/MathObj-Polynomial.html#evaluateArgVector",
          "type": "function"
        },
        "index": {
          "description": "Here the argument is vector for example the coefficients are complex numbers or square matrices and the coefficents are reals",
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "evaluateArgVector",
          "normalized": "T a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "partial": "Arg Vector",
          "signature": "T a-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:evaluateArgVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere the coefficients are vectors,\nfor example the coefficients are real and the coefficents are real vectors.\n\u003c/p\u003e",
          "module": "MathObj.Polynomial",
          "name": "evaluateCoeffVector",
          "package": "numeric-prelude",
          "signature": "T v -\u003e a -\u003e v",
          "source": "src/MathObj-Polynomial.html#evaluateCoeffVector",
          "type": "function"
        },
        "index": {
          "description": "Here the coefficients are vectors for example the coefficients are real and the coefficents are real vectors",
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "evaluateCoeffVector",
          "normalized": "T a-\u003eb-\u003ea",
          "package": "numeric-prelude",
          "partial": "Coeff Vector",
          "signature": "T v-\u003ea-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:evaluateCoeffVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "fromCoeffs",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-Polynomial.html#fromCoeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "fromCoeffs",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Coeffs",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:fromCoeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "fromRoots",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-Polynomial.html#fromRoots",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "fromRoots",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Roots",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:fromRoots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "integrate",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/MathObj-Polynomial.html#integrate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "integrate",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:integrate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "reverse",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-Polynomial.html#reverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "reverse",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "showsExpressionPrec",
          "package": "numeric-prelude",
          "signature": "Int -\u003e String -\u003e T a -\u003e String -\u003e String",
          "source": "src/MathObj-Polynomial.html#showsExpressionPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "showsExpressionPrec",
          "normalized": "Int-\u003eString-\u003eT a-\u003eString-\u003eString",
          "package": "numeric-prelude",
          "partial": "Expression Prec",
          "signature": "Int-\u003eString-\u003eT a-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:showsExpressionPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "shrink",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/MathObj-Polynomial.html#shrink",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "shrink",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:shrink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Polynomial",
          "name": "translate",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/MathObj-Polynomial.html#translate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Polynomial",
          "module": "MathObj.Polynomial",
          "name": "translate",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Polynomial.html#v:translate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "Core",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries-Core.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "Core",
          "package": "numeric-prelude",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "acos",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e (a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#acos",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "acos",
          "normalized": "(a-\u003ea)-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:acos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "add",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor the series of a real function \u003ccode\u003ef\u003c/code\u003e\ncompute the series for \u003ccode\u003ex -\u003e f (-x)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "alternate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#alternate",
          "type": "function"
        },
        "index": {
          "description": "For the series of real function compute the series for",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "alternate",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:alternate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "approximate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#approximate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "approximate",
          "normalized": "[a]-\u003ea-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:approximate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "approximateArgVector",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e v -\u003e [v]",
          "source": "src/MathObj-PowerSeries-Core.html#approximateArgVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "approximateArgVector",
          "normalized": "[a]-\u003eb-\u003e[b]",
          "package": "numeric-prelude",
          "partial": "Arg Vector",
          "signature": "[a]-\u003ev-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:approximateArgVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "approximateCoeffVector",
          "package": "numeric-prelude",
          "signature": "[v] -\u003e a -\u003e [v]",
          "source": "src/MathObj-PowerSeries-Core.html#approximateCoeffVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "approximateCoeffVector",
          "normalized": "[a]-\u003eb-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Coeff Vector",
          "signature": "[v]-\u003ea-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:approximateCoeffVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "asin",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e (a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#asin",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "asin",
          "normalized": "(a-\u003ea)-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003e(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:asin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "atan",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#atan",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "atan",
          "normalized": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:atan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSince the inner series must start with a zero,\nthe first term is omitted in y.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "compose",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#compose",
          "type": "function"
        },
        "index": {
          "description": "Since the inner series must start with zero the first term is omitted in",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "compose",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two power series where the outer series\ncan be developed for any expansion point.\nTo be more precise:\nThe outer series must be expanded with respect to the leading term\nof the inner series.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "composeTaylor",
          "package": "numeric-prelude",
          "signature": "(a -\u003e [a]) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#composeTaylor",
          "type": "function"
        },
        "index": {
          "description": "Compose two power series where the outer series can be developed for any expansion point To be more precise The outer series must be expanded with respect to the leading term of the inner series",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "composeTaylor",
          "normalized": "(a-\u003e[a])-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Taylor",
          "signature": "(a-\u003e[a])-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:composeTaylor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "cos",
          "package": "numeric-prelude",
          "signature": "(a -\u003e (a, a)) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#cos",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "cos",
          "normalized": "(a-\u003e(a,a))-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003e(a,a))-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:cos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes \u003ccode\u003e(log x)'\u003c/code\u003e, that is \u003ccode\u003ex'/x\u003c/code\u003e\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "derivedLog",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#derivedLog",
          "type": "function"
        },
        "index": {
          "description": "Computes log that is",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "derivedLog",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Log",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:derivedLog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "differentiate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#differentiate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "differentiate",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:differentiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "divMod",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e ([a], [a])",
          "source": "src/MathObj-PowerSeries-Core.html#divMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "divMod",
          "normalized": "[a]-\u003e[a]-\u003e([a],[a])",
          "package": "numeric-prelude",
          "partial": "Mod",
          "signature": "[a]-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:divMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide two series where the absolute term of the divisor is non-zero.\nThat is, power series with leading non-zero terms are the units\nin the ring of power series.\n\u003c/p\u003e\u003cp\u003eKnuth: Seminumerical algorithms\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "divide",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#divide",
          "type": "function"
        },
        "index": {
          "description": "Divide two series where the absolute term of the divisor is non-zero That is power series with leading non-zero terms are the units in the ring of power series Knuth Seminumerical algorithms",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "divide",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:divide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide two series also if the divisor has leading zeros.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "divideStripZero",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#divideStripZero",
          "type": "function"
        },
        "index": {
          "description": "Divide two series also if the divisor has leading zeros",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "divideStripZero",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Strip Zero",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:divideStripZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "evaluate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a -\u003e a",
          "source": "src/MathObj-PowerSeries-Core.html#evaluate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "evaluate",
          "normalized": "[a]-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:evaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "evaluateArgVector",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e v -\u003e v",
          "source": "src/MathObj-PowerSeries-Core.html#evaluateArgVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "evaluateArgVector",
          "normalized": "[a]-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "partial": "Arg Vector",
          "signature": "[a]-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:evaluateArgVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "evaluateCoeffVector",
          "package": "numeric-prelude",
          "signature": "[v] -\u003e a -\u003e v",
          "source": "src/MathObj-PowerSeries-Core.html#evaluateCoeffVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "evaluateCoeffVector",
          "normalized": "[a]-\u003eb-\u003ea",
          "package": "numeric-prelude",
          "partial": "Coeff Vector",
          "signature": "[v]-\u003ea-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:evaluateCoeffVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first term needs a transcendent computation but the others do not.\nThat's why we accept a function which computes the first term.\n\u003c/p\u003e\u003cpre\u003e (exp . x)' =   (exp . x) * x'\n (sin . x)' =   (cos . x) * x'\n (cos . x)' = - (sin . x) * x'\n\u003c/pre\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "exp",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#exp",
          "type": "function"
        },
        "index": {
          "description": "The first term needs transcendent computation but the others do not That why we accept function which computes the first term exp exp sin cos cos sin",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "exp",
          "normalized": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor the series of a real function \u003ccode\u003ef\u003c/code\u003e\ncompute the series for \u003ccode\u003ex -\u003e (f x + f (-x)) / 2\u003c/code\u003e\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "holes2",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#holes2",
          "type": "function"
        },
        "index": {
          "description": "For the series of real function compute the series for",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "holes2",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:holes2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor the series of a real function \u003ccode\u003ef\u003c/code\u003e\ncompute the real series for \u003ccode\u003ex -\u003e (f (i*x) + f (-i*x)) / 2\u003c/code\u003e\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "holes2alternate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#holes2alternate",
          "type": "function"
        },
        "index": {
          "description": "For the series of real function compute the real series for",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "holes2alternate",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:holes2alternate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "integrate",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#integrate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "integrate",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:integrate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns the series of the function in the form:\n(point of the expansion, power series)\n\u003c/p\u003e\u003cp\u003eThis is exceptionally slow and needs cubic run-time.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "inv",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e (a, [a])",
          "source": "src/MathObj-PowerSeries-Core.html#inv",
          "type": "function"
        },
        "index": {
          "description": "This function returns the series of the function in the form point of the expansion power series This is exceptionally slow and needs cubic run-time",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "inv",
          "normalized": "[a]-\u003e(a,[a])",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput series must start with non-zero term.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "log",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#log",
          "type": "function"
        },
        "index": {
          "description": "Input series must start with non-zero term",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "log",
          "normalized": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:log"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "mul",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "negate",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "negate",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput series must start with non-zero term.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "pow",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#pow",
          "type": "function"
        },
        "index": {
          "description": "Input series must start with non-zero term",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "pow",
          "normalized": "(a-\u003ea)-\u003ea-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003ea-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:pow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "progression",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Core.html#progression",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "progression",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:progression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "recipProgression",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Core.html#recipProgression",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "recipProgression",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Progression",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:recipProgression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "scale",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "sin",
          "package": "numeric-prelude",
          "signature": "(a -\u003e (a, a)) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#sin",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "sin",
          "normalized": "(a-\u003e(a,a))-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003e(a,a))-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "sinCos",
          "package": "numeric-prelude",
          "signature": "(a -\u003e (a, a)) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/MathObj-PowerSeries-Core.html#sinCos",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "sinCos",
          "normalized": "(a-\u003e(a,a))-\u003e[a]-\u003e([a],[a])",
          "package": "numeric-prelude",
          "partial": "Cos",
          "signature": "(a-\u003e(a,a))-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:sinCos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "sinCosScalar",
          "package": "numeric-prelude",
          "signature": "a -\u003e (a, a)",
          "source": "src/MathObj-PowerSeries-Core.html#sinCosScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "sinCosScalar",
          "normalized": "a-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Cos Scalar",
          "signature": "a-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:sinCosScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe need to compute the square root only of the first term.\nThat is, if the first term is rational,\nthen all terms of the series are rational.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Core",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#sqrt",
          "type": "function"
        },
        "index": {
          "description": "We need to compute the square root only of the first term That is if the first term is rational then all terms of the series are rational",
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "sqrt",
          "normalized": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "stripLeadZero",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e ([a], [a])",
          "source": "src/MathObj-PowerSeries-Core.html#stripLeadZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "stripLeadZero",
          "normalized": "[a]-\u003e[a]-\u003e([a],[a])",
          "package": "numeric-prelude",
          "partial": "Lead Zero",
          "signature": "[a]-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:stripLeadZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "sub",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Core",
          "name": "tan",
          "package": "numeric-prelude",
          "signature": "(a -\u003e (a, a)) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Core.html#tan",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Core",
          "module": "MathObj.PowerSeries.Core",
          "name": "tan",
          "normalized": "(a-\u003e(a,a))-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "(a-\u003e(a,a))-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Core.html#v:tan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLazy evaluation allows for the solution\n of differential equations in terms of power series.\nWhenever you can express the highest derivative of the solution\n as explicit expression of the lower derivatives\n where each coefficient of the solution series\n depends only on lower coefficients,\n the recursive algorithm will work.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "DifferentialEquation",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries-DifferentialEquation.html",
          "type": "module"
        },
        "index": {
          "description": "Lazy evaluation allows for the solution of differential equations in terms of power series Whenever you can express the highest derivative of the solution as explicit expression of the lower derivatives where each coefficient of the solution series depends only on lower coefficients the recursive algorithm will work",
          "hierarchy": "MathObj PowerSeries DifferentialEquation",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "DifferentialEquation",
          "package": "numeric-prelude",
          "partial": "Differential Equation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-DifferentialEquation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "propDiffEq0",
          "package": "numeric-prelude",
          "signature": "Bool",
          "source": "src/MathObj-PowerSeries-DifferentialEquation.html#propDiffEq0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries DifferentialEquation",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "propDiffEq0",
          "package": "numeric-prelude",
          "partial": "Diff Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-DifferentialEquation.html#v:propDiffEq0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "propDiffEq1",
          "package": "numeric-prelude",
          "signature": "Bool",
          "source": "src/MathObj-PowerSeries-DifferentialEquation.html#propDiffEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries DifferentialEquation",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "propDiffEq1",
          "package": "numeric-prelude",
          "partial": "Diff Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-DifferentialEquation.html#v:propDiffEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample for a linear equation:\n   Setup a differential equation for \u003ccode\u003ey\u003c/code\u003e with\n\u003c/p\u003e\u003cpre\u003e    y   t = (exp (-t)) * (sin t)\n    y'  t = -(exp (-t)) * (sin t) + (exp (-t)) * (cos t)\n    y'' t = -2 * (exp (-t)) * (cos t)\n\u003c/pre\u003e\u003cp\u003eThus the differential equation\n\u003c/p\u003e\u003cpre\u003e    y'' = -2 * (y' + y)\n\u003c/pre\u003e\u003cp\u003eholds.\n\u003c/p\u003e\u003cp\u003eThe following function generates\na power series for \u003ccode\u003eexp (-t) * sin t\u003c/code\u003e\nby solving the differential equation.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "solveDiffEq0",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-DifferentialEquation.html#solveDiffEq0",
          "type": "function"
        },
        "index": {
          "description": "Example for linear equation Setup differential equation for with exp sin exp sin exp cos exp cos Thus the differential equation holds The following function generates power series for exp sin by solving the differential equation",
          "hierarchy": "MathObj PowerSeries DifferentialEquation",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "solveDiffEq0",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Diff Eq",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-DifferentialEquation.html#v:solveDiffEq0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe are not restricted to linear equations!\n Let the solution be y with\n  y   t =   (1-t)^-1\n  y'  t =   (1-t)^-2\n  y'' t = 2*(1-t)^-3\n then it holds\n  y'' = 2 * y' * y\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "solveDiffEq1",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-DifferentialEquation.html#solveDiffEq1",
          "type": "function"
        },
        "index": {
          "description": "We are not restricted to linear equations Let the solution be with then it holds",
          "hierarchy": "MathObj PowerSeries DifferentialEquation",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "solveDiffEq1",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Diff Eq",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-DifferentialEquation.html#v:solveDiffEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "verifyDiffEq0",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-DifferentialEquation.html#verifyDiffEq0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries DifferentialEquation",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "verifyDiffEq0",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Diff Eq",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-DifferentialEquation.html#v:verifyDiffEq0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "verifyDiffEq1",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-DifferentialEquation.html#verifyDiffEq1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries DifferentialEquation",
          "module": "MathObj.PowerSeries.DifferentialEquation",
          "name": "verifyDiffEq1",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Diff Eq",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-DifferentialEquation.html#v:verifyDiffEq1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "Example",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries-Example.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "Example",
          "package": "numeric-prelude",
          "partial": "Example",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "acos",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#acos",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "acos",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:acos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "acosODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#acosODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "acosODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:acosODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "asin",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#asin",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "asin",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:asin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "asinODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#asinODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "asinODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:asinODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "atan",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#atan",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "atan",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:atan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "atanExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#atanExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "atanExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:atanExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "atanODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#atanODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "atanODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:atanODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "atanh",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#atanh",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "atanh",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:atanh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "atanhExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#atanhExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "atanhExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:atanhExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "atanhODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#atanhODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "atanhODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:atanhODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "cos",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#cos",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "cos",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:cos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "cosExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#cosExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "cosExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:cosExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "cosODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#cosODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "cosODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:cosODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "cosh",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#cosh",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "cosh",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:cosh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "coshExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#coshExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "coshExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:coshExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "coshODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#coshODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "coshODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:coshODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePower series of error function (almost).\nMore precisely \u003ccode\u003e erf = 2 / sqrt pi * integrate (x -\u003e exp (-x^2)) \u003c/code\u003e,\nwith \u003ccode\u003eerf 0 = 0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries.Example",
          "name": "erf",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#erf",
          "type": "function"
        },
        "index": {
          "description": "Power series of error function almost More precisely erf sqrt pi integrate exp with erf",
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "erf",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:erf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "exp",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "exp",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "expExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#expExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "expExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:expExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "expODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#expODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "expODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:expODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "log",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#log",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "log",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:log"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "logExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#logExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "logExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:logExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "logODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#logODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "logODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:logODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "pow",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Example.html#pow",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "pow",
          "normalized": "a-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:pow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "powExpl",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Example.html#powExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "powExpl",
          "normalized": "a-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:powExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "powODE",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Example.html#powODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "powODE",
          "normalized": "a-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:powODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "recip",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "recipCircle",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#recipCircle",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "recipCircle",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Circle",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:recipCircle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "recipExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#recipExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "recipExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:recipExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sin",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sin",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sin",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sinExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sinExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sinExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sinExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sinODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sinODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sinODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sinODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sinh",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sinh",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sinh",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sinhExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sinhExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sinhExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sinhExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sinhODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sinhODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sinhODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sinhODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sqrt",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sqrtExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sqrtExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sqrtExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sqrtExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "sqrtODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#sqrtODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "sqrtODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:sqrtODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "tan",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#tan",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "tan",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:tan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "tanExpl",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#tanExpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "tanExpl",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:tanExpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "tanExplSieve",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#tanExplSieve",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "tanExplSieve",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Expl Sieve",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:tanExplSieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "tanODE",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#tanODE",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "tanODE",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODE",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:tanODE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Example",
          "name": "tanODESieve",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Example.html#tanODESieve",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Example",
          "module": "MathObj.PowerSeries.Example",
          "name": "tanODESieve",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "ODESieve",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Example.html#v:tanODESieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module computes power series for\nrepresenting some means as generalized $f$-means.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.PowerSeries.Mean",
          "name": "Mean",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries-Mean.html",
          "type": "module"
        },
        "index": {
          "description": "This module computes power series for representing some means as generalized means",
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "Mean",
          "package": "numeric-prelude",
          "partial": "Mean",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "arithmetic2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#arithmetic2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "arithmetic2",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:arithmetic2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "arithmeticDiff2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#arithmeticDiff2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "arithmeticDiff2",
          "package": "numeric-prelude",
          "partial": "Diff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:arithmeticDiff2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "arithmeticMVF",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#arithmeticMVF",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "arithmeticMVF",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "MVF",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:arithmeticMVF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "diffComp",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSeries-Mean.html#diffComp",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "diffComp",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Comp",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:diffComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "elemSym3_2",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#elemSym3_2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "elemSym3_2",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Sym",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:elemSym3_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "geometric2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#geometric2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "geometric2",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:geometric2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "geometricDiff2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#geometricDiff2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "geometricDiff2",
          "package": "numeric-prelude",
          "partial": "Diff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:geometricDiff2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "geometricMVF",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#geometricMVF",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "geometricMVF",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "MVF",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:geometricMVF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "harmonic2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#harmonic2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "harmonic2",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:harmonic2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "harmonicDiff2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#harmonicDiff2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "harmonicDiff2",
          "package": "numeric-prelude",
          "partial": "Diff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:harmonicDiff2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "harmonicMVF",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#harmonicMVF",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "harmonicMVF",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "MVF",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:harmonicMVF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "logarithmic",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#logarithmic",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "logarithmic",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:logarithmic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "meanValueDiff2",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [a] -\u003e T a",
          "source": "src/MathObj-PowerSeries-Mean.html#meanValueDiff2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "meanValueDiff2",
          "normalized": "T a-\u003e[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Value Diff",
          "signature": "T a-\u003e[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:meanValueDiff2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadratic",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#quadratic",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadratic",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:quadratic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadratic2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#quadratic2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadratic2",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:quadratic2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadraticDiff",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#quadraticDiff",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadraticDiff",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "Diff",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:quadraticDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadraticDiff2",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries-Mean.html#quadraticDiff2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadraticDiff2",
          "package": "numeric-prelude",
          "partial": "Diff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:quadraticDiff2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadraticMVF",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries-Mean.html#quadraticMVF",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries Mean",
          "module": "MathObj.PowerSeries.Mean",
          "name": "quadraticMVF",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "partial": "MVF",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries-Mean.html#v:quadraticMVF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePower series, either finite or unbounded.\n(zipWith does exactly the right thing to make it work almost transparently.)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.PowerSeries",
          "name": "PowerSeries",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries.html",
          "type": "module"
        },
        "index": {
          "description": "Power series either finite or unbounded zipWith does exactly the right thing to make it work almost transparently",
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "PowerSeries",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-PowerSeries.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/MathObj-PowerSeries.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate approximations that is evaluate all truncations of the series.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries",
          "name": "approximate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a -\u003e [a]",
          "source": "src/MathObj-PowerSeries.html#approximate",
          "type": "function"
        },
        "index": {
          "description": "Evaluate approximations that is evaluate all truncations of the series",
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "approximate",
          "normalized": "T a-\u003ea-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:approximate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate approximations that is evaluate all truncations of the series.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries",
          "name": "approximateArgVector",
          "package": "numeric-prelude",
          "signature": "T a -\u003e v -\u003e [v]",
          "source": "src/MathObj-PowerSeries.html#approximateArgVector",
          "type": "function"
        },
        "index": {
          "description": "Evaluate approximations that is evaluate all truncations of the series",
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "approximateArgVector",
          "normalized": "T a-\u003eb-\u003e[b]",
          "package": "numeric-prelude",
          "partial": "Arg Vector",
          "signature": "T a-\u003ev-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:approximateArgVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate approximations that is evaluate all truncations of the series.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries",
          "name": "approximateCoeffVector",
          "package": "numeric-prelude",
          "signature": "T v -\u003e a -\u003e [v]",
          "source": "src/MathObj-PowerSeries.html#approximateCoeffVector",
          "type": "function"
        },
        "index": {
          "description": "Evaluate approximations that is evaluate all truncations of the series",
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "approximateCoeffVector",
          "normalized": "T a-\u003eb-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Coeff Vector",
          "signature": "T v-\u003ea-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:approximateCoeffVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "coeffs",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSeries.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "coeffs",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:coeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt fulfills\n  \u003ccode\u003e evaluate x . evaluate y == evaluate (compose x y) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries",
          "name": "compose",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries.html#compose",
          "type": "function"
        },
        "index": {
          "description": "It fulfills evaluate evaluate evaluate compose",
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "compose",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "const",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/MathObj-PowerSeries.html#const",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "const",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate (truncated) power series.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries",
          "name": "evaluate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a -\u003e a",
          "source": "src/MathObj-PowerSeries.html#evaluate",
          "type": "function"
        },
        "index": {
          "description": "Evaluate truncated power series",
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "evaluate",
          "normalized": "T a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:evaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "evaluateArgVector",
          "package": "numeric-prelude",
          "signature": "T a -\u003e v -\u003e v",
          "source": "src/MathObj-PowerSeries.html#evaluateArgVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "evaluateArgVector",
          "normalized": "T a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "partial": "Arg Vector",
          "signature": "T a-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:evaluateArgVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate (truncated) power series.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries",
          "name": "evaluateCoeffVector",
          "package": "numeric-prelude",
          "signature": "T v -\u003e a -\u003e v",
          "source": "src/MathObj-PowerSeries.html#evaluateCoeffVector",
          "type": "function"
        },
        "index": {
          "description": "Evaluate truncated power series",
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "evaluateCoeffVector",
          "normalized": "T a-\u003eb-\u003ea",
          "package": "numeric-prelude",
          "partial": "Coeff Vector",
          "signature": "T v-\u003ea-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:evaluateCoeffVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "fromCoeffs",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-PowerSeries.html#fromCoeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "fromCoeffs",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Coeffs",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:fromCoeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "lift0",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-PowerSeries.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "lift0",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a]) -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "lift1",
          "normalized": "([a]-\u003e[a])-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "([a]-\u003e[a])-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a] -\u003e [a]) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "lift2",
          "normalized": "([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries",
          "name": "truncate",
          "package": "numeric-prelude",
          "signature": "Int -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries.html#truncate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries",
          "module": "MathObj.PowerSeries",
          "name": "truncate",
          "normalized": "Int-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "Int-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries.html#v:truncate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "Core",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries2-Core.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "Core",
          "package": "numeric-prelude",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries2-Core.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "T",
          "package": "numeric-prelude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "add",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSince the inner series must start with a zero,\nthe first term is omitted in y.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries2.Core",
          "name": "compose",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#compose",
          "type": "function"
        },
        "index": {
          "description": "Since the inner series must start with zero the first term is omitted in",
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "compose",
          "normalized": "[a]-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[a]-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "differentiate0",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#differentiate0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "differentiate0",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:differentiate0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "differentiate1",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#differentiate1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "differentiate1",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:differentiate1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "divide",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#divide",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "divide",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:divide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "integrate0",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#integrate0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "integrate0",
          "normalized": "[a]-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[a]-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:integrate0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "integrate1",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#integrate1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "integrate1",
          "normalized": "[a]-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[a]-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:integrate1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "lift0fromPowerSeries",
          "package": "numeric-prelude",
          "signature": "[T a] -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#lift0fromPowerSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "lift0fromPowerSeries",
          "normalized": "[T a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "signature": "[T a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:lift0fromPowerSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "lift1fromPowerSeries",
          "package": "numeric-prelude",
          "signature": "([T a] -\u003e [T a]) -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#lift1fromPowerSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "lift1fromPowerSeries",
          "normalized": "([T a]-\u003e[T a])-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "signature": "([T a]-\u003e[T a])-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:lift1fromPowerSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "lift2fromPowerSeries",
          "package": "numeric-prelude",
          "signature": "([T a] -\u003e [T a] -\u003e [T a]) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#lift2fromPowerSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "lift2fromPowerSeries",
          "normalized": "([T a]-\u003e[T a]-\u003e[T a])-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "signature": "([T a]-\u003e[T a]-\u003e[T a])-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:lift2fromPowerSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "mul",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "negate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#negate",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "negate",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "scale",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "sqrt",
          "normalized": "(a-\u003ea)-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "sub",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2.Core",
          "name": "swapVariables",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2-Core.html#swapVariables",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2 Core",
          "module": "MathObj.PowerSeries2.Core",
          "name": "swapVariables",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Variables",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2-Core.html#v:swapVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTwo-variate power series.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.PowerSeries2",
          "name": "PowerSeries2",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries2.html",
          "type": "module"
        },
        "index": {
          "description": "Two-variate power series",
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "PowerSeries2",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn order to handle both variables equivalently\nwe maintain a list of coefficients for terms of the same total degree.\nThat is\n\u003c/p\u003e\u003cpre\u003e eval [[a], [b,c], [d,e,f]] (x,y) ==\n    a + b*x+c*y + d*x^2+e*x*y+f*y^2\n\u003c/pre\u003e\u003cp\u003eAlthough the sub-lists are always finite and thus are more like polynomials than power series,\ndivision and square root computation are easier to implement for power series.\n\u003c/p\u003e",
          "module": "MathObj.PowerSeries2",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSeries2.html#T",
          "type": "newtype"
        },
        "index": {
          "description": "In order to handle both variables equivalently we maintain list of coefficients for terms of the same total degree That is eval Although the sub-lists are always finite and thus are more like polynomials than power series division and square root computation are easier to implement for power series",
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-PowerSeries2.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/MathObj-PowerSeries2.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "check",
          "package": "numeric-prelude",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/MathObj-PowerSeries2.html#check",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "check",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "numeric-prelude",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "coeffs",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/MathObj-PowerSeries2.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "coeffs",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:coeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "const",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/MathObj-PowerSeries2.html#const",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "const",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "fromCoeffs",
          "package": "numeric-prelude",
          "signature": "[[a]] -\u003e T a",
          "source": "src/MathObj-PowerSeries2.html#fromCoeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "fromCoeffs",
          "normalized": "[[a]]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Coeffs",
          "signature": "[[a]]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:fromCoeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "fromPowerSeries0",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2.html#fromPowerSeries0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "fromPowerSeries0",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:fromPowerSeries0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "fromPowerSeries1",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2.html#fromPowerSeries1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "fromPowerSeries1",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:fromPowerSeries1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "isValid",
          "package": "numeric-prelude",
          "signature": "[[a]] -\u003e Bool",
          "source": "src/MathObj-PowerSeries2.html#isValid",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "isValid",
          "normalized": "[[a]]-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Valid",
          "signature": "[[a]]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:isValid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "lift0",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "lift0",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "(T a -\u003e T a) -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "lift1",
          "normalized": "(T a-\u003eT a)-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(T a-\u003eT a)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSeries2",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(T a -\u003e T a -\u003e T a) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSeries2.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSeries2",
          "module": "MathObj.PowerSeries2",
          "name": "lift2",
          "normalized": "(T a-\u003eT a-\u003eT a)-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(T a-\u003eT a-\u003eT a)-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSeries2.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFor a multi-set of numbers,\nwe describe a sequence of the sums of powers of the numbers in the set.\nThese can be easily converted to polynomials and back.\nThus they provide an easy way for computations on the roots of a polynomial.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.PowerSum",
          "name": "PowerSum",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSum.html",
          "type": "module"
        },
        "index": {
          "description": "For multi-set of numbers we describe sequence of the sums of powers of the numbers in the set These can be easily converted to polynomials and back Thus they provide an easy way for computations on the roots of polynomial",
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "PowerSum",
          "package": "numeric-prelude",
          "partial": "Power Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-PowerSum.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-PowerSum.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "add",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/MathObj-PowerSum.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "approxSeries",
          "package": "numeric-prelude",
          "signature": "[b] -\u003e [a] -\u003e [b]",
          "source": "src/MathObj-PowerSum.html#approxSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "approxSeries",
          "normalized": "[a]-\u003e[b]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Series",
          "signature": "[b]-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:approxSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "binomials",
          "package": "numeric-prelude",
          "signature": "[[a]]",
          "source": "src/MathObj-PowerSum.html#binomials",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "binomials",
          "normalized": "[[a]]",
          "package": "numeric-prelude",
          "signature": "[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:binomials"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "const",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/MathObj-PowerSum.html#const",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "const",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "divOneFlip",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#divOneFlip",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "divOneFlip",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "One Flip",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:divOneFlip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "elemSymFromPolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#elemSymFromPolynomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "elemSymFromPolynomial",
          "normalized": "T a-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Sym From Polynomial",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:elemSymFromPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "fromElemSym",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#fromElemSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "fromElemSym",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Elem Sym",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:fromElemSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "fromElemSymDenormalized",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#fromElemSymDenormalized",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "fromElemSymDenormalized",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Elem Sym Denormalized",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:fromElemSymDenormalized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "fromPolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#fromPolynomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "fromPolynomial",
          "normalized": "T a-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:fromPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "lift0",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-PowerSum.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "lift0",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a]) -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSum.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "lift1",
          "normalized": "([a]-\u003e[a])-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "([a]-\u003e[a])-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a] -\u003e [a]) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-PowerSum.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "lift2",
          "normalized": "([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "mul",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "pow",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#pow",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "pow",
          "normalized": "Integer-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "Integer-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:pow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "propOp",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a] -\u003e [a]) -\u003e (a -\u003e a -\u003e a) -\u003e [a] -\u003e [a] -\u003e [Bool]",
          "source": "src/MathObj-PowerSum.html#propOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "propOp",
          "normalized": "([a]-\u003e[a]-\u003e[a])-\u003e(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]-\u003e[Bool]",
          "package": "numeric-prelude",
          "partial": "Op",
          "signature": "([a]-\u003e[a]-\u003e[a])-\u003e(a-\u003ea-\u003ea)-\u003e[a]-\u003e[a]-\u003e[Bool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:propOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "root",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#root",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "root",
          "normalized": "Integer-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "Integer-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "sums",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-PowerSum.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "sums",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:sums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "toElemSym",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#toElemSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "toElemSym",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Elem Sym",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:toElemSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.PowerSum",
          "name": "toElemSymInt",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-PowerSum.html#toElemSymInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj PowerSum",
          "module": "MathObj.PowerSum",
          "name": "toElemSymInt",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Elem Sym Int",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-PowerSum.html#v:toElemSymInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RefinementMask2",
          "name": "RefinementMask2",
          "package": "numeric-prelude",
          "source": "src/MathObj-RefinementMask2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "RefinementMask2",
          "package": "numeric-prelude",
          "partial": "Refinement Mask",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RefinementMask2",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-RefinementMask2.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RefinementMask2",
          "name": "coeffs",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [a]",
          "source": "src/MathObj-RefinementMask2.html#coeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "coeffs",
          "normalized": "T a-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:coeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvolve polynomials via refinement mask.\n\u003c/p\u003e\u003cp\u003e(mask x + ux*(-1,1)^degree x) * (mask y + uy*(-1,1)^degree y)\n\u003c/p\u003e",
          "module": "MathObj.RefinementMask2",
          "name": "convolvePolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-RefinementMask2.html#convolvePolynomial",
          "type": "function"
        },
        "index": {
          "description": "Convolve polynomials via refinement mask mask ux degree mask uy degree",
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "convolvePolynomial",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:convolvePolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RefinementMask2",
          "name": "convolveTruncatedPowerPolynomials",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-RefinementMask2.html#convolveTruncatedPowerPolynomials",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "convolveTruncatedPowerPolynomials",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Truncated Power Polynomials",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:convolveTruncatedPowerPolynomials"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RefinementMask2",
          "name": "fromCoeffs",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-RefinementMask2.html#fromCoeffs",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "fromCoeffs",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Coeffs",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:fromCoeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine mask by Gauss elimination.\n\u003c/p\u003e\u003cp\u003eR - alternating binomial coefficients\nL - differences of translated polynomials in columns\n\u003c/p\u003e\u003cp\u003ep2 = L * R^(-1) * m\n\u003c/p\u003e\u003cp\u003eR * L^(-1) * p2 = m\n\u003c/p\u003e",
          "module": "MathObj.RefinementMask2",
          "name": "fromPolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-RefinementMask2.html#fromPolynomial",
          "type": "function"
        },
        "index": {
          "description": "Determine mask by Gauss elimination alternating binomial coefficients differences of translated polynomials in columns p2 p2",
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "fromPolynomial",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:fromPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RefinementMask2",
          "name": "refinePolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-RefinementMask2.html#refinePolynomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "refinePolynomial",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:refinePolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the mask does not sum up to a power of \u003ccode\u003e1/2\u003c/code\u003e\nthen the function returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.RefinementMask2",
          "name": "toPolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Maybe (T a)",
          "source": "src/MathObj-RefinementMask2.html#toPolynomial",
          "type": "function"
        },
        "index": {
          "description": "If the mask does not sum up to power of then the function returns Nothing",
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "toPolynomial",
          "normalized": "T a-\u003eMaybe(T a)",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003eMaybe(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:toPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RefinementMask2",
          "name": "toPolynomialFast",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Maybe (T a)",
          "source": "src/MathObj-RefinementMask2.html#toPolynomialFast",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RefinementMask2",
          "module": "MathObj.RefinementMask2",
          "name": "toPolynomialFast",
          "normalized": "T a-\u003eMaybe(T a)",
          "package": "numeric-prelude",
          "partial": "Polynomial Fast",
          "signature": "T a-\u003eMaybe(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RefinementMask2.html#v:toPolynomialFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComputations on the set of roots of a polynomial.\nThese are represented as the list of their elementar symmetric terms.\nThe difference between a polynomial and the list of elementar symmetric terms\nis the reversed order and the alternated signs.\n\u003c/p\u003e\u003cp\u003eCf. \u003cem\u003eMathObj.PowerSum\u003c/em\u003e .\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.RootSet",
          "name": "RootSet",
          "package": "numeric-prelude",
          "source": "src/MathObj-RootSet.html",
          "type": "module"
        },
        "index": {
          "description": "Computations on the set of roots of polynomial These are represented as the list of their elementar symmetric terms The difference between polynomial and the list of elementar symmetric terms is the reversed order and the alternated signs Cf MathObj.PowerSum",
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "RootSet",
          "package": "numeric-prelude",
          "partial": "Root Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-RootSet.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-RootSet.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "add",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "addInt",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#addInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "addInt",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:addInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecf. \u003ccode\u003e\u003ca\u003emulLinearFactor\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e",
          "module": "MathObj.RootSet",
          "name": "addRoot",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#addRoot",
          "type": "function"
        },
        "index": {
          "description": "cf mulLinearFactor",
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "addRoot",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Root",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:addRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/MathObj-RootSet.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an approximation of a root,\nthe degree of the polynomial and maximum value of coefficients,\nfind candidates of polynomials that have approximately this root\nand show the actual value of the polynomial at the given root approximation.\n\u003c/p\u003e\u003cp\u003eThis algorithm runs easily into a stack overflow, I do not know why.\nWe may also employ a more sophisticated integer relation algorithm,\nlike PSLQ and friends.\n\u003c/p\u003e",
          "module": "MathObj.RootSet",
          "name": "approxPolynomial",
          "package": "numeric-prelude",
          "signature": "Int -\u003e Integer -\u003e a -\u003e (a, T a)",
          "source": "src/MathObj-RootSet.html#approxPolynomial",
          "type": "function"
        },
        "index": {
          "description": "Given an approximation of root the degree of the polynomial and maximum value of coefficients find candidates of polynomials that have approximately this root and show the actual value of the polynomial at the given root approximation This algorithm runs easily into stack overflow do not know why We may also employ more sophisticated integer relation algorithm like PSLQ and friends",
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "approxPolynomial",
          "normalized": "Int-\u003eInteger-\u003ea-\u003e(a,T a)",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "Int-\u003eInteger-\u003ea-\u003e(a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:approxPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "coeffs",
          "package": "numeric-prelude",
          "signature": "[a]",
          "source": "src/MathObj-RootSet.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "coeffs",
          "normalized": "[a]",
          "package": "numeric-prelude",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:coeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "const",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/MathObj-RootSet.html#const",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "const",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "fromPolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-RootSet.html#fromPolynomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "fromPolynomial",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:fromPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "fromPowerSums",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#fromPowerSums",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "fromPowerSums",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sums",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:fromPowerSums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "fromRoots",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#fromRoots",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "fromRoots",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Roots",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:fromRoots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "lift0",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/MathObj-RootSet.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "lift0",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a]) -\u003e T a -\u003e T a",
          "source": "src/MathObj-RootSet.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "lift1",
          "normalized": "([a]-\u003e[a])-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "([a]-\u003e[a])-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a] -\u003e [a]) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/MathObj-RootSet.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "lift2",
          "normalized": "([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "([a]-\u003e[a]-\u003e[a])-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "liftPowerSum1",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a]) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#liftPowerSum1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "liftPowerSum1",
          "normalized": "([a]-\u003e[a])-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sum",
          "signature": "([a]-\u003e[a])-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:liftPowerSum1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "liftPowerSum1Gen",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a]) -\u003e ([a] -\u003e [a]) -\u003e ([a] -\u003e [a]) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#liftPowerSum1Gen",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "liftPowerSum1Gen",
          "normalized": "([a]-\u003e[a])-\u003e([a]-\u003e[a])-\u003e([a]-\u003e[a])-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sum Gen",
          "signature": "([a]-\u003e[a])-\u003e([a]-\u003e[a])-\u003e([a]-\u003e[a])-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:liftPowerSum1Gen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "liftPowerSum2",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a] -\u003e [a]) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#liftPowerSum2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "liftPowerSum2",
          "normalized": "([a]-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sum",
          "signature": "([a]-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:liftPowerSum2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "liftPowerSum2Gen",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a]) -\u003e ([a] -\u003e [a]) -\u003e ([a] -\u003e [a] -\u003e [a]) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#liftPowerSum2Gen",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "liftPowerSum2Gen",
          "normalized": "([a]-\u003e[a])-\u003e([a]-\u003e[a])-\u003e([a]-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sum Gen",
          "signature": "([a]-\u003e[a])-\u003e([a]-\u003e[a])-\u003e([a]-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:liftPowerSum2Gen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "liftPowerSumInt1",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a]) -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#liftPowerSumInt1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "liftPowerSumInt1",
          "normalized": "([a]-\u003e[a])-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sum Int",
          "signature": "([a]-\u003e[a])-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:liftPowerSumInt1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "liftPowerSumInt2",
          "package": "numeric-prelude",
          "signature": "([a] -\u003e [a] -\u003e [a]) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#liftPowerSumInt2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "liftPowerSumInt2",
          "normalized": "([a]-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sum Int",
          "signature": "([a]-\u003e[a]-\u003e[a])-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:liftPowerSumInt2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "mul",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "mulInt",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#mulInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "mulInt",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:mulInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "pow",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#pow",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "pow",
          "normalized": "Integer-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "signature": "Integer-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:pow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "powInt",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e [a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#powInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "powInt",
          "normalized": "Integer-\u003e[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "Integer-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:powInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "toPolynomial",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/MathObj-RootSet.html#toPolynomial",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "toPolynomial",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Polynomial",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:toPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.RootSet",
          "name": "toPowerSums",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [a]",
          "source": "src/MathObj-RootSet.html#toPowerSums",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj RootSet",
          "module": "MathObj.RootSet",
          "name": "toPowerSums",
          "normalized": "[a]-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Power Sums",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-RootSet.html#v:toPowerSums"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA wrapper that provides instances of Haskell 98 and NumericPrelude\nnumeric type classes\nfor types that have Haskell 98 instances.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "Haskell98",
          "package": "numeric-prelude",
          "source": "src/MathObj-Wrapper-Haskell98.html",
          "type": "module"
        },
        "index": {
          "description": "wrapper that provides instances of Haskell and NumericPrelude numeric type classes for types that have Haskell instances",
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "Haskell98",
          "package": "numeric-prelude",
          "partial": "Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis makes a type usable in the NumericPrelude framework\nthat was initially implemented for Haskell98 typeclasses.\nE.g. if \u003ccode\u003ea\u003c/code\u003e is in class \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e,\nthen \u003ccode\u003eT a\u003c/code\u003e is both in class \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e and in \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can even lift container types.\nIf \u003ccode\u003ePolynomial a\u003c/code\u003e is in \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e for all types \u003ccode\u003ea\u003c/code\u003e that are in \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e,\nthen \u003ccode\u003eT (Polynomial (MathObj.Wrapper.NumericPrelude.T a))\u003c/code\u003e\nis in \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e for all types \u003ccode\u003ea\u003c/code\u003e that are in \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Wrapper-Haskell98.html#T",
          "type": "newtype"
        },
        "index": {
          "description": "This makes type usable in the NumericPrelude framework that was initially implemented for Haskell98 typeclasses E.g if is in class Num then is both in class Num and in You can even lift container types If Polynomial is in Num for all types that are in Num then Polynomial MathObj.Wrapper.NumericPrelude.T is in for all types that are in",
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.Haskell98",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-Wrapper-Haskell98.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.Haskell98",
          "name": "decons",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/MathObj-Wrapper-Haskell98.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "decons",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#v:decons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.Haskell98",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b) -\u003e T a -\u003e T b",
          "source": "src/MathObj-Wrapper-Haskell98.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "lift1",
          "normalized": "(a-\u003eb)-\u003eT a-\u003eT b",
          "package": "numeric-prelude",
          "signature": "(a-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.Haskell98",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e T b -\u003e T c",
          "source": "src/MathObj-Wrapper-Haskell98.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "lift2",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "package": "numeric-prelude",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.Haskell98",
          "name": "unimplemented",
          "package": "numeric-prelude",
          "signature": "String -\u003e a",
          "source": "src/MathObj-Wrapper-Haskell98.html#unimplemented",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "unimplemented",
          "normalized": "String-\u003ea",
          "package": "numeric-prelude",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#v:unimplemented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.Haskell98",
          "name": "unliftF1",
          "package": "numeric-prelude",
          "signature": "(f (T a) -\u003e f (T b)) -\u003e f a -\u003e f b",
          "source": "src/MathObj-Wrapper-Haskell98.html#unliftF1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "unliftF1",
          "normalized": "(a(T b)-\u003ea(T c))-\u003ea b-\u003ea c",
          "package": "numeric-prelude",
          "signature": "(f(T a)-\u003ef(T b))-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#v:unliftF1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.Haskell98",
          "name": "unliftF2",
          "package": "numeric-prelude",
          "signature": "(f (T a) -\u003e f (T b) -\u003e f (T c)) -\u003e f a -\u003e f b -\u003e f c",
          "source": "src/MathObj-Wrapper-Haskell98.html#unliftF2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper Haskell98",
          "module": "MathObj.Wrapper.Haskell98",
          "name": "unliftF2",
          "normalized": "(a(T b)-\u003ea(T c)-\u003ea(T d))-\u003ea b-\u003ea c-\u003ea d",
          "package": "numeric-prelude",
          "signature": "(f(T a)-\u003ef(T b)-\u003ef(T c))-\u003ef a-\u003ef b-\u003ef c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-Haskell98.html#v:unliftF2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA wrapper that provides instances of Haskell 98 and NumericPrelude\nnumeric type classes\nfor types that have NumericPrelude instances.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "NumericPrelude",
          "package": "numeric-prelude",
          "source": "src/MathObj-Wrapper-NumericPrelude.html",
          "type": "module"
        },
        "index": {
          "description": "wrapper that provides instances of Haskell and NumericPrelude numeric type classes for types that have NumericPrelude instances",
          "hierarchy": "MathObj Wrapper NumericPrelude",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "NumericPrelude",
          "package": "numeric-prelude",
          "partial": "Numeric Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-NumericPrelude.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis makes a type usable with Haskell98 type classes\nthat was initially implemented for NumericPrelude typeclasses.\nE.g. if \u003ccode\u003ea\u003c/code\u003e is in class \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e,\nthen \u003ccode\u003eT a\u003c/code\u003e is both in class \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e and in \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can even lift container types.\nIf \u003ccode\u003ePolynomial a\u003c/code\u003e is in \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e for all types \u003ccode\u003ea\u003c/code\u003e that are in \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e,\nthen \u003ccode\u003eT (Polynomial (MathObj.Wrapper.Haskell98.T a))\u003c/code\u003e\nis in \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e for all types \u003ccode\u003ea\u003c/code\u003e that are in \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/MathObj-Wrapper-NumericPrelude.html#T",
          "type": "newtype"
        },
        "index": {
          "description": "This makes type usable with Haskell98 type classes that was initially implemented for NumericPrelude typeclasses E.g if is in class then is both in class Num and in You can even lift container types If Polynomial is in for all types that are in then Polynomial MathObj.Wrapper.Haskell98.T is in Num for all types that are in Num",
          "hierarchy": "MathObj Wrapper NumericPrelude",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-NumericPrelude.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/MathObj-Wrapper-NumericPrelude.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper NumericPrelude",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-NumericPrelude.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "decons",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/MathObj-Wrapper-NumericPrelude.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper NumericPrelude",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "decons",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-NumericPrelude.html#v:decons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b) -\u003e T a -\u003e T b",
          "source": "src/MathObj-Wrapper-NumericPrelude.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper NumericPrelude",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "lift1",
          "normalized": "(a-\u003eb)-\u003eT a-\u003eT b",
          "package": "numeric-prelude",
          "signature": "(a-\u003eb)-\u003eT a-\u003eT b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-NumericPrelude.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e c) -\u003e T a -\u003e T b -\u003e T c",
          "source": "src/MathObj-Wrapper-NumericPrelude.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper NumericPrelude",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "lift2",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "package": "numeric-prelude",
          "signature": "(a-\u003eb-\u003ec)-\u003eT a-\u003eT b-\u003eT c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-NumericPrelude.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "unimplemented",
          "package": "numeric-prelude",
          "signature": "String -\u003e a",
          "source": "src/MathObj-Wrapper-NumericPrelude.html#unimplemented",
          "type": "function"
        },
        "index": {
          "hierarchy": "MathObj Wrapper NumericPrelude",
          "module": "MathObj.Wrapper.NumericPrelude",
          "name": "unimplemented",
          "normalized": "String-\u003ea",
          "package": "numeric-prelude",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/MathObj-Wrapper-NumericPrelude.html#v:unimplemented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComplex numbers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Complex",
          "name": "Complex",
          "package": "numeric-prelude",
          "source": "src/Number-Complex.html",
          "type": "module"
        },
        "index": {
          "description": "Complex numbers",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "Complex",
          "package": "numeric-prelude",
          "partial": "Complex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe like to build the Complex Algebraic instance\n   on top of the Algebraic instance of the scalar type.\n   This poses no problem to \u003ccode\u003e\u003ca\u003esqrt\u003c/a\u003e\u003c/code\u003e.\n   However, \u003ccode\u003e\u003ca\u003eroot\u003c/a\u003e\u003c/code\u003e requires computing the complex argument\n   which is a transcendent operation.\n   In order to keep the type class dependencies clean\n   for more sophisticated algebraic number types,\n   we introduce a type class which actually performs the radix operation.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "Power",
          "package": "numeric-prelude",
          "source": "src/Number-Complex.html#Power",
          "type": "class"
        },
        "index": {
          "description": "We like to build the Complex Algebraic instance on top of the Algebraic instance of the scalar type This poses no problem to sqrt However root requires computing the complex argument which is transcendent operation In order to keep the type class dependencies clean for more sophisticated algebraic number types we introduce type class which actually performs the radix operation",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "Power",
          "package": "numeric-prelude",
          "partial": "Power",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#t:Power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplex numbers are an algebraic type.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Complex.html#T",
          "type": "data"
        },
        "index": {
          "description": "Complex numbers are an algebraic type",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a complex number from real and imaginary part.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "(+:)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e T a",
          "source": "src/Number-Complex.html#%2B%3A",
          "type": "function"
        },
        "index": {
          "description": "Construct complex number from real and imaginary part",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "(+:) +:",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a complex number with negated imaginary part.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "(-:)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e T a",
          "source": "src/Number-Complex.html#-%3A",
          "type": "function"
        },
        "index": {
          "description": "Construct complex number with negated imaginary part",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "(-:) -:",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:-45-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ecis\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e is a complex value with magnitude \u003ccode\u003e1\u003c/code\u003e\n and phase \u003ccode\u003et\u003c/code\u003e (modulo \u003ccode\u003e2*\u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "cis",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-Complex.html#cis",
          "type": "function"
        },
        "index": {
          "description": "cis is complex value with magnitude and phase modulo pi",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "cis",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:cis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe conjugate of a complex number.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "conjugate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Complex.html#conjugate",
          "type": "function"
        },
        "index": {
          "description": "The conjugate of complex number",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "conjugate",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:conjugate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "defltPow",
          "package": "numeric-prelude",
          "signature": "Rational -\u003e T a -\u003e T a",
          "source": "src/Number-Complex.html#defltPow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "defltPow",
          "normalized": "Rational-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Pow",
          "signature": "Rational-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:defltPow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponential of a complex number with minimal type class constraints.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "exp",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Complex.html#exp",
          "type": "function"
        },
        "index": {
          "description": "Exponential of complex number with minimal type class constraints",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "exp",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm a complex number from polar components of magnitude and phase.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "fromPolar",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e T a",
          "source": "src/Number-Complex.html#fromPolar",
          "type": "function"
        },
        "index": {
          "description": "Form complex number from polar components of magnitude and phase",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "fromPolar",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Polar",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:fromPolar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "fromReal",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-Complex.html#fromReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "fromReal",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Real",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:fromReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "imaginaryUnit",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/Number-Complex.html#imaginaryUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "imaginaryUnit",
          "package": "numeric-prelude",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:imaginaryUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "magnitude",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Complex.html#magnitude",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "magnitude",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:magnitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "magnitudeSqr",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Complex.html#magnitudeSqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "magnitudeSqr",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Sqr",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:magnitudeSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe phase of a complex number, in the range \u003ccode\u003e(-\u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e]\u003c/code\u003e.\n If the magnitude is zero, then so is the phase.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "phase",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Complex.html#phase",
          "type": "function"
        },
        "index": {
          "description": "The phase of complex number in the range pi pi If the magnitude is zero then so is the phase",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "phase",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:phase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "power",
          "package": "numeric-prelude",
          "signature": "Rational -\u003e T a -\u003e T a",
          "source": "src/Number-Complex.html#power",
          "type": "method"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "power",
          "normalized": "Rational-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "Rational-\u003eT a-\u003eT a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "propPolar",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Bool",
          "source": "src/Number-Complex.html#propPolar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "propPolar",
          "normalized": "T a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Polar",
          "signature": "T a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:propPolar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn the point one quarter to the right.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "quarterLeft",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Complex.html#quarterLeft",
          "type": "function"
        },
        "index": {
          "description": "Turn the point one quarter to the right",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "quarterLeft",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Left",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:quarterLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn the point one quarter to the right.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "quarterRight",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Complex.html#quarterRight",
          "type": "function"
        },
        "index": {
          "description": "Turn the point one quarter to the right",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "quarterRight",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Right",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:quarterRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a complex number by a real number.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/Number-Complex.html#scale",
          "type": "function"
        },
        "index": {
          "description": "Scale complex number by real number",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "scale",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a complex number to magnitude 1.\n\u003c/p\u003e\u003cp\u003eFor a complex number \u003ccode\u003ez\u003c/code\u003e,\n\u003ccode\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e z\u003c/code\u003e is a number with the magnitude of \u003ccode\u003ez\u003c/code\u003e,\nbut oriented in the positive real direction,\nwhereas \u003ccode\u003e\u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e z\u003c/code\u003e has the phase of \u003ccode\u003ez\u003c/code\u003e, but unit magnitude.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "signum",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Complex.html#signum",
          "type": "function"
        },
        "index": {
          "description": "Scale complex number to magnitude For complex number abs is number with the magnitude of but oriented in the positive real direction whereas signum has the phase of but unit magnitude",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "signum",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:signum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Complex",
          "name": "signumNorm",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Complex.html#signumNorm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "signumNorm",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Norm",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:signumNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003etoPolar\u003c/a\u003e\u003c/code\u003e takes a complex number and\nreturns a (magnitude, phase) pair in canonical form:\nthe magnitude is nonnegative, and the phase in the range \u003ccode\u003e(-\u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e]\u003c/code\u003e;\nif the magnitude is zero, then so is the phase.\n\u003c/p\u003e",
          "module": "Number.Complex",
          "name": "toPolar",
          "package": "numeric-prelude",
          "signature": "T a -\u003e (a, a)",
          "source": "src/Number-Complex.html#toPolar",
          "type": "function"
        },
        "index": {
          "description": "The function toPolar takes complex number and returns magnitude phase pair in canonical form the magnitude is nonnegative and the phase in the range pi pi if the magnitude is zero then so is the phase",
          "hierarchy": "Number Complex",
          "module": "Number.Complex",
          "name": "toPolar",
          "normalized": "T a-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Polar",
          "signature": "T a-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Complex.html#v:toPolar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpecial physical units: SI unit system\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.DimensionTerm.SI",
          "name": "SI",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm-SI.html",
          "type": "module"
        },
        "index": {
          "description": "Special physical units SI unit system",
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "SI",
          "package": "numeric-prelude",
          "partial": "SI",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "astronomicUnit",
          "package": "numeric-prelude",
          "signature": "Length a",
          "source": "src/Number-DimensionTerm-SI.html#astronomicUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "astronomicUnit",
          "package": "numeric-prelude",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:astronomicUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "atto",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#atto",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:atto\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:atto\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "atto",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:atto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "bit",
          "package": "numeric-prelude",
          "signature": "Information a",
          "source": "src/Number-DimensionTerm-SI.html#bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "bit",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:bit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "byte",
          "package": "numeric-prelude",
          "signature": "Information a",
          "source": "src/Number-DimensionTerm-SI.html#byte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "byte",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:byte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "centi",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#centi",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:centi\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:centi\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "centi",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:centi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "coulomb",
          "package": "numeric-prelude",
          "signature": "Charge a",
          "source": "src/Number-DimensionTerm-SI.html#coulomb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "coulomb",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:coulomb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "day",
          "package": "numeric-prelude",
          "signature": "Time a",
          "source": "src/Number-DimensionTerm-SI.html#day",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "day",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:day"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "deca",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#deca",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:deca\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:deca\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "deca",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:deca"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "deci",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#deci",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:deci\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:deci\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "deci",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:deci"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "exa",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#exa",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:exa\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:exa\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "exa",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:exa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "femto",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#femto",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:femto\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:femto\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "femto",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:femto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "foot",
          "package": "numeric-prelude",
          "signature": "Length a",
          "source": "src/Number-DimensionTerm-SI.html#foot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "foot",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:foot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "giga",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#giga",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:giga\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:giga\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "giga",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:giga"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "gramm",
          "package": "numeric-prelude",
          "signature": "Mass a",
          "source": "src/Number-DimensionTerm-SI.html#gramm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "gramm",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:gramm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "hecto",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#hecto",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:hecto\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:hecto\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "hecto",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:hecto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "hertz",
          "package": "numeric-prelude",
          "signature": "Frequency a",
          "source": "src/Number-DimensionTerm-SI.html#hertz",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "hertz",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:hertz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "hour",
          "package": "numeric-prelude",
          "signature": "Time a",
          "source": "src/Number-DimensionTerm-SI.html#hour",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "hour",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:hour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "inch",
          "package": "numeric-prelude",
          "signature": "Length a",
          "source": "src/Number-DimensionTerm-SI.html#inch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "inch",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:inch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "kelvin",
          "package": "numeric-prelude",
          "signature": "Temperature a",
          "source": "src/Number-DimensionTerm-SI.html#kelvin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "kelvin",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:kelvin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "kilo",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#kilo",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:kilo\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:kilo\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "kilo",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:kilo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "mega",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#mega",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:mega\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:mega\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "mega",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:mega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "meter",
          "package": "numeric-prelude",
          "signature": "Length a",
          "source": "src/Number-DimensionTerm-SI.html#meter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "meter",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:meter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "micro",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#micro",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:micro\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:micro\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "micro",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:micro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "milli",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#milli",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:milli\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:milli\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "milli",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:milli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "minute",
          "package": "numeric-prelude",
          "signature": "Time a",
          "source": "src/Number-DimensionTerm-SI.html#minute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "minute",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:minute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "nano",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#nano",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:nano\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:nano\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "nano",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:nano"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "one",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#one",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:one\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:one\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "one",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "parsec",
          "package": "numeric-prelude",
          "signature": "Length a",
          "source": "src/Number-DimensionTerm-SI.html#parsec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "parsec",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:parsec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "peta",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#peta",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:peta\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:peta\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "peta",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:peta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "pico",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#pico",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:pico\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:pico\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "pico",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:pico"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "second",
          "package": "numeric-prelude",
          "signature": "Time a",
          "source": "src/Number-DimensionTerm-SI.html#second",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "second",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:second"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "tera",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#tera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:tera\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:tera\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "tera",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:tera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "tonne",
          "package": "numeric-prelude",
          "signature": "Mass a",
          "source": "src/Number-DimensionTerm-SI.html#tonne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "tonne",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:tonne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "volt",
          "package": "numeric-prelude",
          "signature": "Voltage a",
          "source": "src/Number-DimensionTerm-SI.html#volt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "volt",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:volt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "yard",
          "package": "numeric-prelude",
          "signature": "Length a",
          "source": "src/Number-DimensionTerm-SI.html#yard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "yard",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:yard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm.SI",
          "name": "year",
          "package": "numeric-prelude",
          "signature": "Time a",
          "source": "src/Number-DimensionTerm-SI.html#year",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "year",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:year"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrefixes used for SI units\n\u003c/p\u003e",
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "yocto",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#yocto",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:yocto\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:yocto\"]"
        },
        "index": {
          "description": "Prefixes used for SI units",
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "yocto",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:yocto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "yotta",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#yotta",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:yotta\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:yotta\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "yotta",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:yotta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "zepto",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#zepto",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:zepto\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:zepto\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "zepto",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:zepto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.DimensionTerm.SI\",\"Number.SI.Unit\"]",
          "name": "zetta",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#zetta",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:zetta\",\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:zetta\"]"
        },
        "index": {
          "hierarchy": "Number DimensionTerm SI",
          "module": "Number.DimensionTerm.SI",
          "name": "zetta",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm-SI.html#v:zetta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSee \u003ca\u003eAlgebra.DimensionTerm\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.DimensionTerm",
          "name": "DimensionTerm",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html",
          "type": "module"
        },
        "index": {
          "description": "See Algebra.DimensionTerm",
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "DimensionTerm",
          "package": "numeric-prelude",
          "partial": "Dimension Term",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Angle",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Angle",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Angle",
          "package": "numeric-prelude",
          "partial": "Angle",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Charge",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Charge",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Charge",
          "package": "numeric-prelude",
          "partial": "Charge",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Charge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Frequency",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Frequency",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Frequency",
          "package": "numeric-prelude",
          "partial": "Frequency",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Frequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Information",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Information",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Information",
          "package": "numeric-prelude",
          "partial": "Information",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Information"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Length",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Length",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Length",
          "package": "numeric-prelude",
          "partial": "Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Mass",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Mass",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Mass",
          "package": "numeric-prelude",
          "partial": "Mass",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Scalar",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Scalar",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Scalar",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Temperature",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Temperature",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Temperature",
          "package": "numeric-prelude",
          "partial": "Temperature",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Temperature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Time",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Time",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Time",
          "package": "numeric-prelude",
          "partial": "Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Voltage",
          "package": "numeric-prelude",
          "source": "src/Number-DimensionTerm.html#Voltage",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Voltage",
          "package": "numeric-prelude",
          "partial": "Voltage",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#t:Voltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "(&*&)",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e T v a -\u003e T (Mul u v) a",
          "source": "src/Number-DimensionTerm.html#%26%2A%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "(&*&) &*&",
          "normalized": "T a b-\u003eT c b-\u003eT(Mul a c)b",
          "package": "numeric-prelude",
          "signature": "T u a-\u003eT v a-\u003eT(Mul u v)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:-38--42--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "(&/&)",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e T v a -\u003e T (Mul u (Recip v)) a",
          "source": "src/Number-DimensionTerm.html#%26%2F%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "(&/&) &/&",
          "normalized": "T a b-\u003eT c b-\u003eT(Mul a(Recip c))b",
          "package": "numeric-prelude",
          "signature": "T u a-\u003eT v a-\u003eT(Mul u(Recip v))a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:-38--47--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "(*&)",
          "package": "numeric-prelude",
          "signature": "a -\u003e T u a -\u003e T u a",
          "source": "src/Number-DimensionTerm.html#%2A%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "(*&) *&",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT u a-\u003eT u a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:-42--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons a",
          "source": "src/Number-DimensionTerm.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "abs",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e T u a",
          "source": "src/Number-DimensionTerm.html#abs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "abs",
          "normalized": "T a b-\u003eT a b",
          "package": "numeric-prelude",
          "signature": "T u a-\u003eT u a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "absSignum",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e (T u a, a)",
          "source": "src/Number-DimensionTerm.html#absSignum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "absSignum",
          "normalized": "T a b-\u003e(T a b,b)",
          "package": "numeric-prelude",
          "partial": "Signum",
          "signature": "T u a-\u003e(T u a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:absSignum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "angle",
          "package": "numeric-prelude",
          "signature": "a -\u003e Angle a",
          "source": "src/Number-DimensionTerm.html#angle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "angle",
          "normalized": "a-\u003eAngle a",
          "package": "numeric-prelude",
          "signature": "a-\u003eAngle a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "cancelToScalar",
          "package": "numeric-prelude",
          "signature": "T (Mul u (Recip u)) a -\u003e a",
          "source": "src/Number-DimensionTerm.html#cancelToScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "cancelToScalar",
          "normalized": "T(Mul a(Recip a))b-\u003eb",
          "package": "numeric-prelude",
          "partial": "To Scalar",
          "signature": "T(Mul u(Recip u))a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:cancelToScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "charge",
          "package": "numeric-prelude",
          "signature": "a -\u003e Charge a",
          "source": "src/Number-DimensionTerm.html#charge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "charge",
          "normalized": "a-\u003eCharge a",
          "package": "numeric-prelude",
          "signature": "a-\u003eCharge a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:charge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "divToScalar",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e T u a -\u003e a",
          "source": "src/Number-DimensionTerm.html#divToScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "divToScalar",
          "normalized": "T a b-\u003eT a b-\u003eb",
          "package": "numeric-prelude",
          "partial": "To Scalar",
          "signature": "T u a-\u003eT u a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:divToScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "frequency",
          "package": "numeric-prelude",
          "signature": "a -\u003e Frequency a",
          "source": "src/Number-DimensionTerm.html#frequency",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "frequency",
          "normalized": "a-\u003eFrequency a",
          "package": "numeric-prelude",
          "signature": "a-\u003eFrequency a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:frequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "fromNumber",
          "package": "numeric-prelude",
          "signature": "a -\u003e Scalar a",
          "source": "src/Number-DimensionTerm.html#fromNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "fromNumber",
          "normalized": "a-\u003eScalar a",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "a-\u003eScalar a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:fromNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "fromNumberWithDimension",
          "package": "numeric-prelude",
          "signature": "u -\u003e a -\u003e T u a",
          "source": "src/Number-DimensionTerm.html#fromNumberWithDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "fromNumberWithDimension",
          "normalized": "a-\u003eb-\u003eT a b",
          "package": "numeric-prelude",
          "partial": "Number With Dimension",
          "signature": "u-\u003ea-\u003eT u a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:fromNumberWithDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "information",
          "package": "numeric-prelude",
          "signature": "a -\u003e Information a",
          "source": "src/Number-DimensionTerm.html#information",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "information",
          "normalized": "a-\u003eInformation a",
          "package": "numeric-prelude",
          "signature": "a-\u003eInformation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:information"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "length",
          "package": "numeric-prelude",
          "signature": "a -\u003e Length a",
          "source": "src/Number-DimensionTerm.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "length",
          "normalized": "a-\u003eLength a",
          "package": "numeric-prelude",
          "signature": "a-\u003eLength a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "mass",
          "package": "numeric-prelude",
          "signature": "a -\u003e Mass a",
          "source": "src/Number-DimensionTerm.html#mass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "mass",
          "normalized": "a-\u003eMass a",
          "package": "numeric-prelude",
          "signature": "a-\u003eMass a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "mulToScalar",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e T (Recip u) a -\u003e a",
          "source": "src/Number-DimensionTerm.html#mulToScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "mulToScalar",
          "normalized": "T a b-\u003eT(Recip a)b-\u003eb",
          "package": "numeric-prelude",
          "partial": "To Scalar",
          "signature": "T u a-\u003eT(Recip u)a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:mulToScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e T (Recip u) a",
          "source": "src/Number-DimensionTerm.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "recip",
          "normalized": "T a b-\u003eT(Recip a)b",
          "package": "numeric-prelude",
          "signature": "T u a-\u003eT(Recip u)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "rewriteDimension",
          "package": "numeric-prelude",
          "signature": "(u -\u003e v) -\u003e T u a -\u003e T v a",
          "source": "src/Number-DimensionTerm.html#rewriteDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "rewriteDimension",
          "normalized": "(a-\u003eb)-\u003eT a c-\u003eT b c",
          "package": "numeric-prelude",
          "partial": "Dimension",
          "signature": "(u-\u003ev)-\u003eT u a-\u003eT v a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:rewriteDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "scalar",
          "package": "numeric-prelude",
          "signature": "a -\u003e Scalar a",
          "source": "src/Number-DimensionTerm.html#scalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "scalar",
          "normalized": "a-\u003eScalar a",
          "package": "numeric-prelude",
          "signature": "a-\u003eScalar a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e T u a -\u003e T u a",
          "source": "src/Number-DimensionTerm.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "scale",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT u a-\u003eT u a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "sqr",
          "package": "numeric-prelude",
          "signature": "T u a -\u003e T (Sqr u) a",
          "source": "src/Number-DimensionTerm.html#sqr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "sqr",
          "normalized": "T a b-\u003eT(Sqr a)b",
          "package": "numeric-prelude",
          "signature": "T u a-\u003eT(Sqr u)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:sqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "T (Sqr u) a -\u003e T u a",
          "source": "src/Number-DimensionTerm.html#sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "sqrt",
          "normalized": "T(Sqr a)b-\u003eT a b",
          "package": "numeric-prelude",
          "signature": "T(Sqr u)a-\u003eT u a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "temperature",
          "package": "numeric-prelude",
          "signature": "a -\u003e Temperature a",
          "source": "src/Number-DimensionTerm.html#temperature",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "temperature",
          "normalized": "a-\u003eTemperature a",
          "package": "numeric-prelude",
          "signature": "a-\u003eTemperature a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:temperature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "time",
          "package": "numeric-prelude",
          "signature": "a -\u003e Time a",
          "source": "src/Number-DimensionTerm.html#time",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "time",
          "normalized": "a-\u003eTime a",
          "package": "numeric-prelude",
          "signature": "a-\u003eTime a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "toNumber",
          "package": "numeric-prelude",
          "signature": "Scalar a -\u003e a",
          "source": "src/Number-DimensionTerm.html#toNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "toNumber",
          "normalized": "Scalar a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "Scalar a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:toNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "toNumberWithDimension",
          "package": "numeric-prelude",
          "signature": "u -\u003e T u a -\u003e a",
          "source": "src/Number-DimensionTerm.html#toNumberWithDimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "toNumberWithDimension",
          "normalized": "a-\u003eT a b-\u003eb",
          "package": "numeric-prelude",
          "partial": "Number With Dimension",
          "signature": "u-\u003eT u a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:toNumberWithDimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "unrecip",
          "package": "numeric-prelude",
          "signature": "T (Recip u) a -\u003e T u a",
          "source": "src/Number-DimensionTerm.html#unrecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "unrecip",
          "normalized": "T(Recip a)b-\u003eT a b",
          "package": "numeric-prelude",
          "signature": "T(Recip u)a-\u003eT u a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:unrecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.DimensionTerm",
          "name": "voltage",
          "package": "numeric-prelude",
          "signature": "a -\u003e Voltage a",
          "source": "src/Number-DimensionTerm.html#voltage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number DimensionTerm",
          "module": "Number.DimensionTerm",
          "name": "voltage",
          "normalized": "a-\u003eVoltage a",
          "package": "numeric-prelude",
          "signature": "a-\u003eVoltage a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-DimensionTerm.html#v:voltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "source": "src/Number-FixedPoint-Check.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-FixedPoint-Check.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/Number-FixedPoint-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-FixedPoint-Check.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "commonDenominator",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e a -\u003e a",
          "source": "src/Number-FixedPoint-Check.html#commonDenominator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "commonDenominator",
          "normalized": "Integer-\u003eInteger-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Denominator",
          "signature": "Integer-\u003eInteger-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:commonDenominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "cons",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#cons",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "cons",
          "normalized": "Integer-\u003eInteger-\u003eT",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "defltDenominator",
          "package": "numeric-prelude",
          "signature": "Integer",
          "source": "src/Number-FixedPoint-Check.html#defltDenominator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "defltDenominator",
          "package": "numeric-prelude",
          "partial": "Denominator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:defltDenominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "defltShow",
          "package": "numeric-prelude",
          "signature": "T -\u003e String",
          "source": "src/Number-FixedPoint-Check.html#defltShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "defltShow",
          "normalized": "T-\u003eString",
          "package": "numeric-prelude",
          "partial": "Show",
          "signature": "T-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:defltShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "denominator",
          "package": "numeric-prelude",
          "signature": "Integer",
          "source": "src/Number-FixedPoint-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "denominator",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:denominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edenominator conversion\n\u003c/p\u003e",
          "module": "Number.FixedPoint.Check",
          "name": "fromFixedPoint",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e T -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#fromFixedPoint",
          "type": "function"
        },
        "index": {
          "description": "denominator conversion",
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "fromFixedPoint",
          "normalized": "Integer-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Fixed Point",
          "signature": "Integer-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:fromFixedPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "fromFloat",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e a -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#fromFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "fromFloat",
          "normalized": "Integer-\u003ea-\u003eT",
          "package": "numeric-prelude",
          "partial": "Float",
          "signature": "Integer-\u003ea-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:fromFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "fromFloatBasis",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Int -\u003e a -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#fromFloatBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "fromFloatBasis",
          "normalized": "Integer-\u003eInt-\u003ea-\u003eT",
          "package": "numeric-prelude",
          "partial": "Float Basis",
          "signature": "Integer-\u003eInt-\u003ea-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:fromFloatBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "fromInteger'",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#fromInteger%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "fromInteger'",
          "normalized": "Integer-\u003eInteger-\u003eT",
          "package": "numeric-prelude",
          "partial": "Integer'",
          "signature": "Integer-\u003eInteger-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:fromInteger-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "fromIntegerBasis",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Int -\u003e Integer -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#fromIntegerBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "fromIntegerBasis",
          "normalized": "Integer-\u003eInt-\u003eInteger-\u003eT",
          "package": "numeric-prelude",
          "partial": "Integer Basis",
          "signature": "Integer-\u003eInt-\u003eInteger-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:fromIntegerBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "fromRational'",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Rational -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#fromRational%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "fromRational'",
          "normalized": "Integer-\u003eRational-\u003eT",
          "package": "numeric-prelude",
          "partial": "Rational'",
          "signature": "Integer-\u003eRational-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:fromRational-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "fromRationalBasis",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Int -\u003e Rational -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#fromRationalBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "fromRationalBasis",
          "normalized": "Integer-\u003eInt-\u003eRational-\u003eT",
          "package": "numeric-prelude",
          "partial": "Rational Basis",
          "signature": "Integer-\u003eInt-\u003eRational-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:fromRationalBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "lift0",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e (Integer -\u003e Integer) -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "lift0",
          "normalized": "Integer-\u003e(Integer-\u003eInteger)-\u003eT",
          "package": "numeric-prelude",
          "signature": "Integer-\u003e(Integer-\u003eInteger)-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "(Integer -\u003e Integer -\u003e Integer) -\u003e T -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "lift1",
          "normalized": "(Integer-\u003eInteger-\u003eInteger)-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "(Integer-\u003eInteger-\u003eInteger)-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(Integer -\u003e Integer -\u003e Integer -\u003e Integer) -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-FixedPoint-Check.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "lift2",
          "normalized": "(Integer-\u003eInteger-\u003eInteger-\u003eInteger)-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "(Integer-\u003eInteger-\u003eInteger-\u003eInteger)-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint.Check",
          "name": "numerator",
          "package": "numeric-prelude",
          "signature": "Integer",
          "source": "src/Number-FixedPoint-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint Check",
          "module": "Number.FixedPoint.Check",
          "name": "numerator",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint-Check.html#v:numerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFixed point numbers.\nThey are implemented as ratios with fixed denominator.\nMany routines fail for some arguments.\nWhen they work,\nthey can be useful for obtaining approximations of some constants.\nWe have not paid attention to rounding errors\nand thus some of the trailing digits may be wrong.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.FixedPoint",
          "name": "FixedPoint",
          "package": "numeric-prelude",
          "source": "src/Number-FixedPoint.html",
          "type": "module"
        },
        "index": {
          "description": "Fixed point numbers They are implemented as ratios with fixed denominator Many routines fail for some arguments When they work they can be useful for obtaining approximations of some constants We have not paid attention to rounding errors and thus some of the trailing digits may be wrong",
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "FixedPoint",
          "package": "numeric-prelude",
          "partial": "Fixed Point",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "add",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "approxLogBase",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e (Int, Integer)",
          "source": "src/Number-FixedPoint.html#approxLogBase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "approxLogBase",
          "normalized": "Integer-\u003eInteger-\u003e(Int,Integer)",
          "package": "numeric-prelude",
          "partial": "Log Base",
          "signature": "Integer-\u003eInteger-\u003e(Int,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:approxLogBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "arctan",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#arctan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "arctan",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:arctan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "arctanSmall",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#arctanSmall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "arctanSmall",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Small",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:arctanSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "cos",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#cos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "cos",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:cos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "divide",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#divide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "divide",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:divide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "eConst",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#eConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "eConst",
          "normalized": "Integer-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Const",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:eConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "evalPowerSeries",
          "package": "numeric-prelude",
          "signature": "[Rational] -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#evalPowerSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "evalPowerSeries",
          "normalized": "[Rational]-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Power Series",
          "signature": "[Rational]-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:evalPowerSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "exp",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "exp",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "expSmall",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#expSmall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "expSmall",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Small",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:expSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edenominator conversion\n\u003c/p\u003e",
          "module": "Number.FixedPoint",
          "name": "fromFixedPoint",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#fromFixedPoint",
          "type": "function"
        },
        "index": {
          "description": "denominator conversion",
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "fromFixedPoint",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Fixed Point",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:fromFixedPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "fromFloat",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e a -\u003e Integer",
          "source": "src/Number-FixedPoint.html#fromFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "fromFloat",
          "normalized": "Integer-\u003ea-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Float",
          "signature": "Integer-\u003ea-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:fromFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "liftShowPosToInt",
          "package": "numeric-prelude",
          "signature": "(Integer -\u003e String) -\u003e Integer -\u003e String",
          "source": "src/Number-FixedPoint.html#liftShowPosToInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "liftShowPosToInt",
          "normalized": "(Integer-\u003eString)-\u003eInteger-\u003eString",
          "package": "numeric-prelude",
          "partial": "Show Pos To Int",
          "signature": "(Integer-\u003eString)-\u003eInteger-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:liftShowPosToInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "ln",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#ln",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "ln",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:ln"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "lnSmall",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#lnSmall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "lnSmall",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Small",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:lnSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "magnitudes",
          "package": "numeric-prelude",
          "signature": "[Integer]",
          "source": "src/Number-FixedPoint.html#magnitudes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "magnitudes",
          "normalized": "[Integer]",
          "package": "numeric-prelude",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:magnitudes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "mul",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "piConst",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#piConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "piConst",
          "normalized": "Integer-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Const",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:piConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "recip",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "recipEConst",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#recipEConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "recipEConst",
          "normalized": "Integer-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "EConst",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:recipEConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "root",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#root",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "root",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "showPositionalBasis",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e String",
          "source": "src/Number-FixedPoint.html#showPositionalBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "showPositionalBasis",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eString",
          "package": "numeric-prelude",
          "partial": "Positional Basis",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:showPositionalBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "showPositionalBin",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e String",
          "source": "src/Number-FixedPoint.html#showPositionalBin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "showPositionalBin",
          "normalized": "Integer-\u003eInteger-\u003eString",
          "package": "numeric-prelude",
          "partial": "Positional Bin",
          "signature": "Integer-\u003eInteger-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:showPositionalBin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003every efficient because it can make use of the decimal output of \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.FixedPoint",
          "name": "showPositionalDec",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e String",
          "source": "src/Number-FixedPoint.html#showPositionalDec",
          "type": "function"
        },
        "index": {
          "description": "very efficient because it can make use of the decimal output of show",
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "showPositionalDec",
          "normalized": "Integer-\u003eInteger-\u003eString",
          "package": "numeric-prelude",
          "partial": "Positional Dec",
          "signature": "Integer-\u003eInteger-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:showPositionalDec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "showPositionalHex",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e String",
          "source": "src/Number-FixedPoint.html#showPositionalHex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "showPositionalHex",
          "normalized": "Integer-\u003eInteger-\u003eString",
          "package": "numeric-prelude",
          "partial": "Positional Hex",
          "signature": "Integer-\u003eInteger-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:showPositionalHex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "sin",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#sin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "sin",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "sqrt",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "sub",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "tan",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer",
          "source": "src/Number-FixedPoint.html#tan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "tan",
          "normalized": "Integer-\u003eInteger-\u003eInteger",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:tan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.FixedPoint",
          "name": "toPositional",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e Integer -\u003e Integer -\u003e (Integer, [Integer])",
          "source": "src/Number-FixedPoint.html#toPositional",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number FixedPoint",
          "module": "Number.FixedPoint",
          "name": "toPositional",
          "normalized": "Integer-\u003eInteger-\u003eInteger-\u003e(Integer,[Integer])",
          "package": "numeric-prelude",
          "partial": "Positional",
          "signature": "Integer-\u003eInteger-\u003eInteger-\u003e(Integer,[Integer])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-FixedPoint.html#v:toPositional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis number type is intended for tests of functions over fields,\nwhere the field elements need constant space.\nThis way we can provide a Storable instance.\nFor \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e this would not be possible.\n\u003c/p\u003e\u003cp\u003eHowever, be aware that sums of non-zero elements may yield zero.\nThus division is not always safe, where it is for rational numbers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.GaloisField2p32m5",
          "name": "GaloisField2p32m5",
          "package": "numeric-prelude",
          "source": "src/Number-GaloisField2p32m5.html",
          "type": "module"
        },
        "index": {
          "description": "This number type is intended for tests of functions over fields where the field elements need constant space This way we can provide Storable instance For Rational this would not be possible However be aware that sums of non-zero elements may yield zero Thus division is not always safe where it is for rational numbers",
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "GaloisField2p32m5",
          "package": "numeric-prelude",
          "partial": "Galois Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.GaloisField2p32m5",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-GaloisField2p32m5.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.GaloisField2p32m5",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/Number-GaloisField2p32m5.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.GaloisField2p32m5",
          "name": "appPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-GaloisField2p32m5.html#appPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "appPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#v:appPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.GaloisField2p32m5",
          "name": "base",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-GaloisField2p32m5.html#base",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "base",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#v:base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.GaloisField2p32m5",
          "name": "decons",
          "package": "numeric-prelude",
          "signature": "Word32",
          "source": "src/Number-GaloisField2p32m5.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "decons",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#v:decons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.GaloisField2p32m5",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(Word64 -\u003e Word64 -\u003e Word64) -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-GaloisField2p32m5.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "lift2",
          "normalized": "(Word-\u003eWord-\u003eWord)-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "(Word-\u003eWord-\u003eWord)-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.GaloisField2p32m5",
          "name": "lift2Integer",
          "package": "numeric-prelude",
          "signature": "(Int64 -\u003e Int64 -\u003e Int64) -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-GaloisField2p32m5.html#lift2Integer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number GaloisField2p32m5",
          "module": "Number.GaloisField2p32m5",
          "name": "lift2Integer",
          "normalized": "(Int-\u003eInt-\u003eInt)-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "(Int-\u003eInt-\u003eInt)-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-GaloisField2p32m5.html#v:lift2Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA type for non-negative numbers.\nIt performs a run-time check at construction time (i.e. at run-time)\nand is a member of the non-negative number type class\n\u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.NonNegative",
          "name": "NonNegative",
          "package": "numeric-prelude",
          "source": "src/Number-NonNegative.html",
          "type": "module"
        },
        "index": {
          "description": "type for non-negative numbers It performs run-time check at construction time i.e at run-time and is member of the non-negative number type class",
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "NonNegative",
          "package": "numeric-prelude",
          "partial": "Non Negative",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "Double",
          "package": "numeric-prelude",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "Double",
          "package": "numeric-prelude",
          "partial": "Double",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#t:Double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "Float",
          "package": "numeric-prelude",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "Float",
          "package": "numeric-prelude",
          "partial": "Float",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#t:Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "Int",
          "package": "numeric-prelude",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "Int",
          "package": "numeric-prelude",
          "partial": "Int",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#t:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "Integer",
          "package": "numeric-prelude",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "Integer",
          "package": "numeric-prelude",
          "partial": "Integer",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#t:Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "Ratio",
          "package": "numeric-prelude",
          "source": "src/Number-NonNegative.html#Ratio",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "Ratio",
          "package": "numeric-prelude",
          "partial": "Ratio",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#t:Ratio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "Rational",
          "package": "numeric-prelude",
          "source": "src/Number-NonNegative.html#Rational",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "Rational",
          "package": "numeric-prelude",
          "partial": "Rational",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#t:Rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a number to a non-negative number.\nIf a negative number is given, an error is raised.\n\u003c/p\u003e",
          "module": "Number.NonNegative",
          "name": "fromNumber",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-NonNegative.html#fromNumber",
          "type": "function"
        },
        "index": {
          "description": "Convert number to non-negative number If negative number is given an error is raised",
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "fromNumber",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#v:fromNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a number to a non-negative number.\nA negative number will be replaced by zero.\nUse this function with care since it may hide bugs.\n\u003c/p\u003e",
          "module": "Number.NonNegative",
          "name": "fromNumberClip",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-NonNegative.html#fromNumberClip",
          "type": "function"
        },
        "index": {
          "description": "Convert number to non-negative number negative number will be replaced by zero Use this function with care since it may hide bugs",
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "fromNumberClip",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Number Clip",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#v:fromNumberClip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "fromNumberMsg",
          "package": "numeric-prelude",
          "signature": "String-\u003e a-\u003e T a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "fromNumberMsg",
          "normalized": "String-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Number Msg",
          "signature": "String-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#v:fromNumberMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap a number into a non-negative number without doing checks.\nThis routine exists entirely for efficiency reasons\nand must be used only in cases where you are absolutely sure,\nthat the input number is non-negative.\n\u003c/p\u003e",
          "module": "Number.NonNegative",
          "name": "fromNumberUnsafe",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "type": "function"
        },
        "index": {
          "description": "Wrap number into non-negative number without doing checks This routine exists entirely for efficiency reasons and must be used only in cases where you are absolutely sure that the input number is non-negative",
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "fromNumberUnsafe",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Number Unsafe",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#v:fromNumberUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegative",
          "name": "toNumber",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegative",
          "module": "Number.NonNegative",
          "name": "toNumber",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegative.html#v:toNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA lazy number type, which is a generalization of lazy Peano numbers.\nComparisons can be made lazy and\nthus computations are possible which are impossible with strict number types,\ne.g. you can compute \u003ccode\u003elet y = min (1+y) 2 in y\u003c/code\u003e.\nYou can even work with infinite values.\nHowever, depending on the granularity,\nthe memory consumption is higher than that for strict number types.\nThis number type is of interest for the merge operation of event lists,\nwhich allows for co-recursive merges.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.NonNegativeChunky",
          "name": "NonNegativeChunky",
          "package": "numeric-prelude",
          "source": "src/Number-NonNegativeChunky.html",
          "type": "module"
        },
        "index": {
          "description": "lazy number type which is generalization of lazy Peano numbers Comparisons can be made lazy and thus computations are possible which are impossible with strict number types e.g you can compute let min in You can even work with infinite values However depending on the granularity the memory consumption is higher than that for strict number types This number type is of interest for the merge operation of event lists which allows for co-recursive merges",
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "NonNegativeChunky",
          "package": "numeric-prelude",
          "partial": "Non Negative Chunky",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA chunky non-negative number is a list of non-negative numbers.\nIt represents the sum of the list elements.\nIt is possible to represent a finite number with infinitely many chunks\nby using an infinite number of zeros.\n\u003c/p\u003e\u003cp\u003eNote the following problems:\n\u003c/p\u003e\u003cp\u003eAddition is commutative only for finite representations.\nE.g. \u003ccode\u003elet y = min (1+y) 2 in y\u003c/code\u003e is defined,\n\u003ccode\u003elet y = min (y+1) 2 in y\u003c/code\u003e is not.\n\u003c/p\u003e\u003cp\u003eThe type is equivalent to \u003ccode\u003e\u003ca\u003eChunky\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.NonNegativeChunky",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-NonNegativeChunky.html#T",
          "type": "data"
        },
        "index": {
          "description": "chunky non-negative number is list of non-negative numbers It represents the sum of the list elements It is possible to represent finite number with infinitely many chunks by using an infinite number of zeros Note the following problems Addition is commutative only for finite representations E.g let min in is defined let min in is not The type is equivalent to Chunky",
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edivModLazy accesses the divisor in a lazy way.\nHowever this is only relevant if the dividend is smaller than the divisor.\nFor large dividends the divisor will be accessed multiple times\nbut since it is already fully evaluated it could also be strict.\n\u003c/p\u003e",
          "module": "Number.NonNegativeChunky",
          "name": "divModLazy",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e (T a, T a)",
          "source": "src/Number-NonNegativeChunky.html#divModLazy",
          "type": "function"
        },
        "index": {
          "description": "divModLazy accesses the divisor in lazy way However this is only relevant if the dividend is smaller than the divisor For large dividends the divisor will be accessed multiple times but since it is already fully evaluated it could also be strict",
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "divModLazy",
          "normalized": "T a-\u003eT a-\u003e(T a,T a)",
          "package": "numeric-prelude",
          "partial": "Mod Lazy",
          "signature": "T a-\u003eT a-\u003e(T a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:divModLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function has a strict divisor\nand maintains the chunk structure of the dividend at a smaller scale.\n\u003c/p\u003e",
          "module": "Number.NonNegativeChunky",
          "name": "divModStrict",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a -\u003e (T a, a)",
          "source": "src/Number-NonNegativeChunky.html#divModStrict",
          "type": "function"
        },
        "index": {
          "description": "This function has strict divisor and maintains the chunk structure of the dividend at smaller scale",
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "divModStrict",
          "normalized": "T a-\u003ea-\u003e(T a,a)",
          "package": "numeric-prelude",
          "partial": "Mod Strict",
          "signature": "T a-\u003ea-\u003e(T a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:divModStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "fromChunks",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e T a",
          "source": "src/Number-NonNegativeChunky.html#fromChunks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "fromChunks",
          "normalized": "[a]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Chunks",
          "signature": "[a]-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:fromChunks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "fromChunky98",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-NonNegativeChunky.html#fromChunky98",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "fromChunky98",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Chunky",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:fromChunky98"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "fromNumber",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-NonNegativeChunky.html#fromNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "fromNumber",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:fromNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "isNull",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Bool",
          "source": "src/Number-NonNegativeChunky.html#isNull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "isNull",
          "normalized": "T a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Null",
          "signature": "T a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:isNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "isPositive",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Bool",
          "source": "src/Number-NonNegativeChunky.html#isPositive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "isPositive",
          "normalized": "T a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Positive",
          "signature": "T a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:isPositive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "minMaxDiff",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e (T a, (Bool, T a))",
          "source": "src/Number-NonNegativeChunky.html#minMaxDiff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "minMaxDiff",
          "normalized": "T a-\u003eT a-\u003e(T a,(Bool,T a))",
          "package": "numeric-prelude",
          "partial": "Max Diff",
          "signature": "T a-\u003eT a-\u003e(T a,(Bool,T a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:minMaxDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove zero chunks.\n\u003c/p\u003e",
          "module": "Number.NonNegativeChunky",
          "name": "normalize",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-NonNegativeChunky.html#normalize",
          "type": "function"
        },
        "index": {
          "description": "Remove zero chunks",
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "normalize",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "toChunks",
          "package": "numeric-prelude",
          "signature": "T a -\u003e [a]",
          "source": "src/Number-NonNegativeChunky.html#toChunks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "toChunks",
          "normalized": "T a-\u003e[a]",
          "package": "numeric-prelude",
          "partial": "Chunks",
          "signature": "T a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:toChunks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "toChunky98",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-NonNegativeChunky.html#toChunky98",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "toChunky98",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Chunky",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:toChunky98"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.NonNegativeChunky",
          "name": "toNumber",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-NonNegativeChunky.html#toNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number NonNegativeChunky",
          "module": "Number.NonNegativeChunky",
          "name": "toNumber",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-NonNegativeChunky.html#v:toNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePhysical expressions track the operations made on physical values\nso we are able to give detailed information on how to resolve\nunit violations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.OccasionallyScalarExpression",
          "name": "OccasionallyScalarExpression",
          "package": "numeric-prelude",
          "source": "src/Number-OccasionallyScalarExpression.html",
          "type": "module"
        },
        "index": {
          "description": "Physical expressions track the operations made on physical values so we are able to give detailed information on how to resolve unit violations",
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "OccasionallyScalarExpression",
          "package": "numeric-prelude",
          "partial": "Occasionally Scalar Expression",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e stores information on how to resolve unit violations.\n     The main application of the module are certainly\n     Number.Physical type instances\n     but in principle it can also be applied to other occasionally scalar types. \n\u003c/p\u003e",
          "module": "Number.OccasionallyScalarExpression",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-OccasionallyScalarExpression.html#T",
          "type": "data"
        },
        "index": {
          "description": "value of type stores information on how to resolve unit violations The main application of the module are certainly Number.Physical type instances but in principle it can also be applied to other occasionally scalar types",
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "Term",
          "package": "numeric-prelude",
          "source": "src/Number-OccasionallyScalarExpression.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "Term",
          "package": "numeric-prelude",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "Add",
          "package": "numeric-prelude",
          "signature": "Add (T a v) (T a v)",
          "source": "src/Number-OccasionallyScalarExpression.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "Add",
          "package": "numeric-prelude",
          "partial": "Add",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:Add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons (Term a v) v",
          "source": "src/Number-OccasionallyScalarExpression.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "Const",
          "package": "numeric-prelude",
          "signature": "Const",
          "source": "src/Number-OccasionallyScalarExpression.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "Const",
          "package": "numeric-prelude",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "Div",
          "package": "numeric-prelude",
          "signature": "Div (T a v) (T a v)",
          "source": "src/Number-OccasionallyScalarExpression.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "Div",
          "package": "numeric-prelude",
          "partial": "Div",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:Div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "Mul",
          "package": "numeric-prelude",
          "signature": "Mul (T a v) (T a v)",
          "source": "src/Number-OccasionallyScalarExpression.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "Mul",
          "package": "numeric-prelude",
          "partial": "Mul",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:Mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "fromScalar",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a v",
          "source": "src/Number-OccasionallyScalarExpression.html#fromScalar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "fromScalar",
          "normalized": "a-\u003eT a b",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "a-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:fromScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "fromValue",
          "package": "numeric-prelude",
          "signature": "v -\u003e T a v",
          "source": "src/Number-OccasionallyScalarExpression.html#fromValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "fromValue",
          "normalized": "a-\u003eT b a",
          "package": "numeric-prelude",
          "partial": "Value",
          "signature": "v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:fromValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "lift",
          "package": "numeric-prelude",
          "signature": "(v -\u003e v) -\u003e T a v -\u003e T a v",
          "source": "src/Number-OccasionallyScalarExpression.html#lift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "lift",
          "normalized": "(a-\u003ea)-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "(v-\u003ev)-\u003eT a v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "makeLine",
          "package": "numeric-prelude",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Number-OccasionallyScalarExpression.html#makeLine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "makeLine",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "numeric-prelude",
          "partial": "Line",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:makeLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "scalarMap",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e T a v -\u003e T a v",
          "source": "src/Number-OccasionallyScalarExpression.html#scalarMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "scalarMap",
          "normalized": "(a-\u003ea)-\u003eT a b-\u003eT a b",
          "package": "numeric-prelude",
          "partial": "Map",
          "signature": "(a-\u003ea)-\u003eT a v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:scalarMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "scalarMap2",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e T a v -\u003e T a v -\u003e T a v",
          "source": "src/Number-OccasionallyScalarExpression.html#scalarMap2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "scalarMap2",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a b-\u003eT a b-\u003eT a b",
          "package": "numeric-prelude",
          "partial": "Map",
          "signature": "(a-\u003ea-\u003ea)-\u003eT a v-\u003eT a v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:scalarMap2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.OccasionallyScalarExpression",
          "name": "showUnitError",
          "package": "numeric-prelude",
          "signature": "Bool -\u003e Int -\u003e v -\u003e T a v -\u003e String",
          "source": "src/Number-OccasionallyScalarExpression.html#showUnitError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number OccasionallyScalarExpression",
          "module": "Number.OccasionallyScalarExpression",
          "name": "showUnitError",
          "normalized": "Bool-\u003eInt-\u003ea-\u003eT b a-\u003eString",
          "package": "numeric-prelude",
          "partial": "Unit Error",
          "signature": "Bool-\u003eInt-\u003ev-\u003eT a v-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-OccasionallyScalarExpression.html#v:showUnitError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDefine Transcendental functions on arbitrary fields.\nThese functions are defined for only a few (in most cases only one) arguments,\nthat's why we discourage making these types instances of \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e.\nBut instances of \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e can be useful when working with power series.\nIf you intend to work with power series with \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e coefficients,\nyou might consider using \u003ccode\u003eMathObj.PowerSeries.T (Number.PartiallyTranscendental.T Rational)\u003c/code\u003e\ninstead of \u003ccode\u003eMathObj.PowerSeries.T Rational\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.PartiallyTranscendental",
          "name": "PartiallyTranscendental",
          "package": "numeric-prelude",
          "source": "src/Number-PartiallyTranscendental.html",
          "type": "module"
        },
        "index": {
          "description": "Define Transcendental functions on arbitrary fields These functions are defined for only few in most cases only one arguments that why we discourage making these types instances of But instances of can be useful when working with power series If you intend to work with power series with Rational coefficients you might consider using MathObj.PowerSeries.T Number.PartiallyTranscendental.T Rational instead of MathObj.PowerSeries.T Rational",
          "hierarchy": "Number PartiallyTranscendental",
          "module": "Number.PartiallyTranscendental",
          "name": "PartiallyTranscendental",
          "package": "numeric-prelude",
          "partial": "Partially Transcendental",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-PartiallyTranscendental.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.PartiallyTranscendental",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-PartiallyTranscendental.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number PartiallyTranscendental",
          "module": "Number.PartiallyTranscendental",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-PartiallyTranscendental.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.PartiallyTranscendental",
          "name": "fromValue",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-PartiallyTranscendental.html#fromValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number PartiallyTranscendental",
          "module": "Number.PartiallyTranscendental",
          "name": "fromValue",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Value",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-PartiallyTranscendental.html#v:fromValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.PartiallyTranscendental",
          "name": "toValue",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-PartiallyTranscendental.html#toValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number PartiallyTranscendental",
          "module": "Number.PartiallyTranscendental",
          "name": "toValue",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Value",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-PartiallyTranscendental.html#v:toValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLazy Peano numbers represent natural numbers inclusive infinity.\nSince they are lazily evaluated,\nthey are optimally for use as number type of \u003ccode\u003e\u003ca\u003egenericLength\u003c/a\u003e\u003c/code\u003e et.al.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Peano",
          "name": "Peano",
          "package": "numeric-prelude",
          "source": "src/Number-Peano.html",
          "type": "module"
        },
        "index": {
          "description": "Lazy Peano numbers represent natural numbers inclusive infinity Since they are lazily evaluated they are optimally for use as number type of genericLength et.al",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "Peano",
          "package": "numeric-prelude",
          "partial": "Peano",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Peano.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "Valuable",
          "package": "numeric-prelude",
          "source": "src/Number-Peano.html#Valuable",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "Valuable",
          "package": "numeric-prelude",
          "partial": "Valuable",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#t:Valuable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute '(&&)' with minimal costs.\n\u003c/p\u003e",
          "module": "Number.Peano",
          "name": "(&&~)",
          "package": "numeric-prelude",
          "signature": "Valuable Bool -\u003e Valuable Bool -\u003e Valuable Bool",
          "source": "src/Number-Peano.html#%26%26~",
          "type": "function"
        },
        "index": {
          "description": "Compute with minimal costs",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "(&&~) &&~",
          "normalized": "Valuable Bool-\u003eValuable Bool-\u003eValuable Bool",
          "package": "numeric-prelude",
          "signature": "Valuable Bool-\u003eValuable Bool-\u003eValuable Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:-38--38--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "Succ",
          "package": "numeric-prelude",
          "signature": "Succ T",
          "source": "src/Number-Peano.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "Succ",
          "package": "numeric-prelude",
          "partial": "Succ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "Valuable",
          "package": "numeric-prelude",
          "signature": "Valuable",
          "source": "src/Number-Peano.html#Valuable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "Valuable",
          "package": "numeric-prelude",
          "partial": "Valuable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:Valuable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "Zero",
          "package": "numeric-prelude",
          "signature": "Zero",
          "source": "src/Number-Peano.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "Zero",
          "package": "numeric-prelude",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "T -\u003e T -\u003e T",
          "source": "src/Number-Peano.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "add",
          "normalized": "T-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "T-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "andW",
          "package": "numeric-prelude",
          "signature": "[Valuable Bool] -\u003e Valuable Bool",
          "source": "src/Number-Peano.html#andW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "andW",
          "normalized": "[Valuable Bool]-\u003eValuable Bool",
          "package": "numeric-prelude",
          "signature": "[Valuable Bool]-\u003eValuable Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:andW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOn equality the first operand is returned.\n\u003c/p\u003e",
          "module": "Number.Peano",
          "name": "argMax",
          "package": "numeric-prelude",
          "signature": "(T, a) -\u003e (T, a) -\u003e a",
          "source": "src/Number-Peano.html#argMax",
          "type": "function"
        },
        "index": {
          "description": "On equality the first operand is returned",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "argMax",
          "normalized": "(T,a)-\u003e(T,a)-\u003ea",
          "package": "numeric-prelude",
          "partial": "Max",
          "signature": "(T,a)-\u003e(T,a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:argMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "argMaxFull",
          "package": "numeric-prelude",
          "signature": "(T, a) -\u003e (T, a) -\u003e (T, a)",
          "source": "src/Number-Peano.html#argMaxFull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "argMaxFull",
          "normalized": "(T,a)-\u003e(T,a)-\u003e(T,a)",
          "package": "numeric-prelude",
          "partial": "Max Full",
          "signature": "(T,a)-\u003e(T,a)-\u003e(T,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:argMaxFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "argMaximum",
          "package": "numeric-prelude",
          "signature": "[(T, a)] -\u003e a",
          "source": "src/Number-Peano.html#argMaximum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "argMaximum",
          "normalized": "[(T,a)]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Maximum",
          "signature": "[(T,a)]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:argMaximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOn equality the first operand is returned.\n\u003c/p\u003e",
          "module": "Number.Peano",
          "name": "argMin",
          "package": "numeric-prelude",
          "signature": "(T, a) -\u003e (T, a) -\u003e a",
          "source": "src/Number-Peano.html#argMin",
          "type": "function"
        },
        "index": {
          "description": "On equality the first operand is returned",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "argMin",
          "normalized": "(T,a)-\u003e(T,a)-\u003ea",
          "package": "numeric-prelude",
          "partial": "Min",
          "signature": "(T,a)-\u003e(T,a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:argMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecf.\nTo how to find the shortest list in a list of lists efficiently,\nthis means, also in the presence of infinite lists.\n\u003ca\u003ehttp://www.haskell.org/pipermail/haskell-cafe/2006-October/018753.html\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Number.Peano",
          "name": "argMinFull",
          "package": "numeric-prelude",
          "signature": "(T, a) -\u003e (T, a) -\u003e (T, a)",
          "source": "src/Number-Peano.html#argMinFull",
          "type": "function"
        },
        "index": {
          "description": "cf To how to find the shortest list in list of lists efficiently this means also in the presence of infinite lists http www.haskell.org pipermail haskell-cafe October html",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "argMinFull",
          "normalized": "(T,a)-\u003e(T,a)-\u003e(T,a)",
          "package": "numeric-prelude",
          "partial": "Min Full",
          "signature": "(T,a)-\u003e(T,a)-\u003e(T,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:argMinFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "argMinimum",
          "package": "numeric-prelude",
          "signature": "[(T, a)] -\u003e a",
          "source": "src/Number-Peano.html#argMinimum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "argMinimum",
          "normalized": "[(T,a)]-\u003ea",
          "package": "numeric-prelude",
          "partial": "Minimum",
          "signature": "[(T,a)]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:argMinimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "costs",
          "package": "numeric-prelude",
          "signature": "T",
          "source": "src/Number-Peano.html#Valuable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "costs",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:costs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "err",
          "package": "numeric-prelude",
          "signature": "String -\u003e String -\u003e a",
          "source": "src/Number-Peano.html#err",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "err",
          "normalized": "String-\u003eString-\u003ea",
          "package": "numeric-prelude",
          "signature": "String-\u003eString-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "fromPosEnum",
          "package": "numeric-prelude",
          "signature": "a -\u003e T",
          "source": "src/Number-Peano.html#fromPosEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "fromPosEnum",
          "normalized": "a-\u003eT",
          "package": "numeric-prelude",
          "partial": "Pos Enum",
          "signature": "a-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:fromPosEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn \u003ccode\u003eglue x y == (z,(b,r))\u003c/code\u003e\n\u003ccode\u003ez\u003c/code\u003e represents \u003ccode\u003emin x y\u003c/code\u003e,\n\u003ccode\u003er\u003c/code\u003e represents \u003ccode\u003emax x y - min x y\u003c/code\u003e,\nand \u003ccode\u003ex\u003c=y  ==  b\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eCf. Numeric.NonNegative.Chunky\n\u003c/p\u003e",
          "module": "Number.Peano",
          "name": "glue",
          "package": "numeric-prelude",
          "signature": "T -\u003e T -\u003e (T, (Bool, T))",
          "source": "src/Number-Peano.html#glue",
          "type": "function"
        },
        "index": {
          "description": "In glue represents min represents max min and Cf Numeric.NonNegative.Chunky",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "glue",
          "normalized": "T-\u003eT-\u003e(T,(Bool,T))",
          "package": "numeric-prelude",
          "signature": "T-\u003eT-\u003e(T,(Bool,T))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:glue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf all values are completely defined,\nthen it holds\n\u003c/p\u003e\u003cpre\u003e if b then x else y == ifLazy b x y\n\u003c/pre\u003e\u003cp\u003eHowever if \u003ccode\u003eb\u003c/code\u003e is undefined,\nthen it is at least known that the result is larger than \u003ccode\u003emin x y\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Peano",
          "name": "ifLazy",
          "package": "numeric-prelude",
          "signature": "Bool -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Peano.html#ifLazy",
          "type": "function"
        },
        "index": {
          "description": "If all values are completely defined then it holds if then else ifLazy However if is undefined then it is at least known that the result is larger than min",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "ifLazy",
          "normalized": "Bool-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Lazy",
          "signature": "Bool-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:ifLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "increaseCosts",
          "package": "numeric-prelude",
          "signature": "T -\u003e Valuable a -\u003e Valuable a",
          "source": "src/Number-Peano.html#increaseCosts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "increaseCosts",
          "normalized": "T-\u003eValuable a-\u003eValuable a",
          "package": "numeric-prelude",
          "partial": "Costs",
          "signature": "T-\u003eValuable a-\u003eValuable a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:increaseCosts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "infinity",
          "package": "numeric-prelude",
          "signature": "T",
          "source": "src/Number-Peano.html#infinity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "infinity",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:infinity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "isAscending",
          "package": "numeric-prelude",
          "signature": "[T] -\u003e Bool",
          "source": "src/Number-Peano.html#isAscending",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "isAscending",
          "normalized": "[T]-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Ascending",
          "signature": "[T]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:isAscending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ex0 \u003c= x1 && x1 \u003c= x2 ... \u003c/code\u003e\nfor possibly infinite numbers in finite lists.\n\u003c/p\u003e",
          "module": "Number.Peano",
          "name": "isAscendingFiniteList",
          "package": "numeric-prelude",
          "signature": "[T] -\u003e Bool",
          "source": "src/Number-Peano.html#isAscendingFiniteList",
          "type": "function"
        },
        "index": {
          "description": "x0 x1 x1 x2 for possibly infinite numbers in finite lists",
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "isAscendingFiniteList",
          "normalized": "[T]-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Ascending Finite List",
          "signature": "[T]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:isAscendingFiniteList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "isAscendingFiniteNumbers",
          "package": "numeric-prelude",
          "signature": "[T] -\u003e Bool",
          "source": "src/Number-Peano.html#isAscendingFiniteNumbers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "isAscendingFiniteNumbers",
          "normalized": "[T]-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Ascending Finite Numbers",
          "signature": "[T]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:isAscendingFiniteNumbers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "isAscendingW",
          "package": "numeric-prelude",
          "signature": "[T] -\u003e Valuable Bool",
          "source": "src/Number-Peano.html#isAscendingW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "isAscendingW",
          "normalized": "[T]-\u003eValuable Bool",
          "package": "numeric-prelude",
          "partial": "Ascending",
          "signature": "[T]-\u003eValuable Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:isAscendingW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "leW",
          "package": "numeric-prelude",
          "signature": "T -\u003e T -\u003e Valuable Bool",
          "source": "src/Number-Peano.html#leW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "leW",
          "normalized": "T-\u003eT-\u003eValuable Bool",
          "package": "numeric-prelude",
          "signature": "T-\u003eT-\u003eValuable Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:leW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "T -\u003e T -\u003e T",
          "source": "src/Number-Peano.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "mul",
          "normalized": "T-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "T-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "notImplemented",
          "package": "numeric-prelude",
          "signature": "String -\u003e a",
          "source": "src/Number-Peano.html#notImplemented",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "notImplemented",
          "normalized": "String-\u003ea",
          "package": "numeric-prelude",
          "partial": "Implemented",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:notImplemented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "T -\u003e T -\u003e T",
          "source": "src/Number-Peano.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "sub",
          "normalized": "T-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "T-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "subNeg",
          "package": "numeric-prelude",
          "signature": "T -\u003e T -\u003e (Bool, T)",
          "source": "src/Number-Peano.html#subNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "subNeg",
          "normalized": "T-\u003eT-\u003e(Bool,T)",
          "package": "numeric-prelude",
          "partial": "Neg",
          "signature": "T-\u003eT-\u003e(Bool,T)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:subNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "toListMaybe",
          "package": "numeric-prelude",
          "signature": "a -\u003e T -\u003e [Maybe a]",
          "source": "src/Number-Peano.html#toListMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "toListMaybe",
          "normalized": "a-\u003eT-\u003e[Maybe a]",
          "package": "numeric-prelude",
          "partial": "List Maybe",
          "signature": "a-\u003eT-\u003e[Maybe a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:toListMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "toPosEnum",
          "package": "numeric-prelude",
          "signature": "T -\u003e a",
          "source": "src/Number-Peano.html#toPosEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "toPosEnum",
          "normalized": "T-\u003ea",
          "package": "numeric-prelude",
          "partial": "Pos Enum",
          "signature": "T-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:toPosEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Peano",
          "name": "value",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-Peano.html#Valuable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Peano",
          "module": "Number.Peano",
          "name": "value",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Peano.html#v:value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConvert a human readable string to a physical value.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Physical.Read",
          "name": "Read",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-Read.html",
          "type": "module"
        },
        "index": {
          "description": "Convert human readable string to physical value",
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "Read",
          "package": "numeric-prelude",
          "partial": "Read",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Read",
          "name": "createDict",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e Map String (T i a)",
          "source": "src/Number-Physical-Read.html#createDict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "createDict",
          "normalized": "T a b-\u003eMap String(T a b)",
          "package": "numeric-prelude",
          "partial": "Dict",
          "signature": "T i a-\u003eMap String(T i a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:createDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Read",
          "name": "ignoreSpace",
          "package": "numeric-prelude",
          "signature": "Parser a -\u003e Parser a",
          "source": "src/Number-Physical-Read.html#ignoreSpace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "ignoreSpace",
          "normalized": "Parser a-\u003eParser a",
          "package": "numeric-prelude",
          "partial": "Space",
          "signature": "Parser a-\u003eParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:ignoreSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Read",
          "name": "mulPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-Physical-Read.html#mulPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "mulPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:mulPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Read",
          "name": "parsePower",
          "package": "numeric-prelude",
          "signature": "Parser (String, Integer)",
          "source": "src/Number-Physical-Read.html#parsePower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "parsePower",
          "normalized": "Parser(String,Integer)",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "Parser(String,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:parsePower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function could also return the value,\n    but a list of pairs (String, Integer) is easier for testing. \n\u003c/p\u003e",
          "module": "Number.Physical.Read",
          "name": "parseProduct",
          "package": "numeric-prelude",
          "signature": "Parser [(String, Integer)]",
          "source": "src/Number-Physical-Read.html#parseProduct",
          "type": "function"
        },
        "index": {
          "description": "This function could also return the value but list of pairs String Integer is easier for testing",
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "parseProduct",
          "normalized": "Parser[(String,Integer)]",
          "package": "numeric-prelude",
          "partial": "Product",
          "signature": "Parser[(String,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:parseProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Read",
          "name": "parseProductTail",
          "package": "numeric-prelude",
          "signature": "Parser [(String, Integer)]",
          "source": "src/Number-Physical-Read.html#parseProductTail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "parseProductTail",
          "normalized": "Parser[(String,Integer)]",
          "package": "numeric-prelude",
          "partial": "Product Tail",
          "signature": "Parser[(String,Integer)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:parseProductTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Read",
          "name": "readUnitPart",
          "package": "numeric-prelude",
          "signature": "Map String (T i a) -\u003e String -\u003e (T i a, String)",
          "source": "src/Number-Physical-Read.html#readUnitPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "readUnitPart",
          "normalized": "Map String(T a b)-\u003eString-\u003e(T a b,String)",
          "package": "numeric-prelude",
          "partial": "Unit Part",
          "signature": "Map String(T i a)-\u003eString-\u003e(T i a,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:readUnitPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Read",
          "name": "readsNat",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e Int -\u003e ReadS (T i v)",
          "source": "src/Number-Physical-Read.html#readsNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Read",
          "module": "Number.Physical.Read",
          "name": "readsNat",
          "normalized": "T a b-\u003eInt-\u003eReadS(T a c)",
          "package": "numeric-prelude",
          "partial": "Nat",
          "signature": "T i a-\u003eInt-\u003eReadS(T i v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Read.html#v:readsNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConvert a physical value to a human readable string.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Physical.Show",
          "name": "Show",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-Show.html",
          "type": "module"
        },
        "index": {
          "description": "Convert physical value to human readable string",
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "Show",
          "package": "numeric-prelude",
          "partial": "Show",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChoose a scale where the number becomes handy\n    and return the scaled number and the corresponding scale. \n\u003c/p\u003e",
          "module": "Number.Physical.Show",
          "name": "chooseScale",
          "package": "numeric-prelude",
          "signature": "v -\u003e UnitSet i a -\u003e (v, Scale a)",
          "source": "src/Number-Physical-Show.html#chooseScale",
          "type": "function"
        },
        "index": {
          "description": "Choose scale where the number becomes handy and return the scaled number and the corresponding scale",
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "chooseScale",
          "normalized": "a-\u003eUnitSet b c-\u003e(a,Scale c)",
          "package": "numeric-prelude",
          "partial": "Scale",
          "signature": "v-\u003eUnitSet i a-\u003e(v,Scale a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:chooseScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Show",
          "name": "defScale",
          "package": "numeric-prelude",
          "signature": "UnitSet i v -\u003e Scale v",
          "source": "src/Number-Physical-Show.html#defScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "defScale",
          "normalized": "UnitSet a b-\u003eScale b",
          "package": "numeric-prelude",
          "partial": "Scale",
          "signature": "UnitSet i v-\u003eScale v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:defScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Show",
          "name": "findCloseScale",
          "package": "numeric-prelude",
          "signature": "a -\u003e [Scale a] -\u003e Scale a",
          "source": "src/Number-Physical-Show.html#findCloseScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "findCloseScale",
          "normalized": "a-\u003e[Scale a]-\u003eScale a",
          "package": "numeric-prelude",
          "partial": "Close Scale",
          "signature": "a-\u003e[Scale a]-\u003eScale a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:findCloseScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunused \n\u003c/p\u003e",
          "module": "Number.Physical.Show",
          "name": "getUnit",
          "package": "numeric-prelude",
          "signature": "String -\u003e T i a -\u003e T i a",
          "source": "src/Number-Physical-Show.html#getUnit",
          "type": "function"
        },
        "index": {
          "description": "unused",
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "getUnit",
          "normalized": "String-\u003eT a b-\u003eT a b",
          "package": "numeric-prelude",
          "partial": "Unit",
          "signature": "String-\u003eT i a-\u003eT i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:getUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Show",
          "name": "mulPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-Physical-Show.html#mulPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "mulPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:mulPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow the physical quantity in a human readable form\n    with respect to a given unit data base. \n\u003c/p\u003e",
          "module": "Number.Physical.Show",
          "name": "showNat",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e T i v -\u003e String",
          "source": "src/Number-Physical-Show.html#showNat",
          "type": "function"
        },
        "index": {
          "description": "Show the physical quantity in human readable form with respect to given unit data base",
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "showNat",
          "normalized": "T a b-\u003eT a c-\u003eString",
          "package": "numeric-prelude",
          "partial": "Nat",
          "signature": "T i a-\u003eT i v-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:showNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Show",
          "name": "showScaled",
          "package": "numeric-prelude",
          "signature": "v -\u003e [UnitSet i a] -\u003e (v, String)",
          "source": "src/Number-Physical-Show.html#showScaled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "showScaled",
          "normalized": "a-\u003e[UnitSet b c]-\u003e(a,String)",
          "package": "numeric-prelude",
          "partial": "Scaled",
          "signature": "v-\u003e[UnitSet i a]-\u003e(v,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:showScaled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the rescaled value as number\n    and the unit as string.\n    The value can be used re-scale connected values\n    and display them under the label of the unit \n\u003c/p\u003e",
          "module": "Number.Physical.Show",
          "name": "showSplit",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e T i v -\u003e (v, String)",
          "source": "src/Number-Physical-Show.html#showSplit",
          "type": "function"
        },
        "index": {
          "description": "Returns the rescaled value as number and the unit as string The value can be used re-scale connected values and display them under the label of the unit",
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "showSplit",
          "normalized": "T a b-\u003eT a c-\u003e(c,String)",
          "package": "numeric-prelude",
          "partial": "Split",
          "signature": "T i a-\u003eT i v-\u003e(v,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:showSplit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Show",
          "name": "showUnitPart",
          "package": "numeric-prelude",
          "signature": "Bool -\u003e Bool -\u003e Scale a -\u003e String",
          "source": "src/Number-Physical-Show.html#showUnitPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "showUnitPart",
          "normalized": "Bool-\u003eBool-\u003eScale a-\u003eString",
          "package": "numeric-prelude",
          "partial": "Unit Part",
          "signature": "Bool-\u003eBool-\u003eScale a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:showUnitPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunused \n\u003c/p\u003e",
          "module": "Number.Physical.Show",
          "name": "totalDefScale",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e a",
          "source": "src/Number-Physical-Show.html#totalDefScale",
          "type": "function"
        },
        "index": {
          "description": "unused",
          "hierarchy": "Number Physical Show",
          "module": "Number.Physical.Show",
          "name": "totalDefScale",
          "normalized": "T a b-\u003eb",
          "package": "numeric-prelude",
          "partial": "Def Scale",
          "signature": "T i a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Show.html#v:totalDefScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstract Physical Units\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Physical.Unit",
          "name": "Unit",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-Unit.html",
          "type": "module"
        },
        "index": {
          "description": "Abstract Physical Units",
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "Unit",
          "package": "numeric-prelude",
          "partial": "Unit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Unit.T is a sparse vector with integer entries\n   Each map n-\u003em means that the unit of the n-th dimension\n   is given m times.\n\u003c/p\u003e\u003cp\u003eExample: Let the quantity of length (meter, m) be the zeroth dimension\n   and let the quantity of time (second, s) be the first dimension,\n   then the composed unit \u003ccode\u003em/s^2\u003c/code\u003e corresponds to the Map\n   \u003ccode\u003e[(0,1),(1,-2)]\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIn future I want to have more abstraction here,\n   e.g. a type class from the Edison project\n   that abstracts from the underlying implementation.\n   Then one can easily switch between\n   Arrays, Binary trees (like Map) and what know I.\n\u003c/p\u003e",
          "module": "Number.Physical.Unit",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-Unit.html#T",
          "type": "type"
        },
        "index": {
          "description": "Unit.T is sparse vector with integer entries Each map means that the unit of the n-th dimension is given times Example Let the quantity of length meter be the zeroth dimension and let the quantity of time second be the first dimension then the composed unit corresponds to the Map In future want to have more abstraction here e.g type class from the Edison project that abstracts from the underlying implementation Then one can easily switch between Arrays Binary trees like Map and what know",
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "T",
          "package": "numeric-prelude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a List to sparse Map representation\n Example: [-1,0,-2] -\u003e [(0,-1),(2,-2)]\n\u003c/p\u003e",
          "module": "Number.Physical.Unit",
          "name": "fromVector",
          "package": "numeric-prelude",
          "signature": "[Int] -\u003e T i",
          "source": "src/Number-Physical-Unit.html#fromVector",
          "type": "function"
        },
        "index": {
          "description": "Convert List to sparse Map representation Example",
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "fromVector",
          "normalized": "[Int]-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Vector",
          "signature": "[Int]-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#v:fromVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest for the neutral Unit.T\n\u003c/p\u003e",
          "module": "Number.Physical.Unit",
          "name": "isScalar",
          "package": "numeric-prelude",
          "signature": "T i -\u003e Bool",
          "source": "src/Number-Physical-Unit.html#isScalar",
          "type": "function"
        },
        "index": {
          "description": "Test for the neutral Unit.T",
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "isScalar",
          "normalized": "T a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "T i-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#v:isScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Unit",
          "name": "ratScale",
          "package": "numeric-prelude",
          "signature": "T Int -\u003e T i -\u003e T i",
          "source": "src/Number-Physical-Unit.html#ratScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "ratScale",
          "normalized": "T Int-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Scale",
          "signature": "T Int-\u003eT i-\u003eT i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#v:ratScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Unit",
          "name": "ratScaleMaybe",
          "package": "numeric-prelude",
          "signature": "T Int -\u003e T i -\u003e Maybe (T i)",
          "source": "src/Number-Physical-Unit.html#ratScaleMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "ratScaleMaybe",
          "normalized": "T Int-\u003eT a-\u003eMaybe(T a)",
          "package": "numeric-prelude",
          "partial": "Scale Maybe",
          "signature": "T Int-\u003eT i-\u003eMaybe(T i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#v:ratScaleMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.Unit",
          "name": "ratScaleMaybe2",
          "package": "numeric-prelude",
          "signature": "T Int -\u003e T i -\u003e Map i (Maybe Int)",
          "source": "src/Number-Physical-Unit.html#ratScaleMaybe2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "ratScaleMaybe2",
          "normalized": "T Int-\u003eT a-\u003eMap a(Maybe Int)",
          "package": "numeric-prelude",
          "partial": "Scale Maybe",
          "signature": "T Int-\u003eT i-\u003eMap i(Maybe Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#v:ratScaleMaybe2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe neutral Unit.T\n\u003c/p\u003e",
          "module": "Number.Physical.Unit",
          "name": "scalar",
          "package": "numeric-prelude",
          "signature": "T i",
          "source": "src/Number-Physical-Unit.html#scalar",
          "type": "function"
        },
        "index": {
          "description": "The neutral Unit.T",
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "scalar",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#v:scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert Map to a List\n\u003c/p\u003e",
          "module": "Number.Physical.Unit",
          "name": "toVector",
          "package": "numeric-prelude",
          "signature": "T i -\u003e [Int]",
          "source": "src/Number-Physical-Unit.html#toVector",
          "type": "function"
        },
        "index": {
          "description": "Convert Map to List",
          "hierarchy": "Number Physical Unit",
          "module": "Number.Physical.Unit",
          "name": "toVector",
          "normalized": "T a-\u003e[Int]",
          "package": "numeric-prelude",
          "partial": "Vector",
          "signature": "T i-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-Unit.html#v:toVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools for creating a data base of physical units\nand for extracting data from it\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "UnitDatabase",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-UnitDatabase.html",
          "type": "module"
        },
        "index": {
          "description": "Tools for creating data base of physical units and for extracting data from it",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "UnitDatabase",
          "package": "numeric-prelude",
          "partial": "Unit Database",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "InitScale",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-UnitDatabase.html#InitScale",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "InitScale",
          "package": "numeric-prelude",
          "partial": "Init Scale",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#t:InitScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "InitUnitSet",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-UnitDatabase.html#InitUnitSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "InitUnitSet",
          "package": "numeric-prelude",
          "partial": "Init Unit Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#t:InitUnitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA common scaling for a unit.\n\u003c/p\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "Scale",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-UnitDatabase.html#Scale",
          "type": "data"
        },
        "index": {
          "description": "common scaling for unit",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "Scale",
          "package": "numeric-prelude",
          "partial": "Scale",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#t:Scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-UnitDatabase.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "T",
          "package": "numeric-prelude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn entry for a unit and there scalings.\n\u003c/p\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "UnitSet",
          "package": "numeric-prelude",
          "source": "src/Number-Physical-UnitDatabase.html#UnitSet",
          "type": "data"
        },
        "index": {
          "description": "An entry for unit and there scalings",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "UnitSet",
          "package": "numeric-prelude",
          "partial": "Unit Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#t:UnitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "InitScale",
          "package": "numeric-prelude",
          "signature": "InitScale",
          "source": "src/Number-Physical-UnitDatabase.html#InitScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "InitScale",
          "package": "numeric-prelude",
          "partial": "Init Scale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:InitScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "InitUnitSet",
          "package": "numeric-prelude",
          "signature": "InitUnitSet",
          "source": "src/Number-Physical-UnitDatabase.html#InitUnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "InitUnitSet",
          "package": "numeric-prelude",
          "partial": "Init Unit Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:InitUnitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "Scale",
          "package": "numeric-prelude",
          "signature": "Scale",
          "source": "src/Number-Physical-UnitDatabase.html#Scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "Scale",
          "package": "numeric-prelude",
          "partial": "Scale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:Scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "UnitSet",
          "package": "numeric-prelude",
          "signature": "UnitSet",
          "source": "src/Number-Physical-UnitDatabase.html#UnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "UnitSet",
          "package": "numeric-prelude",
          "partial": "Unit Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:UnitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "createScale",
          "package": "numeric-prelude",
          "signature": "InitScale a -\u003e Scale a",
          "source": "src/Number-Physical-UnitDatabase.html#createScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "createScale",
          "normalized": "InitScale a-\u003eScale a",
          "package": "numeric-prelude",
          "partial": "Scale",
          "signature": "InitScale a-\u003eScale a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:createScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "createUnitSet",
          "package": "numeric-prelude",
          "signature": "InitUnitSet i a -\u003e UnitSet i a",
          "source": "src/Number-Physical-UnitDatabase.html#createUnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "createUnitSet",
          "normalized": "InitUnitSet a b-\u003eUnitSet a b",
          "package": "numeric-prelude",
          "partial": "Unit Set",
          "signature": "InitUnitSet i a-\u003eUnitSet i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:createUnitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecompose a complex unit into common ones\n\u003c/p\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "decompose",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i a -\u003e [UnitSet i a]",
          "source": "src/Number-Physical-UnitDatabase.html#decompose",
          "type": "function"
        },
        "index": {
          "description": "Decompose complex unit into common ones",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "decompose",
          "normalized": "T a-\u003eT a b-\u003e[UnitSet a b]",
          "package": "numeric-prelude",
          "signature": "T i-\u003eT i a-\u003e[UnitSet i a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:decompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "defScaleIx",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-Physical-UnitDatabase.html#UnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "defScaleIx",
          "package": "numeric-prelude",
          "partial": "Scale Ix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:defScaleIx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "distLE",
          "package": "numeric-prelude",
          "signature": "(Int, Int) -\u003e (Int, Int) -\u003e Bool",
          "source": "src/Number-Physical-UnitDatabase.html#distLE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "distLE",
          "normalized": "(Int,Int)-\u003e(Int,Int)-\u003eBool",
          "package": "numeric-prelude",
          "partial": "LE",
          "signature": "(Int,Int)-\u003e(Int,Int)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:distLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "distances",
          "package": "numeric-prelude",
          "signature": "T i -\u003e [(Int, T i)] -\u003e [(Int, Int)]",
          "source": "src/Number-Physical-UnitDatabase.html#distances",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "distances",
          "normalized": "T a-\u003e[(Int,T a)]-\u003e[(Int,Int)]",
          "package": "numeric-prelude",
          "signature": "T i-\u003e[(Int,T i)]-\u003e[(Int,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:distances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "evalDist",
          "package": "numeric-prelude",
          "signature": "T i-\u003e T i a-\u003e [(UnitSet i a, Int)]",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "evalDist",
          "normalized": "T a-\u003eT a b-\u003e[(UnitSet a b,Int)]",
          "package": "numeric-prelude",
          "partial": "Dist",
          "signature": "T i-\u003eT i a-\u003e[(UnitSet i a,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:evalDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "extractOne",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e a",
          "source": "src/Number-Physical-UnitDatabase.html#extractOne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "extractOne",
          "normalized": "[a]-\u003ea",
          "package": "numeric-prelude",
          "partial": "One",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:extractOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "findBestExp",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i -\u003e (Int, Int)",
          "source": "src/Number-Physical-UnitDatabase.html#findBestExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "findBestExp",
          "normalized": "T a-\u003eT a-\u003e(Int,Int)",
          "package": "numeric-prelude",
          "partial": "Best Exp",
          "signature": "T i-\u003eT i-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:findBestExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "findClosest",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i a -\u003e UnitSet i a",
          "source": "src/Number-Physical-UnitDatabase.html#findClosest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "findClosest",
          "normalized": "T a-\u003eT a b-\u003eUnitSet a b",
          "package": "numeric-prelude",
          "partial": "Closest",
          "signature": "T i-\u003eT i a-\u003eUnitSet i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:findClosest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "findIndep",
          "package": "numeric-prelude",
          "signature": "T i -\u003e T i a -\u003e Maybe (UnitSet i a)",
          "source": "src/Number-Physical-UnitDatabase.html#findIndep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "findIndep",
          "normalized": "T a-\u003eT a b-\u003eMaybe(UnitSet a b)",
          "package": "numeric-prelude",
          "partial": "Indep",
          "signature": "T i-\u003eT i a-\u003eMaybe(UnitSet i a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:findIndep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the exponent that lead to minimal distance\n  Since the list is infinite \u003ccode\u003e\u003ca\u003emaximum\u003c/a\u003e\u003c/code\u003e will fail\n  but the sequence is convex\n  and thus we can abort when the distance stop falling\n\u003c/p\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "findMinExp",
          "package": "numeric-prelude",
          "signature": "[(Int, Int)] -\u003e (Int, Int)",
          "source": "src/Number-Physical-UnitDatabase.html#findMinExp",
          "type": "function"
        },
        "index": {
          "description": "Find the exponent that lead to minimal distance Since the list is infinite maximum will fail but the sequence is convex and thus we can abort when the distance stop falling",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "findMinExp",
          "normalized": "[(Int,Int)]-\u003e(Int,Int)",
          "package": "numeric-prelude",
          "partial": "Min Exp",
          "signature": "[(Int,Int)]-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:findMinExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "independent",
          "package": "numeric-prelude",
          "signature": "Bool",
          "source": "src/Number-Physical-UnitDatabase.html#UnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "independent",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:independent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initDefault",
          "package": "numeric-prelude",
          "signature": "Bool",
          "source": "src/Number-Physical-UnitDatabase.html#InitScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initDefault",
          "package": "numeric-prelude",
          "partial": "Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initIndependent",
          "package": "numeric-prelude",
          "signature": "Bool",
          "source": "src/Number-Physical-UnitDatabase.html#InitUnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initIndependent",
          "package": "numeric-prelude",
          "partial": "Independent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initIndependent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initIsUnit",
          "package": "numeric-prelude",
          "signature": "Bool",
          "source": "src/Number-Physical-UnitDatabase.html#InitScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initIsUnit",
          "package": "numeric-prelude",
          "partial": "Is Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initIsUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initMag",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-Physical-UnitDatabase.html#InitScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initMag",
          "package": "numeric-prelude",
          "partial": "Mag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initMag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initScale",
          "package": "numeric-prelude",
          "signature": "String -\u003e a -\u003e Bool -\u003e Bool -\u003e InitScale a",
          "source": "src/Number-Physical-UnitDatabase.html#initScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initScale",
          "normalized": "String-\u003ea-\u003eBool-\u003eBool-\u003eInitScale a",
          "package": "numeric-prelude",
          "partial": "Scale",
          "signature": "String-\u003ea-\u003eBool-\u003eBool-\u003eInitScale a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initScales",
          "package": "numeric-prelude",
          "signature": "[InitScale a]",
          "source": "src/Number-Physical-UnitDatabase.html#InitUnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initScales",
          "normalized": "[InitScale a]",
          "package": "numeric-prelude",
          "partial": "Scales",
          "signature": "[InitScale a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initScales"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initSymbol",
          "package": "numeric-prelude",
          "signature": "String",
          "source": "src/Number-Physical-UnitDatabase.html#InitScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initSymbol",
          "package": "numeric-prelude",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initUnit",
          "package": "numeric-prelude",
          "signature": "T i",
          "source": "src/Number-Physical-UnitDatabase.html#InitUnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initUnit",
          "package": "numeric-prelude",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "initUnitSet",
          "package": "numeric-prelude",
          "signature": "T i -\u003e Bool -\u003e [InitScale a] -\u003e InitUnitSet i a",
          "source": "src/Number-Physical-UnitDatabase.html#initUnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "initUnitSet",
          "normalized": "T a-\u003eBool-\u003e[InitScale b]-\u003eInitUnitSet a b",
          "package": "numeric-prelude",
          "partial": "Unit Set",
          "signature": "T i-\u003eBool-\u003e[InitScale a]-\u003eInitUnitSet i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:initUnitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "listMultiples",
          "package": "numeric-prelude",
          "signature": "(T i -\u003e T i) -\u003e Int -\u003e [(Int, T i)]",
          "source": "src/Number-Physical-UnitDatabase.html#listMultiples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "listMultiples",
          "normalized": "(T a-\u003eT a)-\u003eInt-\u003e[(Int,T a)]",
          "package": "numeric-prelude",
          "partial": "Multiples",
          "signature": "(T i-\u003eT i)-\u003eInt-\u003e[(Int,T i)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:listMultiples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "magnitude",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-Physical-UnitDatabase.html#Scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "magnitude",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:magnitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReorder the unit components in a way\n     that the units with positive exponents lead the list. \n\u003c/p\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "positiveToFront",
          "package": "numeric-prelude",
          "signature": "[UnitSet i a] -\u003e [UnitSet i a]",
          "source": "src/Number-Physical-UnitDatabase.html#positiveToFront",
          "type": "function"
        },
        "index": {
          "description": "Reorder the unit components in way that the units with positive exponents lead the list",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "positiveToFront",
          "normalized": "[UnitSet a b]-\u003e[UnitSet a b]",
          "package": "numeric-prelude",
          "partial": "To Front",
          "signature": "[UnitSet i a]-\u003e[UnitSet i a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:positiveToFront"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "powerOfScale",
          "package": "numeric-prelude",
          "signature": "Int -\u003e Scale a -\u003e Scale a",
          "source": "src/Number-Physical-UnitDatabase.html#powerOfScale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "powerOfScale",
          "normalized": "Int-\u003eScale a-\u003eScale a",
          "package": "numeric-prelude",
          "partial": "Of Scale",
          "signature": "Int-\u003eScale a-\u003eScale a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:powerOfScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise all scales of a unit and the unit itself to the n-th power \n\u003c/p\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "powerOfUnitSet",
          "package": "numeric-prelude",
          "signature": "Int -\u003e UnitSet i a -\u003e UnitSet i a",
          "source": "src/Number-Physical-UnitDatabase.html#powerOfUnitSet",
          "type": "function"
        },
        "index": {
          "description": "Raise all scales of unit and the unit itself to the n-th power",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "powerOfUnitSet",
          "normalized": "Int-\u003eUnitSet a b-\u003eUnitSet a b",
          "package": "numeric-prelude",
          "partial": "Of Unit Set",
          "signature": "Int-\u003eUnitSet i a-\u003eUnitSet i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:powerOfUnitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf True the symbols must be preceded with a \u003ccode\u003e\u003ca\u003e/\u003c/a\u003e\u003c/code\u003e.\n                              Though it sounds like an attribute of Scale\n                              it must be the same for all scales and we need it\n                              to sort positive powered unitsets to the front\n                              of the list of unit components. \n\u003c/p\u003e",
          "module": "Number.Physical.UnitDatabase",
          "name": "reciprocal",
          "package": "numeric-prelude",
          "signature": "Bool",
          "source": "src/Number-Physical-UnitDatabase.html#UnitSet",
          "type": "function"
        },
        "index": {
          "description": "If True the symbols must be preceded with Though it sounds like an attribute of Scale it must be the same for all scales and we need it to sort positive powered unitsets to the front of the list of unit components",
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "reciprocal",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:reciprocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "scales",
          "package": "numeric-prelude",
          "signature": "[Scale a]",
          "source": "src/Number-Physical-UnitDatabase.html#UnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "scales",
          "normalized": "[Scale a]",
          "package": "numeric-prelude",
          "signature": "[Scale a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:scales"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "showExp",
          "package": "numeric-prelude",
          "signature": "Int -\u003e String",
          "source": "src/Number-Physical-UnitDatabase.html#showExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "showExp",
          "normalized": "Int-\u003eString",
          "package": "numeric-prelude",
          "partial": "Exp",
          "signature": "Int-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:showExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "showableUnit",
          "package": "numeric-prelude",
          "signature": "InitUnitSet i a -\u003e Maybe (InitUnitSet i a)",
          "source": "src/Number-Physical-UnitDatabase.html#showableUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "showableUnit",
          "normalized": "InitUnitSet a b-\u003eMaybe(InitUnitSet a b)",
          "package": "numeric-prelude",
          "partial": "Unit",
          "signature": "InitUnitSet i a-\u003eMaybe(InitUnitSet i a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:showableUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "symbol",
          "package": "numeric-prelude",
          "signature": "String",
          "source": "src/Number-Physical-UnitDatabase.html#Scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "symbol",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical.UnitDatabase",
          "name": "unit",
          "package": "numeric-prelude",
          "signature": "T i",
          "source": "src/Number-Physical-UnitDatabase.html#UnitSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical UnitDatabase",
          "module": "Number.Physical.UnitDatabase",
          "name": "unit",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical-UnitDatabase.html#v:unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumeric values combined with abstract Physical Units\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Physical",
          "name": "Physical",
          "package": "numeric-prelude",
          "source": "src/Number-Physical.html",
          "type": "module"
        },
        "index": {
          "description": "Numeric values combined with abstract Physical Units",
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "Physical",
          "package": "numeric-prelude",
          "partial": "Physical",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Physics.Quantity.Value.T combines a numeric value with a physical unit.\n\u003c/p\u003e",
          "module": "Number.Physical",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Physical.html#T",
          "type": "data"
        },
        "index": {
          "description": "Physics.Quantity.Value.T combines numeric value with physical unit",
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons (T i) a",
          "source": "src/Number-Physical.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd two values if the units match, otherwise return Nothing\n\u003c/p\u003e",
          "module": "Number.Physical",
          "name": "addMaybe",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e T i a -\u003e Maybe (T i a)",
          "source": "src/Number-Physical.html#addMaybe",
          "type": "function"
        },
        "index": {
          "description": "Add two values if the units match otherwise return Nothing",
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "addMaybe",
          "normalized": "T a b-\u003eT a b-\u003eMaybe(T a b)",
          "package": "numeric-prelude",
          "partial": "Maybe",
          "signature": "T i a-\u003eT i a-\u003eMaybe(T i a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:addMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "errorUnitMismatch",
          "package": "numeric-prelude",
          "signature": "String -\u003e a",
          "source": "src/Number-Physical.html#errorUnitMismatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "errorUnitMismatch",
          "normalized": "String-\u003ea",
          "package": "numeric-prelude",
          "partial": "Unit Mismatch",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:errorUnitMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "fromRatio",
          "package": "numeric-prelude",
          "signature": "T a -\u003e b",
          "source": "src/Number-Physical.html#fromRatio",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "fromRatio",
          "normalized": "T a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Ratio",
          "signature": "T a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:fromRatio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "fromScalarSingle",
          "package": "numeric-prelude",
          "signature": "a -\u003e T i a",
          "source": "src/Number-Physical.html#fromScalarSingle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "fromScalarSingle",
          "normalized": "a-\u003eT b a",
          "package": "numeric-prelude",
          "partial": "Scalar Single",
          "signature": "a-\u003eT i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:fromScalarSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest for the neutral Unit.T. Also a zero has a unit!\n\u003c/p\u003e",
          "module": "Number.Physical",
          "name": "isScalar",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e Bool",
          "source": "src/Number-Physical.html#isScalar",
          "type": "function"
        },
        "index": {
          "description": "Test for the neutral Unit.T Also zero has unit",
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "isScalar",
          "normalized": "T a b-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Scalar",
          "signature": "T i a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:isScalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply a function to the numeric value while preserving the unit\n\u003c/p\u003e",
          "module": "Number.Physical",
          "name": "lift",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b) -\u003e T i a -\u003e T i b",
          "source": "src/Number-Physical.html#lift",
          "type": "function"
        },
        "index": {
          "description": "apply function to the numeric value while preserving the unit",
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "lift",
          "normalized": "(a-\u003eb)-\u003eT c a-\u003eT c b",
          "package": "numeric-prelude",
          "signature": "(a-\u003eb)-\u003eT i a-\u003eT i b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "String -\u003e (a -\u003e b -\u003e c) -\u003e T i a -\u003e T i b -\u003e T i c",
          "source": "src/Number-Physical.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "lift2",
          "normalized": "String-\u003e(a-\u003eb-\u003ec)-\u003eT d a-\u003eT d b-\u003eT d c",
          "package": "numeric-prelude",
          "signature": "String-\u003e(a-\u003eb-\u003ec)-\u003eT i a-\u003eT i b-\u003eT i c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "lift2Gen",
          "package": "numeric-prelude",
          "signature": "String -\u003e (a -\u003e b -\u003e c) -\u003e T i a -\u003e T i b -\u003e c",
          "source": "src/Number-Physical.html#lift2Gen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "lift2Gen",
          "normalized": "String-\u003e(a-\u003eb-\u003ec)-\u003eT d a-\u003eT d b-\u003ec",
          "package": "numeric-prelude",
          "partial": "Gen",
          "signature": "String-\u003e(a-\u003eb-\u003ec)-\u003eT i a-\u003eT i b-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:lift2Gen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "lift2Maybe",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e c) -\u003e T i a -\u003e T i b -\u003e Maybe (T i c)",
          "source": "src/Number-Physical.html#lift2Maybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "lift2Maybe",
          "normalized": "(a-\u003eb-\u003ec)-\u003eT d a-\u003eT d b-\u003eMaybe(T d c)",
          "package": "numeric-prelude",
          "partial": "Maybe",
          "signature": "(a-\u003eb-\u003ec)-\u003eT i a-\u003eT i b-\u003eMaybe(T i c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:lift2Maybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a physical value from a numeric value and\n the full vector representation of a unit.\n\u003c/p\u003e",
          "module": "Number.Physical",
          "name": "quantity",
          "package": "numeric-prelude",
          "signature": "[Int] -\u003e a -\u003e T i a",
          "source": "src/Number-Physical.html#quantity",
          "type": "function"
        },
        "index": {
          "description": "Construct physical value from numeric value and the full vector representation of unit",
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "quantity",
          "normalized": "[Int]-\u003ea-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "[Int]-\u003ea-\u003eT i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:quantity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "ratPow",
          "package": "numeric-prelude",
          "signature": "T Int -\u003e T i a -\u003e T i a",
          "source": "src/Number-Physical.html#ratPow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "ratPow",
          "normalized": "T Int-\u003eT a b-\u003eT a b",
          "package": "numeric-prelude",
          "partial": "Pow",
          "signature": "T Int-\u003eT i a-\u003eT i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:ratPow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "ratPowMaybe",
          "package": "numeric-prelude",
          "signature": "T Int -\u003e T i a -\u003e Maybe (T i a)",
          "source": "src/Number-Physical.html#ratPowMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "ratPowMaybe",
          "normalized": "T Int-\u003eT a b-\u003eMaybe(T a b)",
          "package": "numeric-prelude",
          "partial": "Pow Maybe",
          "signature": "T Int-\u003eT i a-\u003eMaybe(T i a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:ratPowMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Physical",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e T i a -\u003e T i a",
          "source": "src/Number-Physical.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "scale",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT i a-\u003eT i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtract two values if the units match, otherwise return Nothing\n\u003c/p\u003e",
          "module": "Number.Physical",
          "name": "subMaybe",
          "package": "numeric-prelude",
          "signature": "T i a -\u003e T i a -\u003e Maybe (T i a)",
          "source": "src/Number-Physical.html#subMaybe",
          "type": "function"
        },
        "index": {
          "description": "Subtract two values if the units match otherwise return Nothing",
          "hierarchy": "Number Physical",
          "module": "Number.Physical",
          "name": "subMaybe",
          "normalized": "T a b-\u003eT a b-\u003eMaybe(T a b)",
          "package": "numeric-prelude",
          "partial": "Maybe",
          "signature": "T i a-\u003eT i a-\u003eMaybe(T i a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Physical.html#v:subMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterface to \u003ca\u003eNumber.Positional\u003c/a\u003e which dynamically checks for equal bases.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Positional.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "source": "src/Number-Positional-Check.html",
          "type": "module"
        },
        "index": {
          "description": "Interface to Number.Positional which dynamically checks for equal bases",
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe value \u003ccode\u003eCons b e m\u003c/code\u003e\nrepresents the number \u003ccode\u003eb^e * (m!!0 / 1 + m!!1 / b + m!!2 / b^2 + ...)\u003c/code\u003e.\nThe interpretation of exponent is chosen such that\n\u003ccode\u003efloor (logBase b (Cons b e m)) == e\u003c/code\u003e.\nThat is, it is good for multiplication and logarithms.\n(Because of the necessity to normalize the multiplication result,\nthe alternative interpretation wouldn't be more complicated.)\nHowever for base conversions, roots, conversion to fixed point and\nworking with the fractional part\nthe interpretation\n\u003ccode\u003eb^e * (m!!0 / b + m!!1 / b^2 + m!!2 / b^3 + ...)\u003c/code\u003e\nwould fit better.\nThe digits in the mantissa range from \u003ccode\u003e1-base\u003c/code\u003e to \u003ccode\u003ebase-1\u003c/code\u003e.\nThe representation is not unique\nand cannot be made unique in finite time.\nThis way we avoid infinite carry ripples.\n\u003c/p\u003e",
          "module": "Number.Positional.Check",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Positional-Check.html#T",
          "type": "data"
        },
        "index": {
          "description": "The value Cons represents the number The interpretation of exponent is chosen such that floor logBase Cons That is it is good for multiplication and logarithms Because of the necessity to normalize the multiplication result the alternative interpretation wouldn be more complicated However for base conversions roots conversion to fixed point and working with the fractional part the interpretation would fit better The digits in the mantissa range from base to base-1 The representation is not unique and cannot be made unique in finite time This way we avoid infinite carry ripples",
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/Number-Positional-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "base",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-Positional-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "base",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eperfect carry resolution, works only on finite numbers \n\u003c/p\u003e",
          "module": "Number.Positional.Check",
          "name": "carry",
          "package": "numeric-prelude",
          "signature": "T -\u003e T",
          "source": "src/Number-Positional-Check.html#carry",
          "type": "function"
        },
        "index": {
          "description": "perfect carry resolution works only on finite numbers",
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "carry",
          "normalized": "T-\u003eT",
          "package": "numeric-prelude",
          "signature": "T-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:carry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "commonBasis",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Basis -\u003e Basis",
          "source": "src/Number-Positional-Check.html#commonBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "commonBasis",
          "normalized": "Basis-\u003eBasis-\u003eBasis",
          "package": "numeric-prelude",
          "partial": "Basis",
          "signature": "Basis-\u003eBasis-\u003eBasis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:commonBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShift digits towards zero by partial application of carries.\nE.g. 1.8 is converted to 2.(-2)\nIf the digits are in the range \u003ccode\u003e(1-base, base-1)\u003c/code\u003e\nthe resulting digits are in the range \u003ccode\u003e((1-base)\u003cem\u003e2-2, (base-1)\u003c/em\u003e2+2)\u003c/code\u003e.\nThe result is still not unique,\nbut may be useful for further processing.\n\u003c/p\u003e",
          "module": "Number.Positional.Check",
          "name": "compress",
          "package": "numeric-prelude",
          "signature": "T -\u003e T",
          "source": "src/Number-Positional-Check.html#compress",
          "type": "function"
        },
        "index": {
          "description": "Shift digits towards zero by partial application of carries E.g is converted to If the digits are in the range base base-1 the resulting digits are in the range base base-1 The result is still not unique but may be useful for further processing",
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "compress",
          "normalized": "T-\u003eT",
          "package": "numeric-prelude",
          "signature": "T-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:compress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "defltBase",
          "package": "numeric-prelude",
          "signature": "Basis",
          "source": "src/Number-Positional-Check.html#defltBase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "defltBase",
          "package": "numeric-prelude",
          "partial": "Base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:defltBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "defltBaseExp",
          "package": "numeric-prelude",
          "signature": "Exponent",
          "source": "src/Number-Positional-Check.html#defltBaseExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "defltBaseExp",
          "package": "numeric-prelude",
          "partial": "Base Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:defltBaseExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "defltBaseRoot",
          "package": "numeric-prelude",
          "signature": "Basis",
          "source": "src/Number-Positional-Check.html#defltBaseRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "defltBaseRoot",
          "package": "numeric-prelude",
          "partial": "Base Root",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:defltBaseRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "defltShow",
          "package": "numeric-prelude",
          "signature": "T -\u003e String",
          "source": "src/Number-Positional-Check.html#defltShow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "defltShow",
          "normalized": "T-\u003eString",
          "package": "numeric-prelude",
          "partial": "Show",
          "signature": "T-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:defltShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "exponent",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-Positional-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "exponent",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:exponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "fromBaseInteger",
          "package": "numeric-prelude",
          "signature": "Int -\u003e Integer -\u003e T",
          "source": "src/Number-Positional-Check.html#fromBaseInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "fromBaseInteger",
          "normalized": "Int-\u003eInteger-\u003eT",
          "package": "numeric-prelude",
          "partial": "Base Integer",
          "signature": "Int-\u003eInteger-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:fromBaseInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "fromBaseRational",
          "package": "numeric-prelude",
          "signature": "Int -\u003e Rational -\u003e T",
          "source": "src/Number-Positional-Check.html#fromBaseRational",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "fromBaseRational",
          "normalized": "Int-\u003eRational-\u003eT",
          "package": "numeric-prelude",
          "partial": "Base Rational",
          "signature": "Int-\u003eRational-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:fromBaseRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "lift0",
          "package": "numeric-prelude",
          "signature": "(Int -\u003e T) -\u003e T",
          "source": "src/Number-Positional-Check.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "lift0",
          "normalized": "(Int-\u003eT)-\u003eT",
          "package": "numeric-prelude",
          "signature": "(Int-\u003eT)-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "(Int -\u003e T -\u003e T) -\u003e T -\u003e T",
          "source": "src/Number-Positional-Check.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "lift1",
          "normalized": "(Int-\u003eT-\u003eT)-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "(Int-\u003eT-\u003eT)-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(Int -\u003e T -\u003e T -\u003e T) -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional-Check.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "lift2",
          "normalized": "(Int-\u003eT-\u003eT-\u003eT)-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "(Int-\u003eT-\u003eT-\u003eT)-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "mantissa",
          "package": "numeric-prelude",
          "signature": "Mantissa",
          "source": "src/Number-Positional-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "mantissa",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:mantissa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional.Check",
          "name": "prependDigit",
          "package": "numeric-prelude",
          "signature": "Int -\u003e T -\u003e T",
          "source": "src/Number-Positional-Check.html#prependDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional Check",
          "module": "Number.Positional.Check",
          "name": "prependDigit",
          "normalized": "Int-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Digit",
          "signature": "Int-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional-Check.html#v:prependDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExact Real Arithmetic - Computable reals.\nInspired by ''The most unreliable technique for computing pi.''\nSee also \u003ca\u003ehttp://www.haskell.org/haskellwiki/Exact_real_arithmetic\u003c/a\u003e .\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Positional",
          "name": "Positional",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html",
          "type": "module"
        },
        "index": {
          "description": "Exact Real Arithmetic Computable reals Inspired by The most unreliable technique for computing pi See also http www.haskell.org haskellwiki Exact real arithmetic",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "Positional",
          "package": "numeric-prelude",
          "partial": "Positional",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "Basis",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html#Basis",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "Basis",
          "package": "numeric-prelude",
          "partial": "Basis",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#t:Basis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "Digit",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html#Digit",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "Digit",
          "package": "numeric-prelude",
          "partial": "Digit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#t:Digit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "Exponent",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html#Exponent",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "Exponent",
          "package": "numeric-prelude",
          "partial": "Exponent",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#t:Exponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "FixedPoint",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html#FixedPoint",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "FixedPoint",
          "package": "numeric-prelude",
          "partial": "Fixed Point",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#t:FixedPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "Mantissa",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html#Mantissa",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "Mantissa",
          "package": "numeric-prelude",
          "partial": "Mantissa",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#t:Mantissa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "Series",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html#Series",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "Series",
          "package": "numeric-prelude",
          "partial": "Series",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#t:Series"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Positional.html#T",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "T",
          "package": "numeric-prelude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "absMant",
          "package": "numeric-prelude",
          "signature": "Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#absMant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "absMant",
          "normalized": "Mantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Mant",
          "signature": "Mantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:absMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "absolute",
          "package": "numeric-prelude",
          "signature": "T -\u003e T",
          "source": "src/Number-Positional.html#absolute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "absolute",
          "normalized": "T-\u003eT",
          "package": "numeric-prelude",
          "signature": "T-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:absolute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd two numbers but do not eliminate leading zeros.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#add",
          "type": "function"
        },
        "index": {
          "description": "Add two numbers but do not eliminate leading zeros",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "add",
          "normalized": "Basis-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd many numbers efficiently by computing sums of sub lists\nwith only little carry propagation.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "addMany",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e [T] -\u003e T",
          "source": "src/Number-Positional.html#addMany",
          "type": "function"
        },
        "index": {
          "description": "Add many numbers efficiently by computing sums of sub lists with only little carry propagation",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "addMany",
          "normalized": "Basis-\u003e[T]-\u003eT",
          "package": "numeric-prelude",
          "partial": "Many",
          "signature": "Basis-\u003e[T]-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:addMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd at most \u003ccode\u003ebasis\u003c/code\u003e summands.\nMore summands will violate the allowed digit range.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "addSome",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e [T] -\u003e T",
          "source": "src/Number-Positional.html#addSome",
          "type": "function"
        },
        "index": {
          "description": "Add at most basis summands More summands will violate the allowed digit range",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "addSome",
          "normalized": "Basis-\u003e[T]-\u003eT",
          "package": "numeric-prelude",
          "partial": "Some",
          "signature": "Basis-\u003e[T]-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:addSome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "align",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#align",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "align",
          "normalized": "Basis-\u003eExponent-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eExponent-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:align"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the mantissa in such a form\nthat it fits an expected exponent.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003e(e, alignMant b e x)\u003c/code\u003e represent the same number.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "alignMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e T -\u003e Mantissa",
          "source": "src/Number-Positional.html#alignMant",
          "type": "function"
        },
        "index": {
          "description": "Get the mantissa in such form that it fits an expected exponent and alignMant represent the same number",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "alignMant",
          "normalized": "Basis-\u003eExponent-\u003eT-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Mant",
          "signature": "Basis-\u003eExponent-\u003eT-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:alignMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an inverse of \u003ccode\u003e\u003ca\u003ecosSin\u003c/a\u003e\u003c/code\u003e,\nalso known as \u003ccode\u003eatan2\u003c/code\u003e with flipped arguments.\nIt's very slow because of the computation of sinus and cosinus.\nHowever, because it uses the \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e implementation as estimator,\nthe final application of arctan series should converge rapidly.\n\u003c/p\u003e\u003cp\u003eIt could be certainly accelerated by not using cosSin\nand its fiddling with pi.\nInstead we could analyse quadrants before calling atan2,\nthen calling cosSinSmall immediately.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "angle",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e (T, T) -\u003e T",
          "source": "src/Number-Positional.html#angle",
          "type": "function"
        },
        "index": {
          "description": "This is an inverse of cosSin also known as atan2 with flipped arguments It very slow because of the computation of sinus and cosinus However because it uses the atan2 implementation as estimator the final application of arctan series should converge rapidly It could be certainly accelerated by not using cosSin and its fiddling with pi Instead we could analyse quadrants before calling atan2 then calling cosSinSmall immediately",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "angle",
          "normalized": "Basis-\u003e(T,T)-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003e(T,T)-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis implementation gets the first decimal place for free\nby calling the arcus tangens implementation for \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "arctan",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#arctan",
          "type": "function"
        },
        "index": {
          "description": "This implementation gets the first decimal place for free by calling the arcus tangens implementation for Double",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "arctan",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:arctan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA classic implementation without ''cheating''\nwith floating point implementations.\n\u003c/p\u003e\u003cp\u003eFor \u003ccode\u003ex \u003c 1 / sqrt 3\u003c/code\u003e\n(\u003ccode\u003e1 / sqrt 3 == tan (pi/6)\u003c/code\u003e)\nuse \u003ccode\u003earctan\u003c/code\u003e power series.\n(\u003ccode\u003esqrt 3\u003c/code\u003e is approximately \u003ccode\u003e19/11\u003c/code\u003e.)\n\u003c/p\u003e\u003cp\u003eFor \u003ccode\u003ex \u003e sqrt 3\u003c/code\u003e\nuse\n\u003ccode\u003earctan x = pi/2 - arctan (1/x)\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eFor other \u003ccode\u003ex\u003c/code\u003e use\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003earctan x = pi/4 - 0.5*arctan ((1-x^2)/2*x)\u003c/code\u003e\n(which follows from\n\u003ccode\u003earctan x + arctan y == arctan ((x+y) / (1-x*y))\u003c/code\u003e\nwhich in turn follows from complex multiplication\n\u003ccode\u003e(1:+x)*(1:+y) == ((1-x*y):+(x+y))\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003ex\u003c/code\u003e is close to \u003ccode\u003esqrt 3\u003c/code\u003e or \u003ccode\u003e1 / sqrt 3\u003c/code\u003e the computation is quite inefficient.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "arctanClassic",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#arctanClassic",
          "type": "function"
        },
        "index": {
          "description": "classic implementation without cheating with floating point implementations For sqrt sqrt tan pi use arctan power series sqrt is approximately For sqrt use arctan pi arctan For other use arctan pi arctan which follows from arctan arctan arctan which in turn follows from complex multiplication If is close to sqrt or sqrt the computation is quite inefficient",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "arctanClassic",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Classic",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:arctanClassic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArcus tangens of arguments with absolute value less than \u003ccode\u003e1 / sqrt 3\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "arctanSeries",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e Series",
          "source": "src/Number-Positional.html#arctanSeries",
          "type": "function"
        },
        "index": {
          "description": "Arcus tangens of arguments with absolute value less than sqrt",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "arctanSeries",
          "normalized": "Basis-\u003eT-\u003eSeries",
          "package": "numeric-prelude",
          "partial": "Series",
          "signature": "Basis-\u003eT-\u003eSeries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:arctanSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "arctanSmall",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#arctanSmall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "arctanSmall",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Small",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:arctanSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEfficient computation of Arcus tangens of an argument of the form \u003ccode\u003e1/n\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "arctanStem",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Int -\u003e T",
          "source": "src/Number-Positional.html#arctanStem",
          "type": "function"
        },
        "index": {
          "description": "Efficient computation of Arcus tangens of an argument of the form",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "arctanStem",
          "normalized": "Basis-\u003eInt-\u003eT",
          "package": "numeric-prelude",
          "partial": "Stem",
          "signature": "Basis-\u003eInt-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:arctanStem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "cardPower",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Integer -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#cardPower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "cardPower",
          "normalized": "Basis-\u003eInteger-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "Basis-\u003eInteger-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:cardPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "checkDigit",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Digit -\u003e Digit",
          "source": "src/Number-Positional.html#checkDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "checkDigit",
          "normalized": "Basis-\u003eDigit-\u003eDigit",
          "package": "numeric-prelude",
          "partial": "Digit",
          "signature": "Basis-\u003eDigit-\u003eDigit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:checkDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "checkPosDigit",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Digit -\u003e Digit",
          "source": "src/Number-Positional.html#checkPosDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "checkPosDigit",
          "normalized": "Basis-\u003eDigit-\u003eDigit",
          "package": "numeric-prelude",
          "partial": "Pos Digit",
          "signature": "Basis-\u003eDigit-\u003eDigit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:checkPosDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe basis must be at least ***.\nNote: Equality cannot be asserted in finite time on infinite precise numbers.\nIf you want to assert, that a number is below a certain threshold,\nyou should not call this routine directly,\nbecause it will fail on equality.\nBetter round the numbers before comparison.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "cmp",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T -\u003e Ordering",
          "source": "src/Number-Positional.html#cmp",
          "type": "function"
        },
        "index": {
          "description": "The basis must be at least Note Equality cannot be asserted in finite time on infinite precise numbers If you want to assert that number is below certain threshold you should not call this routine directly because it will fail on equality Better round the numbers before comparison",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "cmp",
          "normalized": "Basis-\u003eT-\u003eT-\u003eOrdering",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:cmp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMay prepend a digit.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "compress",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#compress",
          "type": "function"
        },
        "index": {
          "description": "May prepend digit",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "compress",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:compress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompress first digit.\nMay prepend a digit.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "compressFirst",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#compressFirst",
          "type": "function"
        },
        "index": {
          "description": "Compress first digit May prepend digit",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "compressFirst",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "First",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:compressFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes not prepend a digit.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "compressMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#compressMant",
          "type": "function"
        },
        "index": {
          "description": "Does not prepend digit",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "compressMant",
          "normalized": "Basis-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Mant",
          "signature": "Basis-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:compressMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompress second digit.\nSometimes this is enough to keep the digits in the admissible range.\nDoes not prepend a digit.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "compressSecondMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#compressSecondMant",
          "type": "function"
        },
        "index": {
          "description": "Compress second digit Sometimes this is enough to keep the digits in the admissible range Does not prepend digit",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "compressSecondMant",
          "normalized": "Basis-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Second Mant",
          "signature": "Basis-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:compressSecondMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "cosSin",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e (T, T)",
          "source": "src/Number-Positional.html#cosSin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "cosSin",
          "normalized": "Basis-\u003eT-\u003e(T,T)",
          "package": "numeric-prelude",
          "partial": "Sin",
          "signature": "Basis-\u003eT-\u003e(T,T)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:cosSin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ecosSinSmall\u003c/a\u003e\u003c/code\u003e but converges faster.\nIt calls \u003ccode\u003ecosSinSmall\u003c/code\u003e with reduced arguments\nusing the trigonometric identities\n\u003ccode\u003e\ncos (4*x) = 8 * cos x ^ 2 * (cos x ^ 2 - 1) + 1\nsin (4*x) = 4 * sin x * cos x * (1 - 2 * sin x ^ 2)\n\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eNote that the faster convergence is hidden by the overhead.\n\u003c/p\u003e\u003cp\u003eThe same could be achieved with a fourth power of a complex number.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "cosSinFourth",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e (T, T)",
          "source": "src/Number-Positional.html#cosSinFourth",
          "type": "function"
        },
        "index": {
          "description": "Like cosSinSmall but converges faster It calls cosSinSmall with reduced arguments using the trigonometric identities cos cos cos sin sin cos sin Note that the faster convergence is hidden by the overhead The same could be achieved with fourth power of complex number",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "cosSinFourth",
          "normalized": "Basis-\u003eT-\u003e(T,T)",
          "package": "numeric-prelude",
          "partial": "Sin Fourth",
          "signature": "Basis-\u003eT-\u003e(T,T)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:cosSinFourth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute value of argument should be below 1.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "cosSinSmall",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e (T, T)",
          "source": "src/Number-Positional.html#cosSinSmall",
          "type": "function"
        },
        "index": {
          "description": "Absolute value of argument should be below",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "cosSinSmall",
          "normalized": "Basis-\u003eT-\u003e(T,T)",
          "package": "numeric-prelude",
          "partial": "Sin Small",
          "signature": "Basis-\u003eT-\u003e(T,T)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:cosSinSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute value of argument should be below 1.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "cosSinhSmall",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e (T, T)",
          "source": "src/Number-Positional.html#cosSinhSmall",
          "type": "function"
        },
        "index": {
          "description": "Absolute value of argument should be below",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "cosSinhSmall",
          "normalized": "Basis-\u003eT-\u003e(T,T)",
          "package": "numeric-prelude",
          "partial": "Sinh Small",
          "signature": "Basis-\u003eT-\u003e(T,T)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:cosSinhSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "cot",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#cot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "cot",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:cot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccept a high leading digit for the sake of a reduced exponent.\nThis eliminates one leading digit.\nLike \u003ccode\u003e\u003ca\u003epumpFirst\u003c/a\u003e\u003c/code\u003e but with exponent management.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "decreaseExp",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#decreaseExp",
          "type": "function"
        },
        "index": {
          "description": "Accept high leading digit for the sake of reduced exponent This eliminates one leading digit Like pumpFirst but with exponent management",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "decreaseExp",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Exp",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:decreaseExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "decreaseExpFP",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e (Exponent, FixedPoint) -\u003e (Exponent, FixedPoint)",
          "source": "src/Number-Positional.html#decreaseExpFP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "decreaseExpFP",
          "normalized": "Basis-\u003e(Exponent,FixedPoint)-\u003e(Exponent,FixedPoint)",
          "package": "numeric-prelude",
          "partial": "Exp FP",
          "signature": "Basis-\u003e(Exponent,FixedPoint)-\u003e(Exponent,FixedPoint)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:decreaseExpFP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "divInt",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Digit -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#divInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "divInt",
          "normalized": "Basis-\u003eDigit-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Int",
          "signature": "Basis-\u003eDigit-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:divInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFast division for small integral divisors,\nwhich occur for instance in summands of power series.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "divIntMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Int -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#divIntMant",
          "type": "function"
        },
        "index": {
          "description": "Fast division for small integral divisors which occur for instance in summands of power series",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "divIntMant",
          "normalized": "Basis-\u003eInt-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Int Mant",
          "signature": "Basis-\u003eInt-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:divIntMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "divIntMantInf",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Int -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#divIntMantInf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "divIntMantInf",
          "normalized": "Basis-\u003eInt-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Int Mant Inf",
          "signature": "Basis-\u003eInt-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:divIntMantInf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "divMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#divMant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "divMant",
          "normalized": "Basis-\u003eMantissa-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Mant",
          "signature": "Basis-\u003eMantissa-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:divMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "divMantSlow",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#divMantSlow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "divMantSlow",
          "normalized": "Basis-\u003eMantissa-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Mant Slow",
          "signature": "Basis-\u003eMantissa-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:divMantSlow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUndefined if the divisor is zero - of course.\nBecause it is impossible to assert that a real is zero,\nthe routine will not throw an error in general.\n\u003c/p\u003e\u003cp\u003eToDo: Rigorously derive the minimal required magnitude of the leading divisor digit.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "divide",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#divide",
          "type": "function"
        },
        "index": {
          "description": "Undefined if the divisor is zero of course Because it is impossible to assert that real is zero the routine will not throw an error in general ToDo Rigorously derive the minimal required magnitude of the leading divisor digit",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "divide",
          "normalized": "Basis-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:divide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "eConst",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T",
          "source": "src/Number-Positional.html#eConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "eConst",
          "normalized": "Basis-\u003eT",
          "package": "numeric-prelude",
          "partial": "Const",
          "signature": "Basis-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:eConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "equalApprox",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e T -\u003e T -\u003e Bool",
          "source": "src/Number-Positional.html#equalApprox",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "equalApprox",
          "normalized": "Basis-\u003eExponent-\u003eT-\u003eT-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Approx",
          "signature": "Basis-\u003eExponent-\u003eT-\u003eT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:equalApprox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "exp",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "exp",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "expSeries",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e Series",
          "source": "src/Number-Positional.html#expSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "expSeries",
          "normalized": "Basis-\u003eT-\u003eSeries",
          "package": "numeric-prelude",
          "partial": "Series",
          "signature": "Basis-\u003eT-\u003eSeries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:expSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "expSeriesLazy",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e Series",
          "source": "src/Number-Positional.html#expSeriesLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "expSeriesLazy",
          "normalized": "Basis-\u003eT-\u003eSeries",
          "package": "numeric-prelude",
          "partial": "Series Lazy",
          "signature": "Basis-\u003eT-\u003eSeries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:expSeriesLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute value of argument should be below 1.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "expSmall",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#expSmall",
          "type": "function"
        },
        "index": {
          "description": "Absolute value of argument should be below",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "expSmall",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Small",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:expSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "expSmallLazy",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#expSmallLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "expSmallLazy",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Small Lazy",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:expSmallLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "fromBaseCardinal",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Integer -\u003e T",
          "source": "src/Number-Positional.html#fromBaseCardinal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromBaseCardinal",
          "normalized": "Basis-\u003eInteger-\u003eT",
          "package": "numeric-prelude",
          "partial": "Base Cardinal",
          "signature": "Basis-\u003eInteger-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromBaseCardinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "fromBaseInteger",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Integer -\u003e T",
          "source": "src/Number-Positional.html#fromBaseInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromBaseInteger",
          "normalized": "Basis-\u003eInteger-\u003eT",
          "package": "numeric-prelude",
          "partial": "Base Integer",
          "signature": "Basis-\u003eInteger-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromBaseInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "fromBaseRational",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Rational -\u003e T",
          "source": "src/Number-Positional.html#fromBaseRational",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromBaseRational",
          "normalized": "Basis-\u003eRational-\u003eT",
          "package": "numeric-prelude",
          "partial": "Base Rational",
          "signature": "Basis-\u003eRational-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromBaseRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert between arbitrary bases.\nThis conversion is expensive (quadratic time).\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "fromBasis",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#fromBasis",
          "type": "function"
        },
        "index": {
          "description": "Convert between arbitrary bases This conversion is expensive quadratic time",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromBasis",
          "normalized": "Basis-\u003eBasis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Basis",
          "signature": "Basis-\u003eBasis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "fromBasisMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Basis -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#fromBasisMant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromBasisMant",
          "normalized": "Basis-\u003eBasis-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Basis Mant",
          "signature": "Basis-\u003eBasis-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromBasisMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecf. \u003ccode\u003e\u003ca\u003efloatToDigits\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "fromDouble",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Double -\u003e T",
          "source": "src/Number-Positional.html#fromDouble",
          "type": "function"
        },
        "index": {
          "description": "cf floatToDigits",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromDouble",
          "normalized": "Basis-\u003eDouble-\u003eT",
          "package": "numeric-prelude",
          "partial": "Double",
          "signature": "Basis-\u003eDouble-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly return as much digits as are contained in Double.\nThis will speedup further computations.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "fromDoubleApprox",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Double -\u003e T",
          "source": "src/Number-Positional.html#fromDoubleApprox",
          "type": "function"
        },
        "index": {
          "description": "Only return as much digits as are contained in Double This will speedup further computations",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromDoubleApprox",
          "normalized": "Basis-\u003eDouble-\u003eT",
          "package": "numeric-prelude",
          "partial": "Double Approx",
          "signature": "Basis-\u003eDouble-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromDoubleApprox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "fromDoubleRough",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Double -\u003e T",
          "source": "src/Number-Positional.html#fromDoubleRough",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromDoubleRough",
          "normalized": "Basis-\u003eDouble-\u003eT",
          "package": "numeric-prelude",
          "partial": "Double Rough",
          "signature": "Basis-\u003eDouble-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromDoubleRough"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "fromFixedPoint",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e FixedPoint -\u003e T",
          "source": "src/Number-Positional.html#fromFixedPoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromFixedPoint",
          "normalized": "Basis-\u003eFixedPoint-\u003eT",
          "package": "numeric-prelude",
          "partial": "Fixed Point",
          "signature": "Basis-\u003eFixedPoint-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromFixedPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "fromLaurent",
          "package": "numeric-prelude",
          "signature": "T Int -\u003e T",
          "source": "src/Number-Positional.html#fromLaurent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "fromLaurent",
          "normalized": "T Int-\u003eT",
          "package": "numeric-prelude",
          "partial": "Laurent",
          "signature": "T Int-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:fromLaurent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf all values are completely defined,\nthen it holds\n\u003c/p\u003e\u003cpre\u003e if b then x else y == ifLazy b x y\n\u003c/pre\u003e\u003cp\u003eHowever if \u003ccode\u003eb\u003c/code\u003e is undefined,\nthen it is at least known that the result is between \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "ifLazy",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Bool -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#ifLazy",
          "type": "function"
        },
        "index": {
          "description": "If all values are completely defined then it holds if then else ifLazy However if is undefined then it is at least known that the result is between and",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "ifLazy",
          "normalized": "Basis-\u003eBool-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Lazy",
          "signature": "Basis-\u003eBool-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:ifLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "intPower",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Integer -\u003e T -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#intPower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "intPower",
          "normalized": "Basis-\u003eInteger-\u003eT-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "Basis-\u003eInteger-\u003eT-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:intPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList.inits is defined by\n\u003ccode\u003einits = foldr (x ys -\u003e [] : map (x:) ys) [[]]\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis is too strict for our application.\n\u003c/p\u003e\u003cpre\u003e Prelude\u003e List.inits (0:1:2:undefined)\n [[],[0],[0,1]*** Exception: Prelude.undefined\n\u003c/pre\u003e\u003cp\u003eThe following routine is more lazy than \u003ccode\u003e\u003ca\u003einits\u003c/a\u003e\u003c/code\u003e\nand even lazier than \u003ccode\u003e\u003ca\u003einits\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003eutility-ht\u003c/code\u003e package,\nbut it is restricted to infinite lists.\nThis degree of laziness is needed for \u003ccode\u003esqrtFP\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e Prelude\u003e lazyInits (0:1:2:undefined)\n [[],[0],[0,1],[0,1,2],[0,1,2,*** Exception: Prelude.undefined\n\u003c/pre\u003e",
          "module": "Number.Positional",
          "name": "lazyInits",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Number-Positional.html#lazyInits",
          "type": "function"
        },
        "index": {
          "description": "List.inits is defined by inits foldr ys map ys This is too strict for our application Prelude List.inits undefined Exception Prelude.undefined The following routine is more lazy than inits and even lazier than inits from utility-ht package but it is restricted to infinite lists This degree of laziness is needed for sqrtFP Prelude lazyInits undefined Exception Prelude.undefined",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "lazyInits",
          "normalized": "[a]-\u003e[[a]]",
          "package": "numeric-prelude",
          "partial": "Inits",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:lazyInits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "lessApprox",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e T -\u003e T -\u003e Bool",
          "source": "src/Number-Positional.html#lessApprox",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "lessApprox",
          "normalized": "Basis-\u003eExponent-\u003eT-\u003eT-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Approx",
          "signature": "Basis-\u003eExponent-\u003eT-\u003eT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:lessApprox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "liftDoubleApprox",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e (Double -\u003e Double) -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#liftDoubleApprox",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "liftDoubleApprox",
          "normalized": "Basis-\u003e(Double-\u003eDouble)-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Double Approx",
          "signature": "Basis-\u003e(Double-\u003eDouble)-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:liftDoubleApprox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "liftDoubleRough",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e (Double -\u003e Double) -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#liftDoubleRough",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "liftDoubleRough",
          "normalized": "Basis-\u003e(Double-\u003eDouble)-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Double Rough",
          "signature": "Basis-\u003e(Double-\u003eDouble)-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:liftDoubleRough"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "liftLaurent2",
          "package": "numeric-prelude",
          "signature": "(T Int -\u003e T Int -\u003e T Int) -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#liftLaurent2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "liftLaurent2",
          "normalized": "(T Int-\u003eT Int-\u003eT Int)-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Laurent",
          "signature": "(T Int-\u003eT Int-\u003eT Int)-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:liftLaurent2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "liftLaurentMany",
          "package": "numeric-prelude",
          "signature": "([T Int] -\u003e T Int) -\u003e [T] -\u003e T",
          "source": "src/Number-Positional.html#liftLaurentMany",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "liftLaurentMany",
          "normalized": "([T Int]-\u003eT Int)-\u003e[T]-\u003eT",
          "package": "numeric-prelude",
          "partial": "Laurent Many",
          "signature": "([T Int]-\u003eT Int)-\u003e[T]-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:liftLaurentMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "ln",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#ln",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "ln",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:ln"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\nx' = x - (exp x - y) / exp x\n   = x + (y * exp (-x) - 1)\n\u003c/pre\u003e\u003cp\u003eFirst, the dependencies on low-significant places are currently\nmuch more than mathematically necessary.\nCheck\n\u003ccode\u003e\n*Number.Positional\u003e expSmall 1000 (-1,100 : replicate 16 0 ++ [undefined])\n(0,[1,105,171,-82,76*** Exception: Prelude.undefined\n\u003c/code\u003e\nEvery multiplication cut off two trailing digits.\n\u003ccode\u003e\n*Number.Positional\u003e nest 8 (mul 1000 (-1,repeat 1)) (-1,100 : replicate 16 0 ++ [undefined])\n(-9,[101,*** Exception: Prelude.undefined\n\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003ePossibly the dependencies of expSmall\ncould be resolved by not computing \u003ccode\u003emul\u003c/code\u003e immediately\nbut computing \u003ccode\u003emul\u003c/code\u003e series which are merged and subsequently added.\nBut this would lead to an explosion of series.\n\u003c/p\u003e\u003cp\u003eSecond, even if the dependencies of all atomic operations\nare reduced to a minimum,\nthe mathematical dependencies of the whole iteration function\nare less than the sums of the parts.\nLets demonstrate this with the square root iteration.\nIt is\n\u003ccode\u003e\n(1.4140 + 2\u003cem\u003e1.4140) \u003c/em\u003e 2 == 1.414213578500707\n(1.4149 + 2\u003cem\u003e1.4149) \u003c/em\u003e 2 == 1.4142137288854335\n\u003c/code\u003e\nThat is, the digits \u003ccode\u003e213\u003c/code\u003e do not depend mathematically on \u003ccode\u003ex\u003c/code\u003e of \u003ccode\u003e1.414x\u003c/code\u003e,\nbut their computation depends.\nMaybe there is a glorious trick to reduce the computational dependencies\nto the mathematical ones.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "lnNewton",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#lnNewton",
          "type": "function"
        },
        "index": {
          "description": "exp exp exp First the dependencies on low-significant places are currently much more than mathematically necessary Check Number.Positional expSmall replicate undefined Exception Prelude.undefined Every multiplication cut off two trailing digits Number.Positional nest mul repeat replicate undefined Exception Prelude.undefined Possibly the dependencies of expSmall could be resolved by not computing mul immediately but computing mul series which are merged and subsequently added But this would lead to an explosion of series Second even if the dependencies of all atomic operations are reduced to minimum the mathematical dependencies of the whole iteration function are less than the sums of the parts Lets demonstrate this with the square root iteration It is That is the digits do not depend mathematically on of but their computation depends Maybe there is glorious trick to reduce the computational dependencies to the mathematical ones",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "lnNewton",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Newton",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:lnNewton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "lnNewton'",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#lnNewton%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "lnNewton'",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Newton'",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:lnNewton-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "lnSeries",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e Series",
          "source": "src/Number-Positional.html#lnSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "lnSeries",
          "normalized": "Basis-\u003eT-\u003eSeries",
          "package": "numeric-prelude",
          "partial": "Series",
          "signature": "Basis-\u003eT-\u003eSeries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:lnSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "lnSmall",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#lnSmall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "lnSmall",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Small",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:lnSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "mantLengthDouble",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent",
          "source": "src/Number-Positional.html#mantLengthDouble",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mantLengthDouble",
          "normalized": "Basis-\u003eExponent",
          "package": "numeric-prelude",
          "partial": "Length Double",
          "signature": "Basis-\u003eExponent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mantLengthDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "mantissaFromCard",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e a -\u003e Mantissa",
          "source": "src/Number-Positional.html#mantissaFromCard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mantissaFromCard",
          "normalized": "Basis-\u003ea-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "From Card",
          "signature": "Basis-\u003ea-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mantissaFromCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "mantissaFromFixedInt",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e Integer -\u003e Mantissa",
          "source": "src/Number-Positional.html#mantissaFromFixedInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mantissaFromFixedInt",
          "normalized": "Basis-\u003eExponent-\u003eInteger-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "From Fixed Int",
          "signature": "Basis-\u003eExponent-\u003eInteger-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mantissaFromFixedInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "mantissaFromInt",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e a -\u003e Mantissa",
          "source": "src/Number-Positional.html#mantissaFromInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mantissaFromInt",
          "normalized": "Basis-\u003ea-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "From Int",
          "signature": "Basis-\u003ea-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mantissaFromInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "mantissaToNum",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e a",
          "source": "src/Number-Positional.html#mantissaToNum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mantissaToNum",
          "normalized": "Basis-\u003eMantissa-\u003ea",
          "package": "numeric-prelude",
          "partial": "To Num",
          "signature": "Basis-\u003eMantissa-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mantissaToNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e mean2 b (x0,x1) (y0,y1)\n\u003c/pre\u003e\u003cp\u003ecomputes \u003ccode\u003e round ((x0.x1 + y0.y1)/2) \u003c/code\u003e,\nwhere \u003ccode\u003ex0.x1\u003c/code\u003e and \u003ccode\u003ey0.y1\u003c/code\u003e are positional rational numbers\nwith respect to basis \u003ccode\u003eb\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "mean2",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e (Digit, Digit) -\u003e (Digit, Digit) -\u003e Digit",
          "source": "src/Number-Positional.html#mean2",
          "type": "function"
        },
        "index": {
          "description": "mean2 x0 x1 y0 y1 computes round x0.x1 y0.y1 where x0.x1 and y0.y1 are positional rational numbers with respect to basis",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mean2",
          "normalized": "Basis-\u003e(Digit,Digit)-\u003e(Digit,Digit)-\u003eDigit",
          "package": "numeric-prelude",
          "signature": "Basis-\u003e(Digit,Digit)-\u003e(Digit,Digit)-\u003eDigit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mean2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "minusOne",
          "package": "numeric-prelude",
          "signature": "T",
          "source": "src/Number-Positional.html#minusOne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "minusOne",
          "package": "numeric-prelude",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:minusOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "moveToZero",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Digit -\u003e (Digit, Digit)",
          "source": "src/Number-Positional.html#moveToZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "moveToZero",
          "normalized": "Basis-\u003eDigit-\u003e(Digit,Digit)",
          "package": "numeric-prelude",
          "partial": "To Zero",
          "signature": "Basis-\u003eDigit-\u003e(Digit,Digit)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:moveToZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor obtaining n result digits it is mathematically sufficient\nto know the first (n+1) digits of the operands.\nHowever this implementation needs (n+2) digits,\nbecause of calls to \u003ccode\u003e\u003ca\u003ecompress\u003c/a\u003e\u003c/code\u003e in both \u003ccode\u003e\u003ca\u003escale\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eseries\u003c/a\u003e\u003c/code\u003e.\nWe should fix that.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#mul",
          "type": "function"
        },
        "index": {
          "description": "For obtaining result digits it is mathematically sufficient to know the first digits of the operands However this implementation needs digits because of calls to compress in both scale and series We should fix that",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mul",
          "normalized": "Basis-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "mulSeries",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T -\u003e Series",
          "source": "src/Number-Positional.html#mulSeries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "mulSeries",
          "normalized": "Basis-\u003eT-\u003eT-\u003eSeries",
          "package": "numeric-prelude",
          "partial": "Series",
          "signature": "Basis-\u003eT-\u003eT-\u003eSeries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:mulSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "neg",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#neg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "neg",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake sure that a number with absolute value less than 1\nhas a (small) negative exponent.\nAlso works with zero because it chooses an heuristic exponent for stopping.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "negativeExp",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#negativeExp",
          "type": "function"
        },
        "index": {
          "description": "Make sure that number with absolute value less than has small negative exponent Also works with zero because it chooses an heuristic exponent for stopping",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "negativeExp",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Exp",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:negativeExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts all digits to non-negative digits,\nthat is the usual positional representation.\nHowever the conversion will fail\nwhen the remaining digits are all zero.\n(This cannot be improved!)\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "nonNegative",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#nonNegative",
          "type": "function"
        },
        "index": {
          "description": "Converts all digits to non-negative digits that is the usual positional representation However the conversion will fail when the remaining digits are all zero This cannot be improved",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "nonNegative",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Negative",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:nonNegative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRequires, that no digit is \u003ccode\u003e(basis-1)\u003c/code\u003e or \u003ccode\u003e(1-basis)\u003c/code\u003e.\nThe leading digit might be negative and might be \u003ccode\u003e-basis\u003c/code\u003e or \u003ccode\u003ebasis\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "nonNegativeMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#nonNegativeMant",
          "type": "function"
        },
        "index": {
          "description": "Requires that no digit is basis-1 or basis The leading digit might be negative and might be basis or basis",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "nonNegativeMant",
          "normalized": "Basis-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Negative Mant",
          "signature": "Basis-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:nonNegativeMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "one",
          "package": "numeric-prelude",
          "signature": "T",
          "source": "src/Number-Positional.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "one",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "piConst",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T",
          "source": "src/Number-Positional.html#piConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "piConst",
          "normalized": "Basis-\u003eT",
          "package": "numeric-prelude",
          "partial": "Const",
          "signature": "Basis-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:piConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "power",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Rational -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#power",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "power",
          "normalized": "Basis-\u003eRational-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eRational-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from a \u003ccode\u003eb\u003c/code\u003e basis representation to a \u003ccode\u003eb^e\u003c/code\u003e basis.\n\u003c/p\u003e\u003cp\u003eWorks well with every exponent.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "powerBasis",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#powerBasis",
          "type": "function"
        },
        "index": {
          "description": "Convert from basis representation to basis Works well with every exponent",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "powerBasis",
          "normalized": "Basis-\u003eExponent-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Basis",
          "signature": "Basis-\u003eExponent-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:powerBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResidue estimates will only hold for exponents\nwith absolute value below one.\n\u003c/p\u003e\u003cp\u003eThe computation is based on \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e,\nthus the denominator should not be too big.\n(Say, at most 1000 for 1000000 digits.)\n\u003c/p\u003e\u003cp\u003eIt is not optimal to split the power into pure root and pure power\n(that means, with integer exponents).\nThe root series can nicely handle all exponents,\nbut for exponents above 1 the series summands rises at the beginning\nand thus make the residue estimate complicated.\nFor powers with integer exponents the root series turns\ninto the binomial formula,\nwhich is just a complicated way to compute a power\nwhich can also be determined by simple multiplication.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "powerSeries",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Rational -\u003e T -\u003e Series",
          "source": "src/Number-Positional.html#powerSeries",
          "type": "function"
        },
        "index": {
          "description": "Residue estimates will only hold for exponents with absolute value below one The computation is based on Int thus the denominator should not be too big Say at most for digits It is not optimal to split the power into pure root and pure power that means with integer exponents The root series can nicely handle all exponents but for exponents above the series summands rises at the beginning and thus make the residue estimate complicated For powers with integer exponents the root series turns into the binomial formula which is just complicated way to compute power which can also be determined by simple multiplication",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "powerSeries",
          "normalized": "Basis-\u003eRational-\u003eT-\u003eSeries",
          "package": "numeric-prelude",
          "partial": "Series",
          "signature": "Basis-\u003eRational-\u003eT-\u003eSeries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:powerSeries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "powerSmall",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Rational -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#powerSmall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "powerSmall",
          "normalized": "Basis-\u003eRational-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Small",
          "signature": "Basis-\u003eRational-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:powerSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "prependDigit",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#prependDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "prependDigit",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Digit",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:prependDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerge leading and second digit.\nThis is somehow an inverse of \u003ccode\u003e\u003ca\u003ecompressMant\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "pumpFirst",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#pumpFirst",
          "type": "function"
        },
        "index": {
          "description": "Merge leading and second digit This is somehow an inverse of compressMant",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "pumpFirst",
          "normalized": "Basis-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "First",
          "signature": "Basis-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:pumpFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "pumpFirstFP",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e FixedPoint -\u003e FixedPoint",
          "source": "src/Number-Positional.html#pumpFirstFP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "pumpFirstFP",
          "normalized": "Basis-\u003eFixedPoint-\u003eFixedPoint",
          "package": "numeric-prelude",
          "partial": "First FP",
          "signature": "Basis-\u003eFixedPoint-\u003eFixedPoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:pumpFirstFP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "recipEConst",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T",
          "source": "src/Number-Positional.html#recipEConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "recipEConst",
          "normalized": "Basis-\u003eT",
          "package": "numeric-prelude",
          "partial": "EConst",
          "signature": "Basis-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:recipEConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "reciprocal",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#reciprocal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "reciprocal",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:reciprocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "root",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Integer -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#root",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "root",
          "normalized": "Basis-\u003eInteger-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eInteger-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from a \u003ccode\u003eb^e\u003c/code\u003e basis representation to a \u003ccode\u003eb\u003c/code\u003e basis.\n\u003c/p\u003e\u003cp\u003eWorks well with every exponent.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "rootBasis",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#rootBasis",
          "type": "function"
        },
        "index": {
          "description": "Convert from basis representation to basis Works well with every exponent",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "rootBasis",
          "normalized": "Basis-\u003eExponent-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Basis",
          "signature": "Basis-\u003eExponent-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:rootBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Digit -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "scale",
          "normalized": "Basis-\u003eDigit-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eDigit-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "scaleMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Digit -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#scaleMant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "scaleMant",
          "normalized": "Basis-\u003eDigit-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Mant",
          "signature": "Basis-\u003eDigit-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:scaleMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "scaleSimple",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#scaleSimple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "scaleSimple",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Simple",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:scaleSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an infinite number of numbers.\nYou must provide a list of estimate of the current remainders.\nThe estimates must be given as exponents of the remainder.\nIf such an exponent is too small, the summation will be aborted.\nIf exponents are too big, computation will become inefficient.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "series",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Series -\u003e T",
          "source": "src/Number-Positional.html#series",
          "type": "function"
        },
        "index": {
          "description": "Add an infinite number of numbers You must provide list of estimate of the current remainders The estimates must be given as exponents of the remainder If such an exponent is too small the summation will be aborted If exponents are too big computation will become inefficient",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "series",
          "normalized": "Basis-\u003eSeries-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eSeries-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:series"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "seriesPlain",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Series -\u003e T",
          "source": "src/Number-Positional.html#seriesPlain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "seriesPlain",
          "normalized": "Basis-\u003eSeries-\u003eT",
          "package": "numeric-prelude",
          "partial": "Plain",
          "signature": "Basis-\u003eSeries-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:seriesPlain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "showBasis",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Exponent -\u003e T -\u003e String",
          "source": "src/Number-Positional.html#showBasis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "showBasis",
          "normalized": "Basis-\u003eExponent-\u003eT-\u003eString",
          "package": "numeric-prelude",
          "partial": "Basis",
          "signature": "Basis-\u003eExponent-\u003eT-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:showBasis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "showBin",
          "package": "numeric-prelude",
          "signature": "Exponent -\u003e T -\u003e String",
          "source": "src/Number-Positional.html#showBin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "showBin",
          "normalized": "Exponent-\u003eT-\u003eString",
          "package": "numeric-prelude",
          "partial": "Bin",
          "signature": "Exponent-\u003eT-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:showBin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a number with respect to basis \u003ccode\u003e10^e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "showDec",
          "package": "numeric-prelude",
          "signature": "Exponent -\u003e T -\u003e String",
          "source": "src/Number-Positional.html#showDec",
          "type": "function"
        },
        "index": {
          "description": "Show number with respect to basis",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "showDec",
          "normalized": "Exponent-\u003eT-\u003eString",
          "package": "numeric-prelude",
          "partial": "Dec",
          "signature": "Exponent-\u003eT-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:showDec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "showHex",
          "package": "numeric-prelude",
          "signature": "Exponent -\u003e T -\u003e String",
          "source": "src/Number-Positional.html#showHex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "showHex",
          "normalized": "Exponent-\u003eT-\u003eString",
          "package": "numeric-prelude",
          "partial": "Hex",
          "signature": "Exponent-\u003eT-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:showHex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "sliceVertPair",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e [(a, a)]",
          "source": "src/Number-Positional.html#sliceVertPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sliceVertPair",
          "normalized": "[a]-\u003e[(a,a)]",
          "package": "numeric-prelude",
          "partial": "Vert Pair",
          "signature": "[a]-\u003e[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sliceVertPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "splitAtMatchPadZero",
          "package": "numeric-prelude",
          "signature": "[()] -\u003e Mantissa -\u003e (Mantissa, Mantissa)",
          "source": "src/Number-Positional.html#splitAtMatchPadZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "splitAtMatchPadZero",
          "normalized": "[()]-\u003eMantissa-\u003e(Mantissa,Mantissa)",
          "package": "numeric-prelude",
          "partial": "At Match Pad Zero",
          "signature": "[()]-\u003eMantissa-\u003e(Mantissa,Mantissa)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:splitAtMatchPadZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e,\nbut it pads with zeros if the list is too short.\nThis way it preserves\n \u003ccode\u003e length (fst (splitAtPadZero n xs)) == n \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "splitAtPadZero",
          "package": "numeric-prelude",
          "signature": "Int -\u003e Mantissa -\u003e (Mantissa, Mantissa)",
          "source": "src/Number-Positional.html#splitAtPadZero",
          "type": "function"
        },
        "index": {
          "description": "Like splitAt but it pads with zeros if the list is too short This way it preserves length fst splitAtPadZero xs",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "splitAtPadZero",
          "normalized": "Int-\u003eMantissa-\u003e(Mantissa,Mantissa)",
          "package": "numeric-prelude",
          "partial": "At Pad Zero",
          "signature": "Int-\u003eMantissa-\u003e(Mantissa,Mantissa)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:splitAtPadZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sqrt",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "sqrtDriver",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e (Basis -\u003e FixedPoint -\u003e Mantissa) -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#sqrtDriver",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sqrtDriver",
          "normalized": "Basis-\u003e(Basis-\u003eFixedPoint-\u003eMantissa)-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Driver",
          "signature": "Basis-\u003e(Basis-\u003eFixedPoint-\u003eMantissa)-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sqrtDriver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquare root.\n\u003c/p\u003e\u003cp\u003eWe need a leading digit of type Integer,\nbecause we have to collect up to 4 digits.\nThis presentation can also be considered as \u003ccode\u003e\u003ca\u003eFixedPoint\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eToDo:\nRigorously derive the minimal required magnitude\nof the leading digit of the root.\n\u003c/p\u003e\u003cp\u003eMathematically the \u003ccode\u003en\u003c/code\u003eth digit of the square root\ndepends roughly only on the first \u003ccode\u003en\u003c/code\u003e digits of the input.\nThis is because \u003ccode\u003esqrt (1+eps) \u003ccode\u003e\u003ca\u003eequalApprox\u003c/a\u003e\u003c/code\u003e 1 + eps/2\u003c/code\u003e.\nHowever this implementation requires \u003ccode\u003e2*n\u003c/code\u003e input digits\nfor emitting \u003ccode\u003en\u003c/code\u003e digits.\nThis is due to the repeated use of \u003ccode\u003e\u003ca\u003ecompressMant\u003c/a\u003e\u003c/code\u003e.\nIt would suffice to fully compress only every \u003ccode\u003ebasis\u003c/code\u003eth iteration (digit)\nand compress only the second leading digit in each iteration.\n\u003c/p\u003e\u003cp\u003eCan the involved operations be made lazy enough to solve\n\u003ccode\u003ey = (x+frac)^2\u003c/code\u003e\nby\n\u003ccode\u003efrac = (y-x^2-frac^2) / (2*x)\u003c/code\u003e ?\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "sqrtFP",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e FixedPoint -\u003e Mantissa",
          "source": "src/Number-Positional.html#sqrtFP",
          "type": "function"
        },
        "index": {
          "description": "Square root We need leading digit of type Integer because we have to collect up to digits This presentation can also be considered as FixedPoint ToDo Rigorously derive the minimal required magnitude of the leading digit of the root Mathematically the th digit of the square root depends roughly only on the first digits of the input This is because sqrt eps equalApprox eps However this implementation requires input digits for emitting digits This is due to the repeated use of compressMant It would suffice to fully compress only every basis th iteration digit and compress only the second leading digit in each iteration Can the involved operations be made lazy enough to solve frac by frac y-x frac",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sqrtFP",
          "normalized": "Basis-\u003eFixedPoint-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "FP",
          "signature": "Basis-\u003eFixedPoint-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sqrtFP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewton iteration doubles the number of correct digits in every step.\nThus we process the data in chunks of sizes of powers of two.\nThis way we get fastest computation possible with Newton\nbut also more dependencies on input than necessary.\nThe question arises whether this implementation still fits the needs\nof computational reals.\nThe input is requested as larger and larger chunks,\nand the input itself might be computed this way,\ne.g. a repeated square root.\nRequesting one digit too much,\nrequires the double amount of work for the input computation,\nwhich in turn multiplies time consumption by a factor of four,\nand so on.\n\u003c/p\u003e\u003cp\u003eOptimal fast implementation of one routine\ndoes not preserve fast computation of composed computations.\n\u003c/p\u003e\u003cp\u003eThe routine assumes, that the integer parts is at least \u003ccode\u003eb^2.\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "sqrtFPNewton",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e FixedPoint -\u003e Mantissa",
          "source": "src/Number-Positional.html#sqrtFPNewton",
          "type": "function"
        },
        "index": {
          "description": "Newton iteration doubles the number of correct digits in every step Thus we process the data in chunks of sizes of powers of two This way we get fastest computation possible with Newton but also more dependencies on input than necessary The question arises whether this implementation still fits the needs of computational reals The input is requested as larger and larger chunks and the input itself might be computed this way e.g repeated square root Requesting one digit too much requires the double amount of work for the input computation which in turn multiplies time consumption by factor of four and so on Optimal fast implementation of one routine does not preserve fast computation of composed computations The routine assumes that the integer parts is at least",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sqrtFPNewton",
          "normalized": "Basis-\u003eFixedPoint-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "FPNewton",
          "signature": "Basis-\u003eFixedPoint-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sqrtFPNewton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "sqrtMant",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e Mantissa -\u003e Mantissa",
          "source": "src/Number-Positional.html#sqrtMant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sqrtMant",
          "normalized": "Basis-\u003eMantissa-\u003eMantissa",
          "package": "numeric-prelude",
          "partial": "Mant",
          "signature": "Basis-\u003eMantissa-\u003eMantissa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sqrtMant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "sqrtNewton",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#sqrtNewton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sqrtNewton",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Newton",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sqrtNewton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "sub",
          "normalized": "Basis-\u003eT-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "tan",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#tan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "tan",
          "normalized": "Basis-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Basis-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:tan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "toDouble",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e Double",
          "source": "src/Number-Positional.html#toDouble",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "toDouble",
          "normalized": "Basis-\u003eT-\u003eDouble",
          "package": "numeric-prelude",
          "partial": "Double",
          "signature": "Basis-\u003eT-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:toDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit into integer and fractional part.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "toFixedPoint",
          "package": "numeric-prelude",
          "signature": "Basis -\u003e T -\u003e FixedPoint",
          "source": "src/Number-Positional.html#toFixedPoint",
          "type": "function"
        },
        "index": {
          "description": "Split into integer and fractional part",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "toFixedPoint",
          "normalized": "Basis-\u003eT-\u003eFixedPoint",
          "package": "numeric-prelude",
          "partial": "Fixed Point",
          "signature": "Basis-\u003eT-\u003eFixedPoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:toFixedPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "toLaurent",
          "package": "numeric-prelude",
          "signature": "T -\u003e T Int",
          "source": "src/Number-Positional.html#toLaurent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "toLaurent",
          "normalized": "T-\u003eT Int",
          "package": "numeric-prelude",
          "partial": "Laurent",
          "signature": "T-\u003eT Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:toLaurent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEliminate leading zero digits.\nThis will fail for zero.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "trim",
          "package": "numeric-prelude",
          "signature": "T -\u003e T",
          "source": "src/Number-Positional.html#trim",
          "type": "function"
        },
        "index": {
          "description": "Eliminate leading zero digits This will fail for zero",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "trim",
          "normalized": "T-\u003eT",
          "package": "numeric-prelude",
          "signature": "T-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:trim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "trimOnce",
          "package": "numeric-prelude",
          "signature": "T -\u003e T",
          "source": "src/Number-Positional.html#trimOnce",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "trimOnce",
          "normalized": "T-\u003eT",
          "package": "numeric-prelude",
          "partial": "Once",
          "signature": "T-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:trimOnce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrim until a minimum exponent is reached.\nSafe for zeros.\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "trimUntil",
          "package": "numeric-prelude",
          "signature": "Exponent -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#trimUntil",
          "type": "function"
        },
        "index": {
          "description": "Trim until minimum exponent is reached Safe for zeros",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "trimUntil",
          "normalized": "Exponent-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "partial": "Until",
          "signature": "Exponent-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:trimUntil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "trunc",
          "package": "numeric-prelude",
          "signature": "Exponent -\u003e T -\u003e T",
          "source": "src/Number-Positional.html#trunc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "trunc",
          "normalized": "Exponent-\u003eT-\u003eT",
          "package": "numeric-prelude",
          "signature": "Exponent-\u003eT-\u003eT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:trunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehelp showing series summands\n\u003c/p\u003e",
          "module": "Number.Positional",
          "name": "truncSeriesSummands",
          "package": "numeric-prelude",
          "signature": "Series -\u003e Series",
          "source": "src/Number-Positional.html#truncSeriesSummands",
          "type": "function"
        },
        "index": {
          "description": "help showing series summands",
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "truncSeriesSummands",
          "normalized": "Series-\u003eSeries",
          "package": "numeric-prelude",
          "partial": "Series Summands",
          "signature": "Series-\u003eSeries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:truncSeriesSummands"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "withTwoMantissas",
          "package": "numeric-prelude",
          "signature": "Mantissa -\u003e Mantissa -\u003e a -\u003e ((Digit, Mantissa) -\u003e (Digit, Mantissa) -\u003e a) -\u003e a",
          "source": "src/Number-Positional.html#withTwoMantissas",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "withTwoMantissas",
          "normalized": "Mantissa-\u003eMantissa-\u003ea-\u003e((Digit,Mantissa)-\u003e(Digit,Mantissa)-\u003ea)-\u003ea",
          "package": "numeric-prelude",
          "partial": "Two Mantissas",
          "signature": "Mantissa-\u003eMantissa-\u003ea-\u003e((Digit,Mantissa)-\u003e(Digit,Mantissa)-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:withTwoMantissas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Positional",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "T",
          "source": "src/Number-Positional.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Positional",
          "module": "Number.Positional",
          "name": "zero",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Positional.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eQuaternions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Quaternion",
          "name": "Quaternion",
          "package": "numeric-prelude",
          "source": "src/Number-Quaternion.html",
          "type": "module"
        },
        "index": {
          "description": "Quaternions",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "Quaternion",
          "package": "numeric-prelude",
          "partial": "Quaternion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuaternions could be defined based on Complex numbers.\nHowever quaternions are often considered as real part and three imaginary parts.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Quaternion.html#T",
          "type": "data"
        },
        "index": {
          "description": "Quaternions could be defined based on Complex numbers However quaternions are often considered as real part and three imaginary parts",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a quaternion from real and imaginary part.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "(+::)",
          "package": "numeric-prelude",
          "signature": "a -\u003e (a, a, a) -\u003e T a",
          "source": "src/Number-Quaternion.html#%2B%3A%3A",
          "type": "function"
        },
        "index": {
          "description": "Construct quaternion from real and imaginary part",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "(+::) +::",
          "normalized": "a-\u003e(a,a,a)-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003e(a,a,a)-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:-43-::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe conjugate of a quaternion.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "conjugate",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Quaternion.html#conjugate",
          "type": "function"
        },
        "index": {
          "description": "The conjugate of quaternion",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "conjugate",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:conjugate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Quaternion",
          "name": "crossProduct",
          "package": "numeric-prelude",
          "signature": "(a, a, a) -\u003e (a, a, a) -\u003e (a, a, a)",
          "source": "src/Number-Quaternion.html#crossProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "crossProduct",
          "normalized": "(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)",
          "package": "numeric-prelude",
          "partial": "Product",
          "signature": "(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:crossProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRevert \u003ccode\u003e\u003ca\u003etoComplexMatrix\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "fromComplexMatrix",
          "package": "numeric-prelude",
          "signature": "Array (Int, Int) (T a) -\u003e T a",
          "source": "src/Number-Quaternion.html#fromComplexMatrix",
          "type": "function"
        },
        "index": {
          "description": "Revert toComplexMatrix",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "fromComplexMatrix",
          "normalized": "Array(Int,Int)(T a)-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Complex Matrix",
          "signature": "Array(Int,Int)(T a)-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:fromComplexMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Quaternion",
          "name": "fromReal",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-Quaternion.html#fromReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "fromReal",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Real",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:fromReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Quaternion",
          "name": "fromRotationMatrix",
          "package": "numeric-prelude",
          "signature": "Array (Int, Int) a -\u003e T a",
          "source": "src/Number-Quaternion.html#fromRotationMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "fromRotationMatrix",
          "normalized": "Array(Int,Int)a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Rotation Matrix",
          "signature": "Array(Int,Int)a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:fromRotationMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rotation matrix must be normalized.\n(I.e. no rotation with scaling)\nThe computed quaternion is not normalized.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "fromRotationMatrixDenorm",
          "package": "numeric-prelude",
          "signature": "Array (Int, Int) a -\u003e T a",
          "source": "src/Number-Quaternion.html#fromRotationMatrixDenorm",
          "type": "function"
        },
        "index": {
          "description": "The rotation matrix must be normalized I.e no rotation with scaling The computed quaternion is not normalized",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "fromRotationMatrixDenorm",
          "normalized": "Array(Int,Int)a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Rotation Matrix Denorm",
          "signature": "Array(Int,Int)a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:fromRotationMatrixDenorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Quaternion",
          "name": "norm",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Quaternion.html#norm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "norm",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe same as NormedEuc.normSqr but with a simpler type class constraint\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "normSqr",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Quaternion.html#normSqr",
          "type": "function"
        },
        "index": {
          "description": "the same as NormedEuc.normSqr but with simpler type class constraint",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "normSqr",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Sqr",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:normSqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escale a quaternion into a unit quaternion\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "normalize",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Quaternion.html#normalize",
          "type": "function"
        },
        "index": {
          "description": "scale quaternion into unit quaternion",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "normalize",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Quaternion",
          "name": "scalarProduct",
          "package": "numeric-prelude",
          "signature": "(a, a, a) -\u003e (a, a, a) -\u003e a",
          "source": "src/Number-Quaternion.html#scalarProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "scalarProduct",
          "normalized": "(a,a,a)-\u003e(a,a,a)-\u003ea",
          "package": "numeric-prelude",
          "partial": "Product",
          "signature": "(a,a,a)-\u003e(a,a,a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:scalarProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale a quaternion by a real number.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/Number-Quaternion.html#scale",
          "type": "function"
        },
        "index": {
          "description": "Scale quaternion by real number",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "scale",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimilarity mapping as needed for rotating 3D vectors\n\u003c/p\u003e\u003cp\u003eIt holds\n\u003ccode\u003esimilarity (cos(a/2) +:: scaleImag (sin(a/2)) v) (0 +:: x) == (0 +:: y)\u003c/code\u003e\nwhere \u003ccode\u003ey\u003c/code\u003e results from rotating \u003ccode\u003ex\u003c/code\u003e around the axis \u003ccode\u003ev\u003c/code\u003e by the angle \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "similarity",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/Number-Quaternion.html#similarity",
          "type": "function"
        },
        "index": {
          "description": "similarity mapping as needed for rotating vectors It holds similarity cos scaleImag sin where results from rotating around the axis by the angle",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "similarity",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:similarity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpherical Linear Interpolation\n\u003c/p\u003e\u003cp\u003eCan be generalized to any transcendent Hilbert space.\nIn fact, we should also include the real part in the interpolation.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "slerp",
          "package": "numeric-prelude",
          "signature": "a-\u003e (a, a, a)-\u003e (a, a, a)-\u003e (a, a, a)",
          "type": "function"
        },
        "index": {
          "description": "Spherical Linear Interpolation Can be generalized to any transcendent Hilbert space In fact we should also include the real part in the interpolation",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "slerp",
          "normalized": "a-\u003e(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)",
          "package": "numeric-prelude",
          "signature": "a-\u003e(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:slerp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a quaternion to complex valued 2x2 matrix,\nsuch that quaternion addition and multiplication\nis mapped to matrix addition and multiplication.\nThe determinant of the matrix equals the squared quaternion norm (\u003ccode\u003e\u003ca\u003enormSqr\u003c/a\u003e\u003c/code\u003e).\nSince complex numbers can be turned into real (orthogonal) matrices,\na quaternion could also be converted into a real matrix.\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "toComplexMatrix",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Array (Int, Int) (T a)",
          "source": "src/Number-Quaternion.html#toComplexMatrix",
          "type": "function"
        },
        "index": {
          "description": "Map quaternion to complex valued x2 matrix such that quaternion addition and multiplication is mapped to matrix addition and multiplication The determinant of the matrix equals the squared quaternion norm normSqr Since complex numbers can be turned into real orthogonal matrices quaternion could also be converted into real matrix",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "toComplexMatrix",
          "normalized": "T a-\u003eArray(Int,Int)(T a)",
          "package": "numeric-prelude",
          "partial": "Complex Matrix",
          "signature": "T a-\u003eArray(Int,Int)(T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:toComplexMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLet \u003ccode\u003ec\u003c/code\u003e be a unit quaternion, then it holds\n\u003ccode\u003esimilarity c (0+::x) == toRotationMatrix c * x\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.Quaternion",
          "name": "toRotationMatrix",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Array (Int, Int) a",
          "source": "src/Number-Quaternion.html#toRotationMatrix",
          "type": "function"
        },
        "index": {
          "description": "Let be unit quaternion then it holds similarity toRotationMatrix",
          "hierarchy": "Number Quaternion",
          "module": "Number.Quaternion",
          "name": "toRotationMatrix",
          "normalized": "T a-\u003eArray(Int,Int)a",
          "package": "numeric-prelude",
          "partial": "Rotation Matrix",
          "signature": "T a-\u003eArray(Int,Int)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Quaternion.html#v:toRotationMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRatios of mathematical objects.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.Ratio",
          "name": "Ratio",
          "package": "numeric-prelude",
          "source": "src/Number-Ratio.html",
          "type": "module"
        },
        "index": {
          "description": "Ratios of mathematical objects",
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "Ratio",
          "package": "numeric-prelude",
          "partial": "Ratio",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": "Rational",
          "package": "numeric-prelude",
          "source": "src/Number-Ratio.html#Rational",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "Rational",
          "package": "numeric-prelude",
          "partial": "Rational",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#t:Rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Ratio.html#T",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Number.Ratio\",\"NumericPrelude.Numeric\"]",
          "name": "(%)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e T a",
          "source": "src/Number-Ratio.html#%25",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:-37-\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-37-\"]"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "(%) %",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:-37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": ":%",
          "package": "numeric-prelude",
          "signature": ":%",
          "source": "src/Number-Ratio.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": ":%",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v::-37-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": "denominator",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-Ratio.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "denominator",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:denominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": "fromValue",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-Ratio.html#fromValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "fromValue",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Value",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:fromValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": "numerator",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-Ratio.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "numerator",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:numerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Ratio.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "recip",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Ratio",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a",
          "source": "src/Number-Ratio.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "scale",
          "normalized": "a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an alternative show method\nthat is more user-friendly but also potentially more ambigious.\n\u003c/p\u003e",
          "module": "Number.Ratio",
          "name": "showsPrecAuto",
          "package": "numeric-prelude",
          "signature": "Int -\u003e T a -\u003e String -\u003e String",
          "source": "src/Number-Ratio.html#showsPrecAuto",
          "type": "function"
        },
        "index": {
          "description": "This is an alternative show method that is more user-friendly but also potentially more ambigious",
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "showsPrecAuto",
          "normalized": "Int-\u003eT a-\u003eString-\u003eString",
          "package": "numeric-prelude",
          "partial": "Prec Auto",
          "signature": "Int-\u003eT a-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:showsPrecAuto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimilar to \u003ccode\u003e\u003ca\u003esplitFraction\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Number.Ratio",
          "name": "split",
          "package": "numeric-prelude",
          "signature": "T a -\u003e (a, T a)",
          "source": "src/Number-Ratio.html#split",
          "type": "function"
        },
        "index": {
          "description": "similar to splitFraction",
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "split",
          "normalized": "T a-\u003e(a,T a)",
          "package": "numeric-prelude",
          "signature": "T a-\u003e(a,T a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNecessary when mixing NumericPrelude.Numeric Rationals with Prelude98 Rationals\n\u003c/p\u003e",
          "module": "Number.Ratio",
          "name": "toRational98",
          "package": "numeric-prelude",
          "signature": "T a -\u003e Ratio a",
          "source": "src/Number-Ratio.html#toRational98",
          "type": "function"
        },
        "index": {
          "description": "Necessary when mixing NumericPrelude.Numeric Rationals with Prelude98 Rationals",
          "hierarchy": "Number Ratio",
          "module": "Number.Ratio",
          "name": "toRational98",
          "normalized": "T a-\u003eRatio a",
          "package": "numeric-prelude",
          "partial": "Rational",
          "signature": "T a-\u003eRatio a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Ratio.html#v:toRational98"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Check.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "Check",
          "package": "numeric-prelude",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe best solution seems to let \u003ccode\u003e\u003ca\u003emodulus\u003c/a\u003e\u003c/code\u003e be part of the type.\nThis could happen with a phantom type for modulus\nand a \u003ccode\u003erun\u003c/code\u003e function like \u003ccode\u003e\u003ca\u003erunST\u003c/a\u003e\u003c/code\u003e.\nThen operations with non-matching moduli could be detected at compile time\nand \u003ccode\u003e\u003ca\u003ezero\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eone\u003c/a\u003e\u003c/code\u003e could be generated with the correct modulus.\nAn alternative trial can be found in module ResidueClassMaybe.\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Check",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Check.html#T",
          "type": "data"
        },
        "index": {
          "description": "The best solution seems to let modulus be part of the type This could happen with phantom type for modulus and run function like runST Then operations with non-matching moduli could be detected at compile time and zero and one could be generated with the correct modulus An alternative trial can be found in module ResidueClassMaybe",
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003er /: m\u003c/code\u003e is the residue class containing \u003ccode\u003er\u003c/code\u003e with respect to the modulus \u003ccode\u003em\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Check",
          "name": "(/:)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e T a",
          "source": "src/Number-ResidueClass-Check.html#%2F%3A",
          "type": "function"
        },
        "index": {
          "description": "is the residue class containing with respect to the modulus",
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "(/:) /:",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:-47-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/Number-ResidueClass-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "errIncompat",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-ResidueClass-Check.html#errIncompat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "errIncompat",
          "package": "numeric-prelude",
          "partial": "Incompat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:errIncompat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "factorPrec",
          "package": "numeric-prelude",
          "signature": "Int",
          "source": "src/Number-ResidueClass-Check.html#factorPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "factorPrec",
          "package": "numeric-prelude",
          "partial": "Prec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:factorPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "fromInteger",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer -\u003e T a",
          "source": "src/Number-ResidueClass-Check.html#fromInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "fromInteger",
          "normalized": "a-\u003eInteger-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "a-\u003eInteger-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "fromRepresentative",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e T a",
          "source": "src/Number-ResidueClass-Check.html#fromRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "fromRepresentative",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Representative",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:fromRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if two residue classes share the same modulus\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Check",
          "name": "isCompatible",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e Bool",
          "source": "src/Number-ResidueClass-Check.html#isCompatible",
          "type": "function"
        },
        "index": {
          "description": "Check if two residue classes share the same modulus",
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "isCompatible",
          "normalized": "T a-\u003eT a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Compatible",
          "signature": "T a-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:isCompatible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e T a -\u003e T a",
          "source": "src/Number-ResidueClass-Check.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "lift1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a -\u003e a) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/Number-ResidueClass-Check.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "lift2",
          "normalized": "(a-\u003ea-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "maybeCompatible",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e Maybe a",
          "source": "src/Number-ResidueClass-Check.html#maybeCompatible",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "maybeCompatible",
          "normalized": "T a-\u003eT a-\u003eMaybe a",
          "package": "numeric-prelude",
          "partial": "Compatible",
          "signature": "T a-\u003eT a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:maybeCompatible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "modulus",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-ResidueClass-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "modulus",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:modulus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "one",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-ResidueClass-Check.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "one",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "representative",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-ResidueClass-Check.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "representative",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:representative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Check",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-ResidueClass-Check.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Check",
          "module": "Number.ResidueClass.Check",
          "name": "zero",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Check.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "Func",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Func.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "Func",
          "package": "numeric-prelude",
          "partial": "Func",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere a residue class is a representative\nand the modulus is an argument.\nYou cannot show a value of type \u003ccode\u003e\u003ca\u003eT\u003c/a\u003e\u003c/code\u003e,\nyou can only show it with respect to a concrete modulus.\nValues cannot be compared,\nbecause the comparison result depends on the modulus.\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Func",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Func.html#T",
          "type": "newtype"
        },
        "index": {
          "description": "Here residue class is representative and the modulus is an argument You cannot show value of type you can only show it with respect to concrete modulus Values cannot be compared because the comparison result depends on the modulus",
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons (a -\u003e a)",
          "source": "src/Number-ResidueClass-Func.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "Cons",
          "normalized": "Cons(a-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Cons",
          "signature": "Cons(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "concrete",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e a",
          "source": "src/Number-ResidueClass-Func.html#concrete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "concrete",
          "normalized": "a-\u003eT a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:concrete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "equal",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a -\u003e T a -\u003e Bool",
          "source": "src/Number-ResidueClass-Func.html#equal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "equal",
          "normalized": "a-\u003eT a-\u003eT a-\u003eBool",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "fromInteger",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e T a",
          "source": "src/Number-ResidueClass-Func.html#fromInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "fromInteger",
          "normalized": "Integer-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "Integer-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "fromRepresentative",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-ResidueClass-Func.html#fromRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "fromRepresentative",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Representative",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:fromRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "lift0",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a) -\u003e T a",
          "source": "src/Number-ResidueClass-Func.html#lift0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "lift0",
          "normalized": "(a-\u003ea)-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea)-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:lift0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "lift1",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a) -\u003e T a -\u003e T a",
          "source": "src/Number-ResidueClass-Func.html#lift1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "lift1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:lift1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a -\u003e a) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/Number-ResidueClass-Func.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "lift2",
          "normalized": "(a-\u003ea-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "lift98_1",
          "package": "numeric-prelude",
          "signature": "(T a -\u003e T a -\u003e T a) -\u003e T a -\u003e T a",
          "source": "src/Number-ResidueClass-Func.html#lift98_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "lift98_1",
          "normalized": "(T a-\u003eT a-\u003eT a)-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(T a-\u003eT a-\u003eT a)-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:lift98_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "lift98_2",
          "package": "numeric-prelude",
          "signature": "(T a -\u003e T a -\u003e T a -\u003e T a) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/Number-ResidueClass-Func.html#lift98_2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "lift98_2",
          "normalized": "(T a-\u003eT a-\u003eT a-\u003eT a)-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(T a-\u003eT a-\u003eT a-\u003eT a)-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:lift98_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "notImplemented",
          "package": "numeric-prelude",
          "signature": "String -\u003e a",
          "source": "src/Number-ResidueClass-Func.html#notImplemented",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "notImplemented",
          "normalized": "String-\u003ea",
          "package": "numeric-prelude",
          "partial": "Implemented",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:notImplemented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "one",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/Number-ResidueClass-Func.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "one",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Func",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "T a",
          "source": "src/Number-ResidueClass-Func.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Func",
          "module": "Number.ResidueClass.Func",
          "name": "zero",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Func.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Maybe",
          "name": "Maybe",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Maybe.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "Maybe",
          "package": "numeric-prelude",
          "partial": "Maybe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere we try to provide implementations for \u003ccode\u003e\u003ca\u003ezero\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eone\u003c/a\u003e\u003c/code\u003e\nby making the modulus optional.\nWe have to provide non-modulus operations for the cases\nwhere both operands have Nothing modulus.\nThis is problematic since operations like '(/)'\ndepend essentially on the modulus.\n\u003c/p\u003e\u003cp\u003eA working version with disabled \u003ccode\u003e\u003ca\u003ezero\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eone\u003c/a\u003e\u003c/code\u003e can be found ResidueClass.\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Maybe",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Maybe.html#T",
          "type": "data"
        },
        "index": {
          "description": "Here we try to provide implementations for zero and one by making the modulus optional We have to provide non-modulus operations for the cases where both operands have Nothing modulus This is problematic since operations like depend essentially on the modulus working version with disabled zero and one can be found ResidueClass",
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003er /: m\u003c/code\u003e is the residue class containing \u003ccode\u003er\u003c/code\u003e with respect to the modulus \u003ccode\u003em\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Maybe",
          "name": "(/:)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e T a",
          "source": "src/Number-ResidueClass-Maybe.html#%2F%3A",
          "type": "function"
        },
        "index": {
          "description": "is the residue class containing with respect to the modulus",
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "(/:) /:",
          "normalized": "a-\u003ea-\u003eT a",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:-47-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Maybe",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/Number-ResidueClass-Maybe.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if two residue classes share the same modulus\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Maybe",
          "name": "isCompatible",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e Bool",
          "source": "src/Number-ResidueClass-Maybe.html#isCompatible",
          "type": "function"
        },
        "index": {
          "description": "Check if two residue classes share the same modulus",
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "isCompatible",
          "normalized": "T a-\u003eT a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Compatible",
          "signature": "T a-\u003eT a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:isCompatible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Maybe",
          "name": "isCompatibleMaybe",
          "package": "numeric-prelude",
          "signature": "Maybe a -\u003e Maybe a -\u003e Bool",
          "source": "src/Number-ResidueClass-Maybe.html#isCompatibleMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "isCompatibleMaybe",
          "normalized": "Maybe a-\u003eMaybe a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Compatible Maybe",
          "signature": "Maybe a-\u003eMaybe a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:isCompatibleMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Maybe",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(a -\u003e a -\u003e a -\u003e a) -\u003e (a -\u003e a -\u003e a) -\u003e T a -\u003e T a -\u003e T a",
          "source": "src/Number-ResidueClass-Maybe.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "lift2",
          "normalized": "(a-\u003ea-\u003ea-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "(a-\u003ea-\u003ea-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eT a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Maybe",
          "name": "matchMaybe",
          "package": "numeric-prelude",
          "signature": "Maybe a -\u003e Maybe a -\u003e Maybe a",
          "source": "src/Number-ResidueClass-Maybe.html#matchMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "matchMaybe",
          "normalized": "Maybe a-\u003eMaybe a-\u003eMaybe a",
          "package": "numeric-prelude",
          "partial": "Maybe",
          "signature": "Maybe a-\u003eMaybe a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:matchMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe modulus can be Nothing to denote a generic constant like \u003ccode\u003e\u003ca\u003ezero\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eone\u003c/a\u003e\u003c/code\u003e which could not be bound to a specific modulus so far\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Maybe",
          "name": "modulus",
          "package": "numeric-prelude",
          "signature": "(Maybe a)",
          "source": "src/Number-ResidueClass-Maybe.html#T",
          "type": "function"
        },
        "index": {
          "description": "the modulus can be Nothing to denote generic constant like zero and one which could not be bound to specific modulus so far",
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "modulus",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:modulus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Maybe",
          "name": "representative",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-ResidueClass-Maybe.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Maybe",
          "module": "Number.ResidueClass.Maybe",
          "name": "representative",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Maybe.html#v:representative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "Reader",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Reader.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "Reader",
          "package": "numeric-prelude",
          "partial": "Reader",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eT is a Reader monad but does not need functional dependencies\nlike that from the Monad Transformer Library.\n\u003c/p\u003e",
          "module": "Number.ResidueClass.Reader",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass-Reader.html#T",
          "type": "newtype"
        },
        "index": {
          "description": "is Reader monad but does not need functional dependencies like that from the Monad Transformer Library",
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/Number-ResidueClass-Reader.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "concrete",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a b -\u003e b",
          "source": "src/Number-ResidueClass-Reader.html#concrete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "concrete",
          "normalized": "a-\u003eT a b-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eT a b-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:concrete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "fromInteger",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e T a a",
          "source": "src/Number-ResidueClass-Reader.html#fromInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "fromInteger",
          "normalized": "Integer-\u003eT a a",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "Integer-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "fromRepresentative",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a a",
          "source": "src/Number-ResidueClass-Reader.html#fromRepresentative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "fromRepresentative",
          "normalized": "a-\u003eT a a",
          "package": "numeric-prelude",
          "partial": "Representative",
          "signature": "a-\u003eT a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:fromRepresentative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getAdd",
          "package": "numeric-prelude",
          "signature": "T a (a -\u003e a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getAdd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getAdd",
          "normalized": "T a(a-\u003ea-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Add",
          "signature": "T a(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getAdditiveVars",
          "package": "numeric-prelude",
          "signature": "T a (a, a -\u003e a -\u003e a, a -\u003e a -\u003e a, a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getAdditiveVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getAdditiveVars",
          "normalized": "T a(a,a-\u003ea-\u003ea,a-\u003ea-\u003ea,a-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Additive Vars",
          "signature": "T a(a,a-\u003ea-\u003ea,a-\u003ea-\u003ea,a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getAdditiveVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getDivide",
          "package": "numeric-prelude",
          "signature": "T a (a -\u003e a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getDivide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getDivide",
          "normalized": "T a(a-\u003ea-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Divide",
          "signature": "T a(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getFieldVars",
          "package": "numeric-prelude",
          "signature": "T a (a -\u003e a -\u003e a, a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getFieldVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getFieldVars",
          "normalized": "T a(a-\u003ea-\u003ea,a-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Field Vars",
          "signature": "T a(a-\u003ea-\u003ea,a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getFieldVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getMul",
          "package": "numeric-prelude",
          "signature": "T a (a -\u003e a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getMul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getMul",
          "normalized": "T a(a-\u003ea-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Mul",
          "signature": "T a(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getNeg",
          "package": "numeric-prelude",
          "signature": "T a (a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getNeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getNeg",
          "normalized": "T a(a-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Neg",
          "signature": "T a(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getOne",
          "package": "numeric-prelude",
          "signature": "T a a",
          "source": "src/Number-ResidueClass-Reader.html#getOne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getOne",
          "package": "numeric-prelude",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getRecip",
          "package": "numeric-prelude",
          "signature": "T a (a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getRecip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getRecip",
          "normalized": "T a(a-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Recip",
          "signature": "T a(a-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getRingVars",
          "package": "numeric-prelude",
          "signature": "T a (a, a -\u003e a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getRingVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getRingVars",
          "normalized": "T a(a,a-\u003ea-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Ring Vars",
          "signature": "T a(a,a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getRingVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getSub",
          "package": "numeric-prelude",
          "signature": "T a (a -\u003e a -\u003e a)",
          "source": "src/Number-ResidueClass-Reader.html#getSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getSub",
          "normalized": "T a(a-\u003ea-\u003ea)",
          "package": "numeric-prelude",
          "partial": "Sub",
          "signature": "T a(a-\u003ea-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "getZero",
          "package": "numeric-prelude",
          "signature": "T a a",
          "source": "src/Number-ResidueClass-Reader.html#getZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "getZero",
          "package": "numeric-prelude",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:getZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "monadExample",
          "package": "numeric-prelude",
          "signature": "T a [a]",
          "source": "src/Number-ResidueClass-Reader.html#monadExample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "monadExample",
          "normalized": "T a[a]",
          "package": "numeric-prelude",
          "partial": "Example",
          "signature": "T a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:monadExample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "runExample",
          "package": "numeric-prelude",
          "signature": "[Integer]",
          "source": "src/Number-ResidueClass-Reader.html#runExample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "runExample",
          "normalized": "[Integer]",
          "package": "numeric-prelude",
          "partial": "Example",
          "signature": "[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:runExample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass.Reader",
          "name": "toFunc",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Number-ResidueClass-Reader.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass Reader",
          "module": "Number.ResidueClass.Reader",
          "name": "toFunc",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Func",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass-Reader.html#v:toFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass",
          "name": "ResidueClass",
          "package": "numeric-prelude",
          "source": "src/Number-ResidueClass.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "ResidueClass",
          "package": "numeric-prelude",
          "partial": "Residue Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass",
          "name": "add",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e a",
          "source": "src/Number-ResidueClass.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "add",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass",
          "name": "divide",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e a",
          "source": "src/Number-ResidueClass.html#divide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "divide",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#v:divide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe division may be ambiguous.\nIn this case an arbitrary quotient is returned.\n\u003c/p\u003e\u003cpre\u003e\n0\u003cem\u003e:4 * 2\u003c/em\u003e:4 == 0/:4\n2\u003cem\u003e:4 * 2\u003c/em\u003e:4 == 0/:4\n\u003c/pre\u003e",
          "module": "Number.ResidueClass",
          "name": "divideMaybe",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e Maybe a",
          "source": "src/Number-ResidueClass.html#divideMaybe",
          "type": "function"
        },
        "index": {
          "description": "The division may be ambiguous In this case an arbitrary quotient is returned",
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "divideMaybe",
          "normalized": "a-\u003ea-\u003ea-\u003eMaybe a",
          "package": "numeric-prelude",
          "partial": "Maybe",
          "signature": "a-\u003ea-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#v:divideMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e a",
          "source": "src/Number-ResidueClass.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "mul",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass",
          "name": "neg",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Number-ResidueClass.html#neg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "neg",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Number-ResidueClass.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "recip",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.ResidueClass",
          "name": "sub",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a -\u003e a",
          "source": "src/Number-ResidueClass.html#sub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number ResidueClass",
          "module": "Number.ResidueClass",
          "name": "sub",
          "normalized": "a-\u003ea-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-ResidueClass.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "Root",
          "package": "numeric-prelude",
          "source": "src/Number-Root.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "Root",
          "package": "numeric-prelude",
          "partial": "Root",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe root degree must be positive.\nThis way we can implement multiplication\nusing only multiplication from type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Number.Root",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-Root.html#T",
          "type": "data"
        },
        "index": {
          "description": "The root degree must be positive This way we can implement multiplication using only multiplication from type",
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "T",
          "package": "numeric-prelude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons Integer a",
          "source": "src/Number-Root.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexponent must be non-negative\n\u003c/p\u003e",
          "module": "Number.Root",
          "name": "cardinalPower",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e T a -\u003e T a",
          "source": "src/Number-Root.html#cardinalPower",
          "type": "function"
        },
        "index": {
          "description": "exponent must be non-negative",
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "cardinalPower",
          "normalized": "Integer-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "Integer-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:cardinalPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "commonDegree",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T (a, a)",
          "source": "src/Number-Root.html#commonDegree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "commonDegree",
          "normalized": "T a-\u003eT a-\u003eT(a,a)",
          "package": "numeric-prelude",
          "partial": "Degree",
          "signature": "T a-\u003eT a-\u003eT(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:commonDegree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "div",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/Number-Root.html#div",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "div",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "fromNumber",
          "package": "numeric-prelude",
          "signature": "a -\u003e T a",
          "source": "src/Number-Root.html#fromNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "fromNumber",
          "normalized": "a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:fromNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexponent can be negative\n\u003c/p\u003e",
          "module": "Number.Root",
          "name": "integerPower",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e T a -\u003e T a",
          "source": "src/Number-Root.html#integerPower",
          "type": "function"
        },
        "index": {
          "description": "exponent can be negative",
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "integerPower",
          "normalized": "Integer-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "Integer-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:integerPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "mul",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a -\u003e T a",
          "source": "src/Number-Root.html#mul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "mul",
          "normalized": "T a-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "rationalPower",
          "package": "numeric-prelude",
          "signature": "Rational -\u003e T a -\u003e T a",
          "source": "src/Number-Root.html#rationalPower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "rationalPower",
          "normalized": "Rational-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Power",
          "signature": "Rational-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:rationalPower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Root.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "recip",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexponent must be positive\n\u003c/p\u003e",
          "module": "Number.Root",
          "name": "root",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e T a -\u003e T a",
          "source": "src/Number-Root.html#root",
          "type": "function"
        },
        "index": {
          "description": "exponent must be positive",
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "root",
          "normalized": "Integer-\u003eT a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "Integer-\u003eT a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Root.html#sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "sqrt",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "toNumber",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Root.html#toNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "toNumber",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Number",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:toNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.Root",
          "name": "toRootSet",
          "package": "numeric-prelude",
          "signature": "T a -\u003e T a",
          "source": "src/Number-Root.html#toRootSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number Root",
          "module": "Number.Root",
          "name": "toRootSet",
          "normalized": "T a-\u003eT a",
          "package": "numeric-prelude",
          "partial": "Root Set",
          "signature": "T a-\u003eT a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-Root.html#v:toRootSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpecial physical units: SI unit system\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.SI.Unit",
          "name": "Unit",
          "package": "numeric-prelude",
          "source": "src/Number-SI-Unit.html",
          "type": "module"
        },
        "index": {
          "description": "Special physical units SI unit system",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Unit",
          "package": "numeric-prelude",
          "partial": "Unit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Dimension",
          "package": "numeric-prelude",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "data"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Dimension",
          "package": "numeric-prelude",
          "partial": "Dimension",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#t:Dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Angle",
          "package": "numeric-prelude",
          "signature": "Angle",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Angle",
          "package": "numeric-prelude",
          "partial": "Angle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:Angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Charge",
          "package": "numeric-prelude",
          "signature": "Charge",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Charge",
          "package": "numeric-prelude",
          "partial": "Charge",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:Charge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Information",
          "package": "numeric-prelude",
          "signature": "Information",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Information",
          "package": "numeric-prelude",
          "partial": "Information",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:Information"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Length",
          "package": "numeric-prelude",
          "signature": "Length",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Length",
          "package": "numeric-prelude",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:Length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Mass",
          "package": "numeric-prelude",
          "signature": "Mass",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Mass",
          "package": "numeric-prelude",
          "partial": "Mass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:Mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Temperature",
          "package": "numeric-prelude",
          "signature": "Temperature",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Temperature",
          "package": "numeric-prelude",
          "partial": "Temperature",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:Temperature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "Time",
          "package": "numeric-prelude",
          "signature": "Time",
          "source": "src/Number-SI-Unit.html#Dimension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "Time",
          "package": "numeric-prelude",
          "partial": "Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "acceleration",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#acceleration",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "acceleration",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:acceleration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhysical constants\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "accelerationOfEarthGravity",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#accelerationOfEarthGravity",
          "type": "function"
        },
        "index": {
          "description": "Physical constants",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "accelerationOfEarthGravity",
          "package": "numeric-prelude",
          "partial": "Of Earth Gravity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:accelerationOfEarthGravity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "angle",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#angle",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "angle",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "angularSpeed",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#angularSpeed",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "angularSpeed",
          "package": "numeric-prelude",
          "partial": "Speed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:angularSpeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "area",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#area",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "area",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:area"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "bytesize",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#bytesize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "bytesize",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:bytesize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "calorien",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#calorien",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "calorien",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:calorien"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "capacitance",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#capacitance",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "capacitance",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:capacitance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "charge",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#charge",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "charge",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:charge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "current",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#current",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "current",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:current"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "dataRate",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#dataRate",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "dataRate",
          "package": "numeric-prelude",
          "partial": "Rate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:dataRate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "database",
          "package": "numeric-prelude",
          "signature": "[InitUnitSet Dimension a]",
          "source": "src/Number-SI-Unit.html#database",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "database",
          "normalized": "[InitUnitSet Dimension a]",
          "package": "numeric-prelude",
          "signature": "[InitUnitSet Dimension a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:database"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnitDatabase.T of units and their common scalings \n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "databaseRead",
          "package": "numeric-prelude",
          "signature": "T Dimension a",
          "source": "src/Number-SI-Unit.html#databaseRead",
          "type": "function"
        },
        "index": {
          "description": "UnitDatabase.T of units and their common scalings",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "databaseRead",
          "package": "numeric-prelude",
          "partial": "Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:databaseRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnitDatabase.T of units and their common scalings \n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "databaseShow",
          "package": "numeric-prelude",
          "signature": "T Dimension a",
          "source": "src/Number-SI-Unit.html#databaseShow",
          "type": "function"
        },
        "index": {
          "description": "UnitDatabase.T of units and their common scalings",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "databaseShow",
          "package": "numeric-prelude",
          "partial": "Show",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:databaseShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "deg180",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#deg180",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "deg180",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:deg180"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "distance",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#distance",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "distance",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:distance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "electronVolt",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#electronVolt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "electronVolt",
          "package": "numeric-prelude",
          "partial": "Volt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:electronVolt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "energy",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#energy",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "energy",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:energy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "force",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#force",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "force",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:force"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "fourth",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#fourth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "fourth",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:fourth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "frequency",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#frequency",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "frequency",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:frequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "grad200",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#grad200",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "grad200",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:grad200"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "half",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#half",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "half",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:half"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "horsePower",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#horsePower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "horsePower",
          "package": "numeric-prelude",
          "partial": "Power",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:horsePower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "information",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#information",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "information",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:information"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "k2",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#k2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "k2",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:k2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "length",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#length",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "length",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "mach",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#mach",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "mach",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:mach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "mass",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#mass",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "mass",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:mass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "meterPerAstronomicUnit",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#meterPerAstronomicUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "meterPerAstronomicUnit",
          "package": "numeric-prelude",
          "partial": "Per Astronomic Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:meterPerAstronomicUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "meterPerFoot",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#meterPerFoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "meterPerFoot",
          "package": "numeric-prelude",
          "partial": "Per Foot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:meterPerFoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "meterPerInch",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#meterPerInch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "meterPerInch",
          "package": "numeric-prelude",
          "partial": "Per Inch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:meterPerInch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "meterPerParsec",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#meterPerParsec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "meterPerParsec",
          "package": "numeric-prelude",
          "partial": "Per Parsec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:meterPerParsec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "meterPerYard",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#meterPerYard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "meterPerYard",
          "package": "numeric-prelude",
          "partial": "Per Yard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:meterPerYard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommon constants\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "percent",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#percent",
          "type": "function"
        },
        "index": {
          "description": "Common constants",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "percent",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:percent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "power",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#power",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "power",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "pressure",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#pressure",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "pressure",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:pressure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "radPerDeg",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#radPerDeg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "radPerDeg",
          "package": "numeric-prelude",
          "partial": "Per Deg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:radPerDeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "radPerGrad",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#radPerGrad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "radPerGrad",
          "package": "numeric-prelude",
          "partial": "Per Grad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:radPerGrad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "resistance",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#resistance",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "resistance",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:resistance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "secondsPerDay",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#secondsPerDay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "secondsPerDay",
          "package": "numeric-prelude",
          "partial": "Per Day",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:secondsPerDay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "secondsPerHour",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#secondsPerHour",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "secondsPerHour",
          "package": "numeric-prelude",
          "partial": "Per Hour",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:secondsPerHour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion factors\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "secondsPerMinute",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#secondsPerMinute",
          "type": "function"
        },
        "index": {
          "description": "Conversion factors",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "secondsPerMinute",
          "package": "numeric-prelude",
          "partial": "Per Minute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:secondsPerMinute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "secondsPerYear",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#secondsPerYear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "secondsPerYear",
          "package": "numeric-prelude",
          "partial": "Per Year",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:secondsPerYear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "speed",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#speed",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "speed",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:speed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "speedOfLight",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#speedOfLight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "speedOfLight",
          "package": "numeric-prelude",
          "partial": "Of Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:speedOfLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "temperature",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#temperature",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "temperature",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:temperature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI.Unit",
          "name": "threeFourth",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Number-SI-Unit.html#threeFourth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "threeFourth",
          "package": "numeric-prelude",
          "partial": "Fourth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:threeFourth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "time",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#time",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "time",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "voltage",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#voltage",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "voltage",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:voltage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome common quantity classes.\n\u003c/p\u003e",
          "module": "Number.SI.Unit",
          "name": "volume",
          "package": "numeric-prelude",
          "signature": "T Dimension",
          "source": "src/Number-SI-Unit.html#volume",
          "type": "function"
        },
        "index": {
          "description": "Some common quantity classes",
          "hierarchy": "Number SI Unit",
          "module": "Number.SI.Unit",
          "name": "volume",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI-Unit.html#v:volume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumerical values equipped with SI units.\nThis is considered as the user front-end.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Number.SI",
          "name": "SI",
          "package": "numeric-prelude",
          "source": "src/Number-SI.html",
          "type": "module"
        },
        "index": {
          "description": "Numerical values equipped with SI units This is considered as the user front-end",
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "SI",
          "package": "numeric-prelude",
          "partial": "SI",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "PValue",
          "package": "numeric-prelude",
          "source": "src/Number-SI.html#PValue",
          "type": "type"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "PValue",
          "package": "numeric-prelude",
          "partial": "PValue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#t:PValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/Number-SI.html#T",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons (PValue v)",
          "source": "src/Number-SI.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "accelerationOfEarthGravity",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#accelerationOfEarthGravity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "accelerationOfEarthGravity",
          "package": "numeric-prelude",
          "partial": "Of Earth Gravity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:accelerationOfEarthGravity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "ampere",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#ampere",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "ampere",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:ampere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "astronomicUnit",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#astronomicUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "astronomicUnit",
          "package": "numeric-prelude",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:astronomicUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "bar",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#bar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "bar",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:bar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "baud",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#baud",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "baud",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:baud"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "bit",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#bit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "bit",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:bit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "byte",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#byte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "byte",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:byte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "calorien",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#calorien",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "calorien",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:calorien"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "coulomb",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#coulomb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "coulomb",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:coulomb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "day",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#day",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "day",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:day"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "electronVolt",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#electronVolt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "electronVolt",
          "package": "numeric-prelude",
          "partial": "Volt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:electronVolt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "farad",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#farad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "farad",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:farad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "foot",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#foot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "foot",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:foot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "fromScalarSingle",
          "package": "numeric-prelude",
          "signature": "v -\u003e T a v",
          "source": "src/Number-SI.html#fromScalarSingle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "fromScalarSingle",
          "normalized": "a-\u003eT b a",
          "package": "numeric-prelude",
          "partial": "Scalar Single",
          "signature": "v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:fromScalarSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "gramm",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#gramm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "gramm",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:gramm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "hertz",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#hertz",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "hertz",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:hertz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "horsePower",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#horsePower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "horsePower",
          "package": "numeric-prelude",
          "partial": "Power",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:horsePower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "hour",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#hour",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "hour",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:hour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "inch",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#inch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "inch",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:inch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "joule",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#joule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "joule",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:joule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "kelvin",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#kelvin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "kelvin",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:kelvin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "lift",
          "package": "numeric-prelude",
          "signature": "(PValue v0 -\u003e PValue v1) -\u003e T a v0 -\u003e T a v1",
          "source": "src/Number-SI.html#lift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "lift",
          "normalized": "(PValue a-\u003ePValue a)-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "(PValue v-\u003ePValue v)-\u003eT a v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "lift2",
          "package": "numeric-prelude",
          "signature": "(PValue v0 -\u003e PValue v1 -\u003e PValue v2) -\u003e T a v0 -\u003e T a v1 -\u003e T a v2",
          "source": "src/Number-SI.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "lift2",
          "normalized": "(PValue a-\u003ePValue a-\u003ePValue a)-\u003eT b a-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "(PValue v-\u003ePValue v-\u003ePValue v)-\u003eT a v-\u003eT a v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "lift2Gen",
          "package": "numeric-prelude",
          "signature": "(PValue v0 -\u003e PValue v1 -\u003e x) -\u003e T a v0 -\u003e T a v1 -\u003e x",
          "source": "src/Number-SI.html#lift2Gen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "lift2Gen",
          "normalized": "(PValue a-\u003ePValue a-\u003eb)-\u003eT c a-\u003eT c a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Gen",
          "signature": "(PValue v-\u003ePValue v-\u003ex)-\u003eT a v-\u003eT a v-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:lift2Gen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "liftGen",
          "package": "numeric-prelude",
          "signature": "(PValue v -\u003e x) -\u003e T a v -\u003e x",
          "source": "src/Number-SI.html#liftGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "liftGen",
          "normalized": "(PValue a-\u003eb)-\u003eT c a-\u003eb",
          "package": "numeric-prelude",
          "partial": "Gen",
          "signature": "(PValue v-\u003ex)-\u003eT a v-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:liftGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "liter",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#liter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "liter",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:liter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "mach",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#mach",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "mach",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:mach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "meter",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#meter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "meter",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:meter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "minute",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#minute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "minute",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:minute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "newton",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#newton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "newton",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:newton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "ohm",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#ohm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "ohm",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:ohm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "parsec",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#parsec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "parsec",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:parsec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "pascal",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#pascal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "pascal",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:pascal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "quantity",
          "package": "numeric-prelude",
          "signature": "T Dimension -\u003e v -\u003e T a v",
          "source": "src/Number-SI.html#quantity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "quantity",
          "normalized": "T Dimension-\u003ea-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "T Dimension-\u003ev-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:quantity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "readsNat",
          "package": "numeric-prelude",
          "signature": "T Dimension a -\u003e Int -\u003e ReadS (T a v)",
          "source": "src/Number-SI.html#readsNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "readsNat",
          "normalized": "T Dimension a-\u003eInt-\u003eReadS(T a b)",
          "package": "numeric-prelude",
          "partial": "Nat",
          "signature": "T Dimension a-\u003eInt-\u003eReadS(T a v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:readsNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "scale",
          "package": "numeric-prelude",
          "signature": "v -\u003e T a v -\u003e T a v",
          "source": "src/Number-SI.html#scale",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "scale",
          "normalized": "a-\u003eT b a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "v-\u003eT a v-\u003eT a v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "second",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#second",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "second",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:second"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "showNat",
          "package": "numeric-prelude",
          "signature": "T Dimension a -\u003e T a v -\u003e String",
          "source": "src/Number-SI.html#showNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "showNat",
          "normalized": "T Dimension a-\u003eT a b-\u003eString",
          "package": "numeric-prelude",
          "partial": "Nat",
          "signature": "T Dimension a-\u003eT a v-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:showNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "speedOfLight",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#speedOfLight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "speedOfLight",
          "package": "numeric-prelude",
          "partial": "Of Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:speedOfLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "tonne",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#tonne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "tonne",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:tonne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "volt",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#volt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "volt",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:volt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "watt",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#watt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "watt",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:watt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "yard",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#yard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "yard",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:yard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Number.SI",
          "name": "year",
          "package": "numeric-prelude",
          "signature": "T a v",
          "source": "src/Number-SI.html#year",
          "type": "function"
        },
        "index": {
          "hierarchy": "Number SI",
          "module": "Number.SI",
          "name": "year",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/Number-SI.html#v:year"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe only point of this module is\nto reexport items that we want from the standard Prelude.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NumericPrelude.Base",
          "name": "Base",
          "package": "numeric-prelude",
          "source": "src/NumericPrelude-Base.html",
          "type": "module"
        },
        "index": {
          "description": "The only point of this module is to reexport items that we want from the standard Prelude",
          "hierarchy": "NumericPrelude Base",
          "module": "NumericPrelude.Base",
          "name": "Base",
          "package": "numeric-prelude",
          "partial": "Base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Base.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003eif'\u003c/a\u003e\u003c/code\u003e, but the name is chosen\nsuch that it can be used for GHC-7.0's rebindable if-then-else syntax.\n\u003c/p\u003e",
          "module": "NumericPrelude.Base",
          "name": "ifThenElse",
          "package": "numeric-prelude",
          "signature": "Bool -\u003e a -\u003e a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "The same as if but the name is chosen such that it can be used for GHC-7.0 rebindable if-then-else syntax",
          "hierarchy": "NumericPrelude Base",
          "module": "NumericPrelude.Base",
          "name": "ifThenElse",
          "normalized": "Bool-\u003ea-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Then Else",
          "signature": "Bool-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Base.html#v:ifThenElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "Elementwise",
          "package": "numeric-prelude",
          "source": "src/NumericPrelude-Elementwise.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "Elementwise",
          "package": "numeric-prelude",
          "partial": "Elementwise",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA reader monad for the special purpose\nof defining instances of certain operations on tuples and records.\nIt does not add any new functionality to the common Reader monad,\nbut it restricts the functions to the required ones\nand exports them from one module.\nThat is you do not have to import\nboth Control.Monad.Trans.Reader and Control.Applicative.\nThe type also tells the user, for what the Reader monad is used.\nWe can more easily replace or extend the implementation when needed.\n\u003c/p\u003e",
          "module": "NumericPrelude.Elementwise",
          "name": "T",
          "package": "numeric-prelude",
          "source": "src/NumericPrelude-Elementwise.html#T",
          "type": "newtype"
        },
        "index": {
          "description": "reader monad for the special purpose of defining instances of certain operations on tuples and records It does not add any new functionality to the common Reader monad but it restricts the functions to the required ones and exports them from one module That is you do not have to import both Control.Monad.Trans.Reader and Control.Applicative The type also tells the user for what the Reader monad is used We can more easily replace or extend the implementation when needed",
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "T",
          "package": "numeric-prelude",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#t:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "Cons",
          "package": "numeric-prelude",
          "signature": "Cons",
          "source": "src/NumericPrelude-Elementwise.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "Cons",
          "package": "numeric-prelude",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "element",
          "package": "numeric-prelude",
          "signature": "(v -\u003e a) -\u003e T v a",
          "source": "src/NumericPrelude-Elementwise.html#element",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "element",
          "normalized": "(a-\u003eb)-\u003eT a b",
          "package": "numeric-prelude",
          "signature": "(v-\u003ea)-\u003eT v a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "run",
          "package": "numeric-prelude",
          "signature": "v -\u003e a",
          "source": "src/NumericPrelude-Elementwise.html#T",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "run",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "run2",
          "package": "numeric-prelude",
          "signature": "T (x, y) a -\u003e x -\u003e y -\u003e a",
          "source": "src/NumericPrelude-Elementwise.html#run2",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "run2",
          "normalized": "T(a,b)c-\u003ea-\u003eb-\u003ec",
          "package": "numeric-prelude",
          "signature": "T(x,y)a-\u003ex-\u003ey-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:run2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "run3",
          "package": "numeric-prelude",
          "signature": "T (x, y, z) a -\u003e x -\u003e y -\u003e z -\u003e a",
          "source": "src/NumericPrelude-Elementwise.html#run3",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "run3",
          "normalized": "T(a,b,c)d-\u003ea-\u003eb-\u003ec-\u003ed",
          "package": "numeric-prelude",
          "signature": "T(x,y,z)a-\u003ex-\u003ey-\u003ez-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:run3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "run4",
          "package": "numeric-prelude",
          "signature": "T (x, y, z, w) a -\u003e x -\u003e y -\u003e z -\u003e w -\u003e a",
          "source": "src/NumericPrelude-Elementwise.html#run4",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "run4",
          "normalized": "T(a,b,c,d)e-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee",
          "package": "numeric-prelude",
          "signature": "T(x,y,z,w)a-\u003ex-\u003ey-\u003ez-\u003ew-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:run4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "run5",
          "package": "numeric-prelude",
          "signature": "T (x, y, z, u, w) a -\u003e x -\u003e y -\u003e z -\u003e u -\u003e w -\u003e a",
          "source": "src/NumericPrelude-Elementwise.html#run5",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "run5",
          "normalized": "T(a,b,c,d,e)f-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef",
          "package": "numeric-prelude",
          "signature": "T(x,y,z,u,w)a-\u003ex-\u003ey-\u003ez-\u003eu-\u003ew-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:run5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Elementwise",
          "name": "with",
          "package": "numeric-prelude",
          "signature": "a -\u003e T v a",
          "source": "src/NumericPrelude-Elementwise.html#with",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Elementwise",
          "module": "NumericPrelude.Elementwise",
          "name": "with",
          "normalized": "a-\u003eT b a",
          "package": "numeric-prelude",
          "signature": "a-\u003eT v a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Elementwise.html#v:with"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome functions that are counterparts of functions from \u003ca\u003eData.List\u003c/a\u003e\nusing NumericPrelude.Numeric type classes.\nThey are distinct in that they check for valid arguments,\ne.g. the length argument of \u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e must be at most the length of the input list.\nHowever, since many Haskell programs rely on the absence of such checks,\nwe did not make these the default implementations\nas in \u003ca\u003eNumericPrelude.List.Generic\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NumericPrelude.List.Checked",
          "name": "Checked",
          "package": "numeric-prelude",
          "source": "src/NumericPrelude-List-Checked.html",
          "type": "module"
        },
        "index": {
          "description": "Some functions that are counterparts of functions from Data.List using NumericPrelude.Numeric type classes They are distinct in that they check for valid arguments e.g the length argument of take must be at most the length of the input list However since many Haskell programs rely on the absence of such checks we did not make these the default implementations as in NumericPrelude.List.Generic",
          "hierarchy": "NumericPrelude List Checked",
          "module": "NumericPrelude.List.Checked",
          "name": "Checked",
          "package": "numeric-prelude",
          "partial": "Checked",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Checked.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe index must be smaller than the length of the list,\notherwise the result is undefined.\n\u003c/p\u003e",
          "module": "[\"NumericPrelude.List.Checked\",\"NumericPrelude.List.Generic\"]",
          "name": "(!!)",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e n -\u003e a",
          "source": "src/NumericPrelude-List-Checked.html#%21%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Checked.html#v:-33--33-\",\"http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:-33--33-\"]"
        },
        "index": {
          "description": "The index must be smaller than the length of the list otherwise the result is undefined",
          "hierarchy": "NumericPrelude List Checked",
          "module": "NumericPrelude.List.Checked",
          "name": "(!!) !!",
          "normalized": "[a]-\u003eb-\u003ea",
          "package": "numeric-prelude",
          "signature": "[a]-\u003en-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Checked.html#v:-33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDropped number of elements must be at most the length of the list,\notherwise the end of the list is undefined.\n\u003c/p\u003e",
          "module": "NumericPrelude.List.Checked",
          "name": "drop",
          "package": "numeric-prelude",
          "signature": "n -\u003e [a] -\u003e [a]",
          "source": "src/NumericPrelude-List-Checked.html#drop",
          "type": "function"
        },
        "index": {
          "description": "Dropped number of elements must be at most the length of the list otherwise the end of the list is undefined",
          "hierarchy": "NumericPrelude List Checked",
          "module": "NumericPrelude.List.Checked",
          "name": "drop",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "numeric-prelude",
          "signature": "n-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Checked.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit position must be at most the length of the list,\notherwise the end of the first list and the second list are undefined.\n\u003c/p\u003e",
          "module": "NumericPrelude.List.Checked",
          "name": "splitAt",
          "package": "numeric-prelude",
          "signature": "n -\u003e [a] -\u003e ([a], [a])",
          "source": "src/NumericPrelude-List-Checked.html#splitAt",
          "type": "function"
        },
        "index": {
          "description": "Split position must be at most the length of the list otherwise the end of the first list and the second list are undefined",
          "hierarchy": "NumericPrelude List Checked",
          "module": "NumericPrelude.List.Checked",
          "name": "splitAt",
          "normalized": "a-\u003e[b]-\u003e([b],[b])",
          "package": "numeric-prelude",
          "partial": "At",
          "signature": "n-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Checked.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTaken number of elements must be at most the length of the list,\notherwise the end of the list is undefined.\n\u003c/p\u003e",
          "module": "NumericPrelude.List.Checked",
          "name": "take",
          "package": "numeric-prelude",
          "signature": "n -\u003e [a] -\u003e [a]",
          "source": "src/NumericPrelude-List-Checked.html#take",
          "type": "function"
        },
        "index": {
          "description": "Taken number of elements must be at most the length of the list otherwise the end of the list is undefined",
          "hierarchy": "NumericPrelude List Checked",
          "module": "NumericPrelude.List.Checked",
          "name": "take",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "numeric-prelude",
          "signature": "n-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Checked.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip two lists which must be of the same length.\nThis is checked only lazily, that is unequal lengths are detected only\nif the list is evaluated completely.\nBut it is more strict than \u003ccode\u003ezipWithPad undefined f\u003c/code\u003e\nsince the latter one may succeed on unequal length list if \u003ccode\u003ef\u003c/code\u003e is lazy.\n\u003c/p\u003e",
          "module": "NumericPrelude.List.Checked",
          "name": "zipWith",
          "package": "numeric-prelude",
          "signature": "(a -\u003e b -\u003e c)-\u003e [a]-\u003e [b]-\u003e [c]",
          "type": "function"
        },
        "index": {
          "description": "Zip two lists which must be of the same length This is checked only lazily that is unequal lengths are detected only if the list is evaluated completely But it is more strict than zipWithPad undefined since the latter one may succeed on unequal length list if is lazy",
          "hierarchy": "NumericPrelude List Checked",
          "module": "NumericPrelude.List.Checked",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e[c]",
          "package": "numeric-prelude",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Checked.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions that are counterparts of the \u003ccode\u003egeneric\u003c/code\u003e functions in \u003ca\u003eData.List\u003c/a\u003e\nusing NumericPrelude.Numeric type classes.\nFor input arguments we use the restrictive \u003ccode\u003eToInteger\u003c/code\u003e constraint,\nalthough in principle \u003ccode\u003eRealRing\u003c/code\u003e would be enough.\nHowever we think that \u003ccode\u003etake 0.5 xs\u003c/code\u003e is rather a bug than a feature,\nthus we forbid fractional types.\nOn the other hand fractional types as result can be quite handy,\ne.g. in \u003ccode\u003eaverage xs = sum xs / length xs\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "NumericPrelude.List.Generic",
          "name": "Generic",
          "package": "numeric-prelude",
          "source": "src/NumericPrelude-List-Generic.html",
          "type": "module"
        },
        "index": {
          "description": "Functions that are counterparts of the generic functions in Data.List using NumericPrelude.Numeric type classes For input arguments we use the restrictive ToInteger constraint although in principle RealRing would be enough However we think that take xs is rather bug than feature thus we forbid fractional types On the other hand fractional types as result can be quite handy e.g in average xs sum xs length xs",
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "Generic",
          "package": "numeric-prelude",
          "partial": "Generic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "drop",
          "package": "numeric-prelude",
          "signature": "n -\u003e [a] -\u003e [a]",
          "source": "src/NumericPrelude-List-Generic.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "drop",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "numeric-prelude",
          "signature": "n-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "elemIndex",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e Maybe n",
          "source": "src/NumericPrelude-List-Generic.html#elemIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "elemIndex",
          "normalized": "a-\u003e[a]-\u003eMaybe b",
          "package": "numeric-prelude",
          "partial": "Index",
          "signature": "a-\u003e[a]-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:elemIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "elemIndices",
          "package": "numeric-prelude",
          "signature": "a -\u003e [a] -\u003e [n]",
          "source": "src/NumericPrelude-List-Generic.html#elemIndices",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "elemIndices",
          "normalized": "a-\u003e[a]-\u003e[b]",
          "package": "numeric-prelude",
          "partial": "Indices",
          "signature": "a-\u003e[a]-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:elemIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "findIndex",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe n",
          "source": "src/NumericPrelude-List-Generic.html#findIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "findIndex",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe b",
          "package": "numeric-prelude",
          "partial": "Index",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:findIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "findIndices",
          "package": "numeric-prelude",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [n]",
          "source": "src/NumericPrelude-List-Generic.html#findIndices",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "findIndices",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[b]",
          "package": "numeric-prelude",
          "partial": "Indices",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:findIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft associative length computation\nthat is appropriate for types like \u003ccode\u003eInteger\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NumericPrelude.List.Generic",
          "name": "lengthLeft",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e n",
          "source": "src/NumericPrelude-List-Generic.html#lengthLeft",
          "type": "function"
        },
        "index": {
          "description": "Left associative length computation that is appropriate for types like Integer",
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "lengthLeft",
          "normalized": "[a]-\u003eb",
          "package": "numeric-prelude",
          "partial": "Left",
          "signature": "[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:lengthLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight associative length computation\nthat is appropriate for types like \u003ccode\u003ePeano\u003c/code\u003e number.\n\u003c/p\u003e",
          "module": "NumericPrelude.List.Generic",
          "name": "lengthRight",
          "package": "numeric-prelude",
          "signature": "[a] -\u003e n",
          "source": "src/NumericPrelude-List-Generic.html#lengthRight",
          "type": "function"
        },
        "index": {
          "description": "Right associative length computation that is appropriate for types like Peano number",
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "lengthRight",
          "normalized": "[a]-\u003eb",
          "package": "numeric-prelude",
          "partial": "Right",
          "signature": "[a]-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:lengthRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "replicate",
          "package": "numeric-prelude",
          "signature": "n -\u003e a -\u003e [a]",
          "source": "src/NumericPrelude-List-Generic.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "replicate",
          "normalized": "a-\u003eb-\u003e[b]",
          "package": "numeric-prelude",
          "signature": "n-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "splitAt",
          "package": "numeric-prelude",
          "signature": "n -\u003e [a] -\u003e ([a], [a])",
          "source": "src/NumericPrelude-List-Generic.html#splitAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "splitAt",
          "normalized": "a-\u003e[b]-\u003e([b],[b])",
          "package": "numeric-prelude",
          "partial": "At",
          "signature": "n-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.List.Generic",
          "name": "take",
          "package": "numeric-prelude",
          "signature": "n -\u003e [a] -\u003e [a]",
          "source": "src/NumericPrelude-List-Generic.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude List Generic",
          "module": "NumericPrelude.List.Generic",
          "name": "take",
          "normalized": "a-\u003e[b]-\u003e[b]",
          "package": "numeric-prelude",
          "signature": "n-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-List-Generic.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "Numeric",
          "package": "numeric-prelude",
          "source": "src/NumericPrelude-Numeric.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "Numeric",
          "package": "numeric-prelude",
          "partial": "Numeric",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDouble-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE double-precision type.\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "Double",
          "package": "numeric-prelude",
          "type": "data"
        },
        "index": {
          "description": "Double-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE double-precision type",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "Double",
          "package": "numeric-prelude",
          "partial": "Double",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#t:Double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE single-precision type.\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "Float",
          "package": "numeric-prelude",
          "type": "data"
        },
        "index": {
          "description": "Single-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE single-precision type",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "Float",
          "package": "numeric-prelude",
          "partial": "Float",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#t:Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fixed-precision integer type with at least the range \u003ccode\u003e[-2^29 .. 2^29-1]\u003c/code\u003e.\n The exact range for a given implementation can be determined by using\n \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e from the \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "Int",
          "package": "numeric-prelude",
          "type": "data"
        },
        "index": {
          "description": "fixed-precision integer type with at least the range The exact range for given implementation can be determined by using minBound and maxBound from the Bounded class",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "Int",
          "package": "numeric-prelude",
          "partial": "Int",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#t:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary-precision integers.\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "Integer",
          "package": "numeric-prelude",
          "type": "data"
        },
        "index": {
          "description": "Arbitrary-precision integers",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "Integer",
          "package": "numeric-prelude",
          "partial": "Integer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#t:Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "Rational",
          "package": "numeric-prelude",
          "source": "src/Number-Ratio.html#Rational",
          "type": "type"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "Rational",
          "package": "numeric-prelude",
          "partial": "Rational",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#t:Rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "(*)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Ring.html#%2A",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(*) *",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "(**)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Transcendental.html#logBase",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(**) **",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-42--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escale a vector by a scalar\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "(*\u003e)",
          "package": "numeric-prelude",
          "signature": "a -\u003e v -\u003e v",
          "source": "src/Algebra-Module.html#%2A%3E",
          "type": "function"
        },
        "index": {
          "description": "scale vector by scalar",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(*\u003e) *\u003e",
          "normalized": "a-\u003eb-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd and subtract elements\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "(+)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Additive.html#%2B",
          "type": "function"
        },
        "index": {
          "description": "add and subtract elements",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(+) +",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd and subtract elements\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "(-)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Additive.html#%2B",
          "type": "function"
        },
        "index": {
          "description": "add and subtract elements",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(-) -",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "(/)",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Field.html#%2F",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(/) /",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe exponent has fixed type \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e in order\n    to avoid an arbitrarily limitted range of exponents,\n    but to reduce the need for the compiler to guess the type (default type).\n    In practice the exponent is most oftenly fixed, and is most oftenly \u003ccode\u003e2\u003c/code\u003e.\n    Fixed exponents can be optimized away and\n    thus the expensive computation of \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003es doesn't matter.\n    The previous solution used a \u003ccode\u003e\u003ca\u003eC\u003c/a\u003e\u003c/code\u003e constrained type\n    and the exponent was converted to Integer before computation.\n    So the current solution is not less efficient.\n\u003c/p\u003e\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003e^\u003c/a\u003e\u003c/code\u003e with more flexibility is provided by \u003ccode\u003e\u003ca\u003eringPower\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "(^)",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer -\u003e a",
          "source": "src/Algebra-Ring.html#%5E",
          "type": "function"
        },
        "index": {
          "description": "The exponent has fixed type Integer in order to avoid an arbitrarily limitted range of exponents but to reduce the need for the compiler to guess the type default type In practice the exponent is most oftenly fixed and is most oftenly Fixed exponents can be optimized away and thus the expensive computation of Integer doesn matter The previous solution used constrained type and the exponent was converted to Integer before computation So the current solution is not less efficient variant of with more flexibility is provided by ringPower",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(^) ^",
          "normalized": "a-\u003eInteger-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003eInteger-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "(^-)",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer -\u003e a",
          "source": "src/Algebra-Field.html#%5E-",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(^-) ^-",
          "normalized": "a-\u003eInteger-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003eInteger-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-94--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "(^/)",
          "package": "numeric-prelude",
          "signature": "a -\u003e Rational -\u003e a",
          "source": "src/Algebra-Algebraic.html#%5E%2F",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "(^/) ^/",
          "normalized": "a-\u003eRational-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003eRational-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:-94--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "abs",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Absolute.html#abs",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "abs",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "acos",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asin",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "acos",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:acos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "acosh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asinh",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "acosh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:acosh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "asin",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asin",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "asin",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:asin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "asinh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asinh",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "asinh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:asinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "atan",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asin",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "atan",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:atan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "atan2",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-RealTranscendental.html#atan2",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "atan2",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:atan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "atanh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#asinh",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "atanh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:atanh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "ceiling",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#ceiling",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "ceiling",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:ceiling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "cos",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sin",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "cos",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:cos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "cosh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sinh",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "cosh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:cosh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "denominator",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Ratio.html#denominator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "denominator",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:denominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "div",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#div",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "div",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "divMod",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Algebra-IntegralDomain.html#divMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "divMod",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Mod",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:divMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "exp",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "exp",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the greatest common divisor and\n    solve a respective Diophantine equation.\n\u003c/p\u003e\u003cpre\u003e   (g,(a,b)) = extendedGCD x y ==\u003e\n        g==a*x+b*y   &&  g == gcd x y\n\u003c/pre\u003e\u003cp\u003eTODO: This method is not appropriate for the PID class,\n          because there are rings like the one of the multivariate polynomials,\n          where for all x and y greatest common divisors of x and y exist,\n          but they cannot be represented as a linear combination of x and y.\n    TODO: The definition of extendedGCD does not return the canonical associate.\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "extendedGCD",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, (a, a))",
          "source": "src/Algebra-PrincipalIdealDomain.html#extendedGCD",
          "type": "function"
        },
        "index": {
          "description": "Compute the greatest common divisor and solve respective Diophantine equation extendedGCD gcd TODO This method is not appropriate for the PID class because there are rings like the one of the multivariate polynomials where for all and greatest common divisors of and exist but they cannot be represented as linear combination of and TODO The definition of extendedGCD does not return the canonical associate",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "extendedGCD",
          "normalized": "a-\u003ea-\u003e(a,(a,a))",
          "package": "numeric-prelude",
          "partial": "GCD",
          "signature": "a-\u003ea-\u003e(a,(a,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:extendedGCD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "floor",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#ceiling",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "floor",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:floor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "fraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-RealRing.html#fraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "fraction",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:fraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "fromInteger",
          "package": "numeric-prelude",
          "signature": "Integer -\u003e a",
          "source": "src/Algebra-Ring.html#fromInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "fromInteger",
          "normalized": "Integer-\u003ea",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "Integer-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "fromRational'",
          "package": "numeric-prelude",
          "signature": "Rational -\u003e a",
          "source": "src/Algebra-Field.html#fromRational%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "fromRational'",
          "normalized": "Rational-\u003ea",
          "package": "numeric-prelude",
          "partial": "Rational'",
          "signature": "Rational-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:fromRational-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Greatest Common Divisor is defined by:\n\u003c/p\u003e\u003cpre\u003e   gcd x y == gcd y x\n   divides z x && divides z y ==\u003e divides z (gcd x y)   (specification)\n   divides (gcd x y) x\n\u003c/pre\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "gcd",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-PrincipalIdealDomain.html#gcd",
          "type": "function"
        },
        "index": {
          "description": "The Greatest Common Divisor is defined by gcd gcd divides divides divides gcd specification divides gcd",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "gcd",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:gcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "isUnit",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-Units.html#isUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "isUnit",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Unit",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:isUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "isZero",
          "package": "numeric-prelude",
          "signature": "a -\u003e Bool",
          "source": "src/Algebra-ZeroTestable.html#isZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "isZero",
          "normalized": "a-\u003eBool",
          "package": "numeric-prelude",
          "partial": "Zero",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast common multiple\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "lcm",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-PrincipalIdealDomain.html#lcm",
          "type": "function"
        },
        "index": {
          "description": "Least common multiple",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "lcm",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:lcm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "log",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "log",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:log"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "logBase",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Transcendental.html#logBase",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "logBase",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "partial": "Base",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:logBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "mod",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-IntegralDomain.html#div",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "mod",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einverse with respect to \u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "negate",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Additive.html#negate",
          "type": "function"
        },
        "index": {
          "description": "inverse with respect to",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "negate",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "numerator",
          "package": "numeric-prelude",
          "signature": "T a -\u003e a",
          "source": "src/Number-Ratio.html#numerator",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "numerator",
          "normalized": "T a-\u003ea",
          "package": "numeric-prelude",
          "signature": "T a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:numerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "one",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-Ring.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "one",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "pi",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-Transcendental.html#pi",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "pi",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "quot",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-RealIntegral.html#quot",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "quot",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:quot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "quotRem",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Algebra-RealIntegral.html#quotRem",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "quotRem",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "numeric-prelude",
          "partial": "Rem",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:quotRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "recip",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Field.html#recip",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "recip",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "rem",
          "package": "numeric-prelude",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-RealIntegral.html#quot",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "rem",
          "normalized": "a-\u003ea-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:rem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "round",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#round",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "round",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:round"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "signum",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Absolute.html#signum",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "signum",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:signum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "sin",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sin",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "sin",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "sinh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sinh",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "sinh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:sinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "splitFraction",
          "package": "numeric-prelude",
          "signature": "a -\u003e (b, a)",
          "source": "src/Algebra-RealRing.html#splitFraction",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "splitFraction",
          "normalized": "a-\u003e(b,a)",
          "package": "numeric-prelude",
          "partial": "Fraction",
          "signature": "a-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:splitFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "sqrt",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Algebraic.html#sqrt",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "sqrt",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "stdAssociate",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Units.html#stdAssociate",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "stdAssociate",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Associate",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:stdAssociate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "stdUnit",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Units.html#stdAssociate",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "stdUnit",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Unit",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:stdUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "stdUnitInv",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Units.html#stdAssociate",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "stdUnitInv",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "partial": "Unit Inv",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:stdUnitInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "tan",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sin",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "tan",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:tan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "tanh",
          "package": "numeric-prelude",
          "signature": "a -\u003e a",
          "source": "src/Algebra-Transcendental.html#sinh",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "tanh",
          "normalized": "a-\u003ea",
          "package": "numeric-prelude",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:tanh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "toInteger",
          "package": "numeric-prelude",
          "signature": "a -\u003e Integer",
          "source": "src/Algebra-ToInteger.html#toInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "toInteger",
          "normalized": "a-\u003eInteger",
          "package": "numeric-prelude",
          "partial": "Integer",
          "signature": "a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:toInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLossless conversion from any representation of a rational to \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "toRational",
          "package": "numeric-prelude",
          "signature": "a -\u003e Rational",
          "source": "src/Algebra-ToRational.html#toRational",
          "type": "function"
        },
        "index": {
          "description": "Lossless conversion from any representation of rational to Rational",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "toRational",
          "normalized": "a-\u003eRational",
          "package": "numeric-prelude",
          "partial": "Rational",
          "signature": "a-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:toRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude.Numeric",
          "name": "truncate",
          "package": "numeric-prelude",
          "signature": "a -\u003e b",
          "source": "src/Algebra-RealRing.html#truncate",
          "type": "function"
        },
        "index": {
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "truncate",
          "normalized": "a-\u003eb",
          "package": "numeric-prelude",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:truncate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ezero element of the vector space\n\u003c/p\u003e",
          "module": "NumericPrelude.Numeric",
          "name": "zero",
          "package": "numeric-prelude",
          "signature": "a",
          "source": "src/Algebra-Additive.html#zero",
          "type": "function"
        },
        "index": {
          "description": "zero element of the vector space",
          "hierarchy": "NumericPrelude Numeric",
          "module": "NumericPrelude.Numeric",
          "name": "zero",
          "package": "numeric-prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude-Numeric.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "NumericPrelude",
          "name": "NumericPrelude",
          "package": "numeric-prelude",
          "source": "src/NumericPrelude.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "NumericPrelude",
          "module": "NumericPrelude",
          "name": "NumericPrelude",
          "package": "numeric-prelude",
          "partial": "Numeric Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/numeric-prelude/docs/NumericPrelude.html#"
      }
    }
  ]
]