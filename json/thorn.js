[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "thorn"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe module Data.Thorn.Basic.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Thorn.Basic",
          "name": "Basic",
          "package": "thorn",
          "source": "src/Data-Thorn-Basic.html",
          "type": "module"
        },
        "index": {
          "description": "The module Data.Thorn.Basic",
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "Basic",
          "package": "thorn",
          "partial": "Basic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T0",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T0",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T0",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T1",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T1",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T1",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T2",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T2",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T3",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T3",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T4",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T4",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T5",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T5",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T5",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T6",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T6",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T6",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T7",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T7",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T7",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T8",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T8",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T8",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Basic",
          "name": "T9",
          "package": "thorn",
          "source": "src/Data-Thorn-Internal.html#T9",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "T9",
          "package": "thorn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#t:T9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e modifyname (\"Prefix\",\"Suffix\") (\"***\",\"+++\") \"Hello\" == \"PrefixHelloSuffix\"\n modifyname (\"Prefix\",\"Suffix\") (\"***\",\"+++\") \":%%%\" == \":***%%%+++\"\n modifyname (\"prefix\",\"suffix\") (\"***\",\"+++\") \"hello\" == \"prefixhellosuffix\"\n modifyname (\"prefix\",\"suffix\") (\"***\",\"+++\") \"%%%\" == \"***%%%+++\"\n\u003c/pre\u003e",
          "module": "Data.Thorn.Basic",
          "name": "modifyname",
          "package": "thorn",
          "signature": "(String, String) -\u003e (String, String) -\u003e String -\u003e String",
          "source": "src/Data-Thorn-Internal.html#modifyname",
          "type": "function"
        },
        "index": {
          "description": "modifyname Prefix Suffix Hello PrefixHelloSuffix modifyname Prefix Suffix modifyname prefix suffix hello prefixhellosuffix modifyname prefix suffix",
          "hierarchy": "Data Thorn Basic",
          "module": "Data.Thorn.Basic",
          "name": "modifyname",
          "normalized": "(String,String)-\u003e(String,String)-\u003eString-\u003eString",
          "package": "thorn",
          "signature": "(String,String)-\u003e(String,String)-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Basic.html#v:modifyname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe module Data.Thorn.Fold.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Thorn.Fold",
          "name": "Fold",
          "package": "thorn",
          "source": "src/Data-Thorn-Fold.html",
          "type": "module"
        },
        "index": {
          "description": "The module Data.Thorn.Fold",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "Fold",
          "package": "thorn",
          "partial": "Fold",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofold u t\u003c/code\u003e provides a fold for the recursive type \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autofold",
          "package": "thorn",
          "signature": "TypeQ-\u003e TypeQ-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "autofold provides fold for the recursive type",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autofold",
          "normalized": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autofold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofoldMutual uts k\u003c/code\u003e provides a fold for the mutually recursive type \u003ccode\u003etk\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autofoldMutual",
          "package": "thorn",
          "signature": "[(TypeQ, TypeQ)]-\u003e Int-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "autofoldMutual uts provides fold for the mutually recursive type tk",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autofoldMutual",
          "normalized": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autofoldMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofolddec s u t\u003c/code\u003e provides a declaration of a fold for the recursive type \u003ccode\u003et\u003c/code\u003e with the name \u003ccode\u003es\u003c/code\u003e, with a type signature.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autofolddec",
          "package": "thorn",
          "signature": "String -\u003e TypeQ -\u003e TypeQ -\u003e DecsQ",
          "source": "src/Data-Thorn-Fold.html#autofolddec",
          "type": "function"
        },
        "index": {
          "description": "autofolddec provides declaration of fold for the recursive type with the name with type signature",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autofolddec",
          "normalized": "String-\u003eTypeQ-\u003eTypeQ-\u003eDecsQ",
          "package": "thorn",
          "signature": "String-\u003eTypeQ-\u003eTypeQ-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autofolddec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofolddecMutual s uts k\u003c/code\u003e provides a declaration of a fold for the mutually recursive type \u003ccode\u003etk\u003c/code\u003e with the name \u003ccode\u003es\u003c/code\u003e, with a type signature.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autofolddecMutual",
          "package": "thorn",
          "signature": "String -\u003e [(TypeQ, TypeQ)] -\u003e Int -\u003e DecsQ",
          "source": "src/Data-Thorn-Fold.html#autofolddecMutual",
          "type": "function"
        },
        "index": {
          "description": "autofolddecMutual uts provides declaration of fold for the mutually recursive type tk with the name with type signature",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autofolddecMutual",
          "normalized": "String-\u003e[(TypeQ,TypeQ)]-\u003eInt-\u003eDecsQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "String-\u003e[(TypeQ,TypeQ)]-\u003eInt-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autofolddecMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofoldtype u t\u003c/code\u003e provides the type of \u003ccode\u003e$(\u003ccode\u003e\u003ca\u003eautofold\u003c/a\u003e\u003c/code\u003e u t)\u003c/code\u003e, that is, \u003ccode\u003e(u x0 .. xn a -\u003e a) -\u003e (t x0 .. xn -\u003e a)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autofoldtype",
          "package": "thorn",
          "signature": "TypeQ -\u003e TypeQ -\u003e TypeQ",
          "source": "src/Data-Thorn-Fold.html#autofoldtype",
          "type": "function"
        },
        "index": {
          "description": "autofoldtype provides the type of autofold that is x0 xn x0 xn",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autofoldtype",
          "normalized": "TypeQ-\u003eTypeQ-\u003eTypeQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eTypeQ-\u003eTypeQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autofoldtype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofoldtypeMutual uts k\u003c/code\u003e provides the type of \u003ccode\u003e$(\u003ccode\u003e\u003ca\u003eautofoldMutual\u003c/a\u003e\u003c/code\u003e uts k)\u003c/code\u003e, that is, \u003ccode\u003e(u0 x0 .. xm a0 .. an -\u003e a0) -\u003e .. -\u003e (un x0 .. xm a0 .. an -\u003e an) -\u003e (tk x0 .. xm -\u003e ak)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autofoldtypeMutual",
          "package": "thorn",
          "signature": "[(TypeQ, TypeQ)] -\u003e Int -\u003e TypeQ",
          "source": "src/Data-Thorn-Fold.html#autofoldtypeMutual",
          "type": "function"
        },
        "index": {
          "description": "autofoldtypeMutual uts provides the type of autofoldMutual uts that is u0 x0 xm a0 an a0 un x0 xm a0 an an tk x0 xm ak",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autofoldtypeMutual",
          "normalized": "[(TypeQ,TypeQ)]-\u003eInt-\u003eTypeQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[(TypeQ,TypeQ)]-\u003eInt-\u003eTypeQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autofoldtypeMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Fold",
          "name": "autohylo",
          "package": "thorn",
          "signature": "TypeQ-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autohylo",
          "normalized": "TypeQ-\u003eExpQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autohylo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutually recursive version of \u003ccode\u003e\u003ca\u003eautohylo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autohyloMutual",
          "package": "thorn",
          "signature": "[TypeQ]-\u003e Int-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "Mutually recursive version of autohylo",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autohyloMutual",
          "normalized": "[TypeQ]-\u003eInt-\u003eExpQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[TypeQ]-\u003eInt-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autohyloMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Fold",
          "name": "autoin",
          "package": "thorn",
          "signature": "TypeQ-\u003e TypeQ-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autoin",
          "normalized": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutually recursive version of \u003ccode\u003e\u003ca\u003eautoin\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autoinMutual",
          "package": "thorn",
          "signature": "[(TypeQ, TypeQ)]-\u003e Int-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "Mutually recursive version of autoin",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autoinMutual",
          "normalized": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autoinMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Thorn.Fold",
          "name": "autoout",
          "package": "thorn",
          "signature": "TypeQ-\u003e TypeQ-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autoout",
          "normalized": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autoout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutually recursive version of \u003ccode\u003e\u003ca\u003eautoout\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autooutMutual",
          "package": "thorn",
          "signature": "[(TypeQ, TypeQ)]-\u003e Int-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "Mutually recursive version of autoout",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autooutMutual",
          "normalized": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autooutMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautounfold u t\u003c/code\u003e provides an unfold for the recursive type \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autounfold",
          "package": "thorn",
          "signature": "TypeQ-\u003e TypeQ-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "autounfold provides an unfold for the recursive type",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autounfold",
          "normalized": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eTypeQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autounfold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautounfoldMutual uts k\u003c/code\u003e provides an unfold for the mutually recursive type \u003ccode\u003etk\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autounfoldMutual",
          "package": "thorn",
          "signature": "[(TypeQ, TypeQ)]-\u003e Int-\u003e ExpQ",
          "type": "function"
        },
        "index": {
          "description": "autounfoldMutual uts provides an unfold for the mutually recursive type tk",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autounfoldMutual",
          "normalized": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[(TypeQ,TypeQ)]-\u003eInt-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autounfoldMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautounfolddec s u t\u003c/code\u003e provides a declaration of an unfold for the recursive type \u003ccode\u003et\u003c/code\u003e with the name \u003ccode\u003es\u003c/code\u003e, with a type signature.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autounfolddec",
          "package": "thorn",
          "signature": "String -\u003e TypeQ -\u003e TypeQ -\u003e DecsQ",
          "source": "src/Data-Thorn-Fold.html#autounfolddec",
          "type": "function"
        },
        "index": {
          "description": "autounfolddec provides declaration of an unfold for the recursive type with the name with type signature",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autounfolddec",
          "normalized": "String-\u003eTypeQ-\u003eTypeQ-\u003eDecsQ",
          "package": "thorn",
          "signature": "String-\u003eTypeQ-\u003eTypeQ-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autounfolddec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautounfolddecMutual s uts k\u003c/code\u003e provides a declaration of an unfold for the mutually recursive type \u003ccode\u003etk\u003c/code\u003e with the name \u003ccode\u003es\u003c/code\u003e, with a type signature.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autounfolddecMutual",
          "package": "thorn",
          "signature": "String -\u003e [(TypeQ, TypeQ)] -\u003e Int -\u003e DecsQ",
          "source": "src/Data-Thorn-Fold.html#autounfolddecMutual",
          "type": "function"
        },
        "index": {
          "description": "autounfolddecMutual uts provides declaration of an unfold for the mutually recursive type tk with the name with type signature",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autounfolddecMutual",
          "normalized": "String-\u003e[(TypeQ,TypeQ)]-\u003eInt-\u003eDecsQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "String-\u003e[(TypeQ,TypeQ)]-\u003eInt-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autounfolddecMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautounfoldtype u t\u003c/code\u003e provides the type of \u003ccode\u003e$(\u003ccode\u003e\u003ca\u003eautounfold\u003c/a\u003e\u003c/code\u003e u t)\u003c/code\u003e, that is, \u003ccode\u003e(a -\u003e u x0 .. xn a) -\u003e (a -\u003e t x0 .. xn)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autounfoldtype",
          "package": "thorn",
          "signature": "TypeQ -\u003e TypeQ -\u003e TypeQ",
          "source": "src/Data-Thorn-Fold.html#autounfoldtype",
          "type": "function"
        },
        "index": {
          "description": "autounfoldtype provides the type of autounfold that is x0 xn x0 xn",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autounfoldtype",
          "normalized": "TypeQ-\u003eTypeQ-\u003eTypeQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eTypeQ-\u003eTypeQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autounfoldtype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautounfoldtypeMutual uts k\u003c/code\u003e provides the type of \u003ccode\u003e$(\u003ccode\u003e\u003ca\u003eautounfoldMutual\u003c/a\u003e\u003c/code\u003e uts k)\u003c/code\u003e, that is, \u003ccode\u003e(a0 -\u003e u0 x0 .. xm a0 .. an) -\u003e .. -\u003e (an -\u003e un x0 .. xm a0 .. an) -\u003e (ak -\u003e tk x0 .. xm)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "autounfoldtypeMutual",
          "package": "thorn",
          "signature": "[(TypeQ, TypeQ)] -\u003e Int -\u003e TypeQ",
          "source": "src/Data-Thorn-Fold.html#autounfoldtypeMutual",
          "type": "function"
        },
        "index": {
          "description": "autounfoldtypeMutual uts provides the type of autounfoldMutual uts that is a0 u0 x0 xm a0 an an un x0 xm a0 an ak tk x0 xm",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "autounfoldtypeMutual",
          "normalized": "[(TypeQ,TypeQ)]-\u003eInt-\u003eTypeQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[(TypeQ,TypeQ)]-\u003eInt-\u003eTypeQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:autounfoldtypeMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse this function to designate how to convert the name of data constructors for \u003ccode\u003e\u003ca\u003eunfixdata\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e modifynameUf \"Hello\" == \"UfHello\"\n modifynameUf \":***\" == \":&***\"\n\u003c/pre\u003e\u003cp\u003eNote that\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003emodifynameUf\u003c/a\u003e\u003c/code\u003e == \u003ccode\u003e\u003ca\u003emodifyname\u003c/a\u003e\u003c/code\u003e (\"Uf\",\"\") (\"&\",\"\")\u003c/pre\u003e",
          "module": "Data.Thorn.Fold",
          "name": "modifynameUf",
          "package": "thorn",
          "signature": "String -\u003e String",
          "source": "src/Data-Thorn-Fold.html#modifynameUf",
          "type": "function"
        },
        "index": {
          "description": "Use this function to designate how to convert the name of data constructors for unfixdata modifynameUf Hello UfHello modifynameUf Note that modifynameUf modifyname Uf",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "modifynameUf",
          "normalized": "String-\u003eString",
          "package": "thorn",
          "partial": "Uf",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:modifynameUf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunfixdata t n f ds\u003c/code\u003e provides a declaration of a nonrecursive datatype whose fixpoint is the recursive type \u003ccode\u003et\u003c/code\u003e, with a deriving declaration with names \u003ccode\u003eds\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Fold",
          "name": "unfixdata",
          "package": "thorn",
          "signature": "TypeQ-\u003e String-\u003e (String -\u003e String)-\u003e [Name]-\u003e DecsQ",
          "type": "function"
        },
        "index": {
          "description": "unfixdata ds provides declaration of nonrecursive datatype whose fixpoint is the recursive type with deriving declaration with names ds",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "unfixdata",
          "normalized": "TypeQ-\u003eString-\u003e(String-\u003eString)-\u003e[Name]-\u003eDecsQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eString-\u003e(String-\u003eString)-\u003e[Name]-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:unfixdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutually recursive version of \u003ccode\u003e\u003ca\u003eunfixdata\u003c/a\u003e\u003c/code\u003e. Note that\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eunfixdata\u003c/a\u003e\u003c/code\u003e t s f ds = \u003ccode\u003e\u003ca\u003eunfixdataMutual\u003c/a\u003e\u003c/code\u003e [(t,s,f,ds)]\u003c/pre\u003e",
          "module": "Data.Thorn.Fold",
          "name": "unfixdataMutual",
          "package": "thorn",
          "signature": "[(TypeQ, String, String -\u003e String, [Name])]-\u003e DecsQ",
          "type": "function"
        },
        "index": {
          "description": "Mutually recursive version of unfixdata Note that unfixdata ds unfixdataMutual ds",
          "hierarchy": "Data Thorn Fold",
          "module": "Data.Thorn.Fold",
          "name": "unfixdataMutual",
          "normalized": "[(TypeQ,String,String-\u003eString,[Name])]-\u003eDecsQ",
          "package": "thorn",
          "partial": "Mutual",
          "signature": "[(TypeQ,String,String-\u003eString,[Name])]-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Fold.html#v:unfixdataMutual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe module Data.Thorn.Functor.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Thorn.Functor",
          "name": "Functor",
          "package": "thorn",
          "source": "src/Data-Thorn-Functor.html",
          "type": "module"
        },
        "index": {
          "description": "The module Data.Thorn.Functor",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "Functor",
          "package": "thorn",
          "partial": "Functor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eVariance\u003c/code\u003e is a variance of a parameter of a functor.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "Variance",
          "package": "thorn",
          "source": "src/Data-Thorn-Functor.html#Variance",
          "type": "data"
        },
        "index": {
          "description": "Variance is variance of parameter of functor",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "Variance",
          "package": "thorn",
          "partial": "Variance",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#t:Variance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCovariance, one of a normal functor.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "Co",
          "package": "thorn",
          "signature": "Co",
          "source": "src/Data-Thorn-Functor.html#Variance",
          "type": "function"
        },
        "index": {
          "description": "Covariance one of normal functor",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "Co",
          "package": "thorn",
          "partial": "Co",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:Co"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContravariance, the dual of covariance.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "Contra",
          "package": "thorn",
          "signature": "Contra",
          "source": "src/Data-Thorn-Functor.html#Variance",
          "type": "function"
        },
        "index": {
          "description": "Contravariance the dual of covariance",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "Contra",
          "package": "thorn",
          "partial": "Contra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:Contra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFixed-variance, or nonvariance, being supposed to satisfy both covariance and contravariance.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "Fixed",
          "package": "thorn",
          "signature": "Fixed",
          "source": "src/Data-Thorn-Functor.html#Variance",
          "type": "function"
        },
        "index": {
          "description": "Fixed-variance or nonvariance being supposed to satisfy both covariance and contravariance",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "Fixed",
          "package": "thorn",
          "partial": "Fixed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:Fixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFree-variance, or invariance, being supposed to satisfy either covariance or contravariance.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "Free",
          "package": "thorn",
          "signature": "Free",
          "source": "src/Data-Thorn-Functor.html#Variance",
          "type": "function"
        },
        "index": {
          "description": "Free-variance or invariance being supposed to satisfy either covariance or contravariance",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "Free",
          "package": "thorn",
          "partial": "Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:Free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofmap t\u003c/code\u003e generates an fmap of the type \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "autofmap",
          "package": "thorn",
          "signature": "TypeQ -\u003e ExpQ",
          "source": "src/Data-Thorn-Functor.html#autofmap",
          "type": "function"
        },
        "index": {
          "description": "autofmap generates an fmap of the type",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "autofmap",
          "normalized": "TypeQ-\u003eExpQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:autofmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofmapdec s t\u003c/code\u003e provides a declaration of an fmap for the type \u003ccode\u003et\u003c/code\u003e with the name \u003ccode\u003es\u003c/code\u003e, with a type signature.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "autofmapdec",
          "package": "thorn",
          "signature": "String -\u003e TypeQ -\u003e DecsQ",
          "source": "src/Data-Thorn-Functor.html#autofmapdec",
          "type": "function"
        },
        "index": {
          "description": "autofmapdec provides declaration of an fmap for the type with the name with type signature",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "autofmapdec",
          "normalized": "String-\u003eTypeQ-\u003eDecsQ",
          "package": "thorn",
          "signature": "String-\u003eTypeQ-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:autofmapdec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofmaptype t\u003c/code\u003e provides the type of \u003ccode\u003e$(\u003ccode\u003e\u003ca\u003eautofmap\u003c/a\u003e\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "autofmaptype",
          "package": "thorn",
          "signature": "TypeQ -\u003e TypeQ",
          "source": "src/Data-Thorn-Functor.html#autofmaptype",
          "type": "function"
        },
        "index": {
          "description": "autofmaptype provides the type of autofmap",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "autofmaptype",
          "normalized": "TypeQ-\u003eTypeQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eTypeQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:autofmaptype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautofunctorize t\u003c/code\u003e provides instance delcarations of the type \u003ccode\u003et\u003c/code\u003e, for the suitable functor classes : \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eBifunctor\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e. Multiple classes can be suitable for \u003ccode\u003et\u003c/code\u003e, when one of the variances of \u003ccode\u003et\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eFree\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "autofunctorize",
          "package": "thorn",
          "signature": "TypeQ -\u003e DecsQ",
          "source": "src/Data-Thorn-Functor.html#autofunctorize",
          "type": "function"
        },
        "index": {
          "description": "autofunctorize provides instance delcarations of the type for the suitable functor classes Functor Contravariant Bifunctor or Profunctor Multiple classes can be suitable for when one of the variances of is Free",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "autofunctorize",
          "normalized": "TypeQ-\u003eDecsQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:autofunctorize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eautovariance t\u003c/code\u003e provides the variances of the type \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Thorn.Functor",
          "name": "autovariance",
          "package": "thorn",
          "signature": "TypeQ -\u003e ExpQ",
          "source": "src/Data-Thorn-Functor.html#autovariance",
          "type": "function"
        },
        "index": {
          "description": "autovariance provides the variances of the type",
          "hierarchy": "Data Thorn Functor",
          "module": "Data.Thorn.Functor",
          "name": "autovariance",
          "normalized": "TypeQ-\u003eExpQ",
          "package": "thorn",
          "signature": "TypeQ-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn-Functor.html#v:autovariance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThorn, Datatype Manipulation with Template Haskell.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Thorn",
          "name": "Thorn",
          "package": "thorn",
          "source": "src/Data-Thorn.html",
          "type": "module"
        },
        "index": {
          "description": "Thorn Datatype Manipulation with Template Haskell",
          "hierarchy": "Data Thorn",
          "module": "Data.Thorn",
          "name": "Thorn",
          "package": "thorn",
          "partial": "Thorn",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/thorn/docs/Data-Thorn.html#"
      }
    }
  ]
]