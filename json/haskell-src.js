[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "haskell-src"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLexer for Haskell.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Lexer",
          "name": "Lexer",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Lexer.html",
          "type": "module"
        },
        "index": {
          "description": "Lexer for Haskell",
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Lexer",
          "package": "haskell-src",
          "partial": "Lexer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Token",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Token",
          "package": "haskell-src",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "At",
          "package": "haskell-src",
          "signature": "At",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "At",
          "package": "haskell-src",
          "partial": "At",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:At"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "BackQuote",
          "package": "haskell-src",
          "signature": "BackQuote",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "BackQuote",
          "package": "haskell-src",
          "partial": "Back Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:BackQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Backslash",
          "package": "haskell-src",
          "signature": "Backslash",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Backslash",
          "package": "haskell-src",
          "partial": "Backslash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Backslash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Bar",
          "package": "haskell-src",
          "signature": "Bar",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Bar",
          "package": "haskell-src",
          "partial": "Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Bar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Character",
          "package": "haskell-src",
          "signature": "Character Char",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Character",
          "package": "haskell-src",
          "partial": "Character",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Character"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Colon",
          "package": "haskell-src",
          "signature": "Colon",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Colon",
          "package": "haskell-src",
          "partial": "Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Colon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Comma",
          "package": "haskell-src",
          "signature": "Comma",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Comma",
          "package": "haskell-src",
          "partial": "Comma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "ConId",
          "package": "haskell-src",
          "signature": "ConId String",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "ConId",
          "package": "haskell-src",
          "partial": "Con Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:ConId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "ConSym",
          "package": "haskell-src",
          "signature": "ConSym String",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "ConSym",
          "package": "haskell-src",
          "partial": "Con Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:ConSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "DotDot",
          "package": "haskell-src",
          "signature": "DotDot",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "DotDot",
          "package": "haskell-src",
          "partial": "Dot Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:DotDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "DoubleArrow",
          "package": "haskell-src",
          "signature": "DoubleArrow",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "DoubleArrow",
          "package": "haskell-src",
          "partial": "Double Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:DoubleArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "DoubleColon",
          "package": "haskell-src",
          "signature": "DoubleColon",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "DoubleColon",
          "package": "haskell-src",
          "partial": "Double Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:DoubleColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "EOF",
          "package": "haskell-src",
          "signature": "EOF",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "EOF",
          "package": "haskell-src",
          "partial": "EOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:EOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Equals",
          "package": "haskell-src",
          "signature": "Equals",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Equals",
          "package": "haskell-src",
          "partial": "Equals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Equals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Exclamation",
          "package": "haskell-src",
          "signature": "Exclamation",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Exclamation",
          "package": "haskell-src",
          "partial": "Exclamation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Exclamation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "FloatTok",
          "package": "haskell-src",
          "signature": "FloatTok Rational",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "FloatTok",
          "package": "haskell-src",
          "partial": "Float Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:FloatTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "IntTok",
          "package": "haskell-src",
          "signature": "IntTok Integer",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "IntTok",
          "package": "haskell-src",
          "partial": "Int Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:IntTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_As",
          "package": "haskell-src",
          "signature": "KW_As",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_As",
          "package": "haskell-src",
          "partial": "KW As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_As"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Case",
          "package": "haskell-src",
          "signature": "KW_Case",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Case",
          "package": "haskell-src",
          "partial": "KW Case",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Case"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Class",
          "package": "haskell-src",
          "signature": "KW_Class",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Class",
          "package": "haskell-src",
          "partial": "KW Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Class"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Data",
          "package": "haskell-src",
          "signature": "KW_Data",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Data",
          "package": "haskell-src",
          "partial": "KW Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Data"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Default",
          "package": "haskell-src",
          "signature": "KW_Default",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Default",
          "package": "haskell-src",
          "partial": "KW Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Deriving",
          "package": "haskell-src",
          "signature": "KW_Deriving",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Deriving",
          "package": "haskell-src",
          "partial": "KW Deriving",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Deriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Do",
          "package": "haskell-src",
          "signature": "KW_Do",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Do",
          "package": "haskell-src",
          "partial": "KW Do",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Do"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Else",
          "package": "haskell-src",
          "signature": "KW_Else",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Else",
          "package": "haskell-src",
          "partial": "KW Else",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Else"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Export",
          "package": "haskell-src",
          "signature": "KW_Export",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Export",
          "package": "haskell-src",
          "partial": "KW Export",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Export"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Foreign",
          "package": "haskell-src",
          "signature": "KW_Foreign",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Foreign",
          "package": "haskell-src",
          "partial": "KW Foreign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Foreign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Hiding",
          "package": "haskell-src",
          "signature": "KW_Hiding",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Hiding",
          "package": "haskell-src",
          "partial": "KW Hiding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Hiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_If",
          "package": "haskell-src",
          "signature": "KW_If",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_If",
          "package": "haskell-src",
          "partial": "KW If",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_If"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Import",
          "package": "haskell-src",
          "signature": "KW_Import",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Import",
          "package": "haskell-src",
          "partial": "KW Import",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Import"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_In",
          "package": "haskell-src",
          "signature": "KW_In",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_In",
          "package": "haskell-src",
          "partial": "KW In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_In"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Infix",
          "package": "haskell-src",
          "signature": "KW_Infix",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Infix",
          "package": "haskell-src",
          "partial": "KW Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Infix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_InfixL",
          "package": "haskell-src",
          "signature": "KW_InfixL",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_InfixL",
          "package": "haskell-src",
          "partial": "KW Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_InfixL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_InfixR",
          "package": "haskell-src",
          "signature": "KW_InfixR",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_InfixR",
          "package": "haskell-src",
          "partial": "KW Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_InfixR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Instance",
          "package": "haskell-src",
          "signature": "KW_Instance",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Instance",
          "package": "haskell-src",
          "partial": "KW Instance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Instance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Let",
          "package": "haskell-src",
          "signature": "KW_Let",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Let",
          "package": "haskell-src",
          "partial": "KW Let",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Module",
          "package": "haskell-src",
          "signature": "KW_Module",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Module",
          "package": "haskell-src",
          "partial": "KW Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_NewType",
          "package": "haskell-src",
          "signature": "KW_NewType",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_NewType",
          "package": "haskell-src",
          "partial": "KW New Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_NewType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Of",
          "package": "haskell-src",
          "signature": "KW_Of",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Of",
          "package": "haskell-src",
          "partial": "KW Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Qualified",
          "package": "haskell-src",
          "signature": "KW_Qualified",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Qualified",
          "package": "haskell-src",
          "partial": "KW Qualified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Qualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Safe",
          "package": "haskell-src",
          "signature": "KW_Safe",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Safe",
          "package": "haskell-src",
          "partial": "KW Safe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Safe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Then",
          "package": "haskell-src",
          "signature": "KW_Then",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Then",
          "package": "haskell-src",
          "partial": "KW Then",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Then"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Type",
          "package": "haskell-src",
          "signature": "KW_Type",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Type",
          "package": "haskell-src",
          "partial": "KW Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Unsafe",
          "package": "haskell-src",
          "signature": "KW_Unsafe",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Unsafe",
          "package": "haskell-src",
          "partial": "KW Unsafe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Unsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "KW_Where",
          "package": "haskell-src",
          "signature": "KW_Where",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "KW_Where",
          "package": "haskell-src",
          "partial": "KW Where",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:KW_Where"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "LeftArrow",
          "package": "haskell-src",
          "signature": "LeftArrow",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "LeftArrow",
          "package": "haskell-src",
          "partial": "Left Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:LeftArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "LeftCurly",
          "package": "haskell-src",
          "signature": "LeftCurly",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "LeftCurly",
          "package": "haskell-src",
          "partial": "Left Curly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:LeftCurly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "LeftParen",
          "package": "haskell-src",
          "signature": "LeftParen",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "LeftParen",
          "package": "haskell-src",
          "partial": "Left Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:LeftParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "LeftSquare",
          "package": "haskell-src",
          "signature": "LeftSquare",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "LeftSquare",
          "package": "haskell-src",
          "partial": "Left Square",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:LeftSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Minus",
          "package": "haskell-src",
          "signature": "Minus",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Minus",
          "package": "haskell-src",
          "partial": "Minus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Minus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "QConId",
          "package": "haskell-src",
          "signature": "QConId (String, String)",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "QConId",
          "normalized": "QConId(String,String)",
          "package": "haskell-src",
          "partial": "QCon Id",
          "signature": "QConId(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:QConId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "QConSym",
          "package": "haskell-src",
          "signature": "QConSym (String, String)",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "QConSym",
          "normalized": "QConSym(String,String)",
          "package": "haskell-src",
          "partial": "QCon Sym",
          "signature": "QConSym(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:QConSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "QVarId",
          "package": "haskell-src",
          "signature": "QVarId (String, String)",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "QVarId",
          "normalized": "QVarId(String,String)",
          "package": "haskell-src",
          "partial": "QVar Id",
          "signature": "QVarId(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:QVarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "QVarSym",
          "package": "haskell-src",
          "signature": "QVarSym (String, String)",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "QVarSym",
          "normalized": "QVarSym(String,String)",
          "package": "haskell-src",
          "partial": "QVar Sym",
          "signature": "QVarSym(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:QVarSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "RightArrow",
          "package": "haskell-src",
          "signature": "RightArrow",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "RightArrow",
          "package": "haskell-src",
          "partial": "Right Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:RightArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "RightCurly",
          "package": "haskell-src",
          "signature": "RightCurly",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "RightCurly",
          "package": "haskell-src",
          "partial": "Right Curly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:RightCurly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "RightParen",
          "package": "haskell-src",
          "signature": "RightParen",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "RightParen",
          "package": "haskell-src",
          "partial": "Right Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:RightParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "RightSquare",
          "package": "haskell-src",
          "signature": "RightSquare",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "RightSquare",
          "package": "haskell-src",
          "partial": "Right Square",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:RightSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "SemiColon",
          "package": "haskell-src",
          "signature": "SemiColon",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "SemiColon",
          "package": "haskell-src",
          "partial": "Semi Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:SemiColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "StringTok",
          "package": "haskell-src",
          "signature": "StringTok String",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "StringTok",
          "package": "haskell-src",
          "partial": "String Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:StringTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Tilde",
          "package": "haskell-src",
          "signature": "Tilde",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Tilde",
          "package": "haskell-src",
          "partial": "Tilde",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Tilde"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "Underscore",
          "package": "haskell-src",
          "signature": "Underscore",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "Underscore",
          "package": "haskell-src",
          "partial": "Underscore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:Underscore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "VRightCurly",
          "package": "haskell-src",
          "signature": "VRightCurly",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "VRightCurly",
          "package": "haskell-src",
          "partial": "VRight Curly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:VRightCurly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "VarId",
          "package": "haskell-src",
          "signature": "VarId String",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "VarId",
          "package": "haskell-src",
          "partial": "Var Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:VarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "VarSym",
          "package": "haskell-src",
          "signature": "VarSym String",
          "source": "src/Language-Haskell-Lexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "VarSym",
          "package": "haskell-src",
          "partial": "Var Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:VarSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Lexer",
          "name": "lexer",
          "package": "haskell-src",
          "signature": "(Token -\u003e P a) -\u003e P a",
          "source": "src/Language-Haskell-Lexer.html#lexer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Lexer",
          "module": "Language.Haskell.Lexer",
          "name": "lexer",
          "normalized": "(Token-\u003eP a)-\u003eP a",
          "package": "haskell-src",
          "signature": "(Token-\u003eP a)-\u003eP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Lexer.html#v:lexer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMonads for the Haskell parser and lexer.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseMonad",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html",
          "type": "module"
        },
        "index": {
          "description": "Monads for the Haskell parser and lexer",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseMonad",
          "package": "haskell-src",
          "partial": "Parse Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "Lex",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html#Lex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "Lex",
          "package": "haskell-src",
          "partial": "Lex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#t:Lex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "LexContext",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html#LexContext",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "LexContext",
          "package": "haskell-src",
          "partial": "Lex Context",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#t:LexContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonad for parsing\n\u003c/p\u003e",
          "module": "Language.Haskell.ParseMonad",
          "name": "P",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html#P",
          "type": "data"
        },
        "index": {
          "description": "Monad for parsing",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "P",
          "package": "haskell-src",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatic parameters governing a parse.\n More to come later, e.g. literate mode, language extensions.\n\u003c/p\u003e",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseMode",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html#ParseMode",
          "type": "data"
        },
        "index": {
          "description": "Static parameters governing parse More to come later e.g literate mode language extensions",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseMode",
          "package": "haskell-src",
          "partial": "Parse Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#t:ParseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of a parse.\n\u003c/p\u003e",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseResult",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html#ParseResult",
          "type": "data"
        },
        "index": {
          "description": "The result of parse",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseResult",
          "package": "haskell-src",
          "partial": "Parse Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "Layout",
          "package": "haskell-src",
          "signature": "Layout Int",
          "source": "src/Language-Haskell-ParseMonad.html#LexContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "Layout",
          "package": "haskell-src",
          "partial": "Layout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:Layout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "NoLayout",
          "package": "haskell-src",
          "signature": "NoLayout",
          "source": "src/Language-Haskell-ParseMonad.html#LexContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "NoLayout",
          "package": "haskell-src",
          "partial": "No Layout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:NoLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parse failed at the specified\n source location, with an error message.\n\u003c/p\u003e",
          "module": "[\"Language.Haskell.ParseMonad\",\"Language.Haskell.Parser\"]",
          "name": "ParseFailed",
          "package": "haskell-src",
          "signature": "ParseFailed SrcLoc String",
          "source": "src/Language-Haskell-ParseMonad.html#ParseResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:ParseFailed\",\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#v:ParseFailed\"]"
        },
        "index": {
          "description": "The parse failed at the specified source location with an error message",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseFailed",
          "package": "haskell-src",
          "partial": "Parse Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:ParseFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.ParseMonad\",\"Language.Haskell.Parser\"]",
          "name": "ParseMode",
          "package": "haskell-src",
          "signature": "ParseMode",
          "source": "src/Language-Haskell-ParseMonad.html#ParseMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:ParseMode\",\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#v:ParseMode\"]"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseMode",
          "package": "haskell-src",
          "partial": "Parse Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:ParseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parse succeeded, yielding a value.\n\u003c/p\u003e",
          "module": "[\"Language.Haskell.ParseMonad\",\"Language.Haskell.Parser\"]",
          "name": "ParseOk",
          "package": "haskell-src",
          "signature": "ParseOk a",
          "source": "src/Language-Haskell-ParseMonad.html#ParseResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:ParseOk\",\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#v:ParseOk\"]"
        },
        "index": {
          "description": "The parse succeeded yielding value",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "ParseOk",
          "package": "haskell-src",
          "partial": "Parse Ok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:ParseOk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "alternative",
          "package": "haskell-src",
          "signature": "Lex a v -\u003e Lex a (Lex a v)",
          "source": "src/Language-Haskell-ParseMonad.html#alternative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "alternative",
          "normalized": "Lex a b-\u003eLex a(Lex a b)",
          "package": "haskell-src",
          "signature": "Lex a v-\u003eLex a(Lex a v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:alternative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "atSrcLoc",
          "package": "haskell-src",
          "signature": "P a -\u003e SrcLoc -\u003e P a",
          "source": "src/Language-Haskell-ParseMonad.html#atSrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "atSrcLoc",
          "normalized": "P a-\u003eSrcLoc-\u003eP a",
          "package": "haskell-src",
          "partial": "Src Loc",
          "signature": "P a-\u003eSrcLoc-\u003eP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:atSrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "checkBOL",
          "package": "haskell-src",
          "signature": "Lex a Bool",
          "source": "src/Language-Haskell-ParseMonad.html#checkBOL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "checkBOL",
          "package": "haskell-src",
          "partial": "BOL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:checkBOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault parameters for a parse,\n currently just a marker for an unknown filename.\n\u003c/p\u003e",
          "module": "[\"Language.Haskell.ParseMonad\",\"Language.Haskell.Parser\"]",
          "name": "defaultParseMode",
          "package": "haskell-src",
          "signature": "ParseMode",
          "source": "src/Language-Haskell-ParseMonad.html#defaultParseMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:defaultParseMode\",\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#v:defaultParseMode\"]"
        },
        "index": {
          "description": "Default parameters for parse currently just marker for an unknown filename",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "defaultParseMode",
          "package": "haskell-src",
          "partial": "Parse Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:defaultParseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscard some input characters (these must not include tabs or newlines).\n\u003c/p\u003e",
          "module": "Language.Haskell.ParseMonad",
          "name": "discard",
          "package": "haskell-src",
          "signature": "Int -\u003e Lex r ()",
          "source": "src/Language-Haskell-ParseMonad.html#discard",
          "type": "function"
        },
        "index": {
          "description": "Discard some input characters these must not include tabs or newlines",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "discard",
          "normalized": "Int-\u003eLex a()",
          "package": "haskell-src",
          "signature": "Int-\u003eLex r()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:discard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "getInput",
          "package": "haskell-src",
          "signature": "Lex r String",
          "source": "src/Language-Haskell-ParseMonad.html#getInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "getInput",
          "package": "haskell-src",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:getInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "getOffside",
          "package": "haskell-src",
          "signature": "Lex a Ordering",
          "source": "src/Language-Haskell-ParseMonad.html#getOffside",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "getOffside",
          "package": "haskell-src",
          "partial": "Offside",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:getOffside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "getSrcLoc",
          "package": "haskell-src",
          "signature": "P SrcLoc",
          "source": "src/Language-Haskell-ParseMonad.html#getSrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "getSrcLoc",
          "package": "haskell-src",
          "partial": "Src Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:getSrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscard the next character, which must be a newline.\n\u003c/p\u003e",
          "module": "Language.Haskell.ParseMonad",
          "name": "lexNewline",
          "package": "haskell-src",
          "signature": "Lex a ()",
          "source": "src/Language-Haskell-ParseMonad.html#lexNewline",
          "type": "function"
        },
        "index": {
          "description": "Discard the next character which must be newline",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "lexNewline",
          "normalized": "Lex a()",
          "package": "haskell-src",
          "partial": "Newline",
          "signature": "Lex a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:lexNewline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscard the next character, which must be a tab.\n\u003c/p\u003e",
          "module": "Language.Haskell.ParseMonad",
          "name": "lexTab",
          "package": "haskell-src",
          "signature": "Lex a ()",
          "source": "src/Language-Haskell-ParseMonad.html#lexTab",
          "type": "function"
        },
        "index": {
          "description": "Discard the next character which must be tab",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "lexTab",
          "normalized": "Lex a()",
          "package": "haskell-src",
          "partial": "Tab",
          "signature": "Lex a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:lexTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "lexWhile",
          "package": "haskell-src",
          "signature": "(Char -\u003e Bool) -\u003e Lex a String",
          "source": "src/Language-Haskell-ParseMonad.html#lexWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "lexWhile",
          "normalized": "(Char-\u003eBool)-\u003eLex a String",
          "package": "haskell-src",
          "partial": "While",
          "signature": "(Char-\u003eBool)-\u003eLex a String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:lexWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoriginal name of the file being parsed\n\u003c/p\u003e",
          "module": "[\"Language.Haskell.ParseMonad\",\"Language.Haskell.Parser\"]",
          "name": "parseFilename",
          "package": "haskell-src",
          "signature": "String",
          "source": "src/Language-Haskell-ParseMonad.html#ParseMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:parseFilename\",\"http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#v:parseFilename\"]"
        },
        "index": {
          "description": "original name of the file being parsed",
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "parseFilename",
          "package": "haskell-src",
          "partial": "Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:parseFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "popContext",
          "package": "haskell-src",
          "signature": "P ()",
          "source": "src/Language-Haskell-ParseMonad.html#popContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "popContext",
          "normalized": "P()",
          "package": "haskell-src",
          "partial": "Context",
          "signature": "P()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:popContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "popContextL",
          "package": "haskell-src",
          "signature": "String -\u003e Lex a ()",
          "source": "src/Language-Haskell-ParseMonad.html#popContextL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "popContextL",
          "normalized": "String-\u003eLex a()",
          "package": "haskell-src",
          "partial": "Context",
          "signature": "String-\u003eLex a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:popContextL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "pushContextL",
          "package": "haskell-src",
          "signature": "LexContext -\u003e Lex a ()",
          "source": "src/Language-Haskell-ParseMonad.html#pushContextL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "pushContextL",
          "normalized": "LexContext-\u003eLex a()",
          "package": "haskell-src",
          "partial": "Context",
          "signature": "LexContext-\u003eLex a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:pushContextL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "pushCurrentContext",
          "package": "haskell-src",
          "signature": "P ()",
          "source": "src/Language-Haskell-ParseMonad.html#pushCurrentContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "pushCurrentContext",
          "normalized": "P()",
          "package": "haskell-src",
          "partial": "Current Context",
          "signature": "P()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:pushCurrentContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "runParser",
          "package": "haskell-src",
          "signature": "P a -\u003e String -\u003e ParseResult a",
          "source": "src/Language-Haskell-ParseMonad.html#runParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "runParser",
          "normalized": "P a-\u003eString-\u003eParseResult a",
          "package": "haskell-src",
          "partial": "Parser",
          "signature": "P a-\u003eString-\u003eParseResult a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:runParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "runParserWithMode",
          "package": "haskell-src",
          "signature": "ParseMode -\u003e P a -\u003e String -\u003e ParseResult a",
          "source": "src/Language-Haskell-ParseMonad.html#runParserWithMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "runParserWithMode",
          "normalized": "ParseMode-\u003eP a-\u003eString-\u003eParseResult a",
          "package": "haskell-src",
          "partial": "Parser With Mode",
          "signature": "ParseMode-\u003eP a-\u003eString-\u003eParseResult a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:runParserWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "setBOL",
          "package": "haskell-src",
          "signature": "Lex a ()",
          "source": "src/Language-Haskell-ParseMonad.html#setBOL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "setBOL",
          "normalized": "Lex a()",
          "package": "haskell-src",
          "partial": "BOL",
          "signature": "Lex a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:setBOL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseMonad",
          "name": "startToken",
          "package": "haskell-src",
          "signature": "Lex a ()",
          "source": "src/Language-Haskell-ParseMonad.html#startToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseMonad",
          "module": "Language.Haskell.ParseMonad",
          "name": "startToken",
          "normalized": "Lex a()",
          "package": "haskell-src",
          "partial": "Token",
          "signature": "Lex a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseMonad.html#v:startToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for the Haskell parser.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.ParseUtils",
          "name": "ParseUtils",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseUtils.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for the Haskell parser",
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "ParseUtils",
          "package": "haskell-src",
          "partial": "Parse Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkAssertion",
          "package": "haskell-src",
          "signature": "HsType -\u003e P HsAsst",
          "source": "src/Language-Haskell-ParseUtils.html#checkAssertion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkAssertion",
          "normalized": "HsType-\u003eP HsAsst",
          "package": "haskell-src",
          "partial": "Assertion",
          "signature": "HsType-\u003eP HsAsst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkAssertion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkClassBody",
          "package": "haskell-src",
          "signature": "[HsDecl] -\u003e P [HsDecl]",
          "source": "src/Language-Haskell-ParseUtils.html#checkClassBody",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkClassBody",
          "normalized": "[HsDecl]-\u003eP[HsDecl]",
          "package": "haskell-src",
          "partial": "Class Body",
          "signature": "[HsDecl]-\u003eP[HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkClassBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkClassHeader",
          "package": "haskell-src",
          "signature": "HsQualType -\u003e P (HsContext, HsName, [HsName])",
          "source": "src/Language-Haskell-ParseUtils.html#checkClassHeader",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkClassHeader",
          "normalized": "HsQualType-\u003eP(HsContext,HsName,[HsName])",
          "package": "haskell-src",
          "partial": "Class Header",
          "signature": "HsQualType-\u003eP(HsContext,HsName,[HsName])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkClassHeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkContext",
          "package": "haskell-src",
          "signature": "HsType -\u003e P HsContext",
          "source": "src/Language-Haskell-ParseUtils.html#checkContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkContext",
          "normalized": "HsType-\u003eP HsContext",
          "package": "haskell-src",
          "partial": "Context",
          "signature": "HsType-\u003eP HsContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkDataHeader",
          "package": "haskell-src",
          "signature": "HsQualType -\u003e P (HsContext, HsName, [HsName])",
          "source": "src/Language-Haskell-ParseUtils.html#checkDataHeader",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkDataHeader",
          "normalized": "HsQualType-\u003eP(HsContext,HsName,[HsName])",
          "package": "haskell-src",
          "partial": "Data Header",
          "signature": "HsQualType-\u003eP(HsContext,HsName,[HsName])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkDataHeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkExpr",
          "package": "haskell-src",
          "signature": "HsExp -\u003e P HsExp",
          "source": "src/Language-Haskell-ParseUtils.html#checkExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkExpr",
          "normalized": "HsExp-\u003eP HsExp",
          "package": "haskell-src",
          "partial": "Expr",
          "signature": "HsExp-\u003eP HsExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkInstHeader",
          "package": "haskell-src",
          "signature": "HsQualType -\u003e P (HsContext, HsQName, [HsType])",
          "source": "src/Language-Haskell-ParseUtils.html#checkInstHeader",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkInstHeader",
          "normalized": "HsQualType-\u003eP(HsContext,HsQName,[HsType])",
          "package": "haskell-src",
          "partial": "Inst Header",
          "signature": "HsQualType-\u003eP(HsContext,HsQName,[HsType])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkInstHeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkPattern",
          "package": "haskell-src",
          "signature": "HsExp -\u003e P HsPat",
          "source": "src/Language-Haskell-ParseUtils.html#checkPattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkPattern",
          "normalized": "HsExp-\u003eP HsPat",
          "package": "haskell-src",
          "partial": "Pattern",
          "signature": "HsExp-\u003eP HsPat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkPattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkPrec",
          "package": "haskell-src",
          "signature": "Integer -\u003e P Int",
          "source": "src/Language-Haskell-ParseUtils.html#checkPrec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkPrec",
          "normalized": "Integer-\u003eP Int",
          "package": "haskell-src",
          "partial": "Prec",
          "signature": "Integer-\u003eP Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkRevDecls",
          "package": "haskell-src",
          "signature": "[HsDecl] -\u003e P [HsDecl]",
          "source": "src/Language-Haskell-ParseUtils.html#checkRevDecls",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkRevDecls",
          "normalized": "[HsDecl]-\u003eP[HsDecl]",
          "package": "haskell-src",
          "partial": "Rev Decls",
          "signature": "[HsDecl]-\u003eP[HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkRevDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkUnQual",
          "package": "haskell-src",
          "signature": "HsQName -\u003e P HsName",
          "source": "src/Language-Haskell-ParseUtils.html#checkUnQual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkUnQual",
          "normalized": "HsQName-\u003eP HsName",
          "package": "haskell-src",
          "partial": "Un Qual",
          "signature": "HsQName-\u003eP HsName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkUnQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "checkValDef",
          "package": "haskell-src",
          "signature": "SrcLoc -\u003e HsExp -\u003e HsRhs -\u003e [HsDecl] -\u003e P HsDecl",
          "source": "src/Language-Haskell-ParseUtils.html#checkValDef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "checkValDef",
          "normalized": "SrcLoc-\u003eHsExp-\u003eHsRhs-\u003e[HsDecl]-\u003eP HsDecl",
          "package": "haskell-src",
          "partial": "Val Def",
          "signature": "SrcLoc-\u003eHsExp-\u003eHsRhs-\u003e[HsDecl]-\u003eP HsDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:checkValDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "mkRecConstrOrUpdate",
          "package": "haskell-src",
          "signature": "HsExp -\u003e [HsFieldUpdate] -\u003e P HsExp",
          "source": "src/Language-Haskell-ParseUtils.html#mkRecConstrOrUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "mkRecConstrOrUpdate",
          "normalized": "HsExp-\u003e[HsFieldUpdate]-\u003eP HsExp",
          "package": "haskell-src",
          "partial": "Rec Constr Or Update",
          "signature": "HsExp-\u003e[HsFieldUpdate]-\u003eP HsExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:mkRecConstrOrUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.ParseUtils",
          "name": "splitTyConApp",
          "package": "haskell-src",
          "signature": "HsType -\u003e P (HsName, [HsType])",
          "source": "src/Language-Haskell-ParseUtils.html#splitTyConApp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell ParseUtils",
          "module": "Language.Haskell.ParseUtils",
          "name": "splitTyConApp",
          "normalized": "HsType-\u003eP(HsName,[HsType])",
          "package": "haskell-src",
          "partial": "Ty Con App",
          "signature": "HsType-\u003eP(HsName,[HsType])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-ParseUtils.html#v:splitTyConApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell parser.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Parser",
          "name": "Parser",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell parser",
          "hierarchy": "Language Haskell Parser",
          "module": "Language.Haskell.Parser",
          "name": "Parser",
          "package": "haskell-src",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatic parameters governing a parse.\n More to come later, e.g. literate mode, language extensions.\n\u003c/p\u003e",
          "module": "Language.Haskell.Parser",
          "name": "ParseMode",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html#ParseMode",
          "type": "data"
        },
        "index": {
          "description": "Static parameters governing parse More to come later e.g literate mode language extensions",
          "hierarchy": "Language Haskell Parser",
          "module": "Language.Haskell.Parser",
          "name": "ParseMode",
          "package": "haskell-src",
          "partial": "Parse Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#t:ParseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of a parse.\n\u003c/p\u003e",
          "module": "Language.Haskell.Parser",
          "name": "ParseResult",
          "package": "haskell-src",
          "source": "src/Language-Haskell-ParseMonad.html#ParseResult",
          "type": "data"
        },
        "index": {
          "description": "The result of parse",
          "hierarchy": "Language Haskell Parser",
          "module": "Language.Haskell.Parser",
          "name": "ParseResult",
          "package": "haskell-src",
          "partial": "Parse Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string, which should contain a complete Haskell 98 module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Parser",
          "name": "parseModule",
          "package": "haskell-src",
          "signature": "String -\u003e ParseResult HsModule",
          "source": "src/Language-Haskell-Parser.html#parseModule",
          "type": "function"
        },
        "index": {
          "description": "Parse of string which should contain complete Haskell module",
          "hierarchy": "Language Haskell Parser",
          "module": "Language.Haskell.Parser",
          "name": "parseModule",
          "normalized": "String-\u003eParseResult HsModule",
          "package": "haskell-src",
          "partial": "Module",
          "signature": "String-\u003eParseResult HsModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#v:parseModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string, which should contain a complete Haskell 98 module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Parser",
          "name": "parseModuleWithMode",
          "package": "haskell-src",
          "signature": "ParseMode -\u003e String -\u003e ParseResult HsModule",
          "source": "src/Language-Haskell-Parser.html#parseModuleWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string which should contain complete Haskell module",
          "hierarchy": "Language Haskell Parser",
          "module": "Language.Haskell.Parser",
          "name": "parseModuleWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult HsModule",
          "package": "haskell-src",
          "partial": "Module With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult HsModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Parser.html#v:parseModuleWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePretty printer for Haskell.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "Pretty",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Pretty.html",
          "type": "module"
        },
        "index": {
          "description": "Pretty printer for Haskell",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "Pretty",
          "package": "haskell-src",
          "partial": "Pretty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Pretty",
          "name": "Indent",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Pretty.html#Indent",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "Indent",
          "package": "haskell-src",
          "partial": "Indent",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#t:Indent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRendering mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "Mode",
          "package": "haskell-src",
          "type": "data"
        },
        "index": {
          "description": "Rendering mode",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "Mode",
          "package": "haskell-src",
          "partial": "Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#t:Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty-printing parameters.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e the \u003ccode\u003e\u003ca\u003eonsideIndent\u003c/a\u003e\u003c/code\u003e must be positive and less than all other indents.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "data"
        },
        "index": {
          "description": "Pretty-printing parameters Note the onsideIndent must be positive and less than all other indents",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src",
          "partial": "PPHs Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#t:PPHsMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVarieties of layout we can use.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "PPLayout",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Pretty.html#PPLayout",
          "type": "data"
        },
        "index": {
          "description": "Varieties of layout we can use",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PPLayout",
          "package": "haskell-src",
          "partial": "PPLayout",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#t:PPLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThings that can be pretty-printed, including all the syntactic objects\n in \u003ca\u003eLanguage.Haskell.Syntax\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "Pretty",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Pretty.html#Pretty",
          "type": "class"
        },
        "index": {
          "description": "Things that can be pretty-printed including all the syntactic objects in Language.Haskell.Syntax",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "Pretty",
          "package": "haskell-src",
          "partial": "Pretty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#t:Pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rendering style.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "Style",
          "package": "haskell-src",
          "type": "data"
        },
        "index": {
          "description": "rendering style",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "Style",
          "package": "haskell-src",
          "partial": "Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#t:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo indentation, infinitely long lines\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "LeftMode",
          "package": "haskell-src",
          "signature": "LeftMode",
          "type": "function"
        },
        "index": {
          "description": "No indentation infinitely long lines",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "LeftMode",
          "package": "haskell-src",
          "partial": "Left Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:LeftMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll on one line\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "OneLineMode",
          "package": "haskell-src",
          "signature": "OneLineMode",
          "type": "function"
        },
        "index": {
          "description": "All on one line",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "OneLineMode",
          "package": "haskell-src",
          "partial": "One Line Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:OneLineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src",
          "signature": "PPHsMode",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src",
          "partial": "PPHs Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:PPHsMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einline decls, with newlines between them\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "PPInLine",
          "package": "haskell-src",
          "signature": "PPInLine",
          "source": "src/Language-Haskell-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "inline decls with newlines between them",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PPInLine",
          "package": "haskell-src",
          "partial": "PPIn Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:PPInLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeverything on a single line\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "PPNoLayout",
          "package": "haskell-src",
          "signature": "PPNoLayout",
          "source": "src/Language-Haskell-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "everything on single line",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PPNoLayout",
          "package": "haskell-src",
          "partial": "PPNo Layout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:PPNoLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclassical layout\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "PPOffsideRule",
          "package": "haskell-src",
          "signature": "PPOffsideRule",
          "source": "src/Language-Haskell-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "classical layout",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PPOffsideRule",
          "package": "haskell-src",
          "partial": "PPOffside Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:PPOffsideRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclassical layout made explicit\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "PPSemiColon",
          "package": "haskell-src",
          "signature": "PPSemiColon",
          "source": "src/Language-Haskell-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "classical layout made explicit",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PPSemiColon",
          "package": "haskell-src",
          "partial": "PPSemi Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:PPSemiColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "PageMode",
          "package": "haskell-src",
          "signature": "PageMode",
          "type": "function"
        },
        "index": {
          "description": "Normal",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "PageMode",
          "package": "haskell-src",
          "partial": "Page Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:PageMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Pretty",
          "name": "Style",
          "package": "haskell-src",
          "signature": "Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "Style",
          "package": "haskell-src",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWith zig-zag cuts\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "ZigZagMode",
          "package": "haskell-src",
          "signature": "ZigZagMode",
          "type": "function"
        },
        "index": {
          "description": "With zig-zag cuts",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "ZigZagMode",
          "package": "haskell-src",
          "partial": "Zig Zag Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:ZigZagMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of the body of a\n \u003ccode\u003ecase\u003c/code\u003e expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "caseIndent",
          "package": "haskell-src",
          "signature": "Indent",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of the body of case expression",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "caseIndent",
          "package": "haskell-src",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:caseIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of a class or instance\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "classIndent",
          "package": "haskell-src",
          "signature": "Indent",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of class or instance",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "classIndent",
          "package": "haskell-src",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:classIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enot implemented yet\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "comments",
          "package": "haskell-src",
          "signature": "Bool",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "not implemented yet",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "comments",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:comments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default mode: pretty-print using the offside rule and sensible\n defaults.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "defaultMode",
          "package": "haskell-src",
          "signature": "PPHsMode",
          "source": "src/Language-Haskell-Pretty.html#defaultMode",
          "type": "function"
        },
        "index": {
          "description": "The default mode pretty-print using the offside rule and sensible defaults",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "defaultMode",
          "package": "haskell-src",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:defaultMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of a \u003ccode\u003edo\u003c/code\u003e-expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "doIndent",
          "package": "haskell-src",
          "signature": "Indent",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of do expression",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "doIndent",
          "package": "haskell-src",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:doIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty-printing style to use\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "layout",
          "package": "haskell-src",
          "signature": "PPLayout",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "Pretty-printing style to use",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "layout",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:layout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of the declarations in a\n \u003ccode\u003elet\u003c/code\u003e expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "letIndent",
          "package": "haskell-src",
          "signature": "Indent",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of the declarations in let expression",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "letIndent",
          "package": "haskell-src",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:letIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLength of line, in chars\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "lineLength",
          "package": "haskell-src",
          "signature": "Int",
          "type": "function"
        },
        "index": {
          "description": "Length of line in chars",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "lineLength",
          "package": "haskell-src",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:lineLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd GHC-style \u003ccode\u003eLINE\u003c/code\u003e pragmas to output?\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "linePragmas",
          "package": "haskell-src",
          "signature": "Bool",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "add GHC-style LINE pragmas to output",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "linePragmas",
          "package": "haskell-src",
          "partial": "Pragmas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:linePragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rendering mode\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "mode",
          "package": "haskell-src",
          "signature": "Mode",
          "type": "function"
        },
        "index": {
          "description": "The rendering mode",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "mode",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation added for continuation\n lines that would otherwise be offside\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "onsideIndent",
          "package": "haskell-src",
          "signature": "Indent",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation added for continuation lines that would otherwise be offside",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "onsideIndent",
          "package": "haskell-src",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:onsideIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epretty-print with the default style and \u003ccode\u003e\u003ca\u003edefaultMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "prettyPrint",
          "package": "haskell-src",
          "signature": "a -\u003e String",
          "source": "src/Language-Haskell-Pretty.html#prettyPrint",
          "type": "function"
        },
        "index": {
          "description": "pretty-print with the default style and defaultMode",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "prettyPrint",
          "normalized": "a-\u003eString",
          "package": "haskell-src",
          "partial": "Print",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:prettyPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epretty-print with a given style and mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "prettyPrintStyleMode",
          "package": "haskell-src",
          "signature": "Style -\u003e PPHsMode -\u003e a -\u003e String",
          "source": "src/Language-Haskell-Pretty.html#prettyPrintStyleMode",
          "type": "function"
        },
        "index": {
          "description": "pretty-print with given style and mode",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "prettyPrintStyleMode",
          "normalized": "Style-\u003ePPHsMode-\u003ea-\u003eString",
          "package": "haskell-src",
          "partial": "Print Style Mode",
          "signature": "Style-\u003ePPHsMode-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:prettyPrintStyleMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epretty-print with the default style and a given mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "prettyPrintWithMode",
          "package": "haskell-src",
          "signature": "PPHsMode -\u003e a -\u003e String",
          "source": "src/Language-Haskell-Pretty.html#prettyPrintWithMode",
          "type": "function"
        },
        "index": {
          "description": "pretty-print with the default style and given mode",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "prettyPrintWithMode",
          "normalized": "PPHsMode-\u003ea-\u003eString",
          "package": "haskell-src",
          "partial": "Print With Mode",
          "signature": "PPHsMode-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:prettyPrintWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRatio of ribbon length to line length\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "ribbonsPerLine",
          "package": "haskell-src",
          "signature": "Float",
          "type": "function"
        },
        "index": {
          "description": "Ratio of ribbon length to line length",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "ribbonsPerLine",
          "package": "haskell-src",
          "partial": "Per Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:ribbonsPerLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblank lines between statements?\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "spacing",
          "package": "haskell-src",
          "signature": "Bool",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "blank lines between statements",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "spacing",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:spacing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default style (\u003ccode\u003emode=PageMode, lineLength=100, ribbonsPerLine=1.5\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "style",
          "package": "haskell-src",
          "signature": "Style",
          "type": "function"
        },
        "index": {
          "description": "The default style mode PageMode lineLength ribbonsPerLine",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "style",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of the declarations in a\n \u003ccode\u003ewhere\u003c/code\u003e clause\n\u003c/p\u003e",
          "module": "Language.Haskell.Pretty",
          "name": "whereIndent",
          "package": "haskell-src",
          "signature": "Indent",
          "source": "src/Language-Haskell-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of the declarations in where clause",
          "hierarchy": "Language Haskell Pretty",
          "module": "Language.Haskell.Pretty",
          "name": "whereIndent",
          "package": "haskell-src",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Pretty.html#v:whereIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA suite of datatypes describing the abstract syntax of Haskell 98\n \u003ca\u003ehttp://www.haskell.org/onlinereport/\u003c/a\u003e plus a few extensions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e multi-parameter type classes\n\u003c/li\u003e\u003cli\u003e parameters of type class assertions are unrestricted\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis module has been changed so that show is a real show.\n For GHC, we also derive Typeable and Data for all types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "Syntax",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html",
          "type": "module"
        },
        "index": {
          "description": "suite of datatypes describing the abstract syntax of Haskell http www.haskell.org onlinereport plus few extensions multi-parameter type classes parameters of type class assertions are unrestricted This module has been changed so that show is real show For GHC we also derive Typeable and Data for all types",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "Syntax",
          "package": "haskell-src",
          "partial": "Syntax",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003ealt\u003c/em\u003e in a \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsAlt",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsAlt",
          "type": "data"
        },
        "index": {
          "description": "An alt in case expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAlt",
          "package": "haskell-src",
          "partial": "Hs Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssociativity of an operator.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssoc",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsAssoc",
          "type": "data"
        },
        "index": {
          "description": "Associativity of an operator",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssoc",
          "package": "haskell-src",
          "partial": "Hs Assoc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass assertions.\n   In Haskell 98, the argument would be a \u003cem\u003etyvar\u003c/em\u003e, but this definition\n   allows multiple parameters, and allows them to be \u003cem\u003etype\u003c/em\u003es.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsAsst",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsAsst",
          "type": "type"
        },
        "index": {
          "description": "Class assertions In Haskell the argument would be tyvar but this definition allows multiple parameters and allows them to be type",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAsst",
          "package": "haskell-src",
          "partial": "Hs Asst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsAsst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a constructor argument or field, optionally including\n a strictness annotation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsBangType",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsBangType",
          "type": "data"
        },
        "index": {
          "description": "The type of constructor argument or field optionally including strictness annotation",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsBangType",
          "package": "haskell-src",
          "partial": "Hs Bang Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsBangType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA name (\u003cem\u003ecname\u003c/em\u003e) of a component of a class or data type in an \u003ccode\u003eimport\u003c/code\u003e\n or export specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsCName",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsCName",
          "type": "data"
        },
        "index": {
          "description": "name cname of component of class or data type in an import or export specification",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsCName",
          "package": "haskell-src",
          "partial": "Hs CName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsCName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclaration of a data constructor.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsConDecl",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsConDecl",
          "type": "data"
        },
        "index": {
          "description": "Declaration of data constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsConDecl",
          "package": "haskell-src",
          "partial": "Hs Con Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsContext",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsContext",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsContext",
          "package": "haskell-src",
          "partial": "Hs Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsDecl",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsDecl",
          "package": "haskell-src",
          "partial": "Hs Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell expressions.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNotes:\u003c/em\u003e\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Because it is difficult for parsers to distinguish patterns from\n   expressions, they typically parse them in the same way and then check\n   that they have the appropriate form.  Hence the expression type\n   includes some forms that are found only in patterns.  After these\n   checks, these constructors should not be used.\n\u003c/li\u003e\u003cli\u003e The parser does not take precedence and associativity into account,\n   so it will leave \u003ccode\u003e\u003ca\u003eHsInfixApp\u003c/a\u003e\u003c/code\u003es associated to the left.\n\u003c/li\u003e\u003cli\u003e The \u003ccode\u003e\u003ca\u003ePretty\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003e\u003ca\u003eHsExp\u003c/a\u003e\u003c/code\u003e does not\n   add parentheses in printing.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsExp",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "data"
        },
        "index": {
          "description": "Haskell expressions Notes Because it is difficult for parsers to distinguish patterns from expressions they typically parse them in the same way and then check that they have the appropriate form Hence the expression type includes some forms that are found only in patterns After these checks these constructors should not be used The parser does not take precedence and associativity into account so it will leave HsInfixApp associated to the left The Pretty instance for HsExp does not add parentheses in printing",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsExp",
          "package": "haskell-src",
          "partial": "Hs Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExport specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsExportSpec",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsExportSpec",
          "type": "data"
        },
        "index": {
          "description": "Export specification",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsExportSpec",
          "package": "haskell-src",
          "partial": "Hs Export Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsExportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003efbind\u003c/em\u003e in a labeled record construction or update expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsFieldUpdate",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsFieldUpdate",
          "type": "data"
        },
        "index": {
          "description": "An fbind in labeled record construction or update expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsFieldUpdate",
          "package": "haskell-src",
          "partial": "Hs Field Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsFieldUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA guarded alternative \u003ccode\u003e|\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e.\n The first expression will be Boolean-valued.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlt",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsGuardedAlt",
          "type": "data"
        },
        "index": {
          "description": "guarded alternative exp exp The first expression will be Boolean-valued",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlt",
          "package": "haskell-src",
          "partial": "Hs Guarded Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsGuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlts",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsGuardedAlts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlts",
          "package": "haskell-src",
          "partial": "Hs Guarded Alts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsGuardedAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA guarded right hand side \u003ccode\u003e|\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e=\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e.\n The first expression will be Boolean-valued.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedRhs",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsGuardedRhs",
          "type": "data"
        },
        "index": {
          "description": "guarded right hand side exp exp The first expression will be Boolean-valued",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedRhs",
          "package": "haskell-src",
          "partial": "Hs Guarded Rhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsGuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImport declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsImportDecl",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsImportDecl",
          "type": "data"
        },
        "index": {
          "description": "Import declaration",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsImportDecl",
          "package": "haskell-src",
          "partial": "Hs Import Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsImportDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImport specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsImportSpec",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsImportSpec",
          "type": "data"
        },
        "index": {
          "description": "Import specification",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsImportSpec",
          "package": "haskell-src",
          "partial": "Hs Import Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsImportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eliteral\u003c/em\u003e.\n Values of this type hold the abstract value of the literal, not the\n precise string representation used.  For example, \u003ccode\u003e10\u003c/code\u003e, \u003ccode\u003e0o12\u003c/code\u003e and \u003ccode\u003e0xa\u003c/code\u003e\n have the same representation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsLiteral",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "data"
        },
        "index": {
          "description": "literal Values of this type hold the abstract value of the literal not the precise string representation used For example o12 and xa have the same representation",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsLiteral",
          "package": "haskell-src",
          "partial": "Hs Literal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClauses of a function binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsMatch",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsMatch",
          "type": "data"
        },
        "index": {
          "description": "Clauses of function binding",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsMatch",
          "package": "haskell-src",
          "partial": "Hs Match",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Haskell source module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsModule",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsModule",
          "type": "data"
        },
        "index": {
          "description": "Haskell source module",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsModule",
          "package": "haskell-src",
          "partial": "Hs Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used to represent variables, and also constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsName",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsName",
          "type": "data"
        },
        "index": {
          "description": "This type is used to represent variables and also constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsName",
          "package": "haskell-src",
          "partial": "Hs Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperators, appearing in \u003ccode\u003einfix\u003c/code\u003e declarations.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsOp",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsOp",
          "type": "data"
        },
        "index": {
          "description": "Operators appearing in infix declarations",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsOp",
          "package": "haskell-src",
          "partial": "Hs Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern, to be matched against a value.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPat",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "data"
        },
        "index": {
          "description": "pattern to be matched against value",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPat",
          "package": "haskell-src",
          "partial": "Hs Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003efpat\u003c/em\u003e in a labeled record pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPatField",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsPatField",
          "type": "data"
        },
        "index": {
          "description": "An fpat in labeled record pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPatField",
          "package": "haskell-src",
          "partial": "Hs Pat Field",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsPatField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used to represent qualified variables, and also\n qualified constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsQName",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsQName",
          "type": "data"
        },
        "index": {
          "description": "This type is used to represent qualified variables and also qualified constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsQName",
          "package": "haskell-src",
          "partial": "Hs QName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly qualified infix operators (\u003cem\u003eqop\u003c/em\u003e), appearing in expressions.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsQOp",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsQOp",
          "type": "data"
        },
        "index": {
          "description": "Possibly qualified infix operators qop appearing in expressions",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsQOp",
          "package": "haskell-src",
          "partial": "Hs QOp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsQOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type qualified with a context.\n   An unqualified type has an empty context.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsQualType",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsQualType",
          "type": "data"
        },
        "index": {
          "description": "type qualified with context An unqualified type has an empty context",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsQualType",
          "package": "haskell-src",
          "partial": "Hs Qual Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsQualType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe right hand side of a function or pattern binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsRhs",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsRhs",
          "type": "data"
        },
        "index": {
          "description": "The right hand side of function or pattern binding",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsRhs",
          "package": "haskell-src",
          "partial": "Hs Rhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSafety level for invoking a foreign entity\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsSafety",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsSafety",
          "type": "data"
        },
        "index": {
          "description": "Safety level for invoking foreign entity",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsSafety",
          "package": "haskell-src",
          "partial": "Hs Safety",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsSafety"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructors with special syntax.\n These names are never qualified, and always refer to builtin type or\n data constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsSpecialCon",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsSpecialCon",
          "type": "data"
        },
        "index": {
          "description": "Constructors with special syntax These names are never qualified and always refer to builtin type or data constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsSpecialCon",
          "package": "haskell-src",
          "partial": "Hs Special Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsSpecialCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type represents both \u003cem\u003estmt\u003c/em\u003e in a \u003ccode\u003edo\u003c/code\u003e-expression,\n   and \u003cem\u003equal\u003c/em\u003e in a list comprehension.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsStmt",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsStmt",
          "type": "data"
        },
        "index": {
          "description": "This type represents both stmt in do expression and qual in list comprehension",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsStmt",
          "package": "haskell-src",
          "partial": "Hs Stmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell types and type constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsType",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#HsType",
          "type": "data"
        },
        "index": {
          "description": "Haskell types and type constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsType",
          "package": "haskell-src",
          "partial": "Hs Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:HsType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of a Haskell module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "Module",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#Module",
          "type": "newtype"
        },
        "index": {
          "description": "The name of Haskell module",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "Module",
          "package": "haskell-src",
          "partial": "Module",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA position in the source.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "SrcLoc",
          "package": "haskell-src",
          "source": "src/Language-Haskell-Syntax.html#SrcLoc",
          "type": "data"
        },
        "index": {
          "description": "position in the source",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "SrcLoc",
          "package": "haskell-src",
          "partial": "Src Loc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#t:SrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsAlt",
          "package": "haskell-src",
          "signature": "HsAlt SrcLoc HsPat HsGuardedAlts [HsDecl]",
          "source": "src/Language-Haskell-Syntax.html#HsAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAlt",
          "normalized": "HsAlt SrcLoc HsPat HsGuardedAlts[HsDecl]",
          "package": "haskell-src",
          "partial": "Hs Alt",
          "signature": "HsAlt SrcLoc HsPat HsGuardedAlts[HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary application\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsApp",
          "package": "haskell-src",
          "signature": "HsApp HsExp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "ordinary application",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsApp",
          "package": "haskell-src",
          "partial": "Hs App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epatterns only\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsAsPat",
          "package": "haskell-src",
          "signature": "HsAsPat HsName HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "patterns only",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAsPat",
          "package": "haskell-src",
          "partial": "Hs As Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsAsPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleft-associative operator (declared with \u003ccode\u003einfixl\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssocLeft",
          "package": "haskell-src",
          "signature": "HsAssocLeft",
          "source": "src/Language-Haskell-Syntax.html#HsAssoc",
          "type": "function"
        },
        "index": {
          "description": "left-associative operator declared with infixl",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssocLeft",
          "package": "haskell-src",
          "partial": "Hs Assoc Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsAssocLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-associative operator (declared with \u003ccode\u003einfix\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssocNone",
          "package": "haskell-src",
          "signature": "HsAssocNone",
          "source": "src/Language-Haskell-Syntax.html#HsAssoc",
          "type": "function"
        },
        "index": {
          "description": "non-associative operator declared with infix",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssocNone",
          "package": "haskell-src",
          "partial": "Hs Assoc None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsAssocNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eright-associative operator (declared with \u003ccode\u003einfixr\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssocRight",
          "package": "haskell-src",
          "signature": "HsAssocRight",
          "source": "src/Language-Haskell-Syntax.html#HsAssoc",
          "type": "function"
        },
        "index": {
          "description": "right-associative operator declared with infixr",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsAssocRight",
          "package": "haskell-src",
          "partial": "Hs Assoc Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsAssocRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estrict component, marked with \"\u003ccode\u003e!\u003c/code\u003e\"\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsBangedTy",
          "package": "haskell-src",
          "signature": "HsBangedTy HsType",
          "source": "src/Language-Haskell-Syntax.html#HsBangType",
          "type": "function"
        },
        "index": {
          "description": "strict component marked with",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsBangedTy",
          "package": "haskell-src",
          "partial": "Hs Banged Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsBangedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecase\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eof\u003c/code\u003e \u003cem\u003ealts\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsCase",
          "package": "haskell-src",
          "signature": "HsCase HsExp [HsAlt]",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "case exp of alts",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsCase",
          "normalized": "HsCase HsExp[HsAlt]",
          "package": "haskell-src",
          "partial": "Hs Case",
          "signature": "HsCase HsExp[HsAlt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echaracter literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsChar",
          "package": "haskell-src",
          "signature": "HsChar Char",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "character literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsChar",
          "package": "haskell-src",
          "partial": "Hs Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGHC unboxed character literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsCharPrim",
          "package": "haskell-src",
          "signature": "HsCharPrim Char",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "GHC unboxed character literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsCharPrim",
          "package": "haskell-src",
          "partial": "Hs Char Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsCharPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsClassDecl",
          "package": "haskell-src",
          "signature": "HsClassDecl SrcLoc HsContext HsName [HsName] [HsDecl]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsClassDecl",
          "normalized": "HsClassDecl SrcLoc HsContext HsName[HsName][HsDecl]",
          "package": "haskell-src",
          "partial": "Hs Class Decl",
          "signature": "HsClassDecl SrcLoc HsContext HsName[HsName][HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsClassDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsCon",
          "package": "haskell-src",
          "signature": "HsCon HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "data constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsCon",
          "package": "haskell-src",
          "partial": "Hs Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsConDecl",
          "package": "haskell-src",
          "signature": "HsConDecl SrcLoc HsName [HsBangType]",
          "source": "src/Language-Haskell-Syntax.html#HsConDecl",
          "type": "function"
        },
        "index": {
          "description": "ordinary data constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsConDecl",
          "normalized": "HsConDecl SrcLoc HsName[HsBangType]",
          "package": "haskell-src",
          "partial": "Hs Con Decl",
          "signature": "HsConDecl SrcLoc HsName[HsBangType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of a data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsConName",
          "package": "haskell-src",
          "signature": "HsConName HsName",
          "source": "src/Language-Haskell-Syntax.html#HsCName",
          "type": "function"
        },
        "index": {
          "description": "name of data constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsConName",
          "package": "haskell-src",
          "partial": "Hs Con Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor operator (\u003cem\u003econop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsConOp",
          "package": "haskell-src",
          "signature": "HsConOp HsName",
          "source": "src/Language-Haskell-Syntax.html#HsOp",
          "type": "function"
        },
        "index": {
          "description": "constructor operator conop",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsConOp",
          "package": "haskell-src",
          "partial": "Hs Con Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsConOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist data constructor \u003ccode\u003e(:)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsCons",
          "package": "haskell-src",
          "signature": "HsCons",
          "source": "src/Language-Haskell-Syntax.html#HsSpecialCon",
          "type": "function"
        },
        "index": {
          "description": "list data constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsCons",
          "package": "haskell-src",
          "partial": "Hs Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsDataDecl",
          "package": "haskell-src",
          "signature": "HsDataDecl SrcLoc HsContext HsName [HsName] [HsConDecl] [HsQName]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsDataDecl",
          "normalized": "HsDataDecl SrcLoc HsContext HsName[HsName][HsConDecl][HsQName]",
          "package": "haskell-src",
          "partial": "Hs Data Decl",
          "signature": "HsDataDecl SrcLoc HsContext HsName[HsName][HsConDecl][HsQName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsDataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsDefaultDecl",
          "package": "haskell-src",
          "signature": "HsDefaultDecl SrcLoc [HsType]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsDefaultDecl",
          "normalized": "HsDefaultDecl SrcLoc[HsType]",
          "package": "haskell-src",
          "partial": "Hs Default Decl",
          "signature": "HsDefaultDecl SrcLoc[HsType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsDefaultDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edo\u003c/code\u003e-expression:\n the last statement in the list\n should be an expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsDo",
          "package": "haskell-src",
          "signature": "HsDo [HsStmt]",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "do expression the last statement in the list should be an expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsDo",
          "normalized": "HsDo[HsStmt]",
          "package": "haskell-src",
          "partial": "Hs Do",
          "signature": "HsDo[HsStmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGHC unboxed double literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsDoublePrim",
          "package": "haskell-src",
          "signature": "HsDoublePrim Rational",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "GHC unboxed double literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsDoublePrim",
          "package": "haskell-src",
          "partial": "Hs Double Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsDoublePrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e:\n a class or datatype exported abstractly,\n or a type synonym.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEAbs",
          "package": "haskell-src",
          "signature": "HsEAbs HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class or datatype exported abstractly or type synonym",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEAbs",
          "package": "haskell-src",
          "partial": "Hs EAbs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emodule M\u003c/code\u003e:\n re-export a module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEModuleContents",
          "package": "haskell-src",
          "signature": "HsEModuleContents Module",
          "source": "src/Language-Haskell-Syntax.html#HsExportSpec",
          "type": "function"
        },
        "index": {
          "description": "module re-export module",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEModuleContents",
          "package": "haskell-src",
          "partial": "Hs EModule Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEModuleContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(..)\u003c/code\u003e:\n a class exported with all of its methods, or\n a datatype exported with all of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEThingAll",
          "package": "haskell-src",
          "signature": "HsEThingAll HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class exported with all of its methods or datatype exported with all of its constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEThingAll",
          "package": "haskell-src",
          "partial": "Hs EThing All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEThingAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(C_1,...,C_n)\u003c/code\u003e:\n a class exported with some of its methods, or\n a datatype exported with some of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEThingWith",
          "package": "haskell-src",
          "signature": "HsEThingWith HsQName [HsCName]",
          "source": "src/Language-Haskell-Syntax.html#HsExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class exported with some of its methods or datatype exported with some of its constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEThingWith",
          "normalized": "HsEThingWith HsQName[HsCName]",
          "package": "haskell-src",
          "partial": "Hs EThing With",
          "signature": "HsEThingWith HsQName[HsCName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEThingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEVar",
          "package": "haskell-src",
          "signature": "HsEVar HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsExportSpec",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEVar",
          "package": "haskell-src",
          "partial": "Hs EVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunbounded arithmetic sequence,\n incrementing by 1\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFrom",
          "package": "haskell-src",
          "signature": "HsEnumFrom HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "unbounded arithmetic sequence incrementing by",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFrom",
          "package": "haskell-src",
          "partial": "Hs Enum From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEnumFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunbounded arithmetic sequence,\n with first two elements given\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFromThen",
          "package": "haskell-src",
          "signature": "HsEnumFromThen HsExp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "unbounded arithmetic sequence with first two elements given",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFromThen",
          "package": "haskell-src",
          "partial": "Hs Enum From Then",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEnumFromThen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebounded arithmetic sequence,\n with first two elements given\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFromThenTo",
          "package": "haskell-src",
          "signature": "HsEnumFromThenTo HsExp HsExp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "bounded arithmetic sequence with first two elements given",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFromThenTo",
          "package": "haskell-src",
          "partial": "Hs Enum From Then To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEnumFromThenTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebounded arithmetic sequence,\n incrementing by 1\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFromTo",
          "package": "haskell-src",
          "signature": "HsEnumFromTo HsExp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "bounded arithmetic sequence incrementing by",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsEnumFromTo",
          "package": "haskell-src",
          "partial": "Hs Enum From To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsEnumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexpression type signature\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsExpTypeSig",
          "package": "haskell-src",
          "signature": "HsExpTypeSig SrcLoc HsExp HsQualType",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "expression type signature",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsExpTypeSig",
          "package": "haskell-src",
          "partial": "Hs Exp Type Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsExpTypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsFieldUpdate",
          "package": "haskell-src",
          "signature": "HsFieldUpdate HsQName HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsFieldUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsFieldUpdate",
          "package": "haskell-src",
          "partial": "Hs Field Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsFieldUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGHC unboxed float literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsFloatPrim",
          "package": "haskell-src",
          "signature": "HsFloatPrim Rational",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "GHC unboxed float literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsFloatPrim",
          "package": "haskell-src",
          "partial": "Hs Float Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsFloatPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsForeignExport",
          "package": "haskell-src",
          "signature": "HsForeignExport SrcLoc String String HsName HsType",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsForeignExport",
          "package": "haskell-src",
          "partial": "Hs Foreign Export",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsForeignExport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsForeignImport",
          "package": "haskell-src",
          "signature": "HsForeignImport SrcLoc String HsSafety String HsName HsType",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsForeignImport",
          "package": "haskell-src",
          "partial": "Hs Foreign Import",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsForeignImport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efloating point literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsFrac",
          "package": "haskell-src",
          "signature": "HsFrac Rational",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "floating point literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsFrac",
          "package": "haskell-src",
          "partial": "Hs Frac",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsFunBind",
          "package": "haskell-src",
          "signature": "HsFunBind [HsMatch]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsFunBind",
          "normalized": "HsFunBind[HsMatch]",
          "package": "haskell-src",
          "partial": "Hs Fun Bind",
          "signature": "HsFunBind[HsMatch]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsFunBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction type constructor \u003ccode\u003e-\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsFunCon",
          "package": "haskell-src",
          "signature": "HsFunCon",
          "source": "src/Language-Haskell-Syntax.html#HsSpecialCon",
          "type": "function"
        },
        "index": {
          "description": "function type constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsFunCon",
          "package": "haskell-src",
          "partial": "Hs Fun Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsFunCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea generator \u003cem\u003epat\u003c/em\u003e \u003ccode\u003e\u003c-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsGenerator",
          "package": "haskell-src",
          "signature": "HsGenerator SrcLoc HsPat HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsStmt",
          "type": "function"
        },
        "index": {
          "description": "generator pat exp",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGenerator",
          "package": "haskell-src",
          "partial": "Hs Generator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsGenerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlt",
          "package": "haskell-src",
          "signature": "HsGuardedAlt SrcLoc HsExp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsGuardedAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlt",
          "package": "haskell-src",
          "partial": "Hs Guarded Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsGuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003egdpat\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlts",
          "package": "haskell-src",
          "signature": "HsGuardedAlts [HsGuardedAlt]",
          "source": "src/Language-Haskell-Syntax.html#HsGuardedAlts",
          "type": "function"
        },
        "index": {
          "description": "gdpat",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedAlts",
          "normalized": "HsGuardedAlts[HsGuardedAlt]",
          "package": "haskell-src",
          "partial": "Hs Guarded Alts",
          "signature": "HsGuardedAlts[HsGuardedAlt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsGuardedAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedRhs",
          "package": "haskell-src",
          "signature": "HsGuardedRhs SrcLoc HsExp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsGuardedRhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedRhs",
          "package": "haskell-src",
          "partial": "Hs Guarded Rhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsGuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eguarded right hand side (\u003cem\u003egdrhs\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedRhss",
          "package": "haskell-src",
          "signature": "HsGuardedRhss [HsGuardedRhs]",
          "source": "src/Language-Haskell-Syntax.html#HsRhs",
          "type": "function"
        },
        "index": {
          "description": "guarded right hand side gdrhs",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsGuardedRhss",
          "normalized": "HsGuardedRhss[HsGuardedRhs]",
          "package": "haskell-src",
          "partial": "Hs Guarded Rhss",
          "signature": "HsGuardedRhss[HsGuardedRhs]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsGuardedRhss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e:\n the name of a class, datatype or type synonym.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIAbs",
          "package": "haskell-src",
          "signature": "HsIAbs HsName",
          "source": "src/Language-Haskell-Syntax.html#HsImportSpec",
          "type": "function"
        },
        "index": {
          "description": "the name of class datatype or type synonym",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIAbs",
          "package": "haskell-src",
          "partial": "Hs IAbs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(..)\u003c/code\u003e:\n a class imported with all of its methods, or\n a datatype imported with all of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIThingAll",
          "package": "haskell-src",
          "signature": "HsIThingAll HsName",
          "source": "src/Language-Haskell-Syntax.html#HsImportSpec",
          "type": "function"
        },
        "index": {
          "description": "class imported with all of its methods or datatype imported with all of its constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIThingAll",
          "package": "haskell-src",
          "partial": "Hs IThing All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIThingAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(C_1,...,C_n)\u003c/code\u003e:\n a class imported with some of its methods, or\n a datatype imported with some of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIThingWith",
          "package": "haskell-src",
          "signature": "HsIThingWith HsName [HsCName]",
          "source": "src/Language-Haskell-Syntax.html#HsImportSpec",
          "type": "function"
        },
        "index": {
          "description": "class imported with some of its methods or datatype imported with some of its constructors",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIThingWith",
          "normalized": "HsIThingWith HsName[HsCName]",
          "package": "haskell-src",
          "partial": "Hs IThing With",
          "signature": "HsIThingWith HsName[HsCName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIThingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIVar",
          "package": "haskell-src",
          "signature": "HsIVar HsName",
          "source": "src/Language-Haskell-Syntax.html#HsImportSpec",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIVar",
          "package": "haskell-src",
          "partial": "Hs IVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003evarid\u003c/em\u003e or \u003cem\u003econid\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIdent",
          "package": "haskell-src",
          "signature": "HsIdent String",
          "source": "src/Language-Haskell-Syntax.html#HsName",
          "type": "function"
        },
        "index": {
          "description": "varid or conid",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIdent",
          "package": "haskell-src",
          "partial": "Hs Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eif\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003ethen\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eelse\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIf",
          "package": "haskell-src",
          "signature": "HsIf HsExp HsExp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "if exp then exp else exp",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIf",
          "package": "haskell-src",
          "partial": "Hs If",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsImportDecl",
          "package": "haskell-src",
          "signature": "HsImportDecl",
          "source": "src/Language-Haskell-Syntax.html#HsImportDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsImportDecl",
          "package": "haskell-src",
          "partial": "Hs Import Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsImportDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix application\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsInfixApp",
          "package": "haskell-src",
          "signature": "HsInfixApp HsExp HsQOp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "infix application",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsInfixApp",
          "package": "haskell-src",
          "partial": "Hs Infix App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsInfixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsInfixDecl",
          "package": "haskell-src",
          "signature": "HsInfixDecl SrcLoc HsAssoc Int [HsOp]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsInfixDecl",
          "normalized": "HsInfixDecl SrcLoc HsAssoc Int[HsOp]",
          "package": "haskell-src",
          "partial": "Hs Infix Decl",
          "signature": "HsInfixDecl SrcLoc HsAssoc Int[HsOp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsInfixDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsInstDecl",
          "package": "haskell-src",
          "signature": "HsInstDecl SrcLoc HsContext HsQName [HsType] [HsDecl]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsInstDecl",
          "normalized": "HsInstDecl SrcLoc HsContext HsQName[HsType][HsDecl]",
          "package": "haskell-src",
          "partial": "Hs Inst Decl",
          "signature": "HsInstDecl SrcLoc HsContext HsQName[HsType][HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsInstDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsInt",
          "package": "haskell-src",
          "signature": "HsInt Integer",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "integer literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsInt",
          "package": "haskell-src",
          "partial": "Hs Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGHC unboxed integer literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIntPrim",
          "package": "haskell-src",
          "signature": "HsIntPrim Integer",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "GHC unboxed integer literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIntPrim",
          "package": "haskell-src",
          "partial": "Hs Int Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIntPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epatterns only\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsIrrPat",
          "package": "haskell-src",
          "signature": "HsIrrPat HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "patterns only",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsIrrPat",
          "package": "haskell-src",
          "partial": "Hs Irr Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsIrrPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elambda expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsLambda",
          "package": "haskell-src",
          "signature": "HsLambda SrcLoc [HsPat] HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "lambda expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsLambda",
          "normalized": "HsLambda SrcLoc[HsPat]HsExp",
          "package": "haskell-src",
          "partial": "Hs Lambda",
          "signature": "HsLambda SrcLoc[HsPat]HsExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleft section \u003ccode\u003e(\u003c/code\u003e\u003cem\u003eexp\u003c/em\u003e \u003cem\u003eqop\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsLeftSection",
          "package": "haskell-src",
          "signature": "HsLeftSection HsExp HsQOp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "left section exp qop",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsLeftSection",
          "package": "haskell-src",
          "partial": "Hs Left Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsLeftSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocal declarations with \u003ccode\u003elet\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsLet",
          "package": "haskell-src",
          "signature": "HsLet [HsDecl] HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "local declarations with let",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsLet",
          "normalized": "HsLet[HsDecl]HsExp",
          "package": "haskell-src",
          "partial": "Hs Let",
          "signature": "HsLet[HsDecl]HsExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocal bindings\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsLetStmt",
          "package": "haskell-src",
          "signature": "HsLetStmt [HsDecl]",
          "source": "src/Language-Haskell-Syntax.html#HsStmt",
          "type": "function"
        },
        "index": {
          "description": "local bindings",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsLetStmt",
          "normalized": "HsLetStmt[HsDecl]",
          "package": "haskell-src",
          "partial": "Hs Let Stmt",
          "signature": "HsLetStmt[HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsLetStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsList",
          "package": "haskell-src",
          "signature": "HsList [HsExp]",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "list expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsList",
          "normalized": "HsList[HsExp]",
          "package": "haskell-src",
          "partial": "Hs List",
          "signature": "HsList[HsExp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist comprehension\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsListComp",
          "package": "haskell-src",
          "signature": "HsListComp HsExp [HsStmt]",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "list comprehension",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsListComp",
          "normalized": "HsListComp HsExp[HsStmt]",
          "package": "haskell-src",
          "partial": "Hs List Comp",
          "signature": "HsListComp HsExp[HsStmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist type constructor \u003ccode\u003e[]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsListCon",
          "package": "haskell-src",
          "signature": "HsListCon",
          "source": "src/Language-Haskell-Syntax.html#HsSpecialCon",
          "type": "function"
        },
        "index": {
          "description": "list type constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsListCon",
          "package": "haskell-src",
          "partial": "Hs List Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsListCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eliteral constant\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsLit",
          "package": "haskell-src",
          "signature": "HsLit HsLiteral",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "literal constant",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsLit",
          "package": "haskell-src",
          "partial": "Hs Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsMatch",
          "package": "haskell-src",
          "signature": "HsMatch SrcLoc HsName [HsPat] HsRhs [HsDecl]",
          "source": "src/Language-Haskell-Syntax.html#HsMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsMatch",
          "normalized": "HsMatch SrcLoc HsName[HsPat]HsRhs[HsDecl]",
          "package": "haskell-src",
          "partial": "Hs Match",
          "signature": "HsMatch SrcLoc HsName[HsPat]HsRhs[HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsModule",
          "package": "haskell-src",
          "signature": "HsModule SrcLoc Module (Maybe [HsExportSpec]) [HsImportDecl] [HsDecl]",
          "source": "src/Language-Haskell-Syntax.html#HsModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsModule",
          "normalized": "HsModule SrcLoc Module(Maybe[HsExportSpec])[HsImportDecl][HsDecl]",
          "package": "haskell-src",
          "partial": "Hs Module",
          "signature": "HsModule SrcLoc Module(Maybe[HsExportSpec])[HsImportDecl][HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegation expression \u003ccode\u003e-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsNegApp",
          "package": "haskell-src",
          "signature": "HsNegApp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "negation expression exp",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsNegApp",
          "package": "haskell-src",
          "partial": "Hs Neg App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsNegApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsNewTypeDecl",
          "package": "haskell-src",
          "signature": "HsNewTypeDecl SrcLoc HsContext HsName [HsName] HsConDecl [HsQName]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsNewTypeDecl",
          "normalized": "HsNewTypeDecl SrcLoc HsContext HsName[HsName]HsConDecl[HsQName]",
          "package": "haskell-src",
          "partial": "Hs New Type Decl",
          "signature": "HsNewTypeDecl SrcLoc HsContext HsName[HsName]HsConDecl[HsQName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsNewTypeDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata constructor and argument\n patterns\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPApp",
          "package": "haskell-src",
          "signature": "HsPApp HsQName [HsPat]",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "data constructor and argument patterns",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPApp",
          "normalized": "HsPApp HsQName[HsPat]",
          "package": "haskell-src",
          "partial": "Hs PApp",
          "signature": "HsPApp HsQName[HsPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e-pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPAsPat",
          "package": "haskell-src",
          "signature": "HsPAsPat HsName HsPat",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPAsPat",
          "package": "haskell-src",
          "partial": "Hs PAs Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPAsPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsPFieldPat",
          "package": "haskell-src",
          "signature": "HsPFieldPat HsQName HsPat",
          "source": "src/Language-Haskell-Syntax.html#HsPatField",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPFieldPat",
          "package": "haskell-src",
          "partial": "Hs PField Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPFieldPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern with infix data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPInfixApp",
          "package": "haskell-src",
          "signature": "HsPInfixApp HsPat HsQName HsPat",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "pattern with infix data constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPInfixApp",
          "package": "haskell-src",
          "partial": "Hs PInfix App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPInfixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eirrefutable pattern (\u003ccode\u003e~\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPIrrPat",
          "package": "haskell-src",
          "signature": "HsPIrrPat HsPat",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "irrefutable pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPIrrPat",
          "package": "haskell-src",
          "partial": "Hs PIrr Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPIrrPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPList",
          "package": "haskell-src",
          "signature": "HsPList [HsPat]",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "list pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPList",
          "normalized": "HsPList[HsPat]",
          "package": "haskell-src",
          "partial": "Hs PList",
          "signature": "HsPList[HsPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eliteral constant\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPLit",
          "package": "haskell-src",
          "signature": "HsPLit HsLiteral",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "literal constant",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPLit",
          "package": "haskell-src",
          "partial": "Hs PLit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegated pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPNeg",
          "package": "haskell-src",
          "signature": "HsPNeg HsPat",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "negated pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPNeg",
          "package": "haskell-src",
          "partial": "Hs PNeg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesized pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPParen",
          "package": "haskell-src",
          "signature": "HsPParen HsPat",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "parenthesized pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPParen",
          "package": "haskell-src",
          "partial": "Hs PParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elabelled pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPRec",
          "package": "haskell-src",
          "signature": "HsPRec HsQName [HsPatField]",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "labelled pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPRec",
          "normalized": "HsPRec HsQName[HsPatField]",
          "package": "haskell-src",
          "partial": "Hs PRec",
          "signature": "HsPRec HsQName[HsPatField]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPTuple",
          "package": "haskell-src",
          "signature": "HsPTuple [HsPat]",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPTuple",
          "normalized": "HsPTuple[HsPat]",
          "package": "haskell-src",
          "partial": "Hs PTuple",
          "signature": "HsPTuple[HsPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPVar",
          "package": "haskell-src",
          "signature": "HsPVar HsName",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPVar",
          "package": "haskell-src",
          "partial": "Hs PVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewildcard pattern (\u003ccode\u003e_\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsPWildCard",
          "package": "haskell-src",
          "signature": "HsPWildCard",
          "source": "src/Language-Haskell-Syntax.html#HsPat",
          "type": "function"
        },
        "index": {
          "description": "wildcard pattern",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPWildCard",
          "package": "haskell-src",
          "partial": "Hs PWild Card",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPWildCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesized expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsParen",
          "package": "haskell-src",
          "signature": "HsParen HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "parenthesized expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsParen",
          "package": "haskell-src",
          "partial": "Hs Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsPatBind",
          "package": "haskell-src",
          "signature": "HsPatBind SrcLoc HsPat HsRhs [HsDecl]",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsPatBind",
          "normalized": "HsPatBind SrcLoc HsPat HsRhs[HsDecl]",
          "package": "haskell-src",
          "partial": "Hs Pat Bind",
          "signature": "HsPatBind SrcLoc HsPat HsRhs[HsDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsPatBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor operator (\u003cem\u003eqconop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsQConOp",
          "package": "haskell-src",
          "signature": "HsQConOp HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsQOp",
          "type": "function"
        },
        "index": {
          "description": "constructor operator qconop",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsQConOp",
          "package": "haskell-src",
          "partial": "Hs QCon Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsQConOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable operator (\u003cem\u003eqvarop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsQVarOp",
          "package": "haskell-src",
          "signature": "HsQVarOp HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsQOp",
          "type": "function"
        },
        "index": {
          "description": "variable operator qvarop",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsQVarOp",
          "package": "haskell-src",
          "partial": "Hs QVar Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsQVarOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsQualType",
          "package": "haskell-src",
          "signature": "HsQualType HsContext HsType",
          "source": "src/Language-Haskell-Syntax.html#HsQualType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsQualType",
          "package": "haskell-src",
          "partial": "Hs Qual Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsQualType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean \u003cem\u003eexp\u003c/em\u003e by itself: in a \u003ccode\u003edo\u003c/code\u003e-expression,\n an action whose result is discarded;\n in a list comprehension, a guard expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsQualifier",
          "package": "haskell-src",
          "signature": "HsQualifier HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsStmt",
          "type": "function"
        },
        "index": {
          "description": "an exp by itself in do expression an action whose result is discarded in list comprehension guard expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsQualifier",
          "package": "haskell-src",
          "partial": "Hs Qualifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsQualifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord construction expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsRecConstr",
          "package": "haskell-src",
          "signature": "HsRecConstr HsQName [HsFieldUpdate]",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "record construction expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsRecConstr",
          "normalized": "HsRecConstr HsQName[HsFieldUpdate]",
          "package": "haskell-src",
          "partial": "Hs Rec Constr",
          "signature": "HsRecConstr HsQName[HsFieldUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsRecConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsRecDecl",
          "package": "haskell-src",
          "signature": "HsRecDecl SrcLoc HsName [([HsName], HsBangType)]",
          "source": "src/Language-Haskell-Syntax.html#HsConDecl",
          "type": "function"
        },
        "index": {
          "description": "record constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsRecDecl",
          "normalized": "HsRecDecl SrcLoc HsName[([HsName],HsBangType)]",
          "package": "haskell-src",
          "partial": "Hs Rec Decl",
          "signature": "HsRecDecl SrcLoc HsName[([HsName],HsBangType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsRecDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord update expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsRecUpdate",
          "package": "haskell-src",
          "signature": "HsRecUpdate HsExp [HsFieldUpdate]",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "record update expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsRecUpdate",
          "normalized": "HsRecUpdate HsExp[HsFieldUpdate]",
          "package": "haskell-src",
          "partial": "Hs Rec Update",
          "signature": "HsRecUpdate HsExp[HsFieldUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsRecUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eright section \u003ccode\u003e(\u003c/code\u003e\u003cem\u003eqop\u003c/em\u003e \u003cem\u003eexp\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsRightSection",
          "package": "haskell-src",
          "signature": "HsRightSection HsQOp HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "right section qop exp",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsRightSection",
          "package": "haskell-src",
          "partial": "Hs Right Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsRightSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecall may generate callbacks\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsSafe",
          "package": "haskell-src",
          "signature": "HsSafe",
          "source": "src/Language-Haskell-Syntax.html#HsSafety",
          "type": "function"
        },
        "index": {
          "description": "call may generate callbacks",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsSafe",
          "package": "haskell-src",
          "partial": "Hs Safe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsSafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estring literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsString",
          "package": "haskell-src",
          "signature": "HsString String",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "string literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsString",
          "package": "haskell-src",
          "partial": "Hs String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGHC unboxed string literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsStringPrim",
          "package": "haskell-src",
          "signature": "HsStringPrim String",
          "source": "src/Language-Haskell-Syntax.html#HsLiteral",
          "type": "function"
        },
        "index": {
          "description": "GHC unboxed string literal",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsStringPrim",
          "package": "haskell-src",
          "partial": "Hs String Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsStringPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003evarsym\u003c/em\u003e or \u003cem\u003econsym\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsSymbol",
          "package": "haskell-src",
          "signature": "HsSymbol String",
          "source": "src/Language-Haskell-Syntax.html#HsName",
          "type": "function"
        },
        "index": {
          "description": "varsym or consym",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsSymbol",
          "package": "haskell-src",
          "partial": "Hs Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsTuple",
          "package": "haskell-src",
          "signature": "HsTuple [HsExp]",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "tuple expression",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTuple",
          "normalized": "HsTuple[HsExp]",
          "package": "haskell-src",
          "partial": "Hs Tuple",
          "signature": "HsTuple[HsExp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003e-ary tuple type and data\n   constructors \u003ccode\u003e(,)\u003c/code\u003e etc\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsTupleCon",
          "package": "haskell-src",
          "signature": "HsTupleCon Int",
          "source": "src/Language-Haskell-Syntax.html#HsSpecialCon",
          "type": "function"
        },
        "index": {
          "description": "ary tuple type and data constructors etc",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTupleCon",
          "package": "haskell-src",
          "partial": "Hs Tuple Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTupleCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapplication of a type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyApp",
          "package": "haskell-src",
          "signature": "HsTyApp HsType HsType",
          "source": "src/Language-Haskell-Syntax.html#HsType",
          "type": "function"
        },
        "index": {
          "description": "application of type constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyApp",
          "package": "haskell-src",
          "partial": "Hs Ty App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTyApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enamed type or type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyCon",
          "package": "haskell-src",
          "signature": "HsTyCon HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsType",
          "type": "function"
        },
        "index": {
          "description": "named type or type constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyCon",
          "package": "haskell-src",
          "partial": "Hs Ty Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction type\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyFun",
          "package": "haskell-src",
          "signature": "HsTyFun HsType HsType",
          "source": "src/Language-Haskell-Syntax.html#HsType",
          "type": "function"
        },
        "index": {
          "description": "function type",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyFun",
          "package": "haskell-src",
          "partial": "Hs Ty Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTyFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple type\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyTuple",
          "package": "haskell-src",
          "signature": "HsTyTuple [HsType]",
          "source": "src/Language-Haskell-Syntax.html#HsType",
          "type": "function"
        },
        "index": {
          "description": "tuple type",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyTuple",
          "normalized": "HsTyTuple[HsType]",
          "package": "haskell-src",
          "partial": "Hs Ty Tuple",
          "signature": "HsTyTuple[HsType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTyTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype variable\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyVar",
          "package": "haskell-src",
          "signature": "HsTyVar HsName",
          "source": "src/Language-Haskell-Syntax.html#HsType",
          "type": "function"
        },
        "index": {
          "description": "type variable",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTyVar",
          "package": "haskell-src",
          "partial": "Hs Ty Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTyVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsTypeDecl",
          "package": "haskell-src",
          "signature": "HsTypeDecl SrcLoc HsName [HsName] HsType",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTypeDecl",
          "normalized": "HsTypeDecl SrcLoc HsName[HsName]HsType",
          "package": "haskell-src",
          "partial": "Hs Type Decl",
          "signature": "HsTypeDecl SrcLoc HsName[HsName]HsType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTypeDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "HsTypeSig",
          "package": "haskell-src",
          "signature": "HsTypeSig SrcLoc [HsName] HsQualType",
          "source": "src/Language-Haskell-Syntax.html#HsDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsTypeSig",
          "normalized": "HsTypeSig SrcLoc[HsName]HsQualType",
          "package": "haskell-src",
          "partial": "Hs Type Sig",
          "signature": "HsTypeSig SrcLoc[HsName]HsQualType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsTypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-strict component\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnBangedTy",
          "package": "haskell-src",
          "signature": "HsUnBangedTy HsType",
          "source": "src/Language-Haskell-Syntax.html#HsBangType",
          "type": "function"
        },
        "index": {
          "description": "non-strict component",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnBangedTy",
          "package": "haskell-src",
          "partial": "Hs Un Banged Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsUnBangedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnGuardedAlt",
          "package": "haskell-src",
          "signature": "HsUnGuardedAlt HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsGuardedAlts",
          "type": "function"
        },
        "index": {
          "description": "exp",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnGuardedAlt",
          "package": "haskell-src",
          "partial": "Hs Un Guarded Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsUnGuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunguarded right hand side (\u003cem\u003eexp\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnGuardedRhs",
          "package": "haskell-src",
          "signature": "HsUnGuardedRhs HsExp",
          "source": "src/Language-Haskell-Syntax.html#HsRhs",
          "type": "function"
        },
        "index": {
          "description": "unguarded right hand side exp",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnGuardedRhs",
          "package": "haskell-src",
          "partial": "Hs Un Guarded Rhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsUnGuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunit type and data constructor \u003ccode\u003e()\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnitCon",
          "package": "haskell-src",
          "signature": "HsUnitCon",
          "source": "src/Language-Haskell-Syntax.html#HsSpecialCon",
          "type": "function"
        },
        "index": {
          "description": "unit type and data constructor",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnitCon",
          "package": "haskell-src",
          "partial": "Hs Unit Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsUnitCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecall will not generate callbacks\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnsafe",
          "package": "haskell-src",
          "signature": "HsUnsafe",
          "source": "src/Language-Haskell-Syntax.html#HsSafety",
          "type": "function"
        },
        "index": {
          "description": "call will not generate callbacks",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsUnsafe",
          "package": "haskell-src",
          "partial": "Hs Unsafe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsVar",
          "package": "haskell-src",
          "signature": "HsVar HsQName",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsVar",
          "package": "haskell-src",
          "partial": "Hs Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of a method or field\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsVarName",
          "package": "haskell-src",
          "signature": "HsVarName HsName",
          "source": "src/Language-Haskell-Syntax.html#HsCName",
          "type": "function"
        },
        "index": {
          "description": "name of method or field",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsVarName",
          "package": "haskell-src",
          "partial": "Hs Var Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsVarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable operator (\u003cem\u003evarop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsVarOp",
          "package": "haskell-src",
          "signature": "HsVarOp HsName",
          "source": "src/Language-Haskell-Syntax.html#HsOp",
          "type": "function"
        },
        "index": {
          "description": "variable operator varop",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsVarOp",
          "package": "haskell-src",
          "partial": "Hs Var Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsVarOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epatterns only\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "HsWildCard",
          "package": "haskell-src",
          "signature": "HsWildCard",
          "source": "src/Language-Haskell-Syntax.html#HsExp",
          "type": "function"
        },
        "index": {
          "description": "patterns only",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "HsWildCard",
          "package": "haskell-src",
          "partial": "Hs Wild Card",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:HsWildCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "Module",
          "package": "haskell-src",
          "signature": "Module String",
          "source": "src/Language-Haskell-Syntax.html#Module",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "Module",
          "package": "haskell-src",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename qualified with a module name\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "Qual",
          "package": "haskell-src",
          "signature": "Qual Module HsName",
          "source": "src/Language-Haskell-Syntax.html#HsQName",
          "type": "function"
        },
        "index": {
          "description": "name qualified with module name",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "Qual",
          "package": "haskell-src",
          "partial": "Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:Qual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilt-in constructor with special syntax\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "Special",
          "package": "haskell-src",
          "signature": "Special HsSpecialCon",
          "source": "src/Language-Haskell-Syntax.html#HsQName",
          "type": "function"
        },
        "index": {
          "description": "built-in constructor with special syntax",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "Special",
          "package": "haskell-src",
          "partial": "Special",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:Special"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "SrcLoc",
          "package": "haskell-src",
          "signature": "SrcLoc",
          "source": "src/Language-Haskell-Syntax.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "SrcLoc",
          "package": "haskell-src",
          "partial": "Src Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:SrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunqualified name\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "UnQual",
          "package": "haskell-src",
          "signature": "UnQual HsName",
          "source": "src/Language-Haskell-Syntax.html#HsQName",
          "type": "function"
        },
        "index": {
          "description": "unqualified name",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "UnQual",
          "package": "haskell-src",
          "partial": "Un Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:UnQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "fun_tycon",
          "package": "haskell-src",
          "signature": "HsType",
          "source": "src/Language-Haskell-Syntax.html#unit_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "fun_tycon",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:fun_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "fun_tycon_name",
          "package": "haskell-src",
          "signature": "HsQName",
          "source": "src/Language-Haskell-Syntax.html#unit_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "fun_tycon_name",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:fun_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional alias name in an\n \u003ccode\u003eas\u003c/code\u003e clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "importAs",
          "package": "haskell-src",
          "signature": "Maybe Module",
          "source": "src/Language-Haskell-Syntax.html#HsImportDecl",
          "type": "function"
        },
        "index": {
          "description": "optional alias name in an as clause",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "importAs",
          "package": "haskell-src",
          "partial": "As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:importAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposition of the \u003ccode\u003eimport\u003c/code\u003e keyword.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "importLoc",
          "package": "haskell-src",
          "signature": "SrcLoc",
          "source": "src/Language-Haskell-Syntax.html#HsImportDecl",
          "type": "function"
        },
        "index": {
          "description": "position of the import keyword",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "importLoc",
          "package": "haskell-src",
          "partial": "Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:importLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of the module imported.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "importModule",
          "package": "haskell-src",
          "signature": "Module",
          "source": "src/Language-Haskell-Syntax.html#HsImportDecl",
          "type": "function"
        },
        "index": {
          "description": "name of the module imported",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "importModule",
          "package": "haskell-src",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:importModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimported \u003ccode\u003equalified\u003c/code\u003e?\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "importQualified",
          "package": "haskell-src",
          "signature": "Bool",
          "source": "src/Language-Haskell-Syntax.html#HsImportDecl",
          "type": "function"
        },
        "index": {
          "description": "imported qualified",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "importQualified",
          "package": "haskell-src",
          "partial": "Qualified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:importQualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional list of import specifications.\n The \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the names are excluded\n by \u003ccode\u003ehiding\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Syntax",
          "name": "importSpecs",
          "package": "haskell-src",
          "signature": "Maybe (Bool, [HsImportSpec])",
          "source": "src/Language-Haskell-Syntax.html#HsImportDecl",
          "type": "function"
        },
        "index": {
          "description": "optional list of import specifications The Bool is True if the names are excluded by hiding",
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "importSpecs",
          "normalized": "Maybe(Bool,[HsImportSpec])",
          "package": "haskell-src",
          "partial": "Specs",
          "signature": "Maybe(Bool,[HsImportSpec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:importSpecs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "list_cons_name",
          "package": "haskell-src",
          "signature": "HsQName",
          "source": "src/Language-Haskell-Syntax.html#list_cons_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "list_cons_name",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:list_cons_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "list_tycon",
          "package": "haskell-src",
          "signature": "HsType",
          "source": "src/Language-Haskell-Syntax.html#unit_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "list_tycon",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:list_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "list_tycon_name",
          "package": "haskell-src",
          "signature": "HsQName",
          "source": "src/Language-Haskell-Syntax.html#unit_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "list_tycon_name",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:list_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "main_mod",
          "package": "haskell-src",
          "signature": "Module",
          "source": "src/Language-Haskell-Syntax.html#prelude_mod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "main_mod",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:main_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "main_name",
          "package": "haskell-src",
          "signature": "HsName",
          "source": "src/Language-Haskell-Syntax.html#main_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "main_name",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:main_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "prelude_mod",
          "package": "haskell-src",
          "signature": "Module",
          "source": "src/Language-Haskell-Syntax.html#prelude_mod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "prelude_mod",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:prelude_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "srcColumn",
          "package": "haskell-src",
          "signature": "Int",
          "source": "src/Language-Haskell-Syntax.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "srcColumn",
          "package": "haskell-src",
          "partial": "Column",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:srcColumn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "srcFilename",
          "package": "haskell-src",
          "signature": "String",
          "source": "src/Language-Haskell-Syntax.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "srcFilename",
          "package": "haskell-src",
          "partial": "Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:srcFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "srcLine",
          "package": "haskell-src",
          "signature": "Int",
          "source": "src/Language-Haskell-Syntax.html#SrcLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "srcLine",
          "package": "haskell-src",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:srcLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "tuple_con",
          "package": "haskell-src",
          "signature": "Int -\u003e HsExp",
          "source": "src/Language-Haskell-Syntax.html#tuple_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "tuple_con",
          "normalized": "Int-\u003eHsExp",
          "package": "haskell-src",
          "signature": "Int-\u003eHsExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:tuple_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "tuple_con_name",
          "package": "haskell-src",
          "signature": "Int -\u003e HsQName",
          "source": "src/Language-Haskell-Syntax.html#tuple_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "tuple_con_name",
          "normalized": "Int-\u003eHsQName",
          "package": "haskell-src",
          "signature": "Int-\u003eHsQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:tuple_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "tuple_tycon",
          "package": "haskell-src",
          "signature": "Int -\u003e HsType",
          "source": "src/Language-Haskell-Syntax.html#tuple_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "tuple_tycon",
          "normalized": "Int-\u003eHsType",
          "package": "haskell-src",
          "signature": "Int-\u003eHsType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:tuple_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "tuple_tycon_name",
          "package": "haskell-src",
          "signature": "Int -\u003e HsQName",
          "source": "src/Language-Haskell-Syntax.html#tuple_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "tuple_tycon_name",
          "normalized": "Int-\u003eHsQName",
          "package": "haskell-src",
          "signature": "Int-\u003eHsQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:tuple_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "unit_con",
          "package": "haskell-src",
          "signature": "HsExp",
          "source": "src/Language-Haskell-Syntax.html#unit_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "unit_con",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:unit_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "unit_con_name",
          "package": "haskell-src",
          "signature": "HsQName",
          "source": "src/Language-Haskell-Syntax.html#unit_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "unit_con_name",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:unit_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "unit_tycon",
          "package": "haskell-src",
          "signature": "HsType",
          "source": "src/Language-Haskell-Syntax.html#unit_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "unit_tycon",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:unit_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Syntax",
          "name": "unit_tycon_name",
          "package": "haskell-src",
          "signature": "HsQName",
          "source": "src/Language-Haskell-Syntax.html#unit_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Syntax",
          "module": "Language.Haskell.Syntax",
          "name": "unit_tycon_name",
          "package": "haskell-src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src/docs/Language-Haskell-Syntax.html#v:unit_tycon_name"
      }
    }
  ]
]