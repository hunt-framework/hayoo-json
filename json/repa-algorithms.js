[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "repa-algorithms"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHyprometric color ramps, for making pretty images from scalar data.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.ColorRamp",
          "name": "ColorRamp",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-ColorRamp.html",
          "type": "module"
        },
        "index": {
          "description": "Hyprometric color ramps for making pretty images from scalar data",
          "hierarchy": "Data Array Repa Algorithms ColorRamp",
          "module": "Data.Array.Repa.Algorithms.ColorRamp",
          "name": "ColorRamp",
          "package": "repa-algorithms",
          "partial": "Color Ramp",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-ColorRamp.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard Hot to Cold hypsometric color ramp.\n\tColor sequence is red, yellow, green, cyan, blue.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.ColorRamp",
          "name": "rampColorHotToCold",
          "package": "repa-algorithms",
          "signature": "a-\u003e a-\u003e a-\u003e (a, a, a)",
          "type": "function"
        },
        "index": {
          "description": "Standard Hot to Cold hypsometric color ramp Color sequence is red yellow green cyan blue",
          "hierarchy": "Data Array Repa Algorithms ColorRamp",
          "module": "Data.Array.Repa.Algorithms.ColorRamp",
          "name": "rampColorHotToCold",
          "normalized": "a-\u003ea-\u003ea-\u003e(a,a,a)",
          "package": "repa-algorithms",
          "partial": "Color Hot To Cold",
          "signature": "a-\u003ea-\u003ea-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-ColorRamp.html#v:rampColorHotToCold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStrict complex doubles.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "Complex",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-Complex.html",
          "type": "module"
        },
        "index": {
          "description": "Strict complex doubles",
          "hierarchy": "Data Array Repa Algorithms Complex",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "Complex",
          "package": "repa-algorithms",
          "partial": "Complex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Complex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplex doubles.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "Complex",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-Complex.html#Complex",
          "type": "type"
        },
        "index": {
          "description": "Complex doubles",
          "hierarchy": "Data Array Repa Algorithms Complex",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "Complex",
          "package": "repa-algorithms",
          "partial": "Complex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Complex.html#t:Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the argument (phase) of a complex number, in the range [-pi .. pi].\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "arg",
          "package": "repa-algorithms",
          "signature": "Complex -\u003e Double",
          "source": "src/Data-Array-Repa-Algorithms-Complex.html#arg",
          "type": "function"
        },
        "index": {
          "description": "Take the argument phase of complex number in the range pi pi",
          "hierarchy": "Data Array Repa Algorithms Complex",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "arg",
          "normalized": "Complex-\u003eDouble",
          "package": "repa-algorithms",
          "signature": "Complex-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Complex.html#v:arg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the magnitude of a complex number.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "mag",
          "package": "repa-algorithms",
          "signature": "Complex -\u003e Double",
          "source": "src/Data-Array-Repa-Algorithms-Complex.html#mag",
          "type": "function"
        },
        "index": {
          "description": "Take the magnitude of complex number",
          "hierarchy": "Data Array Repa Algorithms Complex",
          "module": "Data.Array.Repa.Algorithms.Complex",
          "name": "mag",
          "normalized": "Complex-\u003eDouble",
          "package": "repa-algorithms",
          "signature": "Complex-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Complex.html#v:mag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneric stencil based convolutions. \n\u003c/p\u003e\u003cp\u003eIf your stencil fits within a 7x7 tile and is known at compile-time then using\n   then using the built-in stencil support provided by the main Repa package will\n   be 5-10x faster. \n\u003c/p\u003e\u003cp\u003eIf you have a larger stencil, the coefficients are not statically known, \n   or need more complex boundary handling than provided by the built-in functions,\n   then use this version instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "Convolve",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-Convolve.html",
          "type": "module"
        },
        "index": {
          "description": "Generic stencil based convolutions If your stencil fits within x7 tile and is known at compile-time then using then using the built-in stencil support provided by the main Repa package will be faster If you have larger stencil the coefficients are not statically known or need more complex boundary handling than provided by the built-in functions then use this version instead",
          "hierarchy": "Data Array Repa Algorithms Convolve",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "Convolve",
          "package": "repa-algorithms",
          "partial": "Convolve",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Convolve.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function that gets out of range elements from an image.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "GetOut",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-Convolve.html#GetOut",
          "type": "type"
        },
        "index": {
          "description": "function that gets out of range elements from an image",
          "hierarchy": "Data Array Repa Algorithms Convolve",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "GetOut",
          "package": "repa-algorithms",
          "partial": "Get Out",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Convolve.html#t:GetOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImage-kernel convolution, \n   which takes a function specifying what value to use for out-of-range elements.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "convolveOutP",
          "package": "repa-algorithms",
          "signature": "GetOut a-\u003e Array U DIM2 a-\u003e Array U DIM2 a-\u003e m (Array U DIM2 a)",
          "type": "function"
        },
        "index": {
          "description": "Image-kernel convolution which takes function specifying what value to use for out-of-range elements",
          "hierarchy": "Data Array Repa Algorithms Convolve",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "convolveOutP",
          "normalized": "GetOut a-\u003eArray U DIM a-\u003eArray U DIM a-\u003eb(Array U DIM a)",
          "package": "repa-algorithms",
          "partial": "Out",
          "signature": "GetOut a-\u003eArray U DIM a-\u003eArray U DIM a-\u003em(Array U DIM a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Convolve.html#v:convolveOutP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImage-kernel convolution,\n   which takes a function specifying what value to return when the\n   kernel doesn't apply.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "convolveP",
          "package": "repa-algorithms",
          "signature": "(DIM2 -\u003e a)-\u003e Array U DIM2 a-\u003e Array U DIM2 a-\u003e m (Array U DIM2 a)",
          "type": "function"
        },
        "index": {
          "description": "Image-kernel convolution which takes function specifying what value to return when the kernel doesn apply",
          "hierarchy": "Data Array Repa Algorithms Convolve",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "convolveP",
          "normalized": "(DIM-\u003ea)-\u003eArray U DIM a-\u003eArray U DIM a-\u003eb(Array U DIM a)",
          "package": "repa-algorithms",
          "signature": "(DIM-\u003ea)-\u003eArray U DIM a-\u003eArray U DIM a-\u003em(Array U DIM a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Convolve.html#v:convolveP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the provided value for every out-of-range element.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "outAs",
          "package": "repa-algorithms",
          "signature": "a -\u003e GetOut a",
          "source": "src/Data-Array-Repa-Algorithms-Convolve.html#outAs",
          "type": "function"
        },
        "index": {
          "description": "Use the provided value for every out-of-range element",
          "hierarchy": "Data Array Repa Algorithms Convolve",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "outAs",
          "normalized": "a-\u003eGetOut a",
          "package": "repa-algorithms",
          "partial": "As",
          "signature": "a-\u003eGetOut a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Convolve.html#v:outAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf the requested element is out of range use\n   the closest one from the real image.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "outClamp",
          "package": "repa-algorithms",
          "signature": "GetOut a",
          "source": "src/Data-Array-Repa-Algorithms-Convolve.html#outClamp",
          "type": "function"
        },
        "index": {
          "description": "If the requested element is out of range use the closest one from the real image",
          "hierarchy": "Data Array Repa Algorithms Convolve",
          "module": "Data.Array.Repa.Algorithms.Convolve",
          "name": "outClamp",
          "package": "repa-algorithms",
          "partial": "Clamp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Convolve.html#v:outClamp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eApplying these transforms to the input of a DFT causes the output \n   to be centered so that the zero frequency is in the middle. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "Center",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-DFT-Center.html",
          "type": "module"
        },
        "index": {
          "description": "Applying these transforms to the input of DFT causes the output to be centered so that the zero frequency is in the middle",
          "hierarchy": "Data Array Repa Algorithms DFT Center",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "Center",
          "package": "repa-algorithms",
          "partial": "Center",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT-Center.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the centering transform to a vector.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "center1d",
          "package": "repa-algorithms",
          "signature": "Array r DIM1 Complex -\u003e Array D DIM1 Complex",
          "source": "src/Data-Array-Repa-Algorithms-DFT-Center.html#center1d",
          "type": "function"
        },
        "index": {
          "description": "Apply the centering transform to vector",
          "hierarchy": "Data Array Repa Algorithms DFT Center",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "center1d",
          "normalized": "Array a DIM Complex-\u003eArray D DIM Complex",
          "package": "repa-algorithms",
          "signature": "Array r DIM Complex-\u003eArray D DIM Complex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT-Center.html#v:center1d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the centering transform to a matrix.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "center2d",
          "package": "repa-algorithms",
          "signature": "Array r DIM2 Complex -\u003e Array D DIM2 Complex",
          "source": "src/Data-Array-Repa-Algorithms-DFT-Center.html#center2d",
          "type": "function"
        },
        "index": {
          "description": "Apply the centering transform to matrix",
          "hierarchy": "Data Array Repa Algorithms DFT Center",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "center2d",
          "normalized": "Array a DIM Complex-\u003eArray D DIM Complex",
          "package": "repa-algorithms",
          "signature": "Array r DIM Complex-\u003eArray D DIM Complex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT-Center.html#v:center2d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the centering transform to a 3d array.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "center3d",
          "package": "repa-algorithms",
          "signature": "Array r DIM3 Complex -\u003e Array D DIM3 Complex",
          "source": "src/Data-Array-Repa-Algorithms-DFT-Center.html#center3d",
          "type": "function"
        },
        "index": {
          "description": "Apply the centering transform to array",
          "hierarchy": "Data Array Repa Algorithms DFT Center",
          "module": "Data.Array.Repa.Algorithms.DFT.Center",
          "name": "center3d",
          "normalized": "Array a DIM Complex-\u003eArray D DIM Complex",
          "package": "repa-algorithms",
          "signature": "Array r DIM Complex-\u003eArray D DIM Complex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT-Center.html#v:center3d"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCalculation of roots of unity for the forward and inverse DFT/FFT.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT.Roots",
          "name": "Roots",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-DFT-Roots.html",
          "type": "module"
        },
        "index": {
          "description": "Calculation of roots of unity for the forward and inverse DFT FFT",
          "hierarchy": "Data Array Repa Algorithms DFT Roots",
          "module": "Data.Array.Repa.Algorithms.DFT.Roots",
          "name": "Roots",
          "package": "repa-algorithms",
          "partial": "Roots",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT-Roots.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate roots of unity for the inverse transform.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT.Roots",
          "name": "calcInverseRootsOfUnityP",
          "package": "repa-algorithms",
          "signature": "(sh :. Int)-\u003e m (Array U (sh :. Int) Complex)",
          "type": "function"
        },
        "index": {
          "description": "Calculate roots of unity for the inverse transform",
          "hierarchy": "Data Array Repa Algorithms DFT Roots",
          "module": "Data.Array.Repa.Algorithms.DFT.Roots",
          "name": "calcInverseRootsOfUnityP",
          "normalized": "(a Int)-\u003eb(Array U(a Int)Complex)",
          "package": "repa-algorithms",
          "partial": "Inverse Roots Of Unity",
          "signature": "(sh Int)-\u003em(Array U(sh Int)Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT-Roots.html#v:calcInverseRootsOfUnityP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate roots of unity for the forward transform.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT.Roots",
          "name": "calcRootsOfUnityP",
          "package": "repa-algorithms",
          "signature": "(sh :. Int)-\u003e m (Array U (sh :. Int) Complex)",
          "type": "function"
        },
        "index": {
          "description": "Calculate roots of unity for the forward transform",
          "hierarchy": "Data Array Repa Algorithms DFT Roots",
          "module": "Data.Array.Repa.Algorithms.DFT.Roots",
          "name": "calcRootsOfUnityP",
          "normalized": "(a Int)-\u003eb(Array U(a Int)Complex)",
          "package": "repa-algorithms",
          "partial": "Roots Of Unity",
          "signature": "(sh Int)-\u003em(Array U(sh Int)Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT-Roots.html#v:calcRootsOfUnityP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompute the Discrete Fourier Transform (DFT) along the low order dimension\n   of an array. \n\u003c/p\u003e\u003cp\u003eThis uses the naive algorithm and takes O(n^2) time. \n   However, you can transform an array with an arbitray extent, unlike with FFT which requires\n   each dimension to be a power of two.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003edft\u003c/code\u003e and \u003ccode\u003eidft\u003c/code\u003e functions also compute the roots of unity needed.\n   If you need to transform several arrays with the same extent then it is faster to\n   compute the roots once using \u003ccode\u003ecalcRootsOfUnity\u003c/code\u003e or \u003ccode\u003ecalcInverseRootsOfUnity\u003c/code\u003e, \n   then call \u003ccode\u003edftWithRoots\u003c/code\u003e directly.\n\u003c/p\u003e\u003cp\u003eYou can also compute single values of the transform using \u003ccode\u003edftWithRootsSingle\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "DFT",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-DFT.html",
          "type": "module"
        },
        "index": {
          "description": "Compute the Discrete Fourier Transform DFT along the low order dimension of an array This uses the naive algorithm and takes time However you can transform an array with an arbitray extent unlike with FFT which requires each dimension to be power of two The dft and idft functions also compute the roots of unity needed If you need to transform several arrays with the same extent then it is faster to compute the roots once using calcRootsOfUnity or calcInverseRootsOfUnity then call dftWithRoots directly You can also compute single values of the transform using dftWithRootsSingle",
          "hierarchy": "Data Array Repa Algorithms DFT",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "DFT",
          "package": "repa-algorithms",
          "partial": "DFT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the DFT along the low order dimension of an array.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "dftP",
          "package": "repa-algorithms",
          "signature": "Array U (sh :. Int) Complex -\u003e m (Array U (sh :. Int) Complex)",
          "source": "src/Data-Array-Repa-Algorithms-DFT.html#dftP",
          "type": "function"
        },
        "index": {
          "description": "Compute the DFT along the low order dimension of an array",
          "hierarchy": "Data Array Repa Algorithms DFT",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "dftP",
          "normalized": "Array U(a Int)Complex-\u003eb(Array U(a Int)Complex)",
          "package": "repa-algorithms",
          "signature": "Array U(sh Int)Complex-\u003em(Array U(sh Int)Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT.html#v:dftP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric function for computation of forward or inverse DFT.\n\tThis function is also useful if you transform many arrays with the same extent, \n\tand don't want to recompute the roots for each one.\n\tThe extent of the given roots must match that of the input array, else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "dftWithRootsP",
          "package": "repa-algorithms",
          "signature": "Array U (sh :. Int) Complex-\u003e Array U (sh :. Int) Complex-\u003e m (Array U (sh :. Int) Complex)",
          "type": "function"
        },
        "index": {
          "description": "Generic function for computation of forward or inverse DFT This function is also useful if you transform many arrays with the same extent and don want to recompute the roots for each one The extent of the given roots must match that of the input array else error",
          "hierarchy": "Data Array Repa Algorithms DFT",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "dftWithRootsP",
          "normalized": "Array U(a Int)Complex-\u003eArray U(a Int)Complex-\u003eb(Array U(a Int)Complex)",
          "package": "repa-algorithms",
          "partial": "With Roots",
          "signature": "Array U(sh Int)Complex-\u003eArray U(sh Int)Complex-\u003em(Array U(sh Int)Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT.html#v:dftWithRootsP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a single value of the DFT.\n\tThe extent of the given roots must match that of the input array, else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "dftWithRootsSingleS",
          "package": "repa-algorithms",
          "signature": "Array U (sh :. Int) Complex-\u003e Array U (sh :. Int) Complex-\u003e (sh :. Int)-\u003e Complex",
          "type": "function"
        },
        "index": {
          "description": "Compute single value of the DFT The extent of the given roots must match that of the input array else error",
          "hierarchy": "Data Array Repa Algorithms DFT",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "dftWithRootsSingleS",
          "normalized": "Array U(a Int)Complex-\u003eArray U(a Int)Complex-\u003e(a Int)-\u003eComplex",
          "package": "repa-algorithms",
          "partial": "With Roots Single",
          "signature": "Array U(sh Int)Complex-\u003eArray U(sh Int)Complex-\u003e(sh Int)-\u003eComplex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT.html#v:dftWithRootsSingleS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the inverse DFT along the low order dimension of an array.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "idftP",
          "package": "repa-algorithms",
          "signature": "Array U (sh :. Int) Complex -\u003e m (Array U (sh :. Int) Complex)",
          "source": "src/Data-Array-Repa-Algorithms-DFT.html#idftP",
          "type": "function"
        },
        "index": {
          "description": "Compute the inverse DFT along the low order dimension of an array",
          "hierarchy": "Data Array Repa Algorithms DFT",
          "module": "Data.Array.Repa.Algorithms.DFT",
          "name": "idftP",
          "normalized": "Array U(a Int)Complex-\u003eb(Array U(a Int)Complex)",
          "package": "repa-algorithms",
          "signature": "Array U(sh Int)Complex-\u003em(Array U(sh Int)Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-DFT.html#v:idftP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFast computation of Discrete Fourier Transforms using the Cooley-Tuckey algorithm. \n   Time complexity is O(n log n) in the size of the input. \n\u003c/p\u003e\u003cp\u003eThis uses a naive divide-and-conquer algorithm, the absolute performance is about\n   50x slower than FFTW in estimate mode.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "FFT",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html",
          "type": "module"
        },
        "index": {
          "description": "Fast computation of Discrete Fourier Transforms using the Cooley-Tuckey algorithm Time complexity is log in the size of the input This uses naive divide-and-conquer algorithm the absolute performance is about slower than FFTW in estimate mode",
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "FFT",
          "package": "repa-algorithms",
          "partial": "FFT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Mode",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#Mode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Mode",
          "package": "repa-algorithms",
          "partial": "Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#t:Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Forward",
          "package": "repa-algorithms",
          "signature": "Forward",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Forward",
          "package": "repa-algorithms",
          "partial": "Forward",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#v:Forward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Inverse",
          "package": "repa-algorithms",
          "signature": "Inverse",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Inverse",
          "package": "repa-algorithms",
          "partial": "Inverse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#v:Inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Reverse",
          "package": "repa-algorithms",
          "signature": "Reverse",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "Reverse",
          "package": "repa-algorithms",
          "partial": "Reverse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#v:Reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the DFT of a vector. Array dimensions must be powers of two else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "fft1dP",
          "package": "repa-algorithms",
          "signature": "Mode -\u003e Array r DIM1 Complex -\u003e m (Array U DIM1 Complex)",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#fft1dP",
          "type": "function"
        },
        "index": {
          "description": "Compute the DFT of vector Array dimensions must be powers of two else error",
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "fft1dP",
          "normalized": "Mode-\u003eArray a DIM Complex-\u003eb(Array U DIM Complex)",
          "package": "repa-algorithms",
          "signature": "Mode-\u003eArray r DIM Complex-\u003em(Array U DIM Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#v:fft1dP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the DFT of a matrix. Array dimensions must be powers of two else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "fft2dP",
          "package": "repa-algorithms",
          "signature": "Mode -\u003e Array r DIM2 Complex -\u003e m (Array U DIM2 Complex)",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#fft2dP",
          "type": "function"
        },
        "index": {
          "description": "Compute the DFT of matrix Array dimensions must be powers of two else error",
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "fft2dP",
          "normalized": "Mode-\u003eArray a DIM Complex-\u003eb(Array U DIM Complex)",
          "package": "repa-algorithms",
          "signature": "Mode-\u003eArray r DIM Complex-\u003em(Array U DIM Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#v:fft2dP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the DFT of a 3d array. Array dimensions must be powers of two else \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "fft3dP",
          "package": "repa-algorithms",
          "signature": "Mode -\u003e Array r DIM3 Complex -\u003e m (Array U DIM3 Complex)",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#fft3dP",
          "type": "function"
        },
        "index": {
          "description": "Compute the DFT of array Array dimensions must be powers of two else error",
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "fft3dP",
          "normalized": "Mode-\u003eArray a DIM Complex-\u003eb(Array U DIM Complex)",
          "package": "repa-algorithms",
          "signature": "Mode-\u003eArray r DIM Complex-\u003em(Array U DIM Complex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#v:fft3dP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e is a power of two.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "isPowerOfTwo",
          "package": "repa-algorithms",
          "signature": "Int -\u003e Bool",
          "source": "src/Data-Array-Repa-Algorithms-FFT.html#isPowerOfTwo",
          "type": "function"
        },
        "index": {
          "description": "Check if an Int is power of two",
          "hierarchy": "Data Array Repa Algorithms FFT",
          "module": "Data.Array.Repa.Algorithms.FFT",
          "name": "isPowerOfTwo",
          "normalized": "Int-\u003eBool",
          "package": "repa-algorithms",
          "partial": "Power Of Two",
          "signature": "Int-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-FFT.html#v:isPowerOfTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgorithms operating on matrices.\n\u003c/p\u003e\u003cp\u003eThese functions should give performance comparable with nested loop C\n   implementations. \n\u003c/p\u003e\u003cp\u003eIf you care deeply about runtime performance then you\n   may be better off using a binding to LAPACK, such as hvector.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "Matrix",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html",
          "type": "module"
        },
        "index": {
          "description": "Algorithms operating on matrices These functions should give performance comparable with nested loop implementations If you care deeply about runtime performance then you may be better off using binding to LAPACK such as hvector",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "Matrix",
          "package": "repa-algorithms",
          "partial": "Matrix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the column number of a rank-2 index.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "col",
          "package": "repa-algorithms",
          "signature": "DIM2 -\u003e Int",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#col",
          "type": "function"
        },
        "index": {
          "description": "Take the column number of rank-2 index",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "col",
          "normalized": "DIM-\u003eInt",
          "package": "repa-algorithms",
          "signature": "DIM-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:col"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix matrix multiply, in parallel.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "mmultP",
          "package": "repa-algorithms",
          "signature": "Array U DIM2 Double -\u003e Array U DIM2 Double -\u003e m (Array U DIM2 Double)",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#mmultP",
          "type": "function"
        },
        "index": {
          "description": "Matrix matrix multiply in parallel",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "mmultP",
          "normalized": "Array U DIM Double-\u003eArray U DIM Double-\u003ea(Array U DIM Double)",
          "package": "repa-algorithms",
          "signature": "Array U DIM Double-\u003eArray U DIM Double-\u003em(Array U DIM Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:mmultP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix matrix multiply, sequentially.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "mmultS",
          "package": "repa-algorithms",
          "signature": "Array U DIM2 Double -\u003e Array U DIM2 Double -\u003e Array U DIM2 Double",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#mmultS",
          "type": "function"
        },
        "index": {
          "description": "Matrix matrix multiply sequentially",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "mmultS",
          "normalized": "Array U DIM Double-\u003eArray U DIM Double-\u003eArray U DIM Double",
          "package": "repa-algorithms",
          "signature": "Array U DIM Double-\u003eArray U DIM Double-\u003eArray U DIM Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:mmultS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the row number of a rank-2 index.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "row",
          "package": "repa-algorithms",
          "signature": "DIM2 -\u003e Int",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#row",
          "type": "function"
        },
        "index": {
          "description": "Take the row number of rank-2 index",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "row",
          "normalized": "DIM-\u003eInt",
          "package": "repa-algorithms",
          "signature": "DIM-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:row"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the trace of a (square) 2D matrix, in parallel.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "trace2P",
          "package": "repa-algorithms",
          "signature": "Array U DIM2 Double -\u003e m Double",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#trace2P",
          "type": "function"
        },
        "index": {
          "description": "Get the trace of square matrix in parallel",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "trace2P",
          "normalized": "Array U DIM Double-\u003ea Double",
          "package": "repa-algorithms",
          "signature": "Array U DIM Double-\u003em Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:trace2P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the trace of a (square) 2D matrix, sequentially.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "trace2S",
          "package": "repa-algorithms",
          "signature": "Array U DIM2 Double -\u003e Double",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#trace2S",
          "type": "function"
        },
        "index": {
          "description": "Get the trace of square matrix sequentially",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "trace2S",
          "normalized": "Array U DIM Double-\u003eDouble",
          "package": "repa-algorithms",
          "signature": "Array U DIM Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:trace2S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose a 2D matrix, in parallel.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "transpose2P",
          "package": "repa-algorithms",
          "signature": "Array U DIM2 Double -\u003e m (Array U DIM2 Double)",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#transpose2P",
          "type": "function"
        },
        "index": {
          "description": "Transpose matrix in parallel",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "transpose2P",
          "normalized": "Array U DIM Double-\u003ea(Array U DIM Double)",
          "package": "repa-algorithms",
          "signature": "Array U DIM Double-\u003em(Array U DIM Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:transpose2P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose a 2D matrix, sequentially.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "transpose2S",
          "package": "repa-algorithms",
          "signature": "Array U DIM2 Double -\u003e Array U DIM2 Double",
          "source": "src/Data-Array-Repa-Algorithms-Matrix.html#transpose2S",
          "type": "function"
        },
        "index": {
          "description": "Transpose matrix sequentially",
          "hierarchy": "Data Array Repa Algorithms Matrix",
          "module": "Data.Array.Repa.Algorithms.Matrix",
          "name": "transpose2S",
          "normalized": "Array U DIM Double-\u003eArray U DIM Double",
          "package": "repa-algorithms",
          "signature": "Array U DIM Double-\u003eArray U DIM Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Matrix.html#v:transpose2S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for converting pixel color values.\n\u003c/p\u003e\u003cp\u003eNOTE: These functions are not polymorphic in the Float type because\n       without assisatance, GHC does a bad job of converting Word8s \n       to and from floats. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "Pixel",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for converting pixel color values NOTE These functions are not polymorphic in the Float type because without assisatance GHC does bad job of converting Word8s to and from floats",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "Pixel",
          "package": "repa-algorithms",
          "partial": "Pixel",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an RGB color to its luminance value. Result in the range [0..1].\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "doubleLuminanceOfRGB8",
          "package": "repa-algorithms",
          "signature": "(Word8, Word8, Word8) -\u003e Double",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#doubleLuminanceOfRGB8",
          "type": "function"
        },
        "index": {
          "description": "Convert an RGB color to its luminance value Result in the range",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "doubleLuminanceOfRGB8",
          "normalized": "(Word,Word,Word)-\u003eDouble",
          "package": "repa-algorithms",
          "partial": "Luminance Of RGB",
          "signature": "(Word,Word,Word)-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:doubleLuminanceOfRGB8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the root mean square of an RGB color. Result is in the range [0..1].\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "doubleRmsOfRGB8",
          "package": "repa-algorithms",
          "signature": "(Word8, Word8, Word8) -\u003e Float",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#doubleRmsOfRGB8",
          "type": "function"
        },
        "index": {
          "description": "Compute the root mean square of an RGB color Result is in the range",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "doubleRmsOfRGB8",
          "normalized": "(Word,Word,Word)-\u003eFloat",
          "package": "repa-algorithms",
          "partial": "Rms Of RGB",
          "signature": "(Word,Word,Word)-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:doubleRmsOfRGB8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an RGB color to its luminance value. Result in the range [0..1].\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "floatLuminanceOfRGB8",
          "package": "repa-algorithms",
          "signature": "(Word8, Word8, Word8) -\u003e Float",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#floatLuminanceOfRGB8",
          "type": "function"
        },
        "index": {
          "description": "Convert an RGB color to its luminance value Result in the range",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "floatLuminanceOfRGB8",
          "normalized": "(Word,Word,Word)-\u003eFloat",
          "package": "repa-algorithms",
          "partial": "Luminance Of RGB",
          "signature": "(Word,Word,Word)-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:floatLuminanceOfRGB8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the root mean square of an RGB color. Result is in the range [0..1].\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "floatRmsOfRGB8",
          "package": "repa-algorithms",
          "signature": "(Word8, Word8, Word8) -\u003e Float",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#floatRmsOfRGB8",
          "type": "function"
        },
        "index": {
          "description": "Compute the root mean square of an RGB color Result is in the range",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "floatRmsOfRGB8",
          "normalized": "(Word,Word,Word)-\u003eFloat",
          "package": "repa-algorithms",
          "partial": "Rms Of RGB",
          "signature": "(Word,Word,Word)-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:floatRmsOfRGB8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a tuple of color components to a RGB8 color. \n   Each of the source components should be in the range [0..1].\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfDouble",
          "package": "repa-algorithms",
          "signature": "(Double, Double, Double) -\u003e (Word8, Word8, Word8)",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#rgb8OfDouble",
          "type": "function"
        },
        "index": {
          "description": "Promote tuple of color components to RGB8 color Each of the source components should be in the range",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfDouble",
          "normalized": "(Double,Double,Double)-\u003e(Word,Word,Word)",
          "package": "repa-algorithms",
          "partial": "Of Double",
          "signature": "(Double,Double,Double)-\u003e(Word,Word,Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:rgb8OfDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a tuple of color components to a RGB8 color. \n   Each of the source components should be in the range [0..1].\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfFloat",
          "package": "repa-algorithms",
          "signature": "(Float, Float, Float) -\u003e (Word8, Word8, Word8)",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#rgb8OfFloat",
          "type": "function"
        },
        "index": {
          "description": "Promote tuple of color components to RGB8 color Each of the source components should be in the range",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfFloat",
          "normalized": "(Float,Float,Float)-\u003e(Word,Word,Word)",
          "package": "repa-algorithms",
          "partial": "Of Float",
          "signature": "(Float,Float,Float)-\u003e(Word,Word,Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:rgb8OfFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a value in the range [0..1] to a grey RGB8 color.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfGreyDouble",
          "package": "repa-algorithms",
          "signature": "Double -\u003e (Word8, Word8, Word8)",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#rgb8OfGreyDouble",
          "type": "function"
        },
        "index": {
          "description": "Promote value in the range to grey RGB8 color",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfGreyDouble",
          "normalized": "Double-\u003e(Word,Word,Word)",
          "package": "repa-algorithms",
          "partial": "Of Grey Double",
          "signature": "Double-\u003e(Word,Word,Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:rgb8OfGreyDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote a value in the range [0..1] to a grey RGB8 color.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfGreyFloat",
          "package": "repa-algorithms",
          "signature": "Float -\u003e (Word8, Word8, Word8)",
          "source": "src/Data-Array-Repa-Algorithms-Pixel.html#rgb8OfGreyFloat",
          "type": "function"
        },
        "index": {
          "description": "Promote value in the range to grey RGB8 color",
          "hierarchy": "Data Array Repa Algorithms Pixel",
          "module": "Data.Array.Repa.Algorithms.Pixel",
          "name": "rgb8OfGreyFloat",
          "normalized": "Float-\u003e(Word,Word,Word)",
          "package": "repa-algorithms",
          "partial": "Of Grey Float",
          "signature": "Float-\u003e(Word,Word,Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Pixel.html#v:rgb8OfGreyFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "Randomish",
          "package": "repa-algorithms",
          "source": "src/Data-Array-Repa-Algorithms-Randomish.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Array Repa Algorithms Randomish",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "Randomish",
          "package": "repa-algorithms",
          "partial": "Randomish",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Randomish.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate some randomish doubles with terrible statistical properties.\n   This just takes randomish ints then scales them, so there's not much randomness in low-order bits.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishDoubleArray",
          "package": "repa-algorithms",
          "signature": "sh-\u003e Double-\u003e Double-\u003e Int-\u003e Array U sh Double",
          "type": "function"
        },
        "index": {
          "description": "Generate some randomish doubles with terrible statistical properties This just takes randomish ints then scales them so there not much randomness in low-order bits",
          "hierarchy": "Data Array Repa Algorithms Randomish",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishDoubleArray",
          "normalized": "a-\u003eDouble-\u003eDouble-\u003eInt-\u003eArray U a Double",
          "package": "repa-algorithms",
          "partial": "Double Array",
          "signature": "sh-\u003eDouble-\u003eDouble-\u003eInt-\u003eArray U sh Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Randomish.html#v:randomishDoubleArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate some randomish doubles with terrible statistical properties.\n   This just takes randmish ints then scales them, so there's not much randomness in low-order bits.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishDoubleVector",
          "package": "repa-algorithms",
          "signature": "Int-\u003e Double-\u003e Double-\u003e Int-\u003e Vector Double",
          "type": "function"
        },
        "index": {
          "description": "Generate some randomish doubles with terrible statistical properties This just takes randmish ints then scales them so there not much randomness in low-order bits",
          "hierarchy": "Data Array Repa Algorithms Randomish",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishDoubleVector",
          "normalized": "Int-\u003eDouble-\u003eDouble-\u003eInt-\u003eVector Double",
          "package": "repa-algorithms",
          "partial": "Double Vector",
          "signature": "Int-\u003eDouble-\u003eDouble-\u003eInt-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Randomish.html#v:randomishDoubleVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the ''minimal standard'' Lehmer generator to quickly generate some random\n   numbers with reasonable statistical properties. By ''reasonable'' we mean good\n   enough for games and test data, but not cryptography or anything where the\n   quality of the randomness really matters. \n\u003c/p\u003e\u003cp\u003eBy nature of the algorithm, the maximum value in the output is clipped\n   to (valMin + 2^31 - 1)\n\u003c/p\u003e\u003cp\u003eFrom ''Random Number Generators: Good ones are hard to find''\n   Stephen K. Park and Keith W. Miller.\n   Communications of the ACM, Oct 1988, Volume 31, Number 10.\n\u003c/p\u003e",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishIntArray",
          "package": "repa-algorithms",
          "signature": "sh-\u003e Int-\u003e Int-\u003e Int-\u003e Array U sh Int",
          "type": "function"
        },
        "index": {
          "description": "Use the minimal standard Lehmer generator to quickly generate some random numbers with reasonable statistical properties By reasonable we mean good enough for games and test data but not cryptography or anything where the quality of the randomness really matters By nature of the algorithm the maximum value in the output is clipped to valMin From Random Number Generators Good ones are hard to find Stephen Park and Keith Miller Communications of the ACM Oct Volume Number",
          "hierarchy": "Data Array Repa Algorithms Randomish",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishIntArray",
          "normalized": "a-\u003eInt-\u003eInt-\u003eInt-\u003eArray U a Int",
          "package": "repa-algorithms",
          "partial": "Int Array",
          "signature": "sh-\u003eInt-\u003eInt-\u003eInt-\u003eArray U sh Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Randomish.html#v:randomishIntArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishIntVector",
          "package": "repa-algorithms",
          "signature": "Int-\u003e Int-\u003e Int-\u003e Int-\u003e Vector Int",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Array Repa Algorithms Randomish",
          "module": "Data.Array.Repa.Algorithms.Randomish",
          "name": "randomishIntVector",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eInt-\u003eVector Int",
          "package": "repa-algorithms",
          "partial": "Int Vector",
          "signature": "Int-\u003eInt-\u003eInt-\u003eInt-\u003eVector Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/repa-algorithms/docs/Data-Array-Repa-Algorithms-Randomish.html#v:randomishIntVector"
      }
    }
  ]
]