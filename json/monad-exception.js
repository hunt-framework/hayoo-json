[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "monad-exception"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is intended as a drop-in replacement for \u003ca\u003eControl.Exception\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Exception.Monadic",
          "name": "Monadic",
          "package": "monad-exception",
          "source": "src/Control-Exception-Monadic.html",
          "type": "module"
        },
        "index": {
          "description": "This module is intended as drop-in replacement for Control.Exception",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Monadic",
          "package": "monad-exception",
          "partial": "Monadic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArithmetic exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "ArithException",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "Arithmetic exceptions",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "ArithException",
          "package": "monad-exception",
          "partial": "Arith Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:ArithException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions generated by array operations\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "ArrayException",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "Exceptions generated by array operations",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "ArrayException",
          "package": "monad-exception",
          "partial": "Array Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:ArrayException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eassert\u003c/a\u003e\u003c/code\u003e was applied to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "AssertionFailed",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "assert was applied to False",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "AssertionFailed",
          "package": "monad-exception",
          "partial": "Assertion Failed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:AssertionFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAsynchronous exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "AsyncException",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "Asynchronous exceptions",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "AsyncException",
          "package": "monad-exception",
          "partial": "Async Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:AsyncException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is blocked on an \u003ccode\u003eMVar\u003c/code\u003e, but there are no other references\n to the \u003ccode\u003eMVar\u003c/code\u003e so it can't ever continue.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "The thread is blocked on an MVar but there are no other references to the MVar so it can ever continue",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "monad-exception",
          "partial": "Blocked Indefinitely On MVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:BlockedIndefinitelyOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is waiting to retry an STM transaction, but there are no\n other references to any \u003ccode\u003eTVar\u003c/code\u003es involved, so it can't ever continue.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "The thread is waiting to retry an STM transaction but there are no other references to any TVar involved so it can ever continue",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "monad-exception",
          "partial": "Blocked Indefinitely On STM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:BlockedIndefinitelyOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are no runnable threads, so the program is deadlocked.\n The \u003ccode\u003eDeadlock\u003c/code\u003e exception is raised in the main thread only.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "Deadlock",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "There are no runnable threads so the program is deadlocked The Deadlock exception is raised in the main thread only",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Deadlock",
          "package": "monad-exception",
          "partial": "Deadlock",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:Deadlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is thrown when the user calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e. The \u003ccode\u003eString\u003c/code\u003e is the\n argument given to \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "ErrorCall",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "This is thrown when the user calls error The String is the argument given to error",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "ErrorCall",
          "package": "monad-exception",
          "partial": "Error Call",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:ErrorCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny type that you wish to throw or catch as an exception must be an\ninstance of the \u003ccode\u003eException\u003c/code\u003e class. The simplest case is a new exception\ntype directly below the root:\n\u003c/p\u003e\u003cpre\u003e data MyException = ThisException | ThatException\n     deriving (Show, Typeable)\n\n instance Exception MyException\n\u003c/pre\u003e\u003cp\u003eThe default method definitions in the \u003ccode\u003eException\u003c/code\u003e class do what we need\nin this case. You can now throw and catch \u003ccode\u003eThisException\u003c/code\u003e and\n\u003ccode\u003eThatException\u003c/code\u003e as exceptions:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw ThisException `catch` \\e -\u003e putStrLn (\"Caught \" ++ show (e :: MyException))\nCaught ThisException\n\u003c/pre\u003e\u003cp\u003eIn more complicated examples, you may wish to define a whole hierarchy\nof exceptions:\n\u003c/p\u003e\u003cpre\u003e ---------------------------------------------------------------------\n -- Make the root exception type for all the exceptions in a compiler\n\n data SomeCompilerException = forall e . Exception e =\u003e SomeCompilerException e\n     deriving Typeable\n\n instance Show SomeCompilerException where\n     show (SomeCompilerException e) = show e\n\n instance Exception SomeCompilerException\n\n compilerExceptionToException :: Exception e =\u003e e -\u003e SomeException\n compilerExceptionToException = toException . SomeCompilerException\n\n compilerExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n compilerExceptionFromException x = do\n     SomeCompilerException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make a subhierarchy for exceptions in the frontend of the compiler\n\n data SomeFrontendException = forall e . Exception e =\u003e SomeFrontendException e\n     deriving Typeable\n\n instance Show SomeFrontendException where\n     show (SomeFrontendException e) = show e\n\n instance Exception SomeFrontendException where\n     toException = compilerExceptionToException\n     fromException = compilerExceptionFromException\n\n frontendExceptionToException :: Exception e =\u003e e -\u003e SomeException\n frontendExceptionToException = toException . SomeFrontendException\n\n frontendExceptionFromException :: Exception e =\u003e SomeException -\u003e Maybe e\n frontendExceptionFromException x = do\n     SomeFrontendException a \u003c- fromException x\n     cast a\n\n ---------------------------------------------------------------------\n -- Make an exception type for a particular frontend compiler exception\n\n data MismatchedParentheses = MismatchedParentheses\n     deriving (Typeable, Show)\n\n instance Exception MismatchedParentheses where\n     toException   = frontendExceptionToException\n     fromException = frontendExceptionFromException\n\u003c/pre\u003e\u003cp\u003eWe can now catch a \u003ccode\u003eMismatchedParentheses\u003c/code\u003e exception as\n\u003ccode\u003eMismatchedParentheses\u003c/code\u003e, \u003ccode\u003eSomeFrontendException\u003c/code\u003e or\n\u003ccode\u003eSomeCompilerException\u003c/code\u003e, but not other types, e.g. \u003ccode\u003eIOException\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: MismatchedParentheses))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeFrontendException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: SomeCompilerException))\nCaught MismatchedParentheses\n*Main\u003e throw MismatchedParentheses \u003ccode\u003ecatch\u003c/code\u003e e -\u003e putStrLn (\"Caught \" ++ show (e :: IOException))\n*** Exception: MismatchedParentheses\n\u003c/pre\u003e",
          "module": "Control.Exception.Monadic",
          "name": "Exception",
          "package": "monad-exception",
          "type": "class"
        },
        "index": {
          "description": "Any type that you wish to throw or catch as an exception must be an instance of the Exception class The simplest case is new exception type directly below the root data MyException ThisException ThatException deriving Show Typeable instance Exception MyException The default method definitions in the Exception class do what we need in this case You can now throw and catch ThisException and ThatException as exceptions Main throw ThisException catch putStrLn Caught show MyException Caught ThisException In more complicated examples you may wish to define whole hierarchy of exceptions Make the root exception type for all the exceptions in compiler data SomeCompilerException forall Exception SomeCompilerException deriving Typeable instance Show SomeCompilerException where show SomeCompilerException show instance Exception SomeCompilerException compilerExceptionToException Exception SomeException compilerExceptionToException toException SomeCompilerException compilerExceptionFromException Exception SomeException Maybe compilerExceptionFromException do SomeCompilerException fromException cast Make subhierarchy for exceptions in the frontend of the compiler data SomeFrontendException forall Exception SomeFrontendException deriving Typeable instance Show SomeFrontendException where show SomeFrontendException show instance Exception SomeFrontendException where toException compilerExceptionToException fromException compilerExceptionFromException frontendExceptionToException Exception SomeException frontendExceptionToException toException SomeFrontendException frontendExceptionFromException Exception SomeException Maybe frontendExceptionFromException do SomeFrontendException fromException cast Make an exception type for particular frontend compiler exception data MismatchedParentheses MismatchedParentheses deriving Typeable Show instance Exception MismatchedParentheses where toException frontendExceptionToException fromException frontendExceptionFromException We can now catch MismatchedParentheses exception as MismatchedParentheses SomeFrontendException or SomeCompilerException but not other types e.g IOException Main throw MismatchedParentheses catch putStrLn Caught show MismatchedParentheses Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeFrontendException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show SomeCompilerException Caught MismatchedParentheses Main throw MismatchedParentheses catch putStrLn Caught show IOException Exception MismatchedParentheses",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Exception",
          "package": "monad-exception",
          "partial": "Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:Exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e. You need this when using \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "Handler",
          "package": "monad-exception",
          "source": "src/Control-Exception-Monadic.html#Handler",
          "type": "data"
        },
        "index": {
          "description": "Generalized version of Handler You need this when using catches",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Handler",
          "package": "monad-exception",
          "partial": "Handler",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:Handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions that occur in the \u003ccode\u003eIO\u003c/code\u003e monad.\n An \u003ccode\u003eIOException\u003c/code\u003e records a more specific error type, a descriptive\n string and maybe the handle that was used when the error was\n flagged.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "IOException",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "Exceptions that occur in the IO monad An IOException records more specific error type descriptive string and maybe the handle that was used when the error was flagged",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "IOException",
          "package": "monad-exception",
          "partial": "IOException",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:IOException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the behaviour of a thread when an asynchronous\n exception is received.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "MaskingState",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "Describes the behaviour of thread when an asynchronous exception is received",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "MaskingState",
          "package": "monad-exception",
          "partial": "Masking State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:MaskingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMonadException\u003c/a\u003e\u003c/code\u003e type class. Minimal complete definition: \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "MonadException",
          "package": "monad-exception",
          "source": "src/Control-Monad-Exception-Class.html#MonadException",
          "type": "class"
        },
        "index": {
          "description": "The MonadException type class Minimal complete definition throw catch",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "MonadException",
          "package": "monad-exception",
          "partial": "Monad Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:MonadException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the program attempts to call \u003ccode\u003eatomically\u003c/code\u003e, from the \u003ccode\u003estm\u003c/code\u003e\n package, inside another call to \u003ccode\u003eatomically\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "NestedAtomically",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "Thrown when the program attempts to call atomically from the stm package inside another call to atomically",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "NestedAtomically",
          "package": "monad-exception",
          "partial": "Nested Atomically",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:NestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class method without a definition (neither a default definition,\n nor a definition in the appropriate instance) was called. The\n \u003ccode\u003eString\u003c/code\u003e gives information about which method it was.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "NoMethodError",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "class method without definition neither default definition nor definition in the appropriate instance was called The String gives information about which method it was",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "NoMethodError",
          "package": "monad-exception",
          "partial": "No Method Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:NoMethodError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the runtime system detects that the computation is\n guaranteed not to terminate. Note that there is no guarantee that\n the runtime system will notice whether any given computation is\n guaranteed to terminate or not.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "NonTermination",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "Thrown when the runtime system detects that the computation is guaranteed not to terminate Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "NonTermination",
          "package": "monad-exception",
          "partial": "Non Termination",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:NonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern match failed. The \u003ccode\u003eString\u003c/code\u003e gives information about the\n source location of the pattern.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "PatternMatchFail",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "pattern match failed The String gives information about the source location of the pattern",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "PatternMatchFail",
          "package": "monad-exception",
          "partial": "Pattern Match Fail",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:PatternMatchFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn uninitialised record field was used. The \u003ccode\u003eString\u003c/code\u003e gives\n information about the source location where the record was\n constructed.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "RecConError",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "An uninitialised record field was used The String gives information about the source location where the record was constructed",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "RecConError",
          "package": "monad-exception",
          "partial": "Rec Con Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:RecConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record selector was applied to a constructor without the\n appropriate field. This can only happen with a datatype with\n multiple constructors, where some fields are in one constructor\n but not another. The \u003ccode\u003eString\u003c/code\u003e gives information about the source\n location of the record selector.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "RecSelError",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "record selector was applied to constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another The String gives information about the source location of the record selector",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "RecSelError",
          "package": "monad-exception",
          "partial": "Rec Sel Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:RecSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record update was performed on a constructor without the\n appropriate field. This can only happen with a datatype with\n multiple constructors, where some fields are in one constructor\n but not another. The \u003ccode\u003eString\u003c/code\u003e gives information about the source\n location of the record update.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "RecUpdError",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "record update was performed on constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another The String gives information about the source location of the record update",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "RecUpdError",
          "package": "monad-exception",
          "partial": "Rec Upd Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:RecUpdError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eSomeException\u003c/code\u003e type is the root of the exception type hierarchy.\nWhen an exception of type \u003ccode\u003ee\u003c/code\u003e is thrown, behind the scenes it is\nencapsulated in a \u003ccode\u003eSomeException\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "SomeException",
          "package": "monad-exception",
          "type": "data"
        },
        "index": {
          "description": "The SomeException type is the root of the exception type hierarchy When an exception of type is thrown behind the scenes it is encapsulated in SomeException",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "SomeException",
          "package": "monad-exception",
          "partial": "Some Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#t:SomeException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "AssertionFailed",
          "package": "monad-exception",
          "signature": "AssertionFailed String",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "AssertionFailed",
          "package": "monad-exception",
          "partial": "Assertion Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:AssertionFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "monad-exception",
          "signature": "BlockedIndefinitelyOnMVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnMVar",
          "package": "monad-exception",
          "partial": "Blocked Indefinitely On MVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:BlockedIndefinitelyOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "monad-exception",
          "signature": "BlockedIndefinitelyOnSTM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "BlockedIndefinitelyOnSTM",
          "package": "monad-exception",
          "partial": "Blocked Indefinitely On STM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:BlockedIndefinitelyOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "Deadlock",
          "package": "monad-exception",
          "signature": "Deadlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Deadlock",
          "package": "monad-exception",
          "partial": "Deadlock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:Deadlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "Denormal",
          "package": "monad-exception",
          "signature": "Denormal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Denormal",
          "package": "monad-exception",
          "partial": "Denormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:Denormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "DivideByZero",
          "package": "monad-exception",
          "signature": "DivideByZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "DivideByZero",
          "package": "monad-exception",
          "partial": "Divide By Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:DivideByZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "ErrorCall",
          "package": "monad-exception",
          "signature": "ErrorCall String",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "ErrorCall",
          "package": "monad-exception",
          "partial": "Error Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:ErrorCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "Handler",
          "package": "monad-exception",
          "signature": "Handler (e -\u003e m a)",
          "source": "src/Control-Exception-Monadic.html#Handler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Handler",
          "normalized": "Handler(a-\u003eb c)",
          "package": "monad-exception",
          "partial": "Handler",
          "signature": "Handler(e-\u003em a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:Handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe program's heap is reaching its limit, and\n the program should take action to reduce the amount of\n live data it has. Notes:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e It is undefined which thread receives this exception.\n\u003c/li\u003e\u003cli\u003e GHC currently does not throw \u003ccode\u003e\u003ca\u003eHeapOverflow\u003c/a\u003e\u003c/code\u003e exceptions.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Exception.Monadic",
          "name": "HeapOverflow",
          "package": "monad-exception",
          "signature": "HeapOverflow",
          "type": "function"
        },
        "index": {
          "description": "The program heap is reaching its limit and the program should take action to reduce the amount of live data it has Notes It is undefined which thread receives this exception GHC currently does not throw HeapOverflow exceptions",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "HeapOverflow",
          "package": "monad-exception",
          "partial": "Heap Overflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:HeapOverflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attempt was made to index an array outside\n its declared bounds.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "IndexOutOfBounds",
          "package": "monad-exception",
          "signature": "IndexOutOfBounds String",
          "type": "function"
        },
        "index": {
          "description": "An attempt was made to index an array outside its declared bounds",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "IndexOutOfBounds",
          "package": "monad-exception",
          "partial": "Index Out Of Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:IndexOutOfBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "LossOfPrecision",
          "package": "monad-exception",
          "signature": "LossOfPrecision",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "LossOfPrecision",
          "package": "monad-exception",
          "partial": "Loss Of Precision",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:LossOfPrecision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe state during \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e: asynchronous exceptions are masked, but blocking operations may still be interrupted\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "MaskedInterruptible",
          "package": "monad-exception",
          "signature": "MaskedInterruptible",
          "type": "function"
        },
        "index": {
          "description": "the state during mask asynchronous exceptions are masked but blocking operations may still be interrupted",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "MaskedInterruptible",
          "package": "monad-exception",
          "partial": "Masked Interruptible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:MaskedInterruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe state during \u003ccode\u003e\u003ca\u003euninterruptibleMask\u003c/a\u003e\u003c/code\u003e: asynchronous exceptions are masked, and blocking operations may not be interrupted\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "MaskedUninterruptible",
          "package": "monad-exception",
          "signature": "MaskedUninterruptible",
          "type": "function"
        },
        "index": {
          "description": "the state during uninterruptibleMask asynchronous exceptions are masked and blocking operations may not be interrupted",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "MaskedUninterruptible",
          "package": "monad-exception",
          "partial": "Masked Uninterruptible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:MaskedUninterruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "NestedAtomically",
          "package": "monad-exception",
          "signature": "NestedAtomically",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "NestedAtomically",
          "package": "monad-exception",
          "partial": "Nested Atomically",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:NestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "NoMethodError",
          "package": "monad-exception",
          "signature": "NoMethodError String",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "NoMethodError",
          "package": "monad-exception",
          "partial": "No Method Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:NoMethodError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "NonTermination",
          "package": "monad-exception",
          "signature": "NonTermination",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "NonTermination",
          "package": "monad-exception",
          "partial": "Non Termination",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:NonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "Overflow",
          "package": "monad-exception",
          "signature": "Overflow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Overflow",
          "package": "monad-exception",
          "partial": "Overflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:Overflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "PatternMatchFail",
          "package": "monad-exception",
          "signature": "PatternMatchFail String",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "PatternMatchFail",
          "package": "monad-exception",
          "partial": "Pattern Match Fail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:PatternMatchFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "RecConError",
          "package": "monad-exception",
          "signature": "RecConError String",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "RecConError",
          "package": "monad-exception",
          "partial": "Rec Con Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:RecConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "RecSelError",
          "package": "monad-exception",
          "signature": "RecSelError String",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "RecSelError",
          "package": "monad-exception",
          "partial": "Rec Sel Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:RecSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "RecUpdError",
          "package": "monad-exception",
          "signature": "RecUpdError String",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "RecUpdError",
          "package": "monad-exception",
          "partial": "Rec Upd Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:RecUpdError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "SomeException",
          "package": "monad-exception",
          "signature": "e -\u003e SomeException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "SomeException",
          "normalized": "a-\u003eSomeException",
          "package": "monad-exception",
          "partial": "Some Exception",
          "signature": "e-\u003eSomeException",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:SomeException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current thread's stack exceeded its limit.\n Since an exception has been raised, the thread's stack\n will certainly be below its limit again, but the\n programmer should take remedial action\n immediately.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "StackOverflow",
          "package": "monad-exception",
          "signature": "StackOverflow",
          "type": "function"
        },
        "index": {
          "description": "The current thread stack exceeded its limit Since an exception has been raised the thread stack will certainly be below its limit again but the programmer should take remedial action immediately",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "StackOverflow",
          "package": "monad-exception",
          "partial": "Stack Overflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:StackOverflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis exception is raised by another thread\n calling \u003ccode\u003e\u003ca\u003ekillThread\u003c/a\u003e\u003c/code\u003e, or by the system\n if it needs to terminate the thread for some\n reason.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "ThreadKilled",
          "package": "monad-exception",
          "signature": "ThreadKilled",
          "type": "function"
        },
        "index": {
          "description": "This exception is raised by another thread calling killThread or by the system if it needs to terminate the thread for some reason",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "ThreadKilled",
          "package": "monad-exception",
          "partial": "Thread Killed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:ThreadKilled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attempt was made to evaluate an element of an\n array that had not been initialized.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "UndefinedElement",
          "package": "monad-exception",
          "signature": "UndefinedElement String",
          "type": "function"
        },
        "index": {
          "description": "An attempt was made to evaluate an element of an array that had not been initialized",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "UndefinedElement",
          "package": "monad-exception",
          "partial": "Undefined Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:UndefinedElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "Underflow",
          "package": "monad-exception",
          "signature": "Underflow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Underflow",
          "package": "monad-exception",
          "partial": "Underflow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:Underflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003easynchronous exceptions are unmasked (the normal state)\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "Unmasked",
          "package": "monad-exception",
          "signature": "Unmasked",
          "type": "function"
        },
        "index": {
          "description": "asynchronous exceptions are unmasked the normal state",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "Unmasked",
          "package": "monad-exception",
          "partial": "Unmasked",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:Unmasked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis exception is raised by default in the main thread of\n the program when the user requests to terminate the program\n via the usual mechanism(s) (e.g. Control-C in the console).\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "UserInterrupt",
          "package": "monad-exception",
          "signature": "UserInterrupt",
          "type": "function"
        },
        "index": {
          "description": "This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism e.g Control-C in the console",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "UserInterrupt",
          "package": "monad-exception",
          "partial": "User Interrupt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:UserInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003eallowInterrupt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "allowInterrupt",
          "package": "monad-exception",
          "signature": "m ()",
          "source": "src/Control-Exception-Monadic.html#allowInterrupt",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of allowInterrupt",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "allowInterrupt",
          "normalized": "a()",
          "package": "monad-exception",
          "partial": "Interrupt",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:allowInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "bracket",
          "package": "monad-exception",
          "signature": "m a -\u003e (a -\u003e m b) -\u003e (a -\u003e m c) -\u003e m c",
          "source": "src/Control-Monad-Exception-Class.html#bracket",
          "type": "method"
        },
        "index": {
          "description": "Generalized version of bracket",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "bracket",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003e(b-\u003ea d)-\u003ea d",
          "package": "monad-exception",
          "signature": "m a-\u003e(a-\u003em b)-\u003e(a-\u003em c)-\u003em c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ebracketOnError\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "bracketOnError",
          "package": "monad-exception",
          "signature": "m a -\u003e (a -\u003e m b) -\u003e (a -\u003e m c) -\u003e m c",
          "source": "src/Control-Exception-Monadic.html#bracketOnError",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of bracketOnError",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "bracketOnError",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003e(b-\u003ea d)-\u003ea d",
          "package": "monad-exception",
          "partial": "On Error",
          "signature": "m a-\u003e(a-\u003em b)-\u003e(a-\u003em c)-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:bracketOnError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ebracket_\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "bracket_",
          "package": "monad-exception",
          "signature": "m a -\u003e m b -\u003e m c -\u003e m c",
          "source": "src/Control-Exception-Monadic.html#bracket_",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of bracket",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "bracket_",
          "normalized": "a b-\u003ea c-\u003ea d-\u003ea d",
          "package": "monad-exception",
          "signature": "m a-\u003em b-\u003em c-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:bracket_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "catch",
          "package": "monad-exception",
          "signature": "m a -\u003e (e -\u003e m a) -\u003e m a",
          "source": "src/Control-Monad-Exception-Class.html#catch",
          "type": "method"
        },
        "index": {
          "description": "Generalized version of catch",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "catch",
          "normalized": "a b-\u003e(c-\u003ea b)-\u003ea b",
          "package": "monad-exception",
          "signature": "m a-\u003e(e-\u003em a)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:catch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ecatchJust\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "catchJust",
          "package": "monad-exception",
          "signature": "(e -\u003e Maybe b) -\u003e m a -\u003e (b -\u003e m a) -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#catchJust",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of catchJust",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "catchJust",
          "normalized": "(a-\u003eMaybe b)-\u003ec d-\u003e(b-\u003ec d)-\u003ec d",
          "package": "monad-exception",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003em a-\u003e(b-\u003em a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:catchJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "catches",
          "package": "monad-exception",
          "signature": "m a -\u003e [Handler m a] -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#catches",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of catches",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "catches",
          "normalized": "a b-\u003e[Handler a b]-\u003ea b",
          "package": "monad-exception",
          "signature": "m a-\u003e[Handler m a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:catches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003eevaluate\u003c/a\u003e\u003c/code\u003e. This only works on \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e-like monads.\n See \u003ccode\u003e\u003ca\u003eunsafeEvaluate\u003c/a\u003e\u003c/code\u003e for a version that works on every \u003ccode\u003e\u003ca\u003eMonadException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "evaluate",
          "package": "monad-exception",
          "signature": "a -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#evaluate",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of evaluate This only works on IO like monads See unsafeEvaluate for version that works on every MonadException",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "evaluate",
          "normalized": "a-\u003eb a",
          "package": "monad-exception",
          "signature": "a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:evaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003efinally\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "finally",
          "package": "monad-exception",
          "signature": "m a -\u003e m b -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#finally",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of finally",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "finally",
          "normalized": "a b-\u003ea c-\u003ea b",
          "package": "monad-exception",
          "signature": "m a-\u003em b-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:finally"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "fromException",
          "package": "monad-exception",
          "signature": "SomeException -\u003e Maybe e",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "fromException",
          "normalized": "SomeException-\u003eMaybe a",
          "package": "monad-exception",
          "partial": "Exception",
          "signature": "SomeException-\u003eMaybe e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:fromException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003egetMaskingState\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "getMaskingState",
          "package": "monad-exception",
          "signature": "m MaskingState",
          "source": "src/Control-Exception-Monadic.html#getMaskingState",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of getMaskingState",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "getMaskingState",
          "package": "monad-exception",
          "partial": "Masking State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:getMaskingState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e with the arguments swapped around. See \u003ccode\u003e\u003ca\u003ehandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "handle",
          "package": "monad-exception",
          "signature": "(e -\u003e m a) -\u003e m a -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#handle",
          "type": "function"
        },
        "index": {
          "description": "version of catch with the arguments swapped around See handle",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "handle",
          "normalized": "(a-\u003eb c)-\u003eb c-\u003eb c",
          "package": "monad-exception",
          "signature": "(e-\u003em a)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:handle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatchJust\u003c/a\u003e\u003c/code\u003e with the arguments swapped around. See\n \u003ccode\u003e\u003ca\u003ehandleJust\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "handleJust",
          "package": "monad-exception",
          "signature": "(e -\u003e Maybe b) -\u003e (b -\u003e m a) -\u003e m a -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#handleJust",
          "type": "function"
        },
        "index": {
          "description": "version of catchJust with the arguments swapped around See handleJust",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "handleJust",
          "normalized": "(a-\u003eMaybe b)-\u003e(b-\u003ec d)-\u003ec d-\u003ec d",
          "package": "monad-exception",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003e(b-\u003em a)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:handleJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function maps one exception into another as proposed in the\n paper \"A semantics for imprecise exceptions\".\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "mapException",
          "package": "monad-exception",
          "signature": "(e1 -\u003e e2) -\u003e a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "This function maps one exception into another as proposed in the paper semantics for imprecise exceptions",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "mapException",
          "normalized": "(a-\u003ea)-\u003eb-\u003eb",
          "package": "monad-exception",
          "partial": "Exception",
          "signature": "(e-\u003ee)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:mapException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "mask",
          "package": "monad-exception",
          "signature": "n b -\u003e n b) -\u003e m a) -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#mask",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of mask",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "mask",
          "normalized": "a b-\u003ea b)-\u003ec d)-\u003ec d",
          "package": "monad-exception",
          "signature": "n b-\u003en b)-\u003em a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:mask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "mask_",
          "package": "monad-exception",
          "signature": "m a -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#mask_",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of mask",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "mask_",
          "normalized": "a b-\u003ea b",
          "package": "monad-exception",
          "signature": "m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:mask_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003eonException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "onException",
          "package": "monad-exception",
          "signature": "m a -\u003e m b -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#onException",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of onException",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "onException",
          "normalized": "a b-\u003ea c-\u003ea b",
          "package": "monad-exception",
          "partial": "Exception",
          "signature": "m a-\u003em b-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:onException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ethrowIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "throw",
          "package": "monad-exception",
          "signature": "e -\u003e m a",
          "source": "src/Control-Monad-Exception-Class.html#throw",
          "type": "method"
        },
        "index": {
          "description": "Generalized version of throwIO",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "throw",
          "normalized": "a-\u003eb c",
          "package": "monad-exception",
          "signature": "e-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:throw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "throwTo",
          "package": "monad-exception",
          "signature": "ThreadId -\u003e e -\u003e m ()",
          "source": "src/Control-Exception-Monadic.html#throwTo",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of throwTo",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "throwTo",
          "normalized": "ThreadId-\u003ea-\u003eb()",
          "package": "monad-exception",
          "partial": "To",
          "signature": "ThreadId-\u003ee-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:throwTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Monadic",
          "name": "toException",
          "package": "monad-exception",
          "signature": "e -\u003e SomeException",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "toException",
          "normalized": "a-\u003eSomeException",
          "package": "monad-exception",
          "partial": "Exception",
          "signature": "e-\u003eSomeException",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:toException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized version of \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "try",
          "package": "monad-exception",
          "signature": "m a -\u003e m (Either e a)",
          "source": "src/Control-Exception-Monadic.html#try",
          "type": "function"
        },
        "index": {
          "description": "generalized version of try",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "try",
          "normalized": "a b-\u003ea(Either c b)",
          "package": "monad-exception",
          "signature": "m a-\u003em(Either e a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:try"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized version of \u003ccode\u003e\u003ca\u003etryJust\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "tryJust",
          "package": "monad-exception",
          "signature": "(e -\u003e Maybe b) -\u003e m a -\u003e m (Either b a)",
          "source": "src/Control-Exception-Monadic.html#tryJust",
          "type": "function"
        },
        "index": {
          "description": "generalized version of tryJust",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "tryJust",
          "normalized": "(a-\u003eMaybe b)-\u003ec d-\u003ec(Either b d)",
          "package": "monad-exception",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003em a-\u003em(Either b a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:tryJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "uninterruptibleMask",
          "package": "monad-exception",
          "signature": "n b -\u003e n b) -\u003e m a) -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#uninterruptibleMask",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of mask",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "uninterruptibleMask",
          "normalized": "a b-\u003ea b)-\u003ec d)-\u003ec d",
          "package": "monad-exception",
          "partial": "Mask",
          "signature": "n b-\u003en b)-\u003em a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:uninterruptibleMask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003emask\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "uninterruptibleMask_",
          "package": "monad-exception",
          "signature": "m a -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#uninterruptibleMask_",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of mask",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "uninterruptibleMask_",
          "normalized": "a b-\u003ea b",
          "package": "monad-exception",
          "partial": "Mask",
          "signature": "m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:uninterruptibleMask_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003eevaluate\u003c/a\u003e\u003c/code\u003e. This uses \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e behind\n the scenes to do something kind of similar to what the \u003ccode\u003espoon\u003c/code\u003e package\n does.\n\u003c/p\u003e",
          "module": "Control.Exception.Monadic",
          "name": "unsafeEvaluate",
          "package": "monad-exception",
          "signature": "a -\u003e m a",
          "source": "src/Control-Exception-Monadic.html#unsafeEvaluate",
          "type": "function"
        },
        "index": {
          "description": "Generalized version of evaluate This uses unsafePerformIO behind the scenes to do something kind of similar to what the spoon package does",
          "hierarchy": "Control Exception Monadic",
          "module": "Control.Exception.Monadic",
          "name": "unsafeEvaluate",
          "normalized": "a-\u003eb a",
          "package": "monad-exception",
          "partial": "Evaluate",
          "signature": "a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Exception-Monadic.html#v:unsafeEvaluate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports the \u003ccode\u003e\u003ca\u003eMonadException\u003c/a\u003e\u003c/code\u003e type class.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Exception.Class",
          "name": "Class",
          "package": "monad-exception",
          "source": "src/Control-Monad-Exception-Class.html",
          "type": "module"
        },
        "index": {
          "description": "This module exports the MonadException type class",
          "hierarchy": "Control Monad Exception Class",
          "module": "Control.Monad.Exception.Class",
          "name": "Class",
          "package": "monad-exception",
          "partial": "Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Exception-Class.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMonadException\u003c/a\u003e\u003c/code\u003e type class. Minimal complete definition: \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.Exception.Class",
          "name": "MonadException",
          "package": "monad-exception",
          "source": "src/Control-Monad-Exception-Class.html#MonadException",
          "type": "class"
        },
        "index": {
          "description": "The MonadException type class Minimal complete definition throw catch",
          "hierarchy": "Control Monad Exception Class",
          "module": "Control.Monad.Exception.Class",
          "name": "MonadException",
          "package": "monad-exception",
          "partial": "Monad Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Exception-Class.html#t:MonadException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ebracket\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.Exception.Class",
          "name": "bracket",
          "package": "monad-exception",
          "signature": "m a -\u003e (a -\u003e m b) -\u003e (a -\u003e m c) -\u003e m c",
          "source": "src/Control-Monad-Exception-Class.html#bracket",
          "type": "method"
        },
        "index": {
          "description": "Generalized version of bracket",
          "hierarchy": "Control Monad Exception Class",
          "module": "Control.Monad.Exception.Class",
          "name": "bracket",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003e(b-\u003ea d)-\u003ea d",
          "package": "monad-exception",
          "signature": "m a-\u003e(a-\u003em b)-\u003e(a-\u003em c)-\u003em c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Exception-Class.html#v:bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ecatch\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.Exception.Class",
          "name": "catch",
          "package": "monad-exception",
          "signature": "m a -\u003e (e -\u003e m a) -\u003e m a",
          "source": "src/Control-Monad-Exception-Class.html#catch",
          "type": "method"
        },
        "index": {
          "description": "Generalized version of catch",
          "hierarchy": "Control Monad Exception Class",
          "module": "Control.Monad.Exception.Class",
          "name": "catch",
          "normalized": "a b-\u003e(c-\u003ea b)-\u003ea b",
          "package": "monad-exception",
          "signature": "m a-\u003e(e-\u003em a)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Exception-Class.html#v:catch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized version of \u003ccode\u003e\u003ca\u003ethrowIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.Exception.Class",
          "name": "throw",
          "package": "monad-exception",
          "signature": "e -\u003e m a",
          "source": "src/Control-Monad-Exception-Class.html#throw",
          "type": "method"
        },
        "index": {
          "description": "Generalized version of throwIO",
          "hierarchy": "Control Monad Exception Class",
          "module": "Control.Monad.Exception.Class",
          "name": "throw",
          "normalized": "a-\u003eb c",
          "package": "monad-exception",
          "signature": "e-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Exception-Class.html#v:throw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports the \u003ccode\u003e\u003ca\u003eExceptionT\u003c/a\u003e\u003c/code\u003e monad transformer.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Monad.Trans.Exception",
          "name": "Exception",
          "package": "monad-exception",
          "source": "src/Control-Monad-Trans-Exception.html",
          "type": "module"
        },
        "index": {
          "description": "This module exports the ExceptionT monad transformer",
          "hierarchy": "Control Monad Trans Exception",
          "module": "Control.Monad.Trans.Exception",
          "name": "Exception",
          "package": "monad-exception",
          "partial": "Exception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Trans-Exception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eExceptionT\u003c/a\u003e\u003c/code\u003e monad transformer. This is can be used to add\n \u003ccode\u003e\u003ca\u003eMonadException\u003c/a\u003e\u003c/code\u003e functionality otherwise pure monad stacks. If your monad\n stack is built on top of \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e however, it already has \u003ccode\u003e\u003ca\u003eMonadException\u003c/a\u003e\u003c/code\u003e\n functionality and you should use that instead, unless you have a good\n reason not to. Pass-through instances for the \u003ccode\u003emtl\u003c/code\u003e type classes are\n provided automatically by the \u003ccode\u003emtl-evil-instances\u003c/code\u003e package.\n\u003c/p\u003e",
          "module": "Control.Monad.Trans.Exception",
          "name": "ExceptionT",
          "package": "monad-exception",
          "source": "src/Control-Monad-Trans-Exception.html#ExceptionT",
          "type": "data"
        },
        "index": {
          "description": "The ExceptionT monad transformer This is can be used to add MonadException functionality otherwise pure monad stacks If your monad stack is built on top of IO however it already has MonadException functionality and you should use that instead unless you have good reason not to Pass-through instances for the mtl type classes are provided automatically by the mtl-evil-instances package",
          "hierarchy": "Control Monad Trans Exception",
          "module": "Control.Monad.Trans.Exception",
          "name": "ExceptionT",
          "package": "monad-exception",
          "partial": "Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Trans-Exception.html#t:ExceptionT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the \u003ccode\u003e\u003ca\u003eExceptionT\u003c/a\u003e\u003c/code\u003e monad transformer. This returns \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e if\n everything goes okay, and \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e in the case of an error, with the\n exception wrapped up in a \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.Trans.Exception",
          "name": "runExceptionT",
          "package": "monad-exception",
          "signature": "ExceptionT m a -\u003e m (Either SomeException a)",
          "source": "src/Control-Monad-Trans-Exception.html#runExceptionT",
          "type": "function"
        },
        "index": {
          "description": "Run the ExceptionT monad transformer This returns Right if everything goes okay and Left in the case of an error with the exception wrapped up in SomeException",
          "hierarchy": "Control Monad Trans Exception",
          "module": "Control.Monad.Trans.Exception",
          "name": "runExceptionT",
          "normalized": "ExceptionT a b-\u003ea(Either SomeException b)",
          "package": "monad-exception",
          "partial": "Exception",
          "signature": "ExceptionT m a-\u003em(Either SomeException a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/monad-exception/docs/Control-Monad-Trans-Exception.html#v:runExceptionT"
      }
    }
  ]
]