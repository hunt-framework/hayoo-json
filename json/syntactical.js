[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "syntactical"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe data structures (and associated functions) used in the\n parser. For a normal usage, it should be enough\n to import only \u003ccode\u003eText.Syntactical\u003c/code\u003e, not directly this module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Data",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html",
          "type": "module"
        },
        "index": {
          "description": "The data structures and associated functions used in the parser For normal usage it should be enough to import only Text.Syntactical not directly this module",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Data",
          "package": "syntactical",
          "partial": "Data",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Ambiguity",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Ambiguity",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Ambiguity",
          "package": "syntactical",
          "partial": "Ambiguity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Ambiguity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the associativity of an infix operator.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Associativity",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Associativity",
          "type": "data"
        },
        "index": {
          "description": "Specify the associativity of an infix operator",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Associativity",
          "package": "syntactical",
          "partial": "Associativity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Associativity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "FindBegin",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#FindBegin",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "FindBegin",
          "package": "syntactical",
          "partial": "Find Begin",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:FindBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "FindBoth",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#FindBoth",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "FindBoth",
          "package": "syntactical",
          "partial": "Find Both",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:FindBoth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Hole is used to give various behaviours when dealing\n with internal holes.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Hole",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Hole",
          "type": "data"
        },
        "index": {
          "description": "The Hole is used to give various behaviours when dealing with internal holes",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Hole",
          "package": "syntactical",
          "partial": "Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe operator representation, parametrized by the token type.\n It allows infix, prefix, postfix,\n and closed operators, with possibly multiple internal holes.\n Different holes are possible, to drive the parse in specific ways.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Op",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Op",
          "type": "data"
        },
        "index": {
          "description": "The operator representation parametrized by the token type It allows infix prefix postfix and closed operators with possibly multiple internal holes Different holes are possible to drive the parse in specific ways",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Op",
          "package": "syntactical",
          "partial": "Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Opening",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Opening",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Opening",
          "package": "syntactical",
          "partial": "Opening",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Opening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Part represent a single symbol of an operator.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Part",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Part",
          "type": "data"
        },
        "index": {
          "description": "Part represent single symbol of an operator",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Part",
          "package": "syntactical",
          "partial": "Part",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Part"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Priority",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Priority",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Priority",
          "package": "syntactical",
          "partial": "Priority",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Priority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe s-expression data type used as input and output of the parser.\n The type is parametrized by the type of the token.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "SExpr",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#SExpr",
          "type": "data"
        },
        "index": {
          "description": "The s-expression data type used as input and output of the parser The type is parametrized by the type of the token",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "SExpr",
          "package": "syntactical",
          "partial": "SExpr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:SExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the operator table.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Table",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Table",
          "type": "data"
        },
        "index": {
          "description": "The type of the operator table",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Table",
          "package": "syntactical",
          "partial": "Table",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of the types that can be parsed.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Token",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Token",
          "type": "class"
        },
        "index": {
          "description": "The class of the types that can be parsed",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Token",
          "package": "syntactical",
          "partial": "Token",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe s-expression data type augmented to represent parts (used in\n the operator stack).\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "Tree",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Tree",
          "type": "data"
        },
        "index": {
          "description": "The s-expression data type augmented to represent parts used in the operator stack",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Tree",
          "package": "syntactical",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "AmbiguousBegin",
          "package": "syntactical",
          "signature": "AmbiguousBegin Ambiguity",
          "source": "src/Text-Syntactical-Data.html#FindBegin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "AmbiguousBegin",
          "package": "syntactical",
          "partial": "Ambiguous Begin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:AmbiguousBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "Atom",
          "package": "syntactical",
          "signature": "Atom a",
          "source": "src/Text-Syntactical-Data.html#SExpr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Atom\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:Atom\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Atom",
          "package": "syntactical",
          "partial": "Atom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "BAmbiguous",
          "package": "syntactical",
          "signature": "BAmbiguous Ambiguity",
          "source": "src/Text-Syntactical-Data.html#FindBoth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "BAmbiguous",
          "package": "syntactical",
          "partial": "BAmbiguous",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:BAmbiguous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "BBegin",
          "package": "syntactical",
          "signature": "BBegin (Part a)",
          "source": "src/Text-Syntactical-Data.html#FindBoth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "BBegin",
          "package": "syntactical",
          "partial": "BBegin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:BBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "BContinue",
          "package": "syntactical",
          "signature": "BContinue (Part a)",
          "source": "src/Text-Syntactical-Data.html#FindBoth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "BContinue",
          "package": "syntactical",
          "partial": "BContinue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:BContinue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "BMissingBegin",
          "package": "syntactical",
          "signature": "BMissingBegin [[a]]",
          "source": "src/Text-Syntactical-Data.html#FindBoth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "BMissingBegin",
          "normalized": "BMissingBegin[[a]]",
          "package": "syntactical",
          "partial": "BMissing Begin",
          "signature": "BMissingBegin[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:BMissingBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "BNothing",
          "package": "syntactical",
          "signature": "BNothing",
          "source": "src/Text-Syntactical-Data.html#FindBoth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "BNothing",
          "package": "syntactical",
          "partial": "BNothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:BNothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Begin",
          "package": "syntactical",
          "signature": "Begin (Part a)",
          "source": "src/Text-Syntactical-Data.html#FindBegin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Begin",
          "package": "syntactical",
          "partial": "Begin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Begin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Branch",
          "package": "syntactical",
          "signature": "Branch [Tree a]",
          "source": "src/Text-Syntactical-Data.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Branch",
          "normalized": "Branch[Tree a]",
          "package": "syntactical",
          "partial": "Branch",
          "signature": "Branch[Tree a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Branch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistfix means the \u003ccode\u003econtent\u003c/code\u003e of the hole should be parsed\n as a distfix expression. In this case feeding an empty hole\n will generate a parse error.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "Distfix",
          "package": "syntactical",
          "signature": "Distfix",
          "source": "src/Text-Syntactical-Data.html#Hole",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Distfix\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:Distfix\"]"
        },
        "index": {
          "description": "Distfix means the content of the hole should be parsed as distfix expression In this case feeding an empty hole will generate parse error",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Distfix",
          "package": "syntactical",
          "partial": "Distfix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Distfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "First",
          "package": "syntactical",
          "signature": "First (Maybe (Associativity, Precedence)) a [a] Hole",
          "source": "src/Text-Syntactical-Data.html#Part",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "First",
          "normalized": "First(Maybe(Associativity,Precedence))a[a]Hole",
          "package": "syntactical",
          "partial": "First",
          "signature": "First(Maybe(Associativity,Precedence))a[a]Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:First"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Higher",
          "package": "syntactical",
          "signature": "Higher",
          "source": "src/Text-Syntactical-Data.html#Priority",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Higher",
          "package": "syntactical",
          "partial": "Higher",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Higher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Infix",
          "package": "syntactical",
          "signature": "Infix Associativity",
          "source": "src/Text-Syntactical-Data.html#Opening",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Infix",
          "package": "syntactical",
          "partial": "Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Infix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Last",
          "package": "syntactical",
          "signature": "Last (Op a)",
          "source": "src/Text-Syntactical-Data.html#Part",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Last",
          "package": "syntactical",
          "partial": "Last",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Leaf",
          "package": "syntactical",
          "signature": "Leaf a",
          "source": "src/Text-Syntactical-Data.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Leaf",
          "package": "syntactical",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "LeftAssociative",
          "package": "syntactical",
          "signature": "LeftAssociative",
          "source": "src/Text-Syntactical-Data.html#Associativity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:LeftAssociative\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:LeftAssociative\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "LeftAssociative",
          "package": "syntactical",
          "partial": "Left Associative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:LeftAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "List",
          "package": "syntactical",
          "signature": "List [SExpr a]",
          "source": "src/Text-Syntactical-Data.html#SExpr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:List\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:List\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "List",
          "normalized": "List[SExpr a]",
          "package": "syntactical",
          "partial": "List",
          "signature": "List[SExpr a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Lone",
          "package": "syntactical",
          "signature": "Lone Bool a Opening Precedence",
          "source": "src/Text-Syntactical-Data.html#Part",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Lone",
          "package": "syntactical",
          "partial": "Lone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Lone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "LoneOrFirst",
          "package": "syntactical",
          "signature": "LoneOrFirst",
          "source": "src/Text-Syntactical-Data.html#Ambiguity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:LoneOrFirst\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:LoneOrFirst\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "LoneOrFirst",
          "package": "syntactical",
          "partial": "Lone Or First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:LoneOrFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Lower",
          "package": "syntactical",
          "signature": "Lower",
          "source": "src/Text-Syntactical-Data.html#Priority",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Lower",
          "package": "syntactical",
          "partial": "Lower",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Middle",
          "package": "syntactical",
          "signature": "Middle [a] a [a] Hole",
          "source": "src/Text-Syntactical-Data.html#Part",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Middle",
          "normalized": "Middle[a]a[a]Hole",
          "package": "syntactical",
          "partial": "Middle",
          "signature": "Middle[a]a[a]Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Middle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "MiddleOrLast",
          "package": "syntactical",
          "signature": "MiddleOrLast",
          "source": "src/Text-Syntactical-Data.html#Ambiguity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:MiddleOrLast\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:MiddleOrLast\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "MiddleOrLast",
          "package": "syntactical",
          "partial": "Middle Or Last",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:MiddleOrLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "MissingBegin",
          "package": "syntactical",
          "signature": "MissingBegin [[a]]",
          "source": "src/Text-Syntactical-Data.html#FindBegin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "MissingBegin",
          "normalized": "MissingBegin[[a]]",
          "package": "syntactical",
          "partial": "Missing Begin",
          "signature": "MissingBegin[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:MissingBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "MultipleLone",
          "package": "syntactical",
          "signature": "MultipleLone",
          "source": "src/Text-Syntactical-Data.html#Ambiguity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:MultipleLone\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:MultipleLone\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "MultipleLone",
          "package": "syntactical",
          "partial": "Multiple Lone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:MultipleLone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "NoBegin",
          "package": "syntactical",
          "signature": "NoBegin",
          "source": "src/Text-Syntactical-Data.html#FindBegin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "NoBegin",
          "package": "syntactical",
          "partial": "No Begin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NoBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "NoPriority",
          "package": "syntactical",
          "signature": "NoPriority",
          "source": "src/Text-Syntactical-Data.html#Priority",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "NoPriority",
          "package": "syntactical",
          "partial": "No Priority",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NoPriority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "NonAssociative",
          "package": "syntactical",
          "signature": "NonAssociative",
          "source": "src/Text-Syntactical-Data.html#Associativity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NonAssociative\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:NonAssociative\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "NonAssociative",
          "package": "syntactical",
          "partial": "Non Associative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NonAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "NotSameFirst",
          "package": "syntactical",
          "signature": "NotSameFirst",
          "source": "src/Text-Syntactical-Data.html#Ambiguity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NotSameFirst\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:NotSameFirst\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "NotSameFirst",
          "package": "syntactical",
          "partial": "Not Same First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NotSameFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "NotSameHole",
          "package": "syntactical",
          "signature": "NotSameHole",
          "source": "src/Text-Syntactical-Data.html#Ambiguity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NotSameHole\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:NotSameHole\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "NotSameHole",
          "package": "syntactical",
          "partial": "Not Same Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:NotSameHole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Op1",
          "package": "syntactical",
          "signature": "Op1 Bool a [(Hole, a)] Opening Precedence",
          "source": "src/Text-Syntactical-Data.html#Op",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Op1",
          "normalized": "Op Bool a[(Hole,a)]Opening Precedence",
          "package": "syntactical",
          "partial": "Op",
          "signature": "Op Bool a[(Hole,a)]Opening Precedence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Op1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Op2",
          "package": "syntactical",
          "signature": "Op2 Bool a [(Hole, a)] Hole a",
          "source": "src/Text-Syntactical-Data.html#Op",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Op2",
          "normalized": "Op Bool a[(Hole,a)]Hole a",
          "package": "syntactical",
          "partial": "Op",
          "signature": "Op Bool a[(Hole,a)]Hole a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Op2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Part",
          "package": "syntactical",
          "signature": "Part (Part a)",
          "source": "src/Text-Syntactical-Data.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Part",
          "package": "syntactical",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Part"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Postfix",
          "package": "syntactical",
          "signature": "Postfix",
          "source": "src/Text-Syntactical-Data.html#Opening",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Postfix",
          "package": "syntactical",
          "partial": "Postfix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Postfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "Prefix",
          "package": "syntactical",
          "signature": "Prefix",
          "source": "src/Text-Syntactical-Data.html#Opening",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "Prefix",
          "package": "syntactical",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:Prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "RightAssociative",
          "package": "syntactical",
          "signature": "RightAssociative",
          "source": "src/Text-Syntactical-Data.html#Associativity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:RightAssociative\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:RightAssociative\"]"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "RightAssociative",
          "package": "syntactical",
          "partial": "Right Associative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:RightAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSExpression means the \u003ccode\u003econtent\u003c/code\u003e of the hole should be\n parsed as an s-expression. The resulting value is a List.\n This means the hole can be empty or contain one or more\n sub-expression(s).\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "SExpression",
          "package": "syntactical",
          "signature": "SExpression",
          "source": "src/Text-Syntactical-Data.html#Hole",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:SExpression\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:SExpression\"]"
        },
        "index": {
          "description": "SExpression means the content of the hole should be parsed as an s-expression The resulting value is List This means the hole can be empty or contain one or more sub-expression",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "SExpression",
          "package": "syntactical",
          "partial": "SExpression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:SExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "applicator",
          "package": "syntactical",
          "signature": "Table a -\u003e SExpr a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#applicator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "applicator",
          "normalized": "Table a-\u003eSExpr a-\u003eBool",
          "package": "syntactical",
          "signature": "Table a-\u003eSExpr a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:applicator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "applicator'",
          "package": "syntactical",
          "signature": "Table a -\u003e Tree a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#applicator%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "applicator'",
          "normalized": "Table a-\u003eTree a-\u003eBool",
          "package": "syntactical",
          "signature": "Table a-\u003eTree a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:applicator-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the arity of a complete Part. It is an error to call this\n function on a First or Middle part.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "arity",
          "package": "syntactical",
          "signature": "Part a -\u003e Int",
          "source": "src/Text-Syntactical-Data.html#arity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:arity\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:arity\"]"
        },
        "index": {
          "description": "Return the arity of complete Part It is an error to call this function on First or Middle part",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "arity",
          "normalized": "Part a-\u003eInt",
          "package": "syntactical",
          "signature": "Part a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "begin",
          "package": "syntactical",
          "signature": "Part a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#begin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "begin",
          "normalized": "Part a-\u003eBool",
          "package": "syntactical",
          "signature": "Part a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:begin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebuildTable\u003c/a\u003e\u003c/code\u003e constructs an operator table that can be\n used with the \u003ccode\u003eshunt\u003c/code\u003e function. Operators are given\n in decreasing precedence order.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "buildTable",
          "package": "syntactical",
          "signature": "[[Op a]] -\u003e Table a",
          "source": "src/Text-Syntactical-Data.html#buildTable",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:buildTable\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:buildTable\"]"
        },
        "index": {
          "description": "buildTable constructs an operator table that can be used with the shunt function Operators are given in decreasing precedence order",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "buildTable",
          "normalized": "[[Op a]]-\u003eTable a",
          "package": "syntactical",
          "partial": "Table",
          "signature": "[[Op a]]-\u003eTable a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:buildTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a closed operator. The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "closed",
          "package": "syntactical",
          "signature": "a -\u003e Hole -\u003e a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#closed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:closed\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:closed\"]"
        },
        "index": {
          "description": "Build closed operator The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "closed",
          "normalized": "a-\u003eHole-\u003ea-\u003eOp a",
          "package": "syntactical",
          "signature": "a-\u003eHole-\u003ea-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:closed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a closed operator with the keep property set to False.\n The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "closed_",
          "package": "syntactical",
          "signature": "a -\u003e Hole -\u003e a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#closed_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:closed_\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:closed_\"]"
        },
        "index": {
          "description": "Build closed operator with the keep property set to False The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "closed_",
          "normalized": "a-\u003eHole-\u003ea-\u003eOp a",
          "package": "syntactical",
          "signature": "a-\u003eHole-\u003ea-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:closed_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest if two tokens are the same (used to find match from the\n operator table). A default definition that compares the result\n of toString is provided.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "consider",
          "package": "syntactical",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#consider",
          "type": "method"
        },
        "index": {
          "description": "test if two tokens are the same used to find match from the operator table default definition that compares the result of toString is provided",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "consider",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "syntactical",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:consider"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "continue",
          "package": "syntactical",
          "signature": "Part a -\u003e Part a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#continue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "continue",
          "normalized": "Part a-\u003ePart a-\u003eBool",
          "package": "syntactical",
          "signature": "Part a-\u003ePart a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:continue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the tokens of the given part.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "current",
          "package": "syntactical",
          "signature": "Part a -\u003e [a]",
          "source": "src/Text-Syntactical-Data.html#current",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:current\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:current\"]"
        },
        "index": {
          "description": "Return the tokens of the given part",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "current",
          "normalized": "Part a-\u003e[a]",
          "package": "syntactical",
          "signature": "Part a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:current"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparate an operator in its different parts.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "cut",
          "package": "syntactical",
          "signature": "Op a -\u003e [Part a]",
          "source": "src/Text-Syntactical-Data.html#cut",
          "type": "function"
        },
        "index": {
          "description": "Separate an operator in its different parts",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "cut",
          "normalized": "Op a-\u003e[Part a]",
          "package": "syntactical",
          "signature": "Op a-\u003e[Part a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:cut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "discard",
          "package": "syntactical",
          "signature": "Part a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#discard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "discard",
          "normalized": "Part a-\u003eBool",
          "package": "syntactical",
          "signature": "Part a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:discard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a new part separated by a Distfix hole to the right\n of an operator.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "distfix",
          "package": "syntactical",
          "signature": "Op a -\u003e a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#distfix",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:distfix\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:distfix\"]"
        },
        "index": {
          "description": "Add new part separated by Distfix hole to the right of an operator",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "distfix",
          "normalized": "Op a-\u003ea-\u003eOp a",
          "package": "syntactical",
          "signature": "Op a-\u003ea-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:distfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "end",
          "package": "syntactical",
          "signature": "Part a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#end",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "end",
          "normalized": "Part a-\u003eBool",
          "package": "syntactical",
          "signature": "Part a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:end"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "findBegin",
          "package": "syntactical",
          "signature": "Table a -\u003e a -\u003e FindBegin a",
          "source": "src/Text-Syntactical-Data.html#findBegin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "findBegin",
          "normalized": "Table a-\u003ea-\u003eFindBegin a",
          "package": "syntactical",
          "partial": "Begin",
          "signature": "Table a-\u003ea-\u003eFindBegin a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:findBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "findBoth",
          "package": "syntactical",
          "signature": "Table a -\u003e a -\u003e [Tree a] -\u003e FindBoth a",
          "source": "src/Text-Syntactical-Data.html#findBoth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "findBoth",
          "normalized": "Table a-\u003ea-\u003e[Tree a]-\u003eFindBoth a",
          "package": "syntactical",
          "partial": "Both",
          "signature": "Table a-\u003ea-\u003e[Tree a]-\u003eFindBoth a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:findBoth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a infix operator. The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "infx",
          "package": "syntactical",
          "signature": "Associativity -\u003e a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#infx",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:infx\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:infx\"]"
        },
        "index": {
          "description": "Build infix operator The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "infx",
          "normalized": "Associativity-\u003ea-\u003eOp a",
          "package": "syntactical",
          "signature": "Associativity-\u003ea-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:infx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a infix operator with the keep property set to False.\n The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "infx_",
          "package": "syntactical",
          "signature": "Associativity -\u003e a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#infx_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:infx_\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:infx_\"]"
        },
        "index": {
          "description": "Build infix operator with the keep property set to False The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "infx_",
          "normalized": "Associativity-\u003ea-\u003eOp a",
          "package": "syntactical",
          "signature": "Associativity-\u003ea-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:infx_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "leftOpen",
          "package": "syntactical",
          "signature": "Part a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#leftOpen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "leftOpen",
          "normalized": "Part a-\u003eBool",
          "package": "syntactical",
          "partial": "Open",
          "signature": "Part a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:leftOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the possible tokens continuing the given part.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "next",
          "package": "syntactical",
          "signature": "Part a -\u003e [a]",
          "source": "src/Text-Syntactical-Data.html#next",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:next\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:next\"]"
        },
        "index": {
          "description": "Return the possible tokens continuing the given part",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "next",
          "normalized": "Part a-\u003e[a]",
          "package": "syntactical",
          "signature": "Part a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:next"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate an output node from an operator and its arguments\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "operator",
          "package": "syntactical",
          "signature": "Op a -\u003e [SExpr a] -\u003e SExpr a",
          "source": "src/Text-Syntactical-Data.html#operator",
          "type": "method"
        },
        "index": {
          "description": "create an output node from an operator and its arguments",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "operator",
          "normalized": "Op a-\u003e[SExpr a]-\u003eSExpr a",
          "package": "syntactical",
          "signature": "Op a-\u003e[SExpr a]-\u003eSExpr a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "original",
          "package": "syntactical",
          "signature": "Part a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#original",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "original",
          "normalized": "Part a-\u003eOp a",
          "package": "syntactical",
          "signature": "Part a-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:original"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a postfix operator. The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "postfx",
          "package": "syntactical",
          "signature": "a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#postfx",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:postfx\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:postfx\"]"
        },
        "index": {
          "description": "Build postfix operator The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "postfx",
          "normalized": "a-\u003eOp a",
          "package": "syntactical",
          "signature": "a-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:postfx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a postfix operator with the keep property set to False.\n The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "postfx_",
          "package": "syntactical",
          "signature": "a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#postfx_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:postfx_\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:postfx_\"]"
        },
        "index": {
          "description": "Build postfix operator with the keep property set to False The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "postfx_",
          "normalized": "a-\u003eOp a",
          "package": "syntactical",
          "signature": "a-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:postfx_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a prefix operator. The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "prefx",
          "package": "syntactical",
          "signature": "a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#prefx",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:prefx\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:prefx\"]"
        },
        "index": {
          "description": "Build prefix operator The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "prefx",
          "normalized": "a-\u003eOp a",
          "package": "syntactical",
          "signature": "a-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:prefx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a prefix operator with the keep property set to False.\n The precedence is set to 0.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "prefx_",
          "package": "syntactical",
          "signature": "a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#prefx_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:prefx_\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:prefx_\"]"
        },
        "index": {
          "description": "Build prefix operator with the keep property set to False The precedence is set to",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "prefx_",
          "normalized": "a-\u003eOp a",
          "package": "syntactical",
          "signature": "a-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:prefx_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the tokens preceding the given part.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "previous",
          "package": "syntactical",
          "signature": "Part a -\u003e [a]",
          "source": "src/Text-Syntactical-Data.html#previous",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:previous\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:previous\"]"
        },
        "index": {
          "description": "Return the tokens preceding the given part",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "previous",
          "normalized": "Part a-\u003e[a]",
          "package": "syntactical",
          "signature": "Part a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:previous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "priority",
          "package": "syntactical",
          "signature": "Part a -\u003e Part a -\u003e Priority",
          "source": "src/Text-Syntactical-Data.html#priority",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "priority",
          "normalized": "Part a-\u003ePart a-\u003ePriority",
          "package": "syntactical",
          "signature": "Part a-\u003ePart a-\u003ePriority",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:priority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "rightHole",
          "package": "syntactical",
          "signature": "Part a -\u003e Maybe Hole",
          "source": "src/Text-Syntactical-Data.html#rightHole",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "rightHole",
          "normalized": "Part a-\u003eMaybe Hole",
          "package": "syntactical",
          "partial": "Hole",
          "signature": "Part a-\u003eMaybe Hole",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:rightHole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "rightOpen",
          "package": "syntactical",
          "signature": "Part a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#rightOpen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "rightOpen",
          "normalized": "Part a-\u003eBool",
          "package": "syntactical",
          "partial": "Open",
          "signature": "Part a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:rightOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the precedence of a given operator.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "setPrecedence",
          "package": "syntactical",
          "signature": "Precedence -\u003e Op a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#setPrecedence",
          "type": "function"
        },
        "index": {
          "description": "Set the precedence of given operator",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "setPrecedence",
          "normalized": "Precedence-\u003eOp a-\u003eOp a",
          "package": "syntactical",
          "partial": "Precedence",
          "signature": "Precedence-\u003eOp a-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:setPrecedence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a new part separated by an SExpression hole to the right\n of an operator.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "sexpr",
          "package": "syntactical",
          "signature": "Op a -\u003e a -\u003e Op a",
          "source": "src/Text-Syntactical-Data.html#sexpr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:sexpr\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:sexpr\"]"
        },
        "index": {
          "description": "Add new part separated by an SExpression hole to the right of an operator",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "sexpr",
          "normalized": "Op a-\u003ea-\u003eOp a",
          "package": "syntactical",
          "signature": "Op a-\u003ea-\u003eOp a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:sexpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "showPart",
          "package": "syntactical",
          "signature": "Part a -\u003e String",
          "source": "src/Text-Syntactical-Data.html#showPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "showPart",
          "normalized": "Part a-\u003eString",
          "package": "syntactical",
          "partial": "Part",
          "signature": "Part a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:showPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow an s-expression using nested angle brackets.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "showSExpr",
          "package": "syntactical",
          "signature": "SExpr a -\u003e String",
          "source": "src/Text-Syntactical-Data.html#showSExpr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:showSExpr\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:showSExpr\"]"
        },
        "index": {
          "description": "Show an s-expression using nested angle brackets",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "showSExpr",
          "normalized": "SExpr a-\u003eString",
          "package": "syntactical",
          "partial": "SExpr",
          "signature": "SExpr a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:showSExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Data",
          "name": "showTree",
          "package": "syntactical",
          "signature": "Tree a -\u003e String",
          "source": "src/Text-Syntactical-Data.html#showTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "showTree",
          "normalized": "Tree a-\u003eString",
          "package": "syntactical",
          "partial": "Tree",
          "signature": "Tree a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the token of a given Part.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "symbol",
          "package": "syntactical",
          "signature": "Part a -\u003e a",
          "source": "src/Text-Syntactical-Data.html#symbol",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:symbol\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:symbol\"]"
        },
        "index": {
          "description": "Return the token of given Part",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "symbol",
          "normalized": "Part a-\u003ea",
          "package": "syntactical",
          "signature": "Part a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all the tokens of a given operator.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Data\",\"Text.Syntactical\"]",
          "name": "symbols",
          "package": "syntactical",
          "signature": "Op a -\u003e [a]",
          "source": "src/Text-Syntactical-Data.html#symbols",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:symbols\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:symbols\"]"
        },
        "index": {
          "description": "Return all the tokens of given operator",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "symbols",
          "normalized": "Op a-\u003e[a]",
          "package": "syntactical",
          "signature": "Op a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:symbols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert to a string (for showing purpose)\n\u003c/p\u003e",
          "module": "Text.Syntactical.Data",
          "name": "toString",
          "package": "syntactical",
          "signature": "a -\u003e String",
          "source": "src/Text-Syntactical-Data.html#toString",
          "type": "method"
        },
        "index": {
          "description": "convert to string for showing purpose",
          "hierarchy": "Text Syntactical Data",
          "module": "Text.Syntactical.Data",
          "name": "toString",
          "normalized": "a-\u003eString",
          "package": "syntactical",
          "partial": "String",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Data.html#v:toString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe modified Shunting-Yard algorithm. The modifications allow function\n application by juxtaposition (without any paren around the arguments)\n and distfix operators. For a normal usage, it should be enough\n to import only \u003ccode\u003eText.Syntactical\u003c/code\u003e, not directly this module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Syntactical.Yard",
          "name": "Yard",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Yard.html",
          "type": "module"
        },
        "index": {
          "description": "The modified Shunting-Yard algorithm The modifications allow function application by juxtaposition without any paren around the arguments and distfix operators For normal usage it should be enough to import only Text.Syntactical not directly this module",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Yard",
          "package": "syntactical",
          "partial": "Yard",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe different failure cases the \u003ccode\u003e\u003ca\u003eshunt\u003c/a\u003e\u003c/code\u003e function can return.\n The \u003ccode\u003e\u003ca\u003eshowFailure\u003c/a\u003e\u003c/code\u003e function can be used to give them a textual\n representation.\n\u003c/p\u003e",
          "module": "Text.Syntactical.Yard",
          "name": "Failure",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "data"
        },
        "index": {
          "description": "The different failure cases the shunt function can return The showFailure function can be used to give them textual representation",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Failure",
          "package": "syntactical",
          "partial": "Failure",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#t:Failure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "Rule",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Rule",
          "package": "syntactical",
          "partial": "Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#t:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "Shunt",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Yard.html#Shunt",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Shunt",
          "package": "syntactical",
          "partial": "Shunt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#t:Shunt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea part is used ambiguously in multiple operators\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "Ambiguity",
          "package": "syntactical",
          "signature": "Ambiguity Ambiguity",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Ambiguity\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:Ambiguity\"]"
        },
        "index": {
          "description": "part is used ambiguously in multiple operators",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Ambiguity",
          "package": "syntactical",
          "partial": "Ambiguity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Ambiguity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "Application",
          "package": "syntactical",
          "signature": "Application",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Application",
          "package": "syntactical",
          "partial": "Application",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Application"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "ApplyOp",
          "package": "syntactical",
          "signature": "ApplyOp",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "ApplyOp",
          "package": "syntactical",
          "partial": "Apply Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:ApplyOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "Argument",
          "package": "syntactical",
          "signature": "Argument",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Argument",
          "package": "syntactical",
          "partial": "Argument",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Argument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecan't mix two operators\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "CantMix",
          "package": "syntactical",
          "signature": "CantMix (Part a) (Part a)",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:CantMix\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:CantMix\"]"
        },
        "index": {
          "description": "can mix two operators",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "CantMix",
          "package": "syntactical",
          "partial": "Cant Mix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:CantMix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "ContinueOp",
          "package": "syntactical",
          "signature": "ContinueOp",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "ContinueOp",
          "package": "syntactical",
          "partial": "Continue Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:ContinueOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "Done",
          "package": "syntactical",
          "signature": "Done (Result a)",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Done",
          "package": "syntactical",
          "partial": "Done",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Done"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "Initial",
          "package": "syntactical",
          "signature": "Initial",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Initial",
          "package": "syntactical",
          "partial": "Initial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Initial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "MatchedR",
          "package": "syntactical",
          "signature": "MatchedR",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "MatchedR",
          "package": "syntactical",
          "partial": "Matched",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MatchedR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emissing parts after parts\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "MissingAfter",
          "package": "syntactical",
          "signature": "MissingAfter [a] [a]",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingAfter\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:MissingAfter\"]"
        },
        "index": {
          "description": "missing parts after parts",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "MissingAfter",
          "normalized": "MissingAfter[a][a]",
          "package": "syntactical",
          "partial": "Missing After",
          "signature": "MissingAfter[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emissing parts before part\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "MissingBefore",
          "package": "syntactical",
          "signature": "MissingBefore [[a]] a",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingBefore\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:MissingBefore\"]"
        },
        "index": {
          "description": "missing parts before part",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "MissingBefore",
          "normalized": "MissingBefore[[a]]a",
          "package": "syntactical",
          "partial": "Missing Before",
          "signature": "MissingBefore[[a]]a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emissing sub-expression after string\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "MissingSubAfter",
          "package": "syntactical",
          "signature": "MissingSubAfter a",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingSubAfter\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:MissingSubAfter\"]"
        },
        "index": {
          "description": "missing sub-expression after string",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "MissingSubAfter",
          "package": "syntactical",
          "partial": "Missing Sub After",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingSubAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emissing sub-expression before string\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "MissingSubBefore",
          "package": "syntactical",
          "signature": "MissingSubBefore a",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingSubBefore\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:MissingSubBefore\"]"
        },
        "index": {
          "description": "missing sub-expression before string",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "MissingSubBefore",
          "package": "syntactical",
          "partial": "Missing Sub Before",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingSubBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emissing sub-expression between parts\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "MissingSubBetween",
          "package": "syntactical",
          "signature": "MissingSubBetween a a",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingSubBetween\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:MissingSubBetween\"]"
        },
        "index": {
          "description": "missing sub-expression between parts",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "MissingSubBetween",
          "package": "syntactical",
          "partial": "Missing Sub Between",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:MissingSubBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "S",
          "package": "syntactical",
          "signature": "S [SExpr a] [Tree a] [[SExpr a]] (Rule a)",
          "source": "src/Text-Syntactical-Yard.html#Shunt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "S",
          "normalized": "S[SExpr a][Tree a][[SExpr a]](Rule a)",
          "package": "syntactical",
          "signature": "S[SExpr a][Tree a][[SExpr a]](Rule a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "SExpr",
          "package": "syntactical",
          "signature": "SExpr",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "SExpr",
          "package": "syntactical",
          "partial": "SExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:SExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "StackApp",
          "package": "syntactical",
          "signature": "StackApp",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "StackApp",
          "package": "syntactical",
          "partial": "Stack App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:StackApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "StackL",
          "package": "syntactical",
          "signature": "StackL",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "StackL",
          "package": "syntactical",
          "partial": "Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:StackL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "StackOp",
          "package": "syntactical",
          "signature": "StackOp",
          "source": "src/Text-Syntactical-Yard.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "StackOp",
          "package": "syntactical",
          "partial": "Stack Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:StackOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethis is a bug if it happens\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "Unexpected",
          "package": "syntactical",
          "signature": "Unexpected",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Unexpected\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:Unexpected\"]"
        },
        "index": {
          "description": "this is bug if it happens",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "Unexpected",
          "package": "syntactical",
          "partial": "Unexpected",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:Unexpected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "initial",
          "package": "syntactical",
          "signature": "[SExpr a] -\u003e Shunt a",
          "source": "src/Text-Syntactical-Yard.html#initial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "initial",
          "normalized": "[SExpr a]-\u003eShunt a",
          "package": "syntactical",
          "signature": "[SExpr a]-\u003eShunt a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:initial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "isDone",
          "package": "syntactical",
          "signature": "Shunt a -\u003e Bool",
          "source": "src/Text-Syntactical-Yard.html#isDone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "isDone",
          "normalized": "Shunt a-\u003eBool",
          "package": "syntactical",
          "partial": "Done",
          "signature": "Shunt a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:isDone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGive a textual representation of a \u003ccode\u003e\u003ca\u003eFailure\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "showFailure",
          "package": "syntactical",
          "signature": "Failure a -\u003e String",
          "source": "src/Text-Syntactical-Yard.html#showFailure",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:showFailure\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:showFailure\"]"
        },
        "index": {
          "description": "Give textual representation of Failure",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "showFailure",
          "normalized": "Failure a-\u003eString",
          "package": "syntactical",
          "partial": "Failure",
          "signature": "Failure a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:showFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a list of s-expressions according to an operator table.\n Usually the s-expressions will be the result of applying \u003ccode\u003e\u003ca\u003eAtom\u003c/a\u003e\u003c/code\u003e\n to each token.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "shunt",
          "package": "syntactical",
          "signature": "Table a -\u003e [SExpr a] -\u003e Either (Failure a) (SExpr a)",
          "source": "src/Text-Syntactical-Yard.html#shunt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:shunt\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:shunt\"]"
        },
        "index": {
          "description": "Parse list of s-expressions according to an operator table Usually the s-expressions will be the result of applying Atom to each token",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "shunt",
          "normalized": "Table a-\u003e[SExpr a]-\u003eEither(Failure a)(SExpr a)",
          "package": "syntactical",
          "signature": "Table a-\u003e[SExpr a]-\u003eEither(Failure a)(SExpr a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:shunt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical.Yard",
          "name": "step",
          "package": "syntactical",
          "signature": "Table a -\u003e Shunt a -\u003e Shunt a",
          "source": "src/Text-Syntactical-Yard.html#step",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "step",
          "normalized": "Table a-\u003eShunt a-\u003eShunt a",
          "package": "syntactical",
          "signature": "Table a-\u003eShunt a-\u003eShunt a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to the \u003ccode\u003e\u003ca\u003eshunt\u003c/a\u003e\u003c/code\u003e function but print the steps\n performed by the modified shunting yard algorithm.\n This function is useful to understand (and debug) the\n modified shunting-yard algorithm.\n\u003c/p\u003e",
          "module": "[\"Text.Syntactical.Yard\",\"Text.Syntactical\"]",
          "name": "steps",
          "package": "syntactical",
          "signature": "Table a -\u003e [SExpr a] -\u003e IO ()",
          "source": "src/Text-Syntactical-Yard.html#steps",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:steps\",\"http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:steps\"]"
        },
        "index": {
          "description": "Similar to the shunt function but print the steps performed by the modified shunting yard algorithm This function is useful to understand and debug the modified shunting-yard algorithm",
          "hierarchy": "Text Syntactical Yard",
          "module": "Text.Syntactical.Yard",
          "name": "steps",
          "normalized": "Table a-\u003e[SExpr a]-\u003eIO()",
          "package": "syntactical",
          "signature": "Table a-\u003e[SExpr a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical-Yard.html#v:steps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis convenience module re-exports from \u003ccode\u003eText.Syntactical.Yard\u003c/code\u003e\n and \u003ccode\u003eText.Syntactical.Data\u003c/code\u003e everything a typical usage of Syntactical\n would need.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Syntactical",
          "name": "Syntactical",
          "package": "syntactical",
          "source": "src/Text-Syntactical.html",
          "type": "module"
        },
        "index": {
          "description": "This convenience module re-exports from Text.Syntactical.Yard and Text.Syntactical.Data everything typical usage of Syntactical would need",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Syntactical",
          "package": "syntactical",
          "partial": "Syntactical",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Syntactical",
          "name": "Ambiguity",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Ambiguity",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Ambiguity",
          "package": "syntactical",
          "partial": "Ambiguity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:Ambiguity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the associativity of an infix operator.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "Associativity",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Associativity",
          "type": "data"
        },
        "index": {
          "description": "Specify the associativity of an infix operator",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Associativity",
          "package": "syntactical",
          "partial": "Associativity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:Associativity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe different failure cases the \u003ccode\u003e\u003ca\u003eshunt\u003c/a\u003e\u003c/code\u003e function can return.\n The \u003ccode\u003e\u003ca\u003eshowFailure\u003c/a\u003e\u003c/code\u003e function can be used to give them a textual\n representation.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "Failure",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Yard.html#Failure",
          "type": "data"
        },
        "index": {
          "description": "The different failure cases the shunt function can return The showFailure function can be used to give them textual representation",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Failure",
          "package": "syntactical",
          "partial": "Failure",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:Failure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Hole is used to give various behaviours when dealing\n with internal holes.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "Hole",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Hole",
          "type": "data"
        },
        "index": {
          "description": "The Hole is used to give various behaviours when dealing with internal holes",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Hole",
          "package": "syntactical",
          "partial": "Hole",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:Hole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe operator representation, parametrized by the token type.\n It allows infix, prefix, postfix,\n and closed operators, with possibly multiple internal holes.\n Different holes are possible, to drive the parse in specific ways.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "Op",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Op",
          "type": "data"
        },
        "index": {
          "description": "The operator representation parametrized by the token type It allows infix prefix postfix and closed operators with possibly multiple internal holes Different holes are possible to drive the parse in specific ways",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Op",
          "package": "syntactical",
          "partial": "Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe s-expression data type used as input and output of the parser.\n The type is parametrized by the type of the token.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "SExpr",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#SExpr",
          "type": "data"
        },
        "index": {
          "description": "The s-expression data type used as input and output of the parser The type is parametrized by the type of the token",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "SExpr",
          "package": "syntactical",
          "partial": "SExpr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:SExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the operator table.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "Table",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Table",
          "type": "data"
        },
        "index": {
          "description": "The type of the operator table",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Table",
          "package": "syntactical",
          "partial": "Table",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:Table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of the types that can be parsed.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "Token",
          "package": "syntactical",
          "source": "src/Text-Syntactical-Data.html#Token",
          "type": "class"
        },
        "index": {
          "description": "The class of the types that can be parsed",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "Token",
          "package": "syntactical",
          "partial": "Token",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest if two tokens are the same (used to find match from the\n operator table). A default definition that compares the result\n of toString is provided.\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "consider",
          "package": "syntactical",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Text-Syntactical-Data.html#consider",
          "type": "method"
        },
        "index": {
          "description": "test if two tokens are the same used to find match from the operator table default definition that compares the result of toString is provided",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "consider",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "syntactical",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:consider"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate an output node from an operator and its arguments\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "operator",
          "package": "syntactical",
          "signature": "Op a -\u003e [SExpr a] -\u003e SExpr a",
          "source": "src/Text-Syntactical-Data.html#operator",
          "type": "method"
        },
        "index": {
          "description": "create an output node from an operator and its arguments",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "operator",
          "normalized": "Op a-\u003e[SExpr a]-\u003eSExpr a",
          "package": "syntactical",
          "signature": "Op a-\u003e[SExpr a]-\u003eSExpr a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert to a string (for showing purpose)\n\u003c/p\u003e",
          "module": "Text.Syntactical",
          "name": "toString",
          "package": "syntactical",
          "signature": "a -\u003e String",
          "source": "src/Text-Syntactical-Data.html#toString",
          "type": "method"
        },
        "index": {
          "description": "convert to string for showing purpose",
          "hierarchy": "Text Syntactical",
          "module": "Text.Syntactical",
          "name": "toString",
          "normalized": "a-\u003eString",
          "package": "syntactical",
          "partial": "String",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/syntactical/docs/Text-Syntactical.html#v:toString"
      }
    }
  ]
]