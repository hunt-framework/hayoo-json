[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "lambdacube-engine"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationState",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-AnimationState.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationState",
          "package": "lambdacube-engine",
          "partial": "Animation State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents the state of an animation and the weight of it's influence.\n  remarks\n      Other classes can hold instances of this class to store the state of any animations\n    they are using.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationState",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "data"
        },
        "index": {
          "description": "Represents the state of an animation and the weight of it influence remarks Other classes can hold instances of this class to store the state of any animations they are using",
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationState",
          "package": "lambdacube-engine",
          "partial": "Animation State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#t:AnimationState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass encapsulating a set of AnimationState objects.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationStateSet",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationStateSet",
          "type": "data"
        },
        "index": {
          "description": "Class encapsulating set of AnimationState objects",
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationStateSet",
          "package": "lambdacube-engine",
          "partial": "Animation State Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#t:AnimationStateSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationState",
          "package": "lambdacube-engine",
          "signature": "AnimationState",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationState",
          "package": "lambdacube-engine",
          "partial": "Animation State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:AnimationState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationStateSet",
          "package": "lambdacube-engine",
          "signature": "AnimationStateSet",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationStateSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "AnimationStateSet",
          "package": "lambdacube-engine",
          "partial": "Animation State Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:AnimationStateSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asAnimationName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asAnimationName",
          "package": "lambdacube-engine",
          "partial": "Animation Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:asAnimationName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe blend mask (containing per bone weights)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asBlendMask",
          "package": "lambdacube-engine",
          "signature": "[Float]",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "description": "the blend mask containing per bone weights",
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asBlendMask",
          "normalized": "[Float]",
          "package": "lambdacube-engine",
          "partial": "Blend Mask",
          "signature": "[Float]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:asBlendMask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asEnabled",
          "package": "lambdacube-engine",
          "partial": "Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:asEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asLength",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asLength",
          "package": "lambdacube-engine",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:asLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asLoop",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asLoop",
          "package": "lambdacube-engine",
          "partial": "Loop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:asLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asTimePos",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asTimePos",
          "package": "lambdacube-engine",
          "partial": "Time Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:asTimePos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asWeight",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "asWeight",
          "package": "lambdacube-engine",
          "partial": "Weight",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:asWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "assAnimationStates",
          "package": "lambdacube-engine",
          "signature": "Map String AnimationState",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationStateSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "assAnimationStates",
          "package": "lambdacube-engine",
          "partial": "Animation States",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:assAnimationStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "assDirtyFrameNumber",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationStateSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "assDirtyFrameNumber",
          "package": "lambdacube-engine",
          "partial": "Dirty Frame Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:assDirtyFrameNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of enabled animation states\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "assEnabledAnimationStates",
          "package": "lambdacube-engine",
          "signature": "[AnimationState]",
          "source": "src/Graphics-LambdaCube-AnimationState.html#AnimationStateSet",
          "type": "function"
        },
        "index": {
          "description": "List of enabled animation states",
          "hierarchy": "Graphics LambdaCube AnimationState",
          "module": "Graphics.LambdaCube.AnimationState",
          "name": "assEnabledAnimationStates",
          "normalized": "[AnimationState]",
          "package": "lambdacube-engine",
          "partial": "Enabled Animation States",
          "signature": "[AnimationState]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-AnimationState.html#v:assEnabledAnimationStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "BlendMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "BlendMode",
          "package": "lambdacube-engine",
          "partial": "Blend Mode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendModeEx",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendModeEx",
          "package": "lambdacube-engine",
          "partial": "Layer Blend Mode Ex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:LayerBlendModeEx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture blending operations.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendOperation",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperation",
          "type": "data"
        },
        "index": {
          "description": "Texture blending operations",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendOperation",
          "package": "lambdacube-engine",
          "partial": "Layer Blend Operation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:LayerBlendOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtended texture blending operations.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendOperationEx",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "data"
        },
        "index": {
          "description": "Extended texture blending operations",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendOperationEx",
          "package": "lambdacube-engine",
          "partial": "Layer Blend Operation Ex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:LayerBlendOperationEx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSources of values for blending operations.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendSource",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendSource",
          "type": "data"
        },
        "index": {
          "description": "Sources of values for blending operations",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendSource",
          "package": "lambdacube-engine",
          "partial": "Layer Blend Source",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:LayerBlendSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of texture blend mode.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendType",
          "type": "data"
        },
        "index": {
          "description": "Type of texture blend mode",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendType",
          "package": "lambdacube-engine",
          "partial": "Layer Blend Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:LayerBlendType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlending factors for manually blending objects with the scene.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SceneBlendFactor",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "data"
        },
        "index": {
          "description": "Blending factors for manually blending objects with the scene",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SceneBlendFactor",
          "package": "lambdacube-engine",
          "partial": "Scene Blend Factor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:SceneBlendFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlending operations controls how objects are blended into the scene.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SceneBlendOperation",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendOperation",
          "type": "data"
        },
        "index": {
          "description": "Blending operations controls how objects are blended into the scene",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SceneBlendOperation",
          "package": "lambdacube-engine",
          "partial": "Scene Blend Operation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:SceneBlendOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of blending that you can specify between an object and the\n existing contents of the scene.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SceneBlendType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendType",
          "type": "data"
        },
        "index": {
          "description": "Types of blending that you can specify between an object and the existing contents of the scene",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SceneBlendType",
          "package": "lambdacube-engine",
          "partial": "Scene Blend Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#t:SceneBlendType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd colour components together\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_ADD",
          "package": "lambdacube-engine",
          "signature": "LBO_ADD",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperation",
          "type": "function"
        },
        "index": {
          "description": "add colour components together",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_ADD",
          "package": "lambdacube-engine",
          "partial": "LBO ADD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBO_ADD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblend based on texture alpha\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_ALPHA_BLEND",
          "package": "lambdacube-engine",
          "signature": "LBO_ALPHA_BLEND",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperation",
          "type": "function"
        },
        "index": {
          "description": "blend based on texture alpha",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_ALPHA_BLEND",
          "package": "lambdacube-engine",
          "partial": "LBO ALPHA BLEND",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBO_ALPHA_BLEND"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emultiply colour components together\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_MODULATE",
          "package": "lambdacube-engine",
          "signature": "LBO_MODULATE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperation",
          "type": "function"
        },
        "index": {
          "description": "multiply colour components together",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_MODULATE",
          "package": "lambdacube-engine",
          "partial": "LBO MODULATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBO_MODULATE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplace all colour with texture with no adjustment\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_REPLACE",
          "package": "lambdacube-engine",
          "signature": "LBO_REPLACE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperation",
          "type": "function"
        },
        "index": {
          "description": "replace all colour with texture with no adjustment",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBO_REPLACE",
          "package": "lambdacube-engine",
          "partial": "LBO REPLACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBO_REPLACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe colour as built up from previous stages\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_CURRENT",
          "package": "lambdacube-engine",
          "signature": "LBS_CURRENT",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendSource",
          "type": "function"
        },
        "index": {
          "description": "the colour as built up from previous stages",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_CURRENT",
          "package": "lambdacube-engine",
          "partial": "LBS CURRENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBS_CURRENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe interpolated diffuse colour from the vertices\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_DIFFUSE",
          "package": "lambdacube-engine",
          "signature": "LBS_DIFFUSE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendSource",
          "type": "function"
        },
        "index": {
          "description": "the interpolated diffuse colour from the vertices",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_DIFFUSE",
          "package": "lambdacube-engine",
          "partial": "LBS DIFFUSE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBS_DIFFUSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea colour supplied manually as a separate argument\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_MANUAL",
          "package": "lambdacube-engine",
          "signature": "LBS_MANUAL",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendSource",
          "type": "function"
        },
        "index": {
          "description": "colour supplied manually as separate argument",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_MANUAL",
          "package": "lambdacube-engine",
          "partial": "LBS MANUAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBS_MANUAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe interpolated specular colour from the vertices\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_SPECULAR",
          "package": "lambdacube-engine",
          "signature": "LBS_SPECULAR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendSource",
          "type": "function"
        },
        "index": {
          "description": "the interpolated specular colour from the vertices",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_SPECULAR",
          "package": "lambdacube-engine",
          "partial": "LBS SPECULAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBS_SPECULAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe colour derived from the texture assigned to this layer\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_TEXTURE",
          "package": "lambdacube-engine",
          "signature": "LBS_TEXTURE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendSource",
          "type": "function"
        },
        "index": {
          "description": "the colour derived from the texture assigned to this layer",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBS_TEXTURE",
          "package": "lambdacube-engine",
          "partial": "LBS TEXTURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBS_TEXTURE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBT_ALPHA",
          "package": "lambdacube-engine",
          "signature": "LBT_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBT_ALPHA",
          "package": "lambdacube-engine",
          "partial": "LBT ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBT_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBT_COLOUR",
          "package": "lambdacube-engine",
          "signature": "LBT_COLOUR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBT_COLOUR",
          "package": "lambdacube-engine",
          "partial": "LBT COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBT_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd source1 and source2 together\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_ADD",
          "package": "lambdacube-engine",
          "signature": "LBX_ADD",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "add source1 and source2 together",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_ADD",
          "package": "lambdacube-engine",
          "partial": "LBX ADD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_ADD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas LBX_ADD, but subtract 0.5 from the result\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_ADD_SIGNED",
          "package": "lambdacube-engine",
          "signature": "LBX_ADD_SIGNED",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "as LBX ADD but subtract from the result",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_ADD_SIGNED",
          "package": "lambdacube-engine",
          "partial": "LBX ADD SIGNED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_ADD_SIGNED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas LBX_ADD, but subtract product from the sum\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_ADD_SMOOTH",
          "package": "lambdacube-engine",
          "signature": "LBX_ADD_SMOOTH",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "as LBX ADD but subtract product from the sum",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_ADD_SMOOTH",
          "package": "lambdacube-engine",
          "partial": "LBX ADD SMOOTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_ADD_SMOOTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas LBX_BLEND_DIFFUSE_ALPHA, but use current alpha from previous stages\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_CURRENT_ALPHA",
          "package": "lambdacube-engine",
          "signature": "LBX_BLEND_CURRENT_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "as LBX BLEND DIFFUSE ALPHA but use current alpha from previous stages",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_CURRENT_ALPHA",
          "package": "lambdacube-engine",
          "partial": "LBX BLEND CURRENT ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_BLEND_CURRENT_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse interpolated alpha value from vertices to scale source1, then add source2 scaled by (1-alpha)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_DIFFUSE_ALPHA",
          "package": "lambdacube-engine",
          "signature": "LBX_BLEND_DIFFUSE_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "use interpolated alpha value from vertices to scale source1 then add source2 scaled by alpha",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_DIFFUSE_ALPHA",
          "package": "lambdacube-engine",
          "partial": "LBX BLEND DIFFUSE ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_BLEND_DIFFUSE_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse interpolated color values from vertices to scale source1, then add source2 scaled by (1-color)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "LBX_BLEND_DIFFUSE_COLOUR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "use interpolated color values from vertices to scale source1 then add source2 scaled by color",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "LBX BLEND DIFFUSE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_BLEND_DIFFUSE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas LBX_BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_MANUAL",
          "package": "lambdacube-engine",
          "signature": "LBX_BLEND_MANUAL",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "as LBX BLEND DIFFUSE ALPHA but use constant manual blend value",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_MANUAL",
          "package": "lambdacube-engine",
          "partial": "LBX BLEND MANUAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_BLEND_MANUAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas LBX_BLEND_DIFFUSE_ALPHA, but use alpha from texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_TEXTURE_ALPHA",
          "package": "lambdacube-engine",
          "signature": "LBX_BLEND_TEXTURE_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "as LBX BLEND DIFFUSE ALPHA but use alpha from texture",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_BLEND_TEXTURE_ALPHA",
          "package": "lambdacube-engine",
          "partial": "LBX BLEND TEXTURE ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_BLEND_TEXTURE_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edot product of color1 and color2\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_DOTPRODUCT",
          "package": "lambdacube-engine",
          "signature": "LBX_DOTPRODUCT",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "dot product of color1 and color2",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_DOTPRODUCT",
          "package": "lambdacube-engine",
          "partial": "LBX DOTPRODUCT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_DOTPRODUCT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emultiply source1 and source2 together\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_MODULATE",
          "package": "lambdacube-engine",
          "signature": "LBX_MODULATE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "multiply source1 and source2 together",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_MODULATE",
          "package": "lambdacube-engine",
          "partial": "LBX MODULATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_MODULATE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas LBX_MODULATE but brighten afterwards (x2)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_MODULATE_X2",
          "package": "lambdacube-engine",
          "signature": "LBX_MODULATE_X2",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "as LBX MODULATE but brighten afterwards x2",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_MODULATE_X2",
          "package": "lambdacube-engine",
          "partial": "LBX MODULATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_MODULATE_X2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eas LBX_MODULATE but brighten more afterwards (x4)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_MODULATE_X4",
          "package": "lambdacube-engine",
          "signature": "LBX_MODULATE_X4",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "as LBX MODULATE but brighten more afterwards x4",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_MODULATE_X4",
          "package": "lambdacube-engine",
          "partial": "LBX MODULATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_MODULATE_X4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse source1 without modification\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_SOURCE1",
          "package": "lambdacube-engine",
          "signature": "LBX_SOURCE1",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "use source1 without modification",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_SOURCE1",
          "package": "lambdacube-engine",
          "partial": "LBX SOURCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_SOURCE1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse source2 without modification\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_SOURCE2",
          "package": "lambdacube-engine",
          "signature": "LBX_SOURCE2",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "use source2 without modification",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_SOURCE2",
          "package": "lambdacube-engine",
          "partial": "LBX SOURCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_SOURCE2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esubtract source2 from source1\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_SUBTRACT",
          "package": "lambdacube-engine",
          "signature": "LBX_SUBTRACT",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendOperationEx",
          "type": "function"
        },
        "index": {
          "description": "subtract source2 from source1",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LBX_SUBTRACT",
          "package": "lambdacube-engine",
          "partial": "LBX SUBTRACT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LBX_SUBTRACT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendModeEx",
          "package": "lambdacube-engine",
          "signature": "LayerBlendModeEx",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "LayerBlendModeEx",
          "package": "lambdacube-engine",
          "partial": "Layer Blend Mode Ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:LayerBlendModeEx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_DEST_ALPHA",
          "package": "lambdacube-engine",
          "signature": "SBF_DEST_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_DEST_ALPHA",
          "package": "lambdacube-engine",
          "partial": "SBF DEST ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_DEST_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_DEST_COLOUR",
          "package": "lambdacube-engine",
          "signature": "SBF_DEST_COLOUR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_DEST_COLOUR",
          "package": "lambdacube-engine",
          "partial": "SBF DEST COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_DEST_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE",
          "package": "lambdacube-engine",
          "signature": "SBF_ONE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE",
          "package": "lambdacube-engine",
          "partial": "SBF ONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_ONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_DEST_ALPHA",
          "package": "lambdacube-engine",
          "signature": "SBF_ONE_MINUS_DEST_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_DEST_ALPHA",
          "package": "lambdacube-engine",
          "partial": "SBF ONE MINUS DEST ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_ONE_MINUS_DEST_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_DEST_COLOUR",
          "package": "lambdacube-engine",
          "signature": "SBF_ONE_MINUS_DEST_COLOUR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_DEST_COLOUR",
          "package": "lambdacube-engine",
          "partial": "SBF ONE MINUS DEST COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_ONE_MINUS_DEST_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_SOURCE_ALPHA",
          "package": "lambdacube-engine",
          "signature": "SBF_ONE_MINUS_SOURCE_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_SOURCE_ALPHA",
          "package": "lambdacube-engine",
          "partial": "SBF ONE MINUS SOURCE ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_ONE_MINUS_SOURCE_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_SOURCE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "SBF_ONE_MINUS_SOURCE_COLOUR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ONE_MINUS_SOURCE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "SBF ONE MINUS SOURCE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_ONE_MINUS_SOURCE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_SOURCE_ALPHA",
          "package": "lambdacube-engine",
          "signature": "SBF_SOURCE_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_SOURCE_ALPHA",
          "package": "lambdacube-engine",
          "partial": "SBF SOURCE ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_SOURCE_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_SOURCE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "SBF_SOURCE_COLOUR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_SOURCE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "SBF SOURCE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_SOURCE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ZERO",
          "package": "lambdacube-engine",
          "signature": "SBF_ZERO",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendFactor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBF_ZERO",
          "package": "lambdacube-engine",
          "partial": "SBF ZERO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBF_ZERO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_ADD",
          "package": "lambdacube-engine",
          "signature": "SBO_ADD",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_ADD",
          "package": "lambdacube-engine",
          "partial": "SBO ADD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBO_ADD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_MAX",
          "package": "lambdacube-engine",
          "signature": "SBO_MAX",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_MAX",
          "package": "lambdacube-engine",
          "partial": "SBO MAX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBO_MAX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_MIN",
          "package": "lambdacube-engine",
          "signature": "SBO_MIN",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_MIN",
          "package": "lambdacube-engine",
          "partial": "SBO MIN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBO_MIN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_REVERSE_SUBTRACT",
          "package": "lambdacube-engine",
          "signature": "SBO_REVERSE_SUBTRACT",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_REVERSE_SUBTRACT",
          "package": "lambdacube-engine",
          "partial": "SBO REVERSE SUBTRACT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBO_REVERSE_SUBTRACT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_SUBTRACT",
          "package": "lambdacube-engine",
          "signature": "SBO_SUBTRACT",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBO_SUBTRACT",
          "package": "lambdacube-engine",
          "partial": "SBO SUBTRACT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBO_SUBTRACT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd the texture values to the existing scene content\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_ADD",
          "package": "lambdacube-engine",
          "signature": "SBT_ADD",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendType",
          "type": "function"
        },
        "index": {
          "description": "Add the texture values to the existing scene content",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_ADD",
          "package": "lambdacube-engine",
          "partial": "SBT ADD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBT_ADD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply the 2 colours together\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_MODULATE",
          "package": "lambdacube-engine",
          "signature": "SBT_MODULATE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendType",
          "type": "function"
        },
        "index": {
          "description": "Multiply the colours together",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_MODULATE",
          "package": "lambdacube-engine",
          "partial": "SBT MODULATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBT_MODULATE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default blend mode where source replaces destination\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_REPLACE",
          "package": "lambdacube-engine",
          "signature": "SBT_REPLACE",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendType",
          "type": "function"
        },
        "index": {
          "description": "The default blend mode where source replaces destination",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_REPLACE",
          "package": "lambdacube-engine",
          "partial": "SBT REPLACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBT_REPLACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake the object transparent based on the final alpha values in the texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_TRANSPARENT_ALPHA",
          "package": "lambdacube-engine",
          "signature": "SBT_TRANSPARENT_ALPHA",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendType",
          "type": "function"
        },
        "index": {
          "description": "Make the object transparent based on the final alpha values in the texture",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_TRANSPARENT_ALPHA",
          "package": "lambdacube-engine",
          "partial": "SBT TRANSPARENT ALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBT_TRANSPARENT_ALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake the object transparent based on the colour values in the texture (brighter = more opaque)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_TRANSPARENT_COLOUR",
          "package": "lambdacube-engine",
          "signature": "SBT_TRANSPARENT_COLOUR",
          "source": "src/Graphics-LambdaCube-BlendMode.html#SceneBlendType",
          "type": "function"
        },
        "index": {
          "description": "Make the object transparent based on the colour values in the texture brighter more opaque",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "SBT_TRANSPARENT_COLOUR",
          "package": "lambdacube-engine",
          "partial": "SBT TRANSPARENT COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:SBT_TRANSPARENT_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverts SceneBlendType to SceneBlendFactor pair\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "convertSBTtoSBF",
          "package": "lambdacube-engine",
          "signature": "SceneBlendType -\u003e (SceneBlendFactor, SceneBlendFactor)",
          "source": "src/Graphics-LambdaCube-BlendMode.html#convertSBTtoSBF",
          "type": "function"
        },
        "index": {
          "description": "Converts SceneBlendType to SceneBlendFactor pair",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "convertSBTtoSBF",
          "normalized": "SceneBlendType-\u003e(SceneBlendFactor,SceneBlendFactor)",
          "package": "lambdacube-engine",
          "partial": "SBTto SBF",
          "signature": "SceneBlendType-\u003e(SceneBlendFactor,SceneBlendFactor)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:convertSBTtoSBF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eManual alpha value for manual source1\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbAlphaArg1",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "Manual alpha value for manual source1",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbAlphaArg1",
          "package": "lambdacube-engine",
          "partial": "Alpha Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbAlphaArg1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eManual alpha value for manual source2\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbAlphaArg2",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "Manual alpha value for manual source2",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbAlphaArg2",
          "package": "lambdacube-engine",
          "partial": "Alpha Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbAlphaArg2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of blending (colour or alpha)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbBlendType",
          "package": "lambdacube-engine",
          "signature": "LayerBlendType",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "The type of blending colour or alpha",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbBlendType",
          "package": "lambdacube-engine",
          "partial": "Blend Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbBlendType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eManual colour value for manual source1\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbColourArg1",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "Manual colour value for manual source1",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbColourArg1",
          "package": "lambdacube-engine",
          "partial": "Colour Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbColourArg1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eManual colour value for manual source2\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbColourArg2",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "Manual colour value for manual source2",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbColourArg2",
          "package": "lambdacube-engine",
          "partial": "Colour Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbColourArg2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eManual blending factor\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbFactor",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "Manual blending factor",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbFactor",
          "package": "lambdacube-engine",
          "partial": "Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe operation to be applied\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbOperation",
          "package": "lambdacube-engine",
          "signature": "LayerBlendOperationEx",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "The operation to be applied",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbOperation",
          "package": "lambdacube-engine",
          "partial": "Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first source of colour/alpha\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbSource1",
          "package": "lambdacube-engine",
          "signature": "LayerBlendSource",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "The first source of colour alpha",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbSource1",
          "package": "lambdacube-engine",
          "partial": "Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbSource1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe second source of colour/alpha\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbSource2",
          "package": "lambdacube-engine",
          "signature": "LayerBlendSource",
          "source": "src/Graphics-LambdaCube-BlendMode.html#LayerBlendModeEx",
          "type": "function"
        },
        "index": {
          "description": "The second source of colour alpha",
          "hierarchy": "Graphics LambdaCube BlendMode",
          "module": "Graphics.LambdaCube.BlendMode",
          "name": "lbSource2",
          "package": "lambdacube-engine",
          "partial": "Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-BlendMode.html#v:lbSource2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "Common",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "Common",
          "package": "lambdacube-engine",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComparison functions used for the depth/stencil buffer operations\n and others.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "CompareFunction",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "data"
        },
        "index": {
          "description": "Comparison functions used for the depth stencil buffer operations and others",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CompareFunction",
          "package": "lambdacube-engine",
          "partial": "Compare Function",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:CompareFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHardware culling modes based on vertex winding. This setting applies to how the hardware API culls triangles it is sent.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "CullingMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#CullingMode",
          "type": "data"
        },
        "index": {
          "description": "Hardware culling modes based on vertex winding This setting applies to how the hardware API culls triangles it is sent",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CullingMode",
          "package": "lambdacube-engine",
          "partial": "Culling Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:CullingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFiltering options for textures / mipmaps.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FilterOptions",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#FilterOptions",
          "type": "data"
        },
        "index": {
          "description": "Filtering options for textures mipmaps",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FilterOptions",
          "package": "lambdacube-engine",
          "partial": "Filter Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:FilterOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "FilterType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#FilterType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FilterType",
          "package": "lambdacube-engine",
          "partial": "Filter Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:FilterType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFog modes.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FogMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#FogMode",
          "type": "data"
        },
        "index": {
          "description": "Fog modes",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FogMode",
          "package": "lambdacube-engine",
          "partial": "Fog Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:FogMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "FrameBufferType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#FrameBufferType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FrameBufferType",
          "package": "lambdacube-engine",
          "partial": "Frame Buffer Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:FrameBufferType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eManual culling modes based on vertex normals.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "ManualCullingMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#ManualCullingMode",
          "type": "data"
        },
        "index": {
          "description": "Manual culling modes based on vertex normals",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "ManualCullingMode",
          "package": "lambdacube-engine",
          "partial": "Manual Culling Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:ManualCullingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe polygon mode to use when rasterising.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "PolygonMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#PolygonMode",
          "type": "data"
        },
        "index": {
          "description": "The polygon mode to use when rasterising",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "PolygonMode",
          "package": "lambdacube-engine",
          "partial": "Polygon Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:PolygonMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight shading modes.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "ShadeOptions",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#ShadeOptions",
          "type": "data"
        },
        "index": {
          "description": "Light shading modes",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "ShadeOptions",
          "package": "lambdacube-engine",
          "partial": "Shade Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:ShadeOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort mode for billboard-set and particle-system\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "SortMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#SortMode",
          "type": "data"
        },
        "index": {
          "description": "Sort mode for billboard-set and particle-system",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "SortMode",
          "package": "lambdacube-engine",
          "partial": "Sort Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:SortMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHigh-level filtering options providing shortcuts to settings the\n minification, magnification and mip filters.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "TextureFilterOptions",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#TextureFilterOptions",
          "type": "data"
        },
        "index": {
          "description": "High-level filtering options providing shortcuts to settings the minification magnification and mip filters",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "TextureFilterOptions",
          "package": "lambdacube-engine",
          "partial": "Texture Filter Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:TextureFilterOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "TrackVertexColourType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#TrackVertexColourType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "TrackVertexColourType",
          "package": "lambdacube-engine",
          "partial": "Track Vertex Colour Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:TrackVertexColourType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "WaveformType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Common.html#WaveformType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "WaveformType",
          "package": "lambdacube-engine",
          "partial": "Waveform Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#t:WaveformType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_ALWAYS_FAIL",
          "package": "lambdacube-engine",
          "signature": "CMPF_ALWAYS_FAIL",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_ALWAYS_FAIL",
          "package": "lambdacube-engine",
          "partial": "CMPF ALWAYS FAIL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_ALWAYS_FAIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_ALWAYS_PASS",
          "package": "lambdacube-engine",
          "signature": "CMPF_ALWAYS_PASS",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_ALWAYS_PASS",
          "package": "lambdacube-engine",
          "partial": "CMPF ALWAYS PASS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_ALWAYS_PASS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_EQUAL",
          "package": "lambdacube-engine",
          "signature": "CMPF_EQUAL",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_EQUAL",
          "package": "lambdacube-engine",
          "partial": "CMPF EQUAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_EQUAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_GREATER",
          "package": "lambdacube-engine",
          "signature": "CMPF_GREATER",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_GREATER",
          "package": "lambdacube-engine",
          "partial": "CMPF GREATER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_GREATER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_GREATER_EQUAL",
          "package": "lambdacube-engine",
          "signature": "CMPF_GREATER_EQUAL",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_GREATER_EQUAL",
          "package": "lambdacube-engine",
          "partial": "CMPF GREATER EQUAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_GREATER_EQUAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_LESS",
          "package": "lambdacube-engine",
          "signature": "CMPF_LESS",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_LESS",
          "package": "lambdacube-engine",
          "partial": "CMPF LESS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_LESS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_LESS_EQUAL",
          "package": "lambdacube-engine",
          "signature": "CMPF_LESS_EQUAL",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_LESS_EQUAL",
          "package": "lambdacube-engine",
          "partial": "CMPF LESS EQUAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_LESS_EQUAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_NOT_EQUAL",
          "package": "lambdacube-engine",
          "signature": "CMPF_NOT_EQUAL",
          "source": "src/Graphics-LambdaCube-Common.html#CompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CMPF_NOT_EQUAL",
          "package": "lambdacube-engine",
          "partial": "CMPF NOT EQUAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CMPF_NOT_EQUAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHardware culls triangles whose vertices are listed anticlockwise in the view.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "CULL_ANTICLOCKWISE",
          "package": "lambdacube-engine",
          "signature": "CULL_ANTICLOCKWISE",
          "source": "src/Graphics-LambdaCube-Common.html#CullingMode",
          "type": "function"
        },
        "index": {
          "description": "Hardware culls triangles whose vertices are listed anticlockwise in the view",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CULL_ANTICLOCKWISE",
          "package": "lambdacube-engine",
          "partial": "CULL ANTICLOCKWISE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CULL_ANTICLOCKWISE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHardware culls triangles whose vertices are listed clockwise in the view (default).\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "CULL_CLOCKWISE",
          "package": "lambdacube-engine",
          "signature": "CULL_CLOCKWISE",
          "source": "src/Graphics-LambdaCube-Common.html#CullingMode",
          "type": "function"
        },
        "index": {
          "description": "Hardware culls triangles whose vertices are listed clockwise in the view default",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CULL_CLOCKWISE",
          "package": "lambdacube-engine",
          "partial": "CULL CLOCKWISE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CULL_CLOCKWISE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHardware never culls triangles and renders everything it receives.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "CULL_NONE",
          "package": "lambdacube-engine",
          "signature": "CULL_NONE",
          "source": "src/Graphics-LambdaCube-Common.html#CullingMode",
          "type": "function"
        },
        "index": {
          "description": "Hardware never culls triangles and renders everything it receives",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "CULL_NONE",
          "package": "lambdacube-engine",
          "partial": "CULL NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:CULL_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFog density increases  exponentially from the camera (fog = 1/e^(distance * density))\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_EXP",
          "package": "lambdacube-engine",
          "signature": "FOG_EXP",
          "source": "src/Graphics-LambdaCube-Common.html#FogMode",
          "type": "function"
        },
        "index": {
          "description": "Fog density increases exponentially from the camera fog distance density",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_EXP",
          "package": "lambdacube-engine",
          "partial": "FOG EXP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FOG_EXP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_EXP2",
          "package": "lambdacube-engine",
          "signature": "FOG_EXP2",
          "source": "src/Graphics-LambdaCube-Common.html#FogMode",
          "type": "function"
        },
        "index": {
          "description": "Fog density increases at the square of FOG EXP i.e even quicker fog distance density",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_EXP2",
          "package": "lambdacube-engine",
          "partial": "FOG EXP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FOG_EXP2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFog density increases linearly between the start and end distances\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_LINEAR",
          "package": "lambdacube-engine",
          "signature": "FOG_LINEAR",
          "source": "src/Graphics-LambdaCube-Common.html#FogMode",
          "type": "function"
        },
        "index": {
          "description": "Fog density increases linearly between the start and end distances",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_LINEAR",
          "package": "lambdacube-engine",
          "partial": "FOG LINEAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FOG_LINEAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo fog. Duh.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_NONE",
          "package": "lambdacube-engine",
          "signature": "FOG_NONE",
          "source": "src/Graphics-LambdaCube-Common.html#FogMode",
          "type": "function"
        },
        "index": {
          "description": "No fog Duh",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FOG_NONE",
          "package": "lambdacube-engine",
          "partial": "FOG NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FOG_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to FO_LINEAR, but compensates for the angle of the texture plane\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_ANISOTROPIC",
          "package": "lambdacube-engine",
          "signature": "FO_ANISOTROPIC",
          "source": "src/Graphics-LambdaCube-Common.html#FilterOptions",
          "type": "function"
        },
        "index": {
          "description": "Similar to FO LINEAR but compensates for the angle of the texture plane",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_ANISOTROPIC",
          "package": "lambdacube-engine",
          "partial": "FO ANISOTROPIC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FO_ANISOTROPIC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAverage of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_LINEAR",
          "package": "lambdacube-engine",
          "signature": "FO_LINEAR",
          "source": "src/Graphics-LambdaCube-Common.html#FilterOptions",
          "type": "function"
        },
        "index": {
          "description": "Average of x2 pixel area denotes bilinear for MIN and MAG trilinear for MIP",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_LINEAR",
          "package": "lambdacube-engine",
          "partial": "FO LINEAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FO_LINEAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo filtering, used for FILT_MIP to turn off mipmapping\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_NONE",
          "package": "lambdacube-engine",
          "signature": "FO_NONE",
          "source": "src/Graphics-LambdaCube-Common.html#FilterOptions",
          "type": "function"
        },
        "index": {
          "description": "No filtering used for FILT MIP to turn off mipmapping",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_NONE",
          "package": "lambdacube-engine",
          "partial": "FO NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FO_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the closest pixel\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_POINT",
          "package": "lambdacube-engine",
          "signature": "FO_POINT",
          "source": "src/Graphics-LambdaCube-Common.html#FilterOptions",
          "type": "function"
        },
        "index": {
          "description": "Use the closest pixel",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FO_POINT",
          "package": "lambdacube-engine",
          "partial": "FO POINT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FO_POINT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe filter used when magnifying a texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FT_MAG",
          "package": "lambdacube-engine",
          "signature": "FT_MAG",
          "source": "src/Graphics-LambdaCube-Common.html#FilterType",
          "type": "function"
        },
        "index": {
          "description": "The filter used when magnifying texture",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FT_MAG",
          "package": "lambdacube-engine",
          "partial": "FT MAG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FT_MAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe filter used when shrinking a texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FT_MIN",
          "package": "lambdacube-engine",
          "signature": "FT_MIN",
          "source": "src/Graphics-LambdaCube-Common.html#FilterType",
          "type": "function"
        },
        "index": {
          "description": "The filter used when shrinking texture",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FT_MIN",
          "package": "lambdacube-engine",
          "partial": "FT MIN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FT_MIN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe filter used when determining the mipmap\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "FT_MIP",
          "package": "lambdacube-engine",
          "signature": "FT_MIP",
          "source": "src/Graphics-LambdaCube-Common.html#FilterType",
          "type": "function"
        },
        "index": {
          "description": "The filter used when determining the mipmap",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FT_MIP",
          "package": "lambdacube-engine",
          "partial": "FT MIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FT_MIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "FrameBufferType",
          "package": "lambdacube-engine",
          "signature": "FrameBufferType",
          "source": "src/Graphics-LambdaCube-Common.html#FrameBufferType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "FrameBufferType",
          "package": "lambdacube-engine",
          "partial": "Frame Buffer Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:FrameBufferType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCull triangles whose normal is pointing away from the camera (default).\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "MANUAL_CULL_BACK",
          "package": "lambdacube-engine",
          "signature": "MANUAL_CULL_BACK",
          "source": "src/Graphics-LambdaCube-Common.html#ManualCullingMode",
          "type": "function"
        },
        "index": {
          "description": "Cull triangles whose normal is pointing away from the camera default",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "MANUAL_CULL_BACK",
          "package": "lambdacube-engine",
          "partial": "MANUAL CULL BACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:MANUAL_CULL_BACK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCull triangles whose normal is pointing towards the camera.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "MANUAL_CULL_FRONT",
          "package": "lambdacube-engine",
          "signature": "MANUAL_CULL_FRONT",
          "source": "src/Graphics-LambdaCube-Common.html#ManualCullingMode",
          "type": "function"
        },
        "index": {
          "description": "Cull triangles whose normal is pointing towards the camera",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "MANUAL_CULL_FRONT",
          "package": "lambdacube-engine",
          "partial": "MANUAL CULL FRONT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:MANUAL_CULL_FRONT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo culling so everything is sent to the hardware.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "MANUAL_CULL_NONE",
          "package": "lambdacube-engine",
          "signature": "MANUAL_CULL_NONE",
          "source": "src/Graphics-LambdaCube-Common.html#ManualCullingMode",
          "type": "function"
        },
        "index": {
          "description": "No culling so everything is sent to the hardware",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "MANUAL_CULL_NONE",
          "package": "lambdacube-engine",
          "partial": "MANUAL CULL NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:MANUAL_CULL_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly points are rendered.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "PM_POINTS",
          "package": "lambdacube-engine",
          "signature": "PM_POINTS",
          "source": "src/Graphics-LambdaCube-Common.html#PolygonMode",
          "type": "function"
        },
        "index": {
          "description": "Only points are rendered",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "PM_POINTS",
          "package": "lambdacube-engine",
          "partial": "PM POINTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:PM_POINTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolid polygons are rendered.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "PM_SOLID",
          "package": "lambdacube-engine",
          "signature": "PM_SOLID",
          "source": "src/Graphics-LambdaCube-Common.html#PolygonMode",
          "type": "function"
        },
        "index": {
          "description": "Solid polygons are rendered",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "PM_SOLID",
          "package": "lambdacube-engine",
          "partial": "PM SOLID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:PM_SOLID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWireframe models are rendered.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "PM_WIREFRAME",
          "package": "lambdacube-engine",
          "signature": "PM_WIREFRAME",
          "source": "src/Graphics-LambdaCube-Common.html#PolygonMode",
          "type": "function"
        },
        "index": {
          "description": "Wireframe models are rendered",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "PM_WIREFRAME",
          "package": "lambdacube-engine",
          "partial": "PM WIREFRAME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:PM_WIREFRAME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort by direction of the camera\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "SM_DIRECTION",
          "package": "lambdacube-engine",
          "signature": "SM_DIRECTION",
          "source": "src/Graphics-LambdaCube-Common.html#SortMode",
          "type": "function"
        },
        "index": {
          "description": "Sort by direction of the camera",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "SM_DIRECTION",
          "package": "lambdacube-engine",
          "partial": "SM DIRECTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:SM_DIRECTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort by distance from the camera\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "SM_DISTANCE",
          "package": "lambdacube-engine",
          "signature": "SM_DISTANCE",
          "source": "src/Graphics-LambdaCube-Common.html#SortMode",
          "type": "function"
        },
        "index": {
          "description": "Sort by distance from the camera",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "SM_DISTANCE",
          "package": "lambdacube-engine",
          "partial": "SM DISTANCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:SM_DISTANCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "SO_FLAT",
          "package": "lambdacube-engine",
          "signature": "SO_FLAT",
          "source": "src/Graphics-LambdaCube-Common.html#ShadeOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "SO_FLAT",
          "package": "lambdacube-engine",
          "partial": "SO FLAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:SO_FLAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "SO_GOURAUD",
          "package": "lambdacube-engine",
          "signature": "SO_GOURAUD",
          "source": "src/Graphics-LambdaCube-Common.html#ShadeOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "SO_GOURAUD",
          "package": "lambdacube-engine",
          "partial": "SO GOURAUD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:SO_GOURAUD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "SO_PHONG",
          "package": "lambdacube-engine",
          "signature": "SO_PHONG",
          "source": "src/Graphics-LambdaCube-Common.html#ShadeOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "SO_PHONG",
          "package": "lambdacube-engine",
          "partial": "SO PHONG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:SO_PHONG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEqual to: min=FO_ANISOTROPIC, max=FO_ANISOTROPIC, mip=FO_LINEAR\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_ANISOTROPIC",
          "package": "lambdacube-engine",
          "signature": "TFO_ANISOTROPIC",
          "source": "src/Graphics-LambdaCube-Common.html#TextureFilterOptions",
          "type": "function"
        },
        "index": {
          "description": "Equal to min FO ANISOTROPIC max FO ANISOTROPIC mip FO LINEAR",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_ANISOTROPIC",
          "package": "lambdacube-engine",
          "partial": "TFO ANISOTROPIC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:TFO_ANISOTROPIC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEqual to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_POINT\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_BILINEAR",
          "package": "lambdacube-engine",
          "signature": "TFO_BILINEAR",
          "source": "src/Graphics-LambdaCube-Common.html#TextureFilterOptions",
          "type": "function"
        },
        "index": {
          "description": "Equal to min FO LINEAR mag FO LINEAR mip FO POINT",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_BILINEAR",
          "package": "lambdacube-engine",
          "partial": "TFO BILINEAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:TFO_BILINEAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEqual to: min=FO_POINT, mag=FO_POINT, mip=FO_NONE\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_NONE",
          "package": "lambdacube-engine",
          "signature": "TFO_NONE",
          "source": "src/Graphics-LambdaCube-Common.html#TextureFilterOptions",
          "type": "function"
        },
        "index": {
          "description": "Equal to min FO POINT mag FO POINT mip FO NONE",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_NONE",
          "package": "lambdacube-engine",
          "partial": "TFO NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:TFO_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEqual to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_LINEAR\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_TRILINEAR",
          "package": "lambdacube-engine",
          "signature": "TFO_TRILINEAR",
          "source": "src/Graphics-LambdaCube-Common.html#TextureFilterOptions",
          "type": "function"
        },
        "index": {
          "description": "Equal to min FO LINEAR mag FO LINEAR mip FO LINEAR",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "TFO_TRILINEAR",
          "package": "lambdacube-engine",
          "partial": "TFO TRILINEAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:TFO_TRILINEAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "TrackVertexColourType",
          "package": "lambdacube-engine",
          "signature": "TrackVertexColourType",
          "source": "src/Graphics-LambdaCube-Common.html#TrackVertexColourType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "TrackVertexColourType",
          "package": "lambdacube-engine",
          "partial": "Track Vertex Colour Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:TrackVertexColourType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGradual steady decrease from max to min over the period, with an instant return to max at the end.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_INVERSE_SAWTOOTH",
          "package": "lambdacube-engine",
          "signature": "WFT_INVERSE_SAWTOOTH",
          "source": "src/Graphics-LambdaCube-Common.html#WaveformType",
          "type": "function"
        },
        "index": {
          "description": "Gradual steady decrease from max to min over the period with an instant return to max at the end",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_INVERSE_SAWTOOTH",
          "package": "lambdacube-engine",
          "partial": "WFT INVERSE SAWTOOTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:WFT_INVERSE_SAWTOOTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePulse Width Modulation. Works like WFT_SQUARE, except the high to low transition is controlled by duty cycle.\n  With a duty cycle of 50% (0.5) will give the same output as WFT_SQUARE.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_PWM",
          "package": "lambdacube-engine",
          "signature": "WFT_PWM",
          "source": "src/Graphics-LambdaCube-Common.html#WaveformType",
          "type": "function"
        },
        "index": {
          "description": "Pulse Width Modulation Works like WFT SQUARE except the high to low transition is controlled by duty cycle With duty cycle of will give the same output as WFT SQUARE",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_PWM",
          "package": "lambdacube-engine",
          "partial": "WFT PWM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:WFT_PWM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGradual steady increase from min to max over the period with an instant return to min at the end.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_SAWTOOTH",
          "package": "lambdacube-engine",
          "signature": "WFT_SAWTOOTH",
          "source": "src/Graphics-LambdaCube-Common.html#WaveformType",
          "type": "function"
        },
        "index": {
          "description": "Gradual steady increase from min to max over the period with an instant return to min at the end",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_SAWTOOTH",
          "package": "lambdacube-engine",
          "partial": "WFT SAWTOOTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:WFT_SAWTOOTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard sine wave which smoothly changes from low to high and back again.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_SINE",
          "package": "lambdacube-engine",
          "signature": "WFT_SINE",
          "source": "src/Graphics-LambdaCube-Common.html#WaveformType",
          "type": "function"
        },
        "index": {
          "description": "Standard sine wave which smoothly changes from low to high and back again",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_SINE",
          "package": "lambdacube-engine",
          "partial": "WFT SINE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:WFT_SINE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHalf of the time is spent at the min, half at the max with instant transition between.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_SQUARE",
          "package": "lambdacube-engine",
          "signature": "WFT_SQUARE",
          "source": "src/Graphics-LambdaCube-Common.html#WaveformType",
          "type": "function"
        },
        "index": {
          "description": "Half of the time is spent at the min half at the max with instant transition between",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_SQUARE",
          "package": "lambdacube-engine",
          "partial": "WFT SQUARE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:WFT_SQUARE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn angular wave with a constant increase / decrease speed with pointed peaks.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_TRIANGLE",
          "package": "lambdacube-engine",
          "signature": "WFT_TRIANGLE",
          "source": "src/Graphics-LambdaCube-Common.html#WaveformType",
          "type": "function"
        },
        "index": {
          "description": "An angular wave with constant increase decrease speed with pointed peaks",
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "WFT_TRIANGLE",
          "package": "lambdacube-engine",
          "partial": "WFT TRIANGLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:WFT_TRIANGLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "fbtColour",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Common.html#FrameBufferType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "fbtColour",
          "package": "lambdacube-engine",
          "partial": "Colour",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:fbtColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "fbtDepth",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Common.html#FrameBufferType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "fbtDepth",
          "package": "lambdacube-engine",
          "partial": "Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:fbtDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "fbtStencil",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Common.html#FrameBufferType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "fbtStencil",
          "package": "lambdacube-engine",
          "partial": "Stencil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:fbtStencil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcAmbient",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Common.html#TrackVertexColourType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcAmbient",
          "package": "lambdacube-engine",
          "partial": "Ambient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:tvcAmbient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcDiffuse",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Common.html#TrackVertexColourType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcDiffuse",
          "package": "lambdacube-engine",
          "partial": "Diffuse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:tvcDiffuse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcEmissive",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Common.html#TrackVertexColourType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcEmissive",
          "package": "lambdacube-engine",
          "partial": "Emissive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:tvcEmissive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcSpecular",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Common.html#TrackVertexColourType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Common",
          "module": "Graphics.LambdaCube.Common",
          "name": "tvcSpecular",
          "package": "lambdacube-engine",
          "partial": "Specular",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Common.html#v:tvcSpecular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "Compositor",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "Compositor",
          "package": "lambdacube-engine",
          "partial": "Compositor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionPass",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionPass",
          "package": "lambdacube-engine",
          "partial": "Composition Pass",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:CompositionPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTargetPass",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTargetPass",
          "package": "lambdacube-engine",
          "partial": "Composition Target Pass",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:CompositionTargetPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTechnique",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTechnique",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTechnique",
          "package": "lambdacube-engine",
          "partial": "Composition Technique",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:CompositionTechnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "Compositor",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#Compositor",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "Compositor",
          "package": "lambdacube-engine",
          "partial": "Compositor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:Compositor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput mode of a TargetPass\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "InputMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#InputMode",
          "type": "data"
        },
        "index": {
          "description": "Input mode of TargetPass",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "InputMode",
          "package": "lambdacube-engine",
          "partial": "Input Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:InputMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "InputTex",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#InputTex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "InputTex",
          "package": "lambdacube-engine",
          "partial": "Input Tex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:InputTex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PassType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#PassType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PassType",
          "package": "lambdacube-engine",
          "partial": "Pass Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:PassType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "TextureDefinition",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "TextureDefinition",
          "package": "lambdacube-engine",
          "partial": "Texture Definition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#t:TextureDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionPass",
          "package": "lambdacube-engine",
          "signature": "CompositionPass",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionPass",
          "package": "lambdacube-engine",
          "partial": "Composition Pass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:CompositionPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTargetPass",
          "package": "lambdacube-engine",
          "signature": "CompositionTargetPass",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTargetPass",
          "package": "lambdacube-engine",
          "partial": "Composition Target Pass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:CompositionTargetPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTechnique",
          "package": "lambdacube-engine",
          "signature": "CompositionTechnique",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTechnique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "CompositionTechnique",
          "package": "lambdacube-engine",
          "partial": "Composition Technique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:CompositionTechnique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "Compositor",
          "package": "lambdacube-engine",
          "signature": "Compositor",
          "source": "src/Graphics-LambdaCube-Compositor.html#Compositor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "Compositor",
          "package": "lambdacube-engine",
          "partial": "Compositor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:Compositor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo input\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "IM_NONE",
          "package": "lambdacube-engine",
          "signature": "IM_NONE",
          "source": "src/Graphics-LambdaCube-Compositor.html#InputMode",
          "type": "function"
        },
        "index": {
          "description": "No input",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "IM_NONE",
          "package": "lambdacube-engine",
          "partial": "IM NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:IM_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput of previous Composition in chain\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "IM_PREVIOUS",
          "package": "lambdacube-engine",
          "signature": "IM_PREVIOUS",
          "source": "src/Graphics-LambdaCube-Compositor.html#InputMode",
          "type": "function"
        },
        "index": {
          "description": "Output of previous Composition in chain",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "IM_PREVIOUS",
          "package": "lambdacube-engine",
          "partial": "IM PREVIOUS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:IM_PREVIOUS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "InputTex",
          "package": "lambdacube-engine",
          "signature": "InputTex",
          "source": "src/Graphics-LambdaCube-Compositor.html#InputTex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "InputTex",
          "package": "lambdacube-engine",
          "partial": "Input Tex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:InputTex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear target to one colour\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_CLEAR",
          "package": "lambdacube-engine",
          "signature": "PT_CLEAR",
          "source": "src/Graphics-LambdaCube-Compositor.html#PassType",
          "type": "function"
        },
        "index": {
          "description": "Clear target to one colour",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_CLEAR",
          "package": "lambdacube-engine",
          "partial": "PT CLEAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:PT_CLEAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender a full screen quad\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_RENDERQUAD",
          "package": "lambdacube-engine",
          "signature": "PT_RENDERQUAD",
          "source": "src/Graphics-LambdaCube-Compositor.html#PassType",
          "type": "function"
        },
        "index": {
          "description": "Render full screen quad",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_RENDERQUAD",
          "package": "lambdacube-engine",
          "partial": "PT RENDERQUAD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:PT_RENDERQUAD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender the scene or part of it\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_RENDERSCENE",
          "package": "lambdacube-engine",
          "signature": "PT_RENDERSCENE",
          "source": "src/Graphics-LambdaCube-Compositor.html#PassType",
          "type": "function"
        },
        "index": {
          "description": "Render the scene or part of it",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_RENDERSCENE",
          "package": "lambdacube-engine",
          "partial": "PT RENDERSCENE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:PT_RENDERSCENE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet stencil operation\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_STENCIL",
          "package": "lambdacube-engine",
          "signature": "PT_STENCIL",
          "source": "src/Graphics-LambdaCube-Compositor.html#PassType",
          "type": "function"
        },
        "index": {
          "description": "Set stencil operation",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "PT_STENCIL",
          "package": "lambdacube-engine",
          "partial": "PT STENCIL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:PT_STENCIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "TextureDefinition",
          "package": "lambdacube-engine",
          "signature": "TextureDefinition",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "TextureDefinition",
          "package": "lambdacube-engine",
          "partial": "Texture Definition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:TextureDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cmpName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Compositor.html#Compositor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cmpName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cmpName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cmpSupportedTechniques",
          "package": "lambdacube-engine",
          "signature": "Maybe [CompositionTechnique t lp]",
          "source": "src/Graphics-LambdaCube-Compositor.html#Compositor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cmpSupportedTechniques",
          "normalized": "Maybe[CompositionTechnique a b]",
          "package": "lambdacube-engine",
          "partial": "Supported Techniques",
          "signature": "Maybe[CompositionTechnique t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cmpSupportedTechniques"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cmpTechniques",
          "package": "lambdacube-engine",
          "signature": "[CompositionTechnique t lp]",
          "source": "src/Graphics-LambdaCube-Compositor.html#Compositor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cmpTechniques",
          "normalized": "[CompositionTechnique a b]",
          "package": "lambdacube-engine",
          "partial": "Techniques",
          "signature": "[CompositionTechnique t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cmpTechniques"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear buffers (in case of PT_CLEAR), hint: [colour] [depth] [stencil]\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearBuffers",
          "package": "lambdacube-engine",
          "signature": "(Bool, Bool, Bool)",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Clear buffers in case of PT CLEAR hint colour depth stencil",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearBuffers",
          "normalized": "(Bool,Bool,Bool)",
          "package": "lambdacube-engine",
          "partial": "Clear Buffers",
          "signature": "(Bool,Bool,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpClearBuffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear colour (in case of PT_CLEAR)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearColour",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Clear colour in case of PT CLEAR",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearColour",
          "package": "lambdacube-engine",
          "partial": "Clear Colour",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpClearColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear depth (in case of PT_CLEAR)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearDepth",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Clear depth in case of PT CLEAR",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearDepth",
          "package": "lambdacube-engine",
          "partial": "Clear Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpClearDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear stencil value (in case of PT_CLEAR)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearStencil",
          "package": "lambdacube-engine",
          "signature": "Word32",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Clear stencil value in case of PT CLEAR",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpClearStencil",
          "package": "lambdacube-engine",
          "partial": "Clear Stencil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpClearStencil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003efirst,last\u003c/dt\u003e\u003cdd\u003e render queue to render this pass (in case of PT_RENDERSCENE)\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpFirstRenderQueue",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "first last render queue to render this pass in case of PT RENDERSCENE",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpFirstRenderQueue",
          "package": "lambdacube-engine",
          "partial": "First Render Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpFirstRenderQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentifier for this pass\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpIdentifier",
          "package": "lambdacube-engine",
          "signature": "Word32",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Identifier for this pass",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpIdentifier",
          "package": "lambdacube-engine",
          "partial": "Identifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpIdentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInputs (for material used for rendering the quad)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpInputs",
          "package": "lambdacube-engine",
          "signature": "IntMap InputTex",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Inputs for material used for rendering the quad",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpInputs",
          "package": "lambdacube-engine",
          "partial": "Inputs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpInputs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpLastRenderQueue",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpLastRenderQueue",
          "package": "lambdacube-engine",
          "partial": "Last Render Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpLastRenderQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpMaterial",
          "package": "lambdacube-engine",
          "signature": "Maybe (Material t lp)",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpMaterial",
          "package": "lambdacube-engine",
          "partial": "Material",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpMaterial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaterial used for rendering\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpMaterialName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Material used for rendering",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpMaterialName",
          "package": "lambdacube-engine",
          "partial": "Material Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpMaterialName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadBottom",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadBottom",
          "package": "lambdacube-engine",
          "partial": "Quad Bottom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpQuadBottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etrue if quad should not cover whole screen\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadCornerModified",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "true if quad should not cover whole screen",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadCornerModified",
          "package": "lambdacube-engine",
          "partial": "Quad Corner Modified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpQuadCornerModified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadFarCorners",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadFarCorners",
          "package": "lambdacube-engine",
          "partial": "Quad Far Corners",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpQuadFarCorners"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadFarCornersViewSpace",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadFarCornersViewSpace",
          "package": "lambdacube-engine",
          "partial": "Quad Far Corners View Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpQuadFarCornersViewSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equad positions in normalised coordinates [-1;1]x[-1;1] (in case of PT_RENDERQUAD)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadLeft",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "quad positions in normalised coordinates in case of PT RENDERQUAD",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadLeft",
          "package": "lambdacube-engine",
          "partial": "Quad Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpQuadLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadRight",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadRight",
          "package": "lambdacube-engine",
          "partial": "Quad Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpQuadRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadTop",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpQuadTop",
          "package": "lambdacube-engine",
          "partial": "Quad Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpQuadTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStencil operation parameters\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilCheck",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Stencil operation parameters",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilCheck",
          "package": "lambdacube-engine",
          "partial": "Stencil Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilDepthFailOp",
          "package": "lambdacube-engine",
          "signature": "StencilOperation",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilDepthFailOp",
          "package": "lambdacube-engine",
          "partial": "Stencil Depth Fail Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilDepthFailOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilFailOp",
          "package": "lambdacube-engine",
          "signature": "StencilOperation",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilFailOp",
          "package": "lambdacube-engine",
          "partial": "Stencil Fail Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilFailOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilFunc",
          "package": "lambdacube-engine",
          "signature": "CompareFunction",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilFunc",
          "package": "lambdacube-engine",
          "partial": "Stencil Func",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilMask",
          "package": "lambdacube-engine",
          "signature": "Word32",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilMask",
          "package": "lambdacube-engine",
          "partial": "Stencil Mask",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilMask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilPassOp",
          "package": "lambdacube-engine",
          "signature": "StencilOperation",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilPassOp",
          "package": "lambdacube-engine",
          "partial": "Stencil Pass Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilPassOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilRefValue",
          "package": "lambdacube-engine",
          "signature": "Word32",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilRefValue",
          "package": "lambdacube-engine",
          "partial": "Stencil Ref Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilRefValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilTwoSidedOperation",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpStencilTwoSidedOperation",
          "package": "lambdacube-engine",
          "partial": "Stencil Two Sided Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpStencilTwoSidedOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of composition pass\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpType",
          "package": "lambdacube-engine",
          "signature": "PassType",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionPass",
          "type": "function"
        },
        "index": {
          "description": "Type of composition pass",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "cpType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:cpType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput target pass (can be only one)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctOutputTarget",
          "package": "lambdacube-engine",
          "signature": "CompositionTargetPass t lp",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTechnique",
          "type": "function"
        },
        "index": {
          "description": "Output target pass can be only one",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctOutputTarget",
          "package": "lambdacube-engine",
          "partial": "Output Target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctOutputTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional scheme name\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctSchemeName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTechnique",
          "type": "function"
        },
        "index": {
          "description": "Optional scheme name",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctSchemeName",
          "package": "lambdacube-engine",
          "partial": "Scheme Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctSchemeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntermediate target passes\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctTargetPasses",
          "package": "lambdacube-engine",
          "signature": "[CompositionTargetPass t lp]",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTechnique",
          "type": "function"
        },
        "index": {
          "description": "Intermediate target passes",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctTargetPasses",
          "normalized": "[CompositionTargetPass a b]",
          "package": "lambdacube-engine",
          "partial": "Target Passes",
          "signature": "[CompositionTargetPass t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctTargetPasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal texture definitions\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctTextureDefinitions",
          "package": "lambdacube-engine",
          "signature": "[TextureDefinition t]",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTechnique",
          "type": "function"
        },
        "index": {
          "description": "Local texture definitions",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctTextureDefinitions",
          "normalized": "[TextureDefinition a]",
          "package": "lambdacube-engine",
          "partial": "Texture Definitions",
          "signature": "[TextureDefinition t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctTextureDefinitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput name\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpInputMode",
          "package": "lambdacube-engine",
          "signature": "InputMode",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "Input name",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpInputMode",
          "package": "lambdacube-engine",
          "partial": "Input Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpInputMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLOD bias of this render\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpLodBias",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "LOD bias of this render",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpLodBias",
          "package": "lambdacube-engine",
          "partial": "Lod Bias",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpLodBias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaterial scheme name\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpMaterialScheme",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "Material scheme name",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpMaterialScheme",
          "package": "lambdacube-engine",
          "partial": "Material Scheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpMaterialScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis target pass is only executed initially after the effect has been enabled.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpOnlyInitial",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "This target pass is only executed initially after the effect has been enabled",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpOnlyInitial",
          "package": "lambdacube-engine",
          "partial": "Only Initial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpOnlyInitial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpOutput",
          "package": "lambdacube-engine",
          "signature": "Maybe (TextureDefinition t)",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpOutput",
          "package": "lambdacube-engine",
          "partial": "Output",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(local) output texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpOutputName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "local output texture",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpOutputName",
          "package": "lambdacube-engine",
          "partial": "Output Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpOutputName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePasses\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpPasses",
          "package": "lambdacube-engine",
          "signature": "[CompositionPass t lp]",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "Passes",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpPasses",
          "normalized": "[CompositionPass a b]",
          "package": "lambdacube-engine",
          "partial": "Passes",
          "signature": "[CompositionPass t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpPasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShadows option\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpShadowsEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "Shadows option",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpShadowsEnabled",
          "package": "lambdacube-engine",
          "partial": "Shadows Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpShadowsEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVisibility mask for this render\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpVisibilityMask",
          "package": "lambdacube-engine",
          "signature": "Word32",
          "source": "src/Graphics-LambdaCube-Compositor.html#CompositionTargetPass",
          "type": "function"
        },
        "index": {
          "description": "Visibility mask for this render",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "ctpVisibilityMask",
          "package": "lambdacube-engine",
          "partial": "Visibility Mask",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:ctpVisibilityMask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMRT surface index if applicable\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "itMrtIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Compositor.html#InputTex",
          "type": "function"
        },
        "index": {
          "description": "MRT surface index if applicable",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "itMrtIndex",
          "package": "lambdacube-engine",
          "partial": "Mrt Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:itMrtIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName (local) of the input texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "itName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Compositor.html#InputTex",
          "type": "function"
        },
        "index": {
          "description": "Name local of the input texture",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "itName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:itName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emore than one means MRT\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdFormatList",
          "package": "lambdacube-engine",
          "signature": "[PixelFormat]",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "more than one means MRT",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdFormatList",
          "normalized": "[PixelFormat]",
          "package": "lambdacube-engine",
          "partial": "Format List",
          "signature": "[PixelFormat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdFormatList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFSAA enabled; true = determine from main target (if render_scene), false = disable\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdFsaa",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "FSAA enabled true determine from main target if render scene false disable",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdFsaa",
          "package": "lambdacube-engine",
          "partial": "Fsaa",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdFsaa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNothing means adapt to target height\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdHeight",
          "package": "lambdacube-engine",
          "signature": "Maybe Int",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "Nothing means adapt to target height",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdHeight",
          "package": "lambdacube-engine",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emultiple of target height to use (if height = Nothing)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdHeightFactor",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "multiple of target height to use if height Nothing",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdHeightFactor",
          "package": "lambdacube-engine",
          "partial": "Height Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdHeightFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo sRGB gamma correction on write (only 8-bit per channel formats)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdHwGammaWrite",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "Do sRGB gamma correction on write only bit per channel formats",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdHwGammaWrite",
          "package": "lambdacube-engine",
          "partial": "Hw Gamma Write",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdHwGammaWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhether to use shared textures for this one\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdShared",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "whether to use shared textures for this one",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdShared",
          "package": "lambdacube-engine",
          "partial": "Shared",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdShared"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdTexture",
          "package": "lambdacube-engine",
          "signature": "Maybe t",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdTexture",
          "package": "lambdacube-engine",
          "partial": "Texture",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNothing means adapt to target width\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdWidth",
          "package": "lambdacube-engine",
          "signature": "Maybe Int",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "Nothing means adapt to target width",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdWidth",
          "package": "lambdacube-engine",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emultiple of target width to use (if width = Nothing)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdWidthFactor",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Compositor.html#TextureDefinition",
          "type": "function"
        },
        "index": {
          "description": "multiple of target width to use if width Nothing",
          "hierarchy": "Graphics LambdaCube Compositor",
          "module": "Graphics.LambdaCube.Compositor",
          "name": "tdWidthFactor",
          "package": "lambdacube-engine",
          "partial": "Width Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Compositor.html#v:tdWidthFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "Entity",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Entity.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "Entity",
          "package": "lambdacube-engine",
          "partial": "Entity",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "Entity",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Entity.html#Entity",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "Entity",
          "package": "lambdacube-engine",
          "partial": "Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#t:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sub-parts of an Entity. Its primary function is to provide\n the link between the Material which the SubEntity uses (which may\n be the default Material for the SubMesh or may have been changed\n for this object) and the SubMesh data.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Entity",
          "name": "SubEntity",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Entity.html#SubEntity",
          "type": "data"
        },
        "index": {
          "description": "The sub-parts of an Entity Its primary function is to provide the link between the Material which the SubEntity uses which may be the default Material for the SubMesh or may have been changed for this object and the SubMesh data",
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "SubEntity",
          "package": "lambdacube-engine",
          "partial": "Sub Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#t:SubEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "VertexDataBindChoice",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Entity.html#VertexDataBindChoice",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "VertexDataBindChoice",
          "package": "lambdacube-engine",
          "partial": "Vertex Data Bind Choice",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#t:VertexDataBindChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_HARDWARE_MORPH",
          "package": "lambdacube-engine",
          "signature": "BIND_HARDWARE_MORPH",
          "source": "src/Graphics-LambdaCube-Entity.html#VertexDataBindChoice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_HARDWARE_MORPH",
          "package": "lambdacube-engine",
          "partial": "BIND HARDWARE MORPH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:BIND_HARDWARE_MORPH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_ORIGINAL",
          "package": "lambdacube-engine",
          "signature": "BIND_ORIGINAL",
          "source": "src/Graphics-LambdaCube-Entity.html#VertexDataBindChoice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_ORIGINAL",
          "package": "lambdacube-engine",
          "partial": "BIND ORIGINAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:BIND_ORIGINAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_SOFTWARE_MORPH",
          "package": "lambdacube-engine",
          "signature": "BIND_SOFTWARE_MORPH",
          "source": "src/Graphics-LambdaCube-Entity.html#VertexDataBindChoice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_SOFTWARE_MORPH",
          "package": "lambdacube-engine",
          "partial": "BIND SOFTWARE MORPH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:BIND_SOFTWARE_MORPH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_SOFTWARE_SKELETAL",
          "package": "lambdacube-engine",
          "signature": "BIND_SOFTWARE_SKELETAL",
          "source": "src/Graphics-LambdaCube-Entity.html#VertexDataBindChoice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "BIND_SOFTWARE_SKELETAL",
          "package": "lambdacube-engine",
          "partial": "BIND SOFTWARE SKELETAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:BIND_SOFTWARE_SKELETAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "Entity",
          "package": "lambdacube-engine",
          "signature": "Entity",
          "source": "src/Graphics-LambdaCube-Entity.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "Entity",
          "package": "lambdacube-engine",
          "partial": "Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "SubEntity",
          "package": "lambdacube-engine",
          "signature": "SubEntity",
          "source": "src/Graphics-LambdaCube-Entity.html#SubEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "SubEntity",
          "package": "lambdacube-engine",
          "partial": "Sub Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:SubEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "enMesh",
          "package": "lambdacube-engine",
          "signature": "Mesh vb ib",
          "source": "src/Graphics-LambdaCube-Entity.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "enMesh",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:enMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "enName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Entity.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "enName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:enName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "enRenderQueue",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Entity.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "enRenderQueue",
          "package": "lambdacube-engine",
          "partial": "Render Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:enRenderQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "enSubEntityList",
          "package": "lambdacube-engine",
          "signature": "[SubEntity vb ib t lp]",
          "source": "src/Graphics-LambdaCube-Entity.html#Entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "enSubEntityList",
          "normalized": "[SubEntity a b c d]",
          "package": "lambdacube-engine",
          "partial": "Sub Entity List",
          "signature": "[SubEntity vb ib t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:enSubEntityList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Entity",
          "name": "prepareEntity",
          "package": "lambdacube-engine",
          "signature": "Proj4 -\u003e Entity vb ib t lp -\u003e [RenderEntity vb ib t lp]",
          "source": "src/Graphics-LambdaCube-Entity.html#prepareEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "prepareEntity",
          "normalized": "Proj-\u003eEntity a b c d-\u003e[RenderEntity a b c d]",
          "package": "lambdacube-engine",
          "partial": "Entity",
          "signature": "Proj-\u003eEntity vb ib t lp-\u003e[RenderEntity vb ib t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:prepareEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCached pointer to material.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Entity",
          "name": "seMaterial",
          "package": "lambdacube-engine",
          "signature": "Material t lp",
          "source": "src/Graphics-LambdaCube-Entity.html#SubEntity",
          "type": "function"
        },
        "index": {
          "description": "Cached pointer to material",
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "seMaterial",
          "package": "lambdacube-engine",
          "partial": "Material",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:seMaterial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePointer to the SubMesh defining geometry.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Entity",
          "name": "seSubMesh",
          "package": "lambdacube-engine",
          "signature": "SubMesh vb ib",
          "source": "src/Graphics-LambdaCube-Entity.html#SubEntity",
          "type": "function"
        },
        "index": {
          "description": "Pointer to the SubMesh defining geometry",
          "hierarchy": "Graphics LambdaCube Entity",
          "module": "Graphics.LambdaCube.Entity",
          "name": "seSubMesh",
          "package": "lambdacube-engine",
          "partial": "Sub Mesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Entity.html#v:seSubMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Frustum",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Frustum.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Frustum",
          "package": "lambdacube-engine",
          "partial": "Frustum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Frustum",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Frustum.html#Frustum",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Frustum",
          "package": "lambdacube-engine",
          "partial": "Frustum",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#t:Frustum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Plane",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Frustum.html#Plane",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Plane",
          "package": "lambdacube-engine",
          "partial": "Plane",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#t:Plane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Frustum",
          "package": "lambdacube-engine",
          "signature": "Frustum",
          "source": "src/Graphics-LambdaCube-Frustum.html#Frustum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Frustum",
          "package": "lambdacube-engine",
          "partial": "Frustum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:Frustum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Plane",
          "package": "lambdacube-engine",
          "signature": "Plane",
          "source": "src/Graphics-LambdaCube-Frustum.html#Plane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "Plane",
          "package": "lambdacube-engine",
          "partial": "Plane",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:Plane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "boxInFrustum",
          "package": "lambdacube-engine",
          "signature": "Vec3 -\u003e Vec3 -\u003e Frustum -\u003e Bool",
          "source": "src/Graphics-LambdaCube-Frustum.html#boxInFrustum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "boxInFrustum",
          "normalized": "Vec-\u003eVec-\u003eFrustum-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "In Frustum",
          "signature": "Vec-\u003eVec-\u003eFrustum-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:boxInFrustum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "frPlanes",
          "package": "lambdacube-engine",
          "signature": "[Plane]",
          "source": "src/Graphics-LambdaCube-Frustum.html#Frustum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "frPlanes",
          "normalized": "[Plane]",
          "package": "lambdacube-engine",
          "partial": "Planes",
          "signature": "[Plane]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:frPlanes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "frustum",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e Vec3 -\u003e Vec3 -\u003e Vec3 -\u003e Frustum",
          "source": "src/Graphics-LambdaCube-Frustum.html#frustum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "frustum",
          "normalized": "FloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eVec-\u003eVec-\u003eVec-\u003eFrustum",
          "package": "lambdacube-engine",
          "signature": "FloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eVec-\u003eVec-\u003eVec-\u003eFrustum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:frustum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "frustumFromMatrix",
          "package": "lambdacube-engine",
          "signature": "Mat4 -\u003e Frustum",
          "source": "src/Graphics-LambdaCube-Frustum.html#frustumFromMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "frustumFromMatrix",
          "normalized": "Mat-\u003eFrustum",
          "package": "lambdacube-engine",
          "partial": "From Matrix",
          "signature": "Mat-\u003eFrustum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:frustumFromMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "plDist",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Frustum.html#Plane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "plDist",
          "package": "lambdacube-engine",
          "partial": "Dist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:plDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "plNormal",
          "package": "lambdacube-engine",
          "signature": "Vec3",
          "source": "src/Graphics-LambdaCube-Frustum.html#Plane",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "plNormal",
          "package": "lambdacube-engine",
          "partial": "Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:plNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "pointInFrustum",
          "package": "lambdacube-engine",
          "signature": "Vec3 -\u003e Frustum -\u003e Bool",
          "source": "src/Graphics-LambdaCube-Frustum.html#pointInFrustum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "pointInFrustum",
          "normalized": "Vec-\u003eFrustum-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "In Frustum",
          "signature": "Vec-\u003eFrustum-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:pointInFrustum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Frustum",
          "name": "sphereInFrustum",
          "package": "lambdacube-engine",
          "signature": "Vec3 -\u003e FloatType -\u003e Frustum -\u003e Bool",
          "source": "src/Graphics-LambdaCube-Frustum.html#sphereInFrustum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Frustum",
          "module": "Graphics.LambdaCube.Frustum",
          "name": "sphereInFrustum",
          "normalized": "Vec-\u003eFloatType-\u003eFrustum-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "In Frustum",
          "signature": "Vec-\u003eFloatType-\u003eFrustum-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Frustum.html#v:sphereInFrustum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgram",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgram.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgram",
          "package": "lambdacube-engine",
          "partial": "Gpu Program",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgram",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgram",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgram",
          "package": "lambdacube-engine",
          "partial": "Gpu Program",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#t:GpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgramDescriptor",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgramDescriptor",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Descriptor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#t:GpuProgramDescriptor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgramType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgramType",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#t:GpuProgramType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "LinkedGpuProgram",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#LinkedGpuProgram",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "LinkedGpuProgram",
          "package": "lambdacube-engine",
          "partial": "Linked Gpu Program",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#t:LinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GPT_FRAGMENT_PROGRAM",
          "package": "lambdacube-engine",
          "signature": "GPT_FRAGMENT_PROGRAM",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GPT_FRAGMENT_PROGRAM",
          "package": "lambdacube-engine",
          "partial": "GPT FRAGMENT PROGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:GPT_FRAGMENT_PROGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GPT_GEOMETRY_PROGRAM",
          "package": "lambdacube-engine",
          "signature": "GPT_GEOMETRY_PROGRAM",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GPT_GEOMETRY_PROGRAM",
          "package": "lambdacube-engine",
          "partial": "GPT GEOMETRY PROGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:GPT_GEOMETRY_PROGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GPT_VERTEX_PROGRAM",
          "package": "lambdacube-engine",
          "signature": "GPT_VERTEX_PROGRAM",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GPT_VERTEX_PROGRAM",
          "package": "lambdacube-engine",
          "partial": "GPT VERTEX PROGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:GPT_VERTEX_PROGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgramDescriptor",
          "package": "lambdacube-engine",
          "signature": "GpuProgramDescriptor",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "GpuProgramDescriptor",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Descriptor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:GpuProgramDescriptor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdAttach",
          "package": "lambdacube-engine",
          "signature": "[String]",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdAttach",
          "normalized": "[String]",
          "package": "lambdacube-engine",
          "partial": "Attach",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdAttach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default parameters for use with this object\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdDefaultParams",
          "package": "lambdacube-engine",
          "signature": "GpuProgramParameters",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "The default parameters for use with this object",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdDefaultParams",
          "package": "lambdacube-engine",
          "partial": "Default Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdDefaultParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the file to load source from (may be blank)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdFilename",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "The name of the file to load source from may be blank",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdFilename",
          "package": "lambdacube-engine",
          "partial": "Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdGpuProgram",
          "package": "lambdacube-engine",
          "signature": "Maybe p",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdGpuProgram",
          "package": "lambdacube-engine",
          "partial": "Gpu Program",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this (vertex) program include morph animation?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdMorphAnimation",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "Does this vertex program include morph animation",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdMorphAnimation",
          "package": "lambdacube-engine",
          "partial": "Morph Animation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdMorphAnimation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this (geometry) program require adjacency information?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdNeedsAdjacencyInfo",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "Does this geometry program require adjacency information",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdNeedsAdjacencyInfo",
          "package": "lambdacube-engine",
          "partial": "Needs Adjacency Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdNeedsAdjacencyInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this (vertex) program include pose animation (count of number of poses supported)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdPoseAnimation",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "Does this vertex program include pose animation count of number of poses supported",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdPoseAnimation",
          "package": "lambdacube-engine",
          "partial": "Pose Animation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdPoseAnimation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this (vertex) program include skeletal animation?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdSkeletalAnimation",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "Does this vertex program include skeletal animation",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdSkeletalAnimation",
          "package": "lambdacube-engine",
          "partial": "Skeletal Animation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdSkeletalAnimation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyntax code e.g. arbvp1, vs_2_0 etc\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdSyntaxCode",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "Syntax code e.g arbvp1 vs etc",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdSyntaxCode",
          "package": "lambdacube-engine",
          "partial": "Syntax Code",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdSyntaxCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the program\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdType",
          "package": "lambdacube-engine",
          "signature": "GpuProgramType",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "The type of the program",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this (vertex) program require support for vertex texture fetch?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdVertexTextureFetch",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgram.html#GpuProgramDescriptor",
          "type": "function"
        },
        "index": {
          "description": "Does this vertex program require support for vertex texture fetch",
          "hierarchy": "Graphics LambdaCube GpuProgram",
          "module": "Graphics.LambdaCube.GpuProgram",
          "name": "gpdVertexTextureFetch",
          "package": "lambdacube-engine",
          "partial": "Vertex Texture Fetch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgram.html#v:gpdVertexTextureFetch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuProgramParams",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuProgramParams",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Params",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDataType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#ACDataType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDataType",
          "package": "lambdacube-engine",
          "partial": "ACData Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:ACDataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantDefinition",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantDefinition",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantDefinition",
          "package": "lambdacube-engine",
          "partial": "Auto Constant Definition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:AutoConstantDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantEntry",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantEntry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantEntry",
          "package": "lambdacube-engine",
          "partial": "Auto Constant Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:AutoConstantEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe types of automatically updated values that may be bound to\n GpuProgram parameters, or used to modify parameters on a per-object\n basis.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "data"
        },
        "index": {
          "description": "The types of automatically updated values that may be bound to GpuProgram parameters or used to modify parameters on per-object basis",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantType",
          "package": "lambdacube-engine",
          "partial": "Auto Constant Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:AutoConstantType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of physical mappings that we are going to bring in.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "CopyDataEntry",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#CopyDataEntry",
          "type": "data"
        },
        "index": {
          "description": "The list of physical mappings that we are going to bring in",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "CopyDataEntry",
          "package": "lambdacube-engine",
          "partial": "Copy Data Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:CopyDataEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ElementType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#ElementType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ElementType",
          "package": "lambdacube-engine",
          "partial": "Element Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:ElementType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInformation about predefined program constants.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuConstantDefinition",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "data"
        },
        "index": {
          "description": "Information about predefined program constants",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuConstantDefinition",
          "package": "lambdacube-engine",
          "partial": "Gpu Constant Definition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuConstantDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe types of constants we may encounter in programs.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuConstantType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "data"
        },
        "index": {
          "description": "The types of constants we may encounter in programs",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuConstantType",
          "package": "lambdacube-engine",
          "partial": "Gpu Constant Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuConstantType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContainer to allow params to safely & update shared list of\n logical buffer assignments\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalBufferStruct",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalBufferStruct",
          "type": "data"
        },
        "index": {
          "description": "Container to allow params to safely update shared list of logical buffer assignments",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalBufferStruct",
          "package": "lambdacube-engine",
          "partial": "Gpu Logical Buffer Struct",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuLogicalBufferStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStructure recording the use of a physical buffer by a logical\n parameter index. Only used for low-level programs.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalIndexUse",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalIndexUse",
          "type": "data"
        },
        "index": {
          "description": "Structure recording the use of physical buffer by logical parameter index Only used for low-level programs",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalIndexUse",
          "package": "lambdacube-engine",
          "partial": "Gpu Logical Index Use",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuLogicalIndexUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstant",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstant",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstant",
          "package": "lambdacube-engine",
          "partial": "Gpu Named Constant",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuNamedConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStruct collecting together the information for named constants.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstants",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstants",
          "type": "data"
        },
        "index": {
          "description": "Struct collecting together the information for named constants",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstants",
          "package": "lambdacube-engine",
          "partial": "Gpu Named Constants",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuNamedConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe variability of a GPU parameter, as derived from auto-params\n targetting it.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuParamVariability",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuParamVariability",
          "type": "data"
        },
        "index": {
          "description": "The variability of GPU parameter as derived from auto-params targetting it",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuParamVariability",
          "package": "lambdacube-engine",
          "partial": "Gpu Param Variability",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuParamVariability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuProgramParameters",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuProgramParameters",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuProgramParameters",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Parameters",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuProgramParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA group of manually updated parameters that are shared between\n many parameter sets.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParameters",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "data"
        },
        "index": {
          "description": "group of manually updated parameters that are shared between many parameter sets",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParameters",
          "package": "lambdacube-engine",
          "partial": "Gpu Shared Parameters",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuSharedParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe usage of a set of shared parameters in a concrete set of\n GpuProgramParameters.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParametersUsage",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParametersUsage",
          "type": "data"
        },
        "index": {
          "description": "The usage of set of shared parameters in concrete set of GpuProgramParameters",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParametersUsage",
          "package": "lambdacube-engine",
          "partial": "Gpu Shared Parameters Usage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#t:GpuSharedParametersUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe auto constant requires data of type int\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDT_INT",
          "package": "lambdacube-engine",
          "signature": "ACDT_INT",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#ACDataType",
          "type": "function"
        },
        "index": {
          "description": "the auto constant requires data of type int",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDT_INT",
          "package": "lambdacube-engine",
          "partial": "ACDT INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACDT_INT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eno data is required\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDT_NONE",
          "package": "lambdacube-engine",
          "signature": "ACDT_NONE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#ACDataType",
          "type": "function"
        },
        "index": {
          "description": "no data is required",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDT_NONE",
          "package": "lambdacube-engine",
          "partial": "ACDT NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACDT_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe auto constant requires data of type real\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDT_REAL",
          "package": "lambdacube-engine",
          "signature": "ACDT_REAL",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#ACDataType",
          "type": "function"
        },
        "index": {
          "description": "the auto constant requires data of type real",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACDT_REAL",
          "package": "lambdacube-engine",
          "partial": "ACDT REAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACDT_REAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ambient light colour set in the scene\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_AMBIENT_LIGHT_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_AMBIENT_LIGHT_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The ambient light colour set in the scene",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_AMBIENT_LIGHT_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT AMBIENT LIGHT COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_AMBIENT_LIGHT_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides a parametric animation value [0..1], only available where the renderable specifically implements it.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_ANIMATION_PARAMETRIC",
          "package": "lambdacube-engine",
          "signature": "ACT_ANIMATION_PARAMETRIC",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides parametric animation value only available where the renderable specifically implements it",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_ANIMATION_PARAMETRIC",
          "package": "lambdacube-engine",
          "partial": "ACT ANIMATION PARAMETRIC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_ANIMATION_PARAMETRIC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current camera's position in world space\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_CAMERA_POSITION",
          "package": "lambdacube-engine",
          "signature": "ACT_CAMERA_POSITION",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current camera position in world space",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_CAMERA_POSITION",
          "package": "lambdacube-engine",
          "partial": "ACT CAMERA POSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_CAMERA_POSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current camera's position in object space\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_CAMERA_POSITION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "signature": "ACT_CAMERA_POSITION_OBJECT_SPACE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current camera position in object space",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_CAMERA_POSITION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "partial": "ACT CAMERA POSITION OBJECT SPACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_CAMERA_POSITION_OBJECT_SPACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCosine of \u003ca\u003eTime0_1\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eCosTime0_1\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_COSTIME_0_1",
          "package": "lambdacube-engine",
          "signature": "ACT_COSTIME_0_1",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Cosine of Time0 Equivalent to RenderMonkey CosTime0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_COSTIME_0_1",
          "package": "lambdacube-engine",
          "partial": "ACT COSTIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_COSTIME_0_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCosine of \u003ca\u003eTime0_2PI\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eCosTime0_2PI\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_COSTIME_0_2PI",
          "package": "lambdacube-engine",
          "signature": "ACT_COSTIME_0_2PI",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Cosine of Time0 PI Equivalent to RenderMonkey CosTime0 PI",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_COSTIME_0_2PI",
          "package": "lambdacube-engine",
          "partial": "ACT COSTIME PI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_COSTIME_0_2PI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCosine of \u003ca\u003eTime0_X\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eCosTime0_X\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_COSTIME_0_X",
          "package": "lambdacube-engine",
          "signature": "ACT_COSTIME_0_X",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Cosine of Time0 Equivalent to RenderMonkey CosTime0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_COSTIME_0_X",
          "package": "lambdacube-engine",
          "partial": "ACT COSTIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_COSTIME_0_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA custom parameter which will come from the renderable, using 'data' as the identifier\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_CUSTOM",
          "package": "lambdacube-engine",
          "signature": "ACT_CUSTOM",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "custom parameter which will come from the renderable using data as the identifier",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_CUSTOM",
          "package": "lambdacube-engine",
          "partial": "ACT CUSTOM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_CUSTOM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_AMBIENT_LIGHT_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_DERIVED_AMBIENT_LIGHT_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_AMBIENT_LIGHT_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT DERIVED AMBIENT LIGHT COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_DERIVED_AMBIENT_LIGHT_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_DERIVED_LIGHT_DIFFUSE_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT DERIVED LIGHT DIFFUSE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_DERIVED_LIGHT_DIFFUSE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of derived light diffuse colours (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of derived light diffuse colours count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT DERIVED LIGHT DIFFUSE COLOUR ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_SPECULAR_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_DERIVED_LIGHT_SPECULAR_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_SPECULAR_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT DERIVED LIGHT SPECULAR COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_DERIVED_LIGHT_SPECULAR_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of derived light specular colours (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of derived light specular colours count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT DERIVED LIGHT SPECULAR COLOUR ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_SCENE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_DERIVED_SCENE_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_DERIVED_SCENE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT DERIVED SCENE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_DERIVED_SCENE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable provides the far clip distance as a floating point value. Equivalent to RenderMonkey's \u003ca\u003eFarClipPlane\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FAR_CLIP_DISTANCE",
          "package": "lambdacube-engine",
          "signature": "ACT_FAR_CLIP_DISTANCE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable provides the far clip distance as floating point value Equivalent to RenderMonkey FarClipPlane",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FAR_CLIP_DISTANCE",
          "package": "lambdacube-engine",
          "partial": "ACT FAR CLIP DISTANCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_FAR_CLIP_DISTANCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFog colour\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FOG_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_FOG_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Fog colour",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FOG_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT FOG COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_FOG_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFog params: density, linear start, linear end, 1/(end-start)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FOG_PARAMS",
          "package": "lambdacube-engine",
          "signature": "ACT_FOG_PARAMS",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Fog params density linear start linear end end-start",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FOG_PARAMS",
          "package": "lambdacube-engine",
          "partial": "ACT FOG PARAMS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_FOG_PARAMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable provides the field of view as a floating point value. Equivalent to RenderMonkey's \u003ca\u003eFOV\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FOV",
          "package": "lambdacube-engine",
          "signature": "ACT_FOV",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable provides the field of view as floating point value Equivalent to RenderMonkey FOV",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FOV",
          "package": "lambdacube-engine",
          "partial": "ACT FOV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_FOV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprovides the calculated frames per second, returned as a floating point value.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FPS",
          "package": "lambdacube-engine",
          "signature": "ACT_FPS",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "provides the calculated frames per second returned as floating point value",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FPS",
          "package": "lambdacube-engine",
          "partial": "ACT FPS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_FPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprovides the scaled frame time, returned as a floating point value.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FRAME_TIME",
          "package": "lambdacube-engine",
          "signature": "ACT_FRAME_TIME",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "provides the scaled frame time returned as floating point value",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_FRAME_TIME",
          "package": "lambdacube-engine",
          "partial": "ACT FRAME TIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_FRAME_TIME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse of projection matrix. Equivalent to RenderMonkey's \u003ca\u003eProjectionInverse\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_PROJECTION_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse of projection matrix Equivalent to RenderMonkey ProjectionInverse",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE PROJECTION MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_PROJECTION_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse texture size of the texture unit (index determined by setAutoConstant call). Packed as float4(1 \u003cem\u003e width, 1 \u003c/em\u003e height, 1 / depth, 1)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TEXTURE_SIZE",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_TEXTURE_SIZE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse texture size of the texture unit index determined by setAutoConstant call Packed as float4 width height depth",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TEXTURE_SIZE",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE TEXTURE SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_TEXTURE_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse transpose of projection matrix. Equivalent to RenderMonkey's \u003ca\u003eProjectionInverseTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse transpose of projection matrix Equivalent to RenderMonkey ProjectionInverseTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE TRANSPOSE PROJECTION MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse transpose of concatenated view and projection matrices. Equivalent to RenderMonkey's \u003ca\u003eViewProjectionInverseTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse transpose of concatenated view and projection matrices Equivalent to RenderMonkey ViewProjectionInverseTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE TRANSPOSE VIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse transpose of view matrix. Equivalent to RenderMonkey's \u003ca\u003eViewInverseTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_TRANSPOSE_VIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse transpose of view matrix Equivalent to RenderMonkey ViewInverseTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE TRANSPOSE VIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_TRANSPOSE_VIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse transpose of concatenated world, view and projection matrices. Equivalent to RenderMonkey's \u003ca\u003eWorldViewProjectionInverseTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse transpose of concatenated world view and projection matrices Equivalent to RenderMonkey WorldViewProjectionInverseTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE TRANSPOSE WORLDVIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current world & view matrices concatenated, then inverted & transposed\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current world view matrices concatenated then inverted transposed",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE TRANSPOSE WORLDVIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current world matrix, inverted & transposed\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_TRANSPOSE_WORLD_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current world matrix inverted transposed",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_TRANSPOSE_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE TRANSPOSE WORLD MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_TRANSPOSE_WORLD_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable represents 1.0/ViewportHeight. Equivalent to RenderMonkey's \u003ca\u003eViewportHeightInverse\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEWPORT_HEIGHT",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_VIEWPORT_HEIGHT",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable represents ViewportHeight Equivalent to RenderMonkey ViewportHeightInverse",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEWPORT_HEIGHT",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE VIEWPORT HEIGHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_VIEWPORT_HEIGHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable represents 1.0/ViewportWidth. Equivalent to RenderMonkey's \u003ca\u003eViewportWidthInverse\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEWPORT_WIDTH",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_VIEWPORT_WIDTH",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable represents ViewportWidth Equivalent to RenderMonkey ViewportWidthInverse",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEWPORT_WIDTH",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE VIEWPORT WIDTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_VIEWPORT_WIDTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse of concatenated view and projection matrices. Equivalent to RenderMonkey's \u003ca\u003eViewProjectionInverse\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_VIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse of concatenated view and projection matrices Equivalent to RenderMonkey ViewProjectionInverse",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE VIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_VIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current view matrix, inverted\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_VIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current view matrix inverted",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE VIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_VIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides inverse of concatenated world, view and projection matrices. Equivalent to RenderMonkey's \u003ca\u003eWorldViewProjectionInverse\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_WORLDVIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides inverse of concatenated world view and projection matrices Equivalent to RenderMonkey WorldViewProjectionInverse",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE WORLDVIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_WORLDVIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current world & view matrices concatenated, then inverted\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_WORLDVIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current world view matrices concatenated then inverted",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE WORLDVIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_WORLDVIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current world matrix, inverted\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_INVERSE_WORLD_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current world matrix inverted",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_INVERSE_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT INVERSE WORLD MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_INVERSE_WORLD_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight attenuation parameters, Vector4(range, constant, linear, quadric)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_ATTENUATION",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_ATTENUATION",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Light attenuation parameters Vector4 range constant linear quadric",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_ATTENUATION",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT ATTENUATION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_ATTENUATION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light attenuation parameters, Vector4(range, constant, linear, quadric) (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_ATTENUATION_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_ATTENUATION_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light attenuation parameters Vector4 range constant linear quadric count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_ATTENUATION_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT ATTENUATION ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_ATTENUATION_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns (int) 1 if the  given light casts shadows, 0 otherwise (index set in extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_CASTS_SHADOWS",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_CASTS_SHADOWS",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Returns int if the given light casts shadows otherwise index set in extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_CASTS_SHADOWS",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT CASTS SHADOWS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_CASTS_SHADOWS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of active light sources (better than gl_MaxLights)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_COUNT",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_COUNT",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The number of active light sources better than gl MaxLights",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_COUNT",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT COUNT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_COUNT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinds custom per-light constants to the shaders.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_CUSTOM",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_CUSTOM",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Binds custom per-light constants to the shaders",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_CUSTOM",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT CUSTOM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_CUSTOM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight diffuse colour (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIFFUSE_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Light diffuse colour index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIFFUSE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIFFUSE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light diffuse colours (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIFFUSE_COLOUR_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light diffuse colours count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIFFUSE COLOUR ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIFFUSE_COLOUR_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight diffuse colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Light diffuse colour pre-scaled by Light setPowerScale index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIFFUSE COLOUR POWER SCALED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light diffuse colours scaled by light power (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light diffuse colours scaled by light power count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIFFUSE COLOUR POWER SCALED ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA light direction in world space (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIRECTION",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "light direction in world space index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIRECTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIRECTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light directions in world space (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIRECTION_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light directions in world space count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIRECTION ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIRECTION_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA light direction in object space (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIRECTION_OBJECT_SPACE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "light direction in object space index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIRECTION OBJECT SPACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIRECTION_OBJECT_SPACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light directions in object space (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light directions in object space count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIRECTION OBJECT SPACE ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA light direction in view space (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_VIEW_SPACE",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIRECTION_VIEW_SPACE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "light direction in view space index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_VIEW_SPACE",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIRECTION VIEW SPACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIRECTION_VIEW_SPACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light directions in view space (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light directions in view space count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DIRECTION VIEW SPACE ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe distance of the light from the center of the object a useful approximation as an alternative to per-vertex distance calculations.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DISTANCE_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DISTANCE_OBJECT_SPACE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The distance of the light from the center of the object useful approximation as an alternative to per-vertex distance calculations",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DISTANCE_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DISTANCE OBJECT SPACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DISTANCE_OBJECT_SPACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of distances of the lights from the center of the object a useful approximation as an alternative to per-vertex distance calculations. (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of distances of the lights from the center of the object useful approximation as an alternative to per-vertex distance calculations count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT DISTANCE OBJECT SPACE ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_NUMBER",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_NUMBER",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_NUMBER",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT NUMBER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_NUMBER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA light position in world space (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POSITION",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "light position in world space index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light positions in world space (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POSITION_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light positions in world space count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POSITION ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POSITION_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA light position in object space (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POSITION_OBJECT_SPACE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "light position in object space index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POSITION OBJECT SPACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POSITION_OBJECT_SPACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light positions in object space (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light positions in object space count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POSITION OBJECT SPACE ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA light position in view space (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_VIEW_SPACE",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POSITION_VIEW_SPACE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "light position in view space index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_VIEW_SPACE",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POSITION VIEW SPACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POSITION_VIEW_SPACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light positions in view space (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light positions in view space count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POSITION VIEW SPACE ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight power level, a single scalar as set in Light::setPowerScale  (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POWER_SCALE",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POWER_SCALE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Light power level single scalar as set in Light setPowerScale index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POWER_SCALE",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POWER SCALE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POWER_SCALE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light power levels, a single scalar as set in Light::setPowerScale (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POWER_SCALE_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_POWER_SCALE_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light power levels single scalar as set in Light setPowerScale count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_POWER_SCALE_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT POWER SCALE ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_POWER_SCALE_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight specular colour (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_SPECULAR_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Light specular colour index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT SPECULAR COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_SPECULAR_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light specular colours (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_SPECULAR_COLOUR_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light specular colours count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT SPECULAR COLOUR ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_SPECULAR_COLOUR_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight specular colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Light specular colour pre-scaled by Light setPowerScale index determined by setAutoConstant call",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT SPECULAR COLOUR POWER SCALED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of light specular colours scaled by light power (count set by extra param)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of light specular colours scaled by light power count set by extra param",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT LIGHT SPECULAR COLOUR POWER SCALED ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LOD_CAMERA_POSITION",
          "package": "lambdacube-engine",
          "signature": "ACT_LOD_CAMERA_POSITION",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LOD_CAMERA_POSITION",
          "package": "lambdacube-engine",
          "partial": "ACT LOD CAMERA POSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LOD_CAMERA_POSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LOD_CAMERA_POSITION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "signature": "ACT_LOD_CAMERA_POSITION_OBJECT_SPACE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_LOD_CAMERA_POSITION_OBJECT_SPACE",
          "package": "lambdacube-engine",
          "partial": "ACT LOD CAMERA POSITION OBJECT SPACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_LOD_CAMERA_POSITION_OBJECT_SPACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable provides the near clip distance as a floating point value. Equivalent to RenderMonkey's \u003ca\u003eNearClipPlane\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_NEAR_CLIP_DISTANCE",
          "package": "lambdacube-engine",
          "signature": "ACT_NEAR_CLIP_DISTANCE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable provides the near clip distance as floating point value Equivalent to RenderMonkey NearClipPlane",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_NEAR_CLIP_DISTANCE",
          "package": "lambdacube-engine",
          "partial": "ACT NEAR CLIP DISTANCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_NEAR_CLIP_DISTANCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides packed texture size of the texture unit (index determined by setAutoConstant call). Packed as float4(width, height, 1 \u003cem\u003e width, 1 \u003c/em\u003e height)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PACKED_TEXTURE_SIZE",
          "package": "lambdacube-engine",
          "signature": "ACT_PACKED_TEXTURE_SIZE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides packed texture size of the texture unit index determined by setAutoConstant call Packed as float4 width height width height",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PACKED_TEXTURE_SIZE",
          "package": "lambdacube-engine",
          "partial": "ACT PACKED TEXTURE SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_PACKED_TEXTURE_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprovides the current iteration number of the pass. The iteration number is the number of times the current render operation has been drawn for the active pass.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PASS_ITERATION_NUMBER",
          "package": "lambdacube-engine",
          "signature": "ACT_PASS_ITERATION_NUMBER",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "provides the current iteration number of the pass The iteration number is the number of times the current render operation has been drawn for the active pass",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PASS_ITERATION_NUMBER",
          "package": "lambdacube-engine",
          "partial": "ACT PASS ITERATION NUMBER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_PASS_ITERATION_NUMBER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprovides the pass index number within the technique of the active materil.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PASS_NUMBER",
          "package": "lambdacube-engine",
          "signature": "ACT_PASS_NUMBER",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "provides the pass index number within the technique of the active materil",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PASS_NUMBER",
          "package": "lambdacube-engine",
          "partial": "ACT PASS NUMBER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_PASS_NUMBER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current projection matrix\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_PROJECTION_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current projection matrix",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT PROJECTION MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_PROJECTION_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e1 if requires texture flipping, +1 otherwise. It's useful when you bypassed projection matrix transform, still able use this value to adjust transformed y position.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_RENDER_TARGET_FLIPPING",
          "package": "lambdacube-engine",
          "signature": "ACT_RENDER_TARGET_FLIPPING",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "if requires texture flipping otherwise It useful when you bypassed projection matrix transform still able use this value to adjust transformed position",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_RENDER_TARGET_FLIPPING",
          "package": "lambdacube-engine",
          "partial": "ACT RENDER TARGET FLIPPING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_RENDER_TARGET_FLIPPING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SCENE_DEPTH_RANGE",
          "package": "lambdacube-engine",
          "signature": "ACT_SCENE_DEPTH_RANGE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SCENE_DEPTH_RANGE",
          "package": "lambdacube-engine",
          "partial": "ACT SCENE DEPTH RANGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SCENE_DEPTH_RANGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides the fixed shadow colour as configured via SceneManager::setShadowColour; useful for integrated modulative shadows.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SHADOW_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_SHADOW_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides the fixed shadow colour as configured via SceneManager setShadowColour useful for integrated modulative shadows",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SHADOW_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT SHADOW COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SHADOW_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe distance a shadow volume should be extruded when using finite extrusion programs.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SHADOW_EXTRUSION_DISTANCE",
          "package": "lambdacube-engine",
          "signature": "ACT_SHADOW_EXTRUSION_DISTANCE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The distance shadow volume should be extruded when using finite extrusion programs",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SHADOW_EXTRUSION_DISTANCE",
          "package": "lambdacube-engine",
          "partial": "ACT SHADOW EXTRUSION DISTANCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SHADOW_EXTRUSION_DISTANCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SHADOW_SCENE_DEPTH_RANGE",
          "package": "lambdacube-engine",
          "signature": "ACT_SHADOW_SCENE_DEPTH_RANGE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SHADOW_SCENE_DEPTH_RANGE",
          "package": "lambdacube-engine",
          "partial": "ACT SHADOW SCENE DEPTH RANGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SHADOW_SCENE_DEPTH_RANGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSine of \u003ca\u003eTime0_1\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eSinTime0_1\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SINTIME_0_1",
          "package": "lambdacube-engine",
          "signature": "ACT_SINTIME_0_1",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Sine of Time0 Equivalent to RenderMonkey SinTime0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SINTIME_0_1",
          "package": "lambdacube-engine",
          "partial": "ACT SINTIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SINTIME_0_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSine of \u003ca\u003eTime0_2PI\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eSinTime0_2PI\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SINTIME_0_2PI",
          "package": "lambdacube-engine",
          "signature": "ACT_SINTIME_0_2PI",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Sine of Time0 PI Equivalent to RenderMonkey SinTime0 PI",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SINTIME_0_2PI",
          "package": "lambdacube-engine",
          "partial": "ACT SINTIME PI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SINTIME_0_2PI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSine of \u003ca\u003eTime0_X\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eSinTime0_X\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SINTIME_0_X",
          "package": "lambdacube-engine",
          "signature": "ACT_SINTIME_0_X",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Sine of Time0 Equivalent to RenderMonkey SinTime0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SINTIME_0_X",
          "package": "lambdacube-engine",
          "partial": "ACT SINTIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SINTIME_0_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_PARAMS",
          "package": "lambdacube-engine",
          "signature": "ACT_SPOTLIGHT_PARAMS",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_PARAMS",
          "package": "lambdacube-engine",
          "partial": "ACT SPOTLIGHT PARAMS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SPOTLIGHT_PARAMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_PARAMS_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_SPOTLIGHT_PARAMS_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_PARAMS_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT SPOTLIGHT PARAMS ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SPOTLIGHT_PARAMS_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe view/projection matrix of a given spotlight\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_SPOTLIGHT_VIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The view projection matrix of given spotlight",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT SPOTLIGHT VIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SPOTLIGHT_VIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe view/projection matrix of a given spotlight projection frustum, combined with the current world matrix\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The view projection matrix of given spotlight projection frustum combined with the current world matrix",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT SPOTLIGHT WORLDVIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurface ambient colour, as set in Pass::setAmbient\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_AMBIENT_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_SURFACE_AMBIENT_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Surface ambient colour as set in Pass setAmbient",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_AMBIENT_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT SURFACE AMBIENT COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SURFACE_AMBIENT_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurface diffuse colour, as set in Pass::setDiffuse\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_SURFACE_DIFFUSE_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Surface diffuse colour as set in Pass setDiffuse",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_DIFFUSE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT SURFACE DIFFUSE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SURFACE_DIFFUSE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurface emissive colour, as set in Pass::setSelfIllumination\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_EMISSIVE_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_SURFACE_EMISSIVE_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Surface emissive colour as set in Pass setSelfIllumination",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_EMISSIVE_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT SURFACE EMISSIVE COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SURFACE_EMISSIVE_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurface shininess, as set in Pass::setShininess\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_SHININESS",
          "package": "lambdacube-engine",
          "signature": "ACT_SURFACE_SHININESS",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Surface shininess as set in Pass setShininess",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_SHININESS",
          "package": "lambdacube-engine",
          "partial": "ACT SURFACE SHININESS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SURFACE_SHININESS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSurface specular colour, as set in Pass::setSpecular\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_SPECULAR_COLOUR",
          "package": "lambdacube-engine",
          "signature": "ACT_SURFACE_SPECULAR_COLOUR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Surface specular colour as set in Pass setSpecular",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_SURFACE_SPECULAR_COLOUR",
          "package": "lambdacube-engine",
          "partial": "ACT SURFACE SPECULAR COLOUR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_SURFACE_SPECULAR_COLOUR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTangent of \u003ca\u003eTime0_1\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTanTime0_1\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TANTIME_0_1",
          "package": "lambdacube-engine",
          "signature": "ACT_TANTIME_0_1",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Tangent of Time0 Equivalent to RenderMonkey TanTime0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TANTIME_0_1",
          "package": "lambdacube-engine",
          "partial": "ACT TANTIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TANTIME_0_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTangent of \u003ca\u003eTime0_2PI\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTanTime0_2PI\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TANTIME_0_2PI",
          "package": "lambdacube-engine",
          "signature": "ACT_TANTIME_0_2PI",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Tangent of Time0 PI Equivalent to RenderMonkey TanTime0 PI",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TANTIME_0_2PI",
          "package": "lambdacube-engine",
          "partial": "ACT TANTIME PI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TANTIME_0_2PI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTangent of \u003ca\u003eTime0_X\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTanTime0_X\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TANTIME_0_X",
          "package": "lambdacube-engine",
          "signature": "ACT_TANTIME_0_X",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Tangent of Time0 Equivalent to RenderMonkey TanTime0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TANTIME_0_X",
          "package": "lambdacube-engine",
          "partial": "ACT TANTIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TANTIME_0_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXEL_OFFSETS",
          "package": "lambdacube-engine",
          "signature": "ACT_TEXEL_OFFSETS",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXEL_OFFSETS",
          "package": "lambdacube-engine",
          "partial": "ACT TEXEL OFFSETS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TEXEL_OFFSETS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides the current transform matrix of the texture unit (index determined by setAutoConstant call), as seen by the fixed-function pipeline.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TEXTURE_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides the current transform matrix of the texture unit index determined by setAutoConstant call as seen by the fixed-function pipeline",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TEXTURE MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TEXTURE_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides texture size of the texture unit (index determined by setAutoConstant call). Packed as float4(width, height, depth, 1)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_SIZE",
          "package": "lambdacube-engine",
          "signature": "ACT_TEXTURE_SIZE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides texture size of the texture unit index determined by setAutoConstant call Packed as float4 width height depth",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_SIZE",
          "package": "lambdacube-engine",
          "partial": "ACT TEXTURE SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TEXTURE_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe view/projection matrix of the assigned texture projection frustum\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TEXTURE_VIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The view projection matrix of the assigned texture projection frustum",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TEXTURE VIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TEXTURE_VIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of view/projection matrices of the first n texture projection frustums\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of view projection matrices of the first texture projection frustums",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT TEXTURE VIEWPROJ MATRIX ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe view/projection matrix of the assigned texture projection frustum, combined with the current world matrix\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TEXTURE_WORLDVIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The view projection matrix of the assigned texture projection frustum combined with the current world matrix",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TEXTURE WORLDVIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TEXTURE_WORLDVIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray of world\u003cem\u003eview\u003c/em\u003eprojection matrices of the first n texture projection frustums\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Array of world view projection matrices of the first texture projection frustums",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT TEXTURE WORLDVIEWPROJ MATRIX ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprovides current elapsed time\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME",
          "package": "lambdacube-engine",
          "signature": "ACT_TIME",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "provides current elapsed time",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME",
          "package": "lambdacube-engine",
          "partial": "ACT TIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TIME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle float value, which represents scaled time value [0..1], which repeats itself based on given as parameter \u003ca\u003ecycle time\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTime0_1\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_1",
          "package": "lambdacube-engine",
          "signature": "ACT_TIME_0_1",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Single float value which represents scaled time value which repeats itself based on given as parameter cycle time Equivalent to RenderMonkey Time0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_1",
          "package": "lambdacube-engine",
          "partial": "ACT TIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TIME_0_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector of \u003ca\u003eTime0_1\u003c/a\u003e, \u003ca\u003eSinTime0_1\u003c/a\u003e, \u003ca\u003eCosTime0_1\u003c/a\u003e, \u003ca\u003eTanTime0_1\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTime0_1_Packed\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_1_PACKED",
          "package": "lambdacube-engine",
          "signature": "ACT_TIME_0_1_PACKED",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Vector of Time0 SinTime0 CosTime0 TanTime0 Equivalent to RenderMonkey Time0 Packed",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_1_PACKED",
          "package": "lambdacube-engine",
          "partial": "ACT TIME PACKED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TIME_0_1_PACKED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle float value, which represents scaled time value [0..2*Pi], which repeats itself based on given as parameter \u003ca\u003ecycle time\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTime0_2PI\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_2PI",
          "package": "lambdacube-engine",
          "signature": "ACT_TIME_0_2PI",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Single float value which represents scaled time value Pi which repeats itself based on given as parameter cycle time Equivalent to RenderMonkey Time0 PI",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_2PI",
          "package": "lambdacube-engine",
          "partial": "ACT TIME PI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TIME_0_2PI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector of \u003ca\u003eTime0_2PI\u003c/a\u003e, \u003ca\u003eSinTime0_2PI\u003c/a\u003e, \u003ca\u003eCosTime0_2PI\u003c/a\u003e, \u003ca\u003eTanTime0_2PI\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTime0_2PI_Packed\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_2PI_PACKED",
          "package": "lambdacube-engine",
          "signature": "ACT_TIME_0_2PI_PACKED",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Vector of Time0 PI SinTime0 PI CosTime0 PI TanTime0 PI Equivalent to RenderMonkey Time0 PI Packed",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_2PI_PACKED",
          "package": "lambdacube-engine",
          "partial": "ACT TIME PI PACKED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TIME_0_2PI_PACKED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle float value, which repeats itself based on given as parameter \u003ca\u003ecycle time\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTime0_X\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_X",
          "package": "lambdacube-engine",
          "signature": "ACT_TIME_0_X",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Single float value which repeats itself based on given as parameter cycle time Equivalent to RenderMonkey Time0",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_X",
          "package": "lambdacube-engine",
          "partial": "ACT TIME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TIME_0_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector of \u003ca\u003eTime0_X\u003c/a\u003e, \u003ca\u003eSinTime0_X\u003c/a\u003e, \u003ca\u003eCosTime0_X\u003c/a\u003e, \u003ca\u003eTanTime0_X\u003c/a\u003e. Equivalent to RenderMonkey's \u003ca\u003eTime0_X_Packed\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_X_PACKED",
          "package": "lambdacube-engine",
          "signature": "ACT_TIME_0_X_PACKED",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Vector of Time0 SinTime0 CosTime0 TanTime0 Equivalent to RenderMonkey Time0 Packed",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TIME_0_X_PACKED",
          "package": "lambdacube-engine",
          "partial": "ACT TIME PACKED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TIME_0_X_PACKED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides transpose of projection matrix. Equivalent to RenderMonkey's \u003ca\u003eProjectionTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TRANSPOSE_PROJECTION_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides transpose of projection matrix Equivalent to RenderMonkey ProjectionTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_PROJECTION_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TRANSPOSE PROJECTION MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TRANSPOSE_PROJECTION_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides transpose of concatenated view and projection matrices. Equivalent to RenderMonkey's \u003ca\u003eViewProjectionTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TRANSPOSE_VIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides transpose of concatenated view and projection matrices Equivalent to RenderMonkey ViewProjectionTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TRANSPOSE VIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TRANSPOSE_VIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides transpose of view matrix. Equivalent to RenderMonkey's \u003ca\u003eViewTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TRANSPOSE_VIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides transpose of view matrix Equivalent to RenderMonkey ViewTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TRANSPOSE VIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TRANSPOSE_VIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides transpose of concatenated world, view and projection matrices. Equivalent to RenderMonkey's \u003ca\u003eWorldViewProjectionTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides transpose of concatenated world view and projection matrices Equivalent to RenderMonkey WorldViewProjectionTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TRANSPOSE WORLDVIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides transpose of concatenated world and view matrices. Equivalent to RenderMonkey's \u003ca\u003eWorldViewTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TRANSPOSE_WORLDVIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides transpose of concatenated world and view matrices Equivalent to RenderMonkey WorldViewTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TRANSPOSE WORLDVIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TRANSPOSE_WORLDVIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides transpose of world matrix. Equivalent to RenderMonkey's \u003ca\u003eWorldTranspose\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_TRANSPOSE_WORLD_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Provides transpose of world matrix Equivalent to RenderMonkey WorldTranspose",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_TRANSPOSE_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT TRANSPOSE WORLD MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_TRANSPOSE_WORLD_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent viewport height (in pixels) as floating point value. Equivalent to RenderMonkey's \u003ca\u003eViewportHeight\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPORT_HEIGHT",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEWPORT_HEIGHT",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Current viewport height in pixels as floating point value Equivalent to RenderMonkey ViewportHeight",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPORT_HEIGHT",
          "package": "lambdacube-engine",
          "partial": "ACT VIEWPORT HEIGHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEWPORT_HEIGHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePacked of \u003ca\u003eViewportWidth\u003c/a\u003e, \u003ca\u003eViewportHeight\u003c/a\u003e, \u003ca\u003eViewportWidthInverse\u003c/a\u003e, \u003ca\u003eViewportHeightInverse\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPORT_SIZE",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEWPORT_SIZE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Packed of ViewportWidth ViewportHeight ViewportWidthInverse ViewportHeightInverse",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPORT_SIZE",
          "package": "lambdacube-engine",
          "partial": "ACT VIEWPORT SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEWPORT_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent viewport width (in pixels) as floating point value. Equivalent to RenderMonkey's \u003ca\u003eViewportWidth\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPORT_WIDTH",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEWPORT_WIDTH",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "Current viewport width in pixels as floating point value Equivalent to RenderMonkey ViewportWidth",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPORT_WIDTH",
          "package": "lambdacube-engine",
          "partial": "ACT VIEWPORT WIDTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEWPORT_WIDTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current view & projection matrices concatenated\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current view projection matrices concatenated",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT VIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable provides the view direction vector (world space). Equivalent to RenderMonkey's \u003ca\u003eViewDirection\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_DIRECTION",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEW_DIRECTION",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable provides the view direction vector world space Equivalent to RenderMonkey ViewDirection",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_DIRECTION",
          "package": "lambdacube-engine",
          "partial": "ACT VIEW DIRECTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEW_DIRECTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current view matrix\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current view matrix",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT VIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable provides the view side vector (world space). Equivalent to RenderMonkey's \u003ca\u003eViewSideVector\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_SIDE_VECTOR",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEW_SIDE_VECTOR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable provides the view side vector world space Equivalent to RenderMonkey ViewSideVector",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_SIDE_VECTOR",
          "package": "lambdacube-engine",
          "partial": "ACT VIEW SIDE VECTOR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEW_SIDE_VECTOR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis variable provides the view up vector (world space). Equivalent to RenderMonkey's \u003ca\u003eViewUpVector\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_UP_VECTOR",
          "package": "lambdacube-engine",
          "signature": "ACT_VIEW_UP_VECTOR",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "This variable provides the view up vector world space Equivalent to RenderMonkey ViewUpVector",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_VIEW_UP_VECTOR",
          "package": "lambdacube-engine",
          "partial": "ACT VIEW UP VECTOR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_VIEW_UP_VECTOR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current world, view & projection matrices concatenated\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_WORLDVIEWPROJ_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current world view projection matrices concatenated",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLDVIEWPROJ_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT WORLDVIEWPROJ MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_WORLDVIEWPROJ_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current world & view matrices concatenated\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_WORLDVIEW_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current world view matrices concatenated",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLDVIEW_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT WORLDVIEW MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_WORLDVIEW_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current world matrix\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "signature": "ACT_WORLD_MATRIX",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current world matrix",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLD_MATRIX",
          "package": "lambdacube-engine",
          "partial": "ACT WORLD MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_WORLD_MATRIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current array of world matrices, used for blending\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLD_MATRIX_ARRAY",
          "package": "lambdacube-engine",
          "signature": "ACT_WORLD_MATRIX_ARRAY",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current array of world matrices used for blending",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLD_MATRIX_ARRAY",
          "package": "lambdacube-engine",
          "partial": "ACT WORLD MATRIX ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_WORLD_MATRIX_ARRAY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current array of world matrices, as a 3x4 matrix, used for blending\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLD_MATRIX_ARRAY_3x4",
          "package": "lambdacube-engine",
          "signature": "ACT_WORLD_MATRIX_ARRAY_3x4",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantType",
          "type": "function"
        },
        "index": {
          "description": "The current array of world matrices as x4 matrix used for blending",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ACT_WORLD_MATRIX_ARRAY_3x4",
          "package": "lambdacube-engine",
          "partial": "ACT WORLD MATRIX ARRAY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ACT_WORLD_MATRIX_ARRAY_3x4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantDefinition",
          "package": "lambdacube-engine",
          "signature": "AutoConstantDefinition",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantDefinition",
          "package": "lambdacube-engine",
          "partial": "Auto Constant Definition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:AutoConstantDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantEntry",
          "package": "lambdacube-engine",
          "signature": "AutoConstantEntry",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "AutoConstantEntry",
          "package": "lambdacube-engine",
          "partial": "Auto Constant Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:AutoConstantEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "CopyDataEntry",
          "package": "lambdacube-engine",
          "signature": "CopyDataEntry",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#CopyDataEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "CopyDataEntry",
          "package": "lambdacube-engine",
          "partial": "Copy Data Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:CopyDataEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ET_INT",
          "package": "lambdacube-engine",
          "signature": "ET_INT",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#ElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ET_INT",
          "package": "lambdacube-engine",
          "partial": "ET INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ET_INT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ET_REAL",
          "package": "lambdacube-engine",
          "signature": "ET_REAL",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#ElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "ET_REAL",
          "package": "lambdacube-engine",
          "partial": "ET REAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:ET_REAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT1",
          "package": "lambdacube-engine",
          "signature": "GCT_FLOAT1",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT1",
          "package": "lambdacube-engine",
          "partial": "GCT FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_FLOAT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT2",
          "package": "lambdacube-engine",
          "signature": "GCT_FLOAT2",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT2",
          "package": "lambdacube-engine",
          "partial": "GCT FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_FLOAT2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT3",
          "package": "lambdacube-engine",
          "signature": "GCT_FLOAT3",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT3",
          "package": "lambdacube-engine",
          "partial": "GCT FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_FLOAT3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT4",
          "package": "lambdacube-engine",
          "signature": "GCT_FLOAT4",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_FLOAT4",
          "package": "lambdacube-engine",
          "partial": "GCT FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_FLOAT4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT1",
          "package": "lambdacube-engine",
          "signature": "GCT_INT1",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT1",
          "package": "lambdacube-engine",
          "partial": "GCT INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_INT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT2",
          "package": "lambdacube-engine",
          "signature": "GCT_INT2",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT2",
          "package": "lambdacube-engine",
          "partial": "GCT INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_INT2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT3",
          "package": "lambdacube-engine",
          "signature": "GCT_INT3",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT3",
          "package": "lambdacube-engine",
          "partial": "GCT INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_INT3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT4",
          "package": "lambdacube-engine",
          "signature": "GCT_INT4",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_INT4",
          "package": "lambdacube-engine",
          "partial": "GCT INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_INT4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_2X2",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_2X2",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_2X2",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_2X2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_2X3",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_2X3",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_2X3",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_2X3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_2X4",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_2X4",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_2X4",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_2X4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_3X2",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_3X2",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_3X2",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_3X2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_3X3",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_3X3",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_3X3",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_3X3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_3X4",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_3X4",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_3X4",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_3X4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_4X2",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_4X2",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_4X2",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_4X2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_4X3",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_4X3",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_4X3",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_4X3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_4X4",
          "package": "lambdacube-engine",
          "signature": "GCT_MATRIX_4X4",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_MATRIX_4X4",
          "package": "lambdacube-engine",
          "partial": "GCT MATRIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_MATRIX_4X4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER1D",
          "package": "lambdacube-engine",
          "signature": "GCT_SAMPLER1D",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER1D",
          "package": "lambdacube-engine",
          "partial": "GCT SAMPLER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_SAMPLER1D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER1DSHADOW",
          "package": "lambdacube-engine",
          "signature": "GCT_SAMPLER1DSHADOW",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER1DSHADOW",
          "package": "lambdacube-engine",
          "partial": "GCT SAMPLER DSHADOW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_SAMPLER1DSHADOW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER2D",
          "package": "lambdacube-engine",
          "signature": "GCT_SAMPLER2D",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER2D",
          "package": "lambdacube-engine",
          "partial": "GCT SAMPLER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_SAMPLER2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER2DSHADOW",
          "package": "lambdacube-engine",
          "signature": "GCT_SAMPLER2DSHADOW",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER2DSHADOW",
          "package": "lambdacube-engine",
          "partial": "GCT SAMPLER DSHADOW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_SAMPLER2DSHADOW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER3D",
          "package": "lambdacube-engine",
          "signature": "GCT_SAMPLER3D",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLER3D",
          "package": "lambdacube-engine",
          "partial": "GCT SAMPLER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_SAMPLER3D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLERCUBE",
          "package": "lambdacube-engine",
          "signature": "GCT_SAMPLERCUBE",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_SAMPLERCUBE",
          "package": "lambdacube-engine",
          "partial": "GCT SAMPLERCUBE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_SAMPLERCUBE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_UNKNOWN",
          "package": "lambdacube-engine",
          "signature": "GCT_UNKNOWN",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GCT_UNKNOWN",
          "package": "lambdacube-engine",
          "partial": "GCT UNKNOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GCT_UNKNOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuConstantDefinition",
          "package": "lambdacube-engine",
          "signature": "GpuConstantDefinition",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuConstantDefinition",
          "package": "lambdacube-engine",
          "partial": "Gpu Constant Definition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuConstantDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalBufferStruct",
          "package": "lambdacube-engine",
          "signature": "GpuLogicalBufferStruct",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalBufferStruct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalBufferStruct",
          "package": "lambdacube-engine",
          "partial": "Gpu Logical Buffer Struct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuLogicalBufferStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalIndexUse",
          "package": "lambdacube-engine",
          "signature": "GpuLogicalIndexUse",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalIndexUse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuLogicalIndexUse",
          "package": "lambdacube-engine",
          "partial": "Gpu Logical Index Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuLogicalIndexUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstant",
          "package": "lambdacube-engine",
          "signature": "GpuNamedConstant",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstant",
          "package": "lambdacube-engine",
          "partial": "Gpu Named Constant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuNamedConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstants",
          "package": "lambdacube-engine",
          "signature": "GpuNamedConstants",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstants",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuNamedConstants",
          "package": "lambdacube-engine",
          "partial": "Gpu Named Constants",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuNamedConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuParamVariability",
          "package": "lambdacube-engine",
          "signature": "GpuParamVariability",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuParamVariability",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuParamVariability",
          "package": "lambdacube-engine",
          "partial": "Gpu Param Variability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuParamVariability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuProgramParameters",
          "package": "lambdacube-engine",
          "signature": "GpuProgramParameters",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuProgramParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuProgramParameters",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Parameters",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuProgramParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParameters",
          "package": "lambdacube-engine",
          "signature": "GpuSharedParameters",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParameters",
          "package": "lambdacube-engine",
          "partial": "Gpu Shared Parameters",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuSharedParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParametersUsage",
          "package": "lambdacube-engine",
          "signature": "GpuSharedParametersUsage",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParametersUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "GpuSharedParametersUsage",
          "package": "lambdacube-engine",
          "partial": "Gpu Shared Parameters Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:GpuSharedParametersUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of any extra data\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdDataType",
          "package": "lambdacube-engine",
          "signature": "ACDataType",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "The type of any extra data",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdDataType",
          "package": "lambdacube-engine",
          "partial": "Data Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:acdDataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdElementCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdElementCount",
          "package": "lambdacube-engine",
          "partial": "Element Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:acdElementCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of the constant in the program\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdElementType",
          "package": "lambdacube-engine",
          "signature": "ElementType",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "The type of the constant in the program",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdElementType",
          "package": "lambdacube-engine",
          "partial": "Element Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:acdElementType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:acdName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdType",
          "package": "lambdacube-engine",
          "signature": "AutoConstantType",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantDefinition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acdType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:acdType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of elements per individual entry in this constant Used in case people used packed elements smaller than 4 (e.g. GLSL) and bind an auto which is 4-element packed to it\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "aceElementCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantEntry",
          "type": "function"
        },
        "index": {
          "description": "The number of elements per individual entry in this constant Used in case people used packed elements smaller than e.g GLSL and bind an auto which is element packed to it",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "aceElementCount",
          "package": "lambdacube-engine",
          "partial": "Element Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:aceElementCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of parameter\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "aceParamType",
          "package": "lambdacube-engine",
          "signature": "AutoConstantType",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantEntry",
          "type": "function"
        },
        "index": {
          "description": "The type of parameter",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "aceParamType",
          "package": "lambdacube-engine",
          "partial": "Param Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:aceParamType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe target (physical) constant index\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acePhysicalIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantEntry",
          "type": "function"
        },
        "index": {
          "description": "The target physical constant index",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "acePhysicalIndex",
          "package": "lambdacube-engine",
          "partial": "Physical Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:acePhysicalIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe variability of this parameter (see GpuParamVariability)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "aceVariability",
          "package": "lambdacube-engine",
          "signature": "GpuParamVariability",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#AutoConstantEntry",
          "type": "function"
        },
        "index": {
          "description": "The variability of this parameter see GpuParamVariability",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "aceVariability",
          "package": "lambdacube-engine",
          "partial": "Variability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:aceVariability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "autoConstantDictionary",
          "package": "lambdacube-engine",
          "signature": "[(AutoConstantType, String, Int, ElementType, ACDataType)]",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#autoConstantDictionary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "autoConstantDictionary",
          "normalized": "[(AutoConstantType,String,Int,ElementType,ACDataType)]",
          "package": "lambdacube-engine",
          "partial": "Constant Dictionary",
          "signature": "[(AutoConstantType,String,Int,ElementType,ACDataType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:autoConstantDictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "cdeDstDefinition",
          "package": "lambdacube-engine",
          "signature": "GpuConstantDefinition",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#CopyDataEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "cdeDstDefinition",
          "package": "lambdacube-engine",
          "partial": "Dst Definition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:cdeDstDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "cdeSrcDefinition",
          "package": "lambdacube-engine",
          "signature": "GpuConstantDefinition",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#CopyDataEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "cdeSrcDefinition",
          "package": "lambdacube-engine",
          "partial": "Src Definition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:cdeSrcDefinition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLength of array\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdArraySize",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "Length of array",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdArraySize",
          "package": "lambdacube-engine",
          "partial": "Array Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gcdArraySize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData type\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdConstType",
          "package": "lambdacube-engine",
          "signature": "GpuConstantType",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "Data type",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdConstType",
          "package": "lambdacube-engine",
          "partial": "Const Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gcdConstType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of raw buffer slots per element (some programs pack each array element to float4, some do not)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdElementSize",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "Number of raw buffer slots per element some programs pack each array element to float4 some do not",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdElementSize",
          "package": "lambdacube-engine",
          "partial": "Element Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gcdElementSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical index - used to communicate this constant to the rendersystem\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdLogicalIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "Logical index used to communicate this constant to the rendersystem",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdLogicalIndex",
          "package": "lambdacube-engine",
          "partial": "Logical Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gcdLogicalIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhysical start index in buffer (either float or int buffer)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdPhysicalIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "Physical start index in buffer either float or int buffer",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdPhysicalIndex",
          "package": "lambdacube-engine",
          "partial": "Physical Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gcdPhysicalIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow this parameter varies (bitwise combination of GpuProgramVariability)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdVariability",
          "package": "lambdacube-engine",
          "signature": "GpuParamVariability",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuConstantDefinition",
          "type": "function"
        },
        "index": {
          "description": "How this parameter varies bitwise combination of GpuProgramVariability",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gcdVariability",
          "package": "lambdacube-engine",
          "partial": "Variability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gcdVariability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the element size of a given type, including whether to pad\n the elements into multiples of 4 (e.g. SM1 and D3D does, GLSL\n doesn't)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "getElementSize",
          "package": "lambdacube-engine",
          "signature": "GpuConstantType -\u003e Bool -\u003e Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#getElementSize",
          "type": "function"
        },
        "index": {
          "description": "Get the element size of given type including whether to pad the elements into multiples of e.g SM1 and D3D does GLSL doesn",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "getElementSize",
          "normalized": "GpuConstantType-\u003eBool-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Element Size",
          "signature": "GpuConstantType-\u003eBool-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:getElementSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent physical size allocation\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gliCurrentSize",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalIndexUse",
          "type": "function"
        },
        "index": {
          "description": "Current physical size allocation",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gliCurrentSize",
          "package": "lambdacube-engine",
          "partial": "Current Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gliCurrentSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePhysical buffer index\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gliPhysicalIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalIndexUse",
          "type": "function"
        },
        "index": {
          "description": "Physical buffer index",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gliPhysicalIndex",
          "package": "lambdacube-engine",
          "partial": "Physical Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gliPhysicalIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow the contents of this slot vary\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gliVariability",
          "package": "lambdacube-engine",
          "signature": "Word16",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalIndexUse",
          "type": "function"
        },
        "index": {
          "description": "How the contents of this slot vary",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gliVariability",
          "package": "lambdacube-engine",
          "partial": "Variability",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gliVariability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShortcut to know the buffer size needs\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gluBufferSize",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalBufferStruct",
          "type": "function"
        },
        "index": {
          "description": "Shortcut to know the buffer size needs",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gluBufferSize",
          "package": "lambdacube-engine",
          "partial": "Buffer Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gluBufferSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap from logical index to physical buffer location\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gluMap",
          "package": "lambdacube-engine",
          "signature": "Map Int GpuLogicalIndexUse",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuLogicalBufferStruct",
          "type": "function"
        },
        "index": {
          "description": "Map from logical index to physical buffer location",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gluMap",
          "package": "lambdacube-engine",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gluMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTotal size of the float buffer required\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncFloatBufferSize",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstants",
          "type": "function"
        },
        "index": {
          "description": "Total size of the float buffer required",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncFloatBufferSize",
          "package": "lambdacube-engine",
          "partial": "Float Buffer Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncFloatBufferSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncFloatValues",
          "package": "lambdacube-engine",
          "signature": "[FloatType]",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncFloatValues",
          "normalized": "[FloatType]",
          "package": "lambdacube-engine",
          "partial": "Float Values",
          "signature": "[FloatType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncFloatValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncGenerateAllConstantDefinitionArrayEntries",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstants",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncGenerateAllConstantDefinitionArrayEntries",
          "package": "lambdacube-engine",
          "partial": "Generate All Constant Definition Array Entries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncGenerateAllConstantDefinitionArrayEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTotal size of the int buffer required\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncIntBufferSize",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstants",
          "type": "function"
        },
        "index": {
          "description": "Total size of the int buffer required",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncIntBufferSize",
          "package": "lambdacube-engine",
          "partial": "Int Buffer Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncIntBufferSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncIntValues",
          "package": "lambdacube-engine",
          "signature": "[Int]",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncIntValues",
          "normalized": "[Int]",
          "package": "lambdacube-engine",
          "partial": "Int Values",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncIntValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap of parameter names to GpuConstantDefinition\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncMap",
          "package": "lambdacube-engine",
          "signature": "Map String GpuConstantDefinition",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstants",
          "type": "function"
        },
        "index": {
          "description": "Map of parameter names to GpuConstantDefinition",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncMap",
          "package": "lambdacube-engine",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncType",
          "package": "lambdacube-engine",
          "signature": "ElementType",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuNamedConstant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gncType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gncType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gppNamedConstants",
          "package": "lambdacube-engine",
          "signature": "[GpuNamedConstant]",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuProgramParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gppNamedConstants",
          "normalized": "[GpuNamedConstant]",
          "package": "lambdacube-engine",
          "partial": "Named Constants",
          "signature": "[GpuNamedConstant]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gppNamedConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo variation except by manual setting - the default\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvGlobal",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuParamVariability",
          "type": "function"
        },
        "index": {
          "description": "No variation except by manual setting the default",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvGlobal",
          "package": "lambdacube-engine",
          "partial": "Global",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gpvGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVaries with light setup\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvLights",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuParamVariability",
          "type": "function"
        },
        "index": {
          "description": "Varies with light setup",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvLights",
          "package": "lambdacube-engine",
          "partial": "Lights",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gpvLights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVaries with pass iteration number\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvPassIterationNumber",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuParamVariability",
          "type": "function"
        },
        "index": {
          "description": "Varies with pass iteration number",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvPassIterationNumber",
          "package": "lambdacube-engine",
          "partial": "Pass Iteration Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gpvPassIterationNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVaries per object (based on an auto param usually), but not per light setup\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvPerObject",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuParamVariability",
          "type": "function"
        },
        "index": {
          "description": "Varies per object based on an auto param usually but not per light setup",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gpvPerObject",
          "package": "lambdacube-engine",
          "partial": "Per Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gpvPerObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspFloatConstants",
          "package": "lambdacube-engine",
          "signature": "[Float]",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspFloatConstants",
          "normalized": "[Float]",
          "package": "lambdacube-engine",
          "partial": "Float Constants",
          "signature": "[Float]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gspFloatConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNot used when copying data, but might be useful to RS using shared buffers\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspFrameLastUpdated",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "function"
        },
        "index": {
          "description": "Not used when copying data but might be useful to RS using shared buffers",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspFrameLastUpdated",
          "package": "lambdacube-engine",
          "partial": "Frame Last Updated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gspFrameLastUpdated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspIntConstants",
          "package": "lambdacube-engine",
          "signature": "[Int]",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspIntConstants",
          "normalized": "[Int]",
          "package": "lambdacube-engine",
          "partial": "Int Constants",
          "signature": "[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gspIntConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gspName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspNamedConstants",
          "package": "lambdacube-engine",
          "signature": "GpuNamedConstants",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspNamedConstants",
          "package": "lambdacube-engine",
          "partial": "Named Constants",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gspNamedConstants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion number of the definitions in this buffer\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspVersion",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParameters",
          "type": "function"
        },
        "index": {
          "description": "Version number of the definitions in this buffer",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "gspVersion",
          "package": "lambdacube-engine",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:gspVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "isFloat",
          "package": "lambdacube-engine",
          "signature": "GpuConstantType -\u003e Bool",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#isFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "isFloat",
          "normalized": "GpuConstantType-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Float",
          "signature": "GpuConstantType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:isFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "isSampler",
          "package": "lambdacube-engine",
          "signature": "GpuConstantType -\u003e Bool",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#isSampler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "isSampler",
          "normalized": "GpuConstantType-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Sampler",
          "signature": "GpuConstantType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:isSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "spuCopyDataList",
          "package": "lambdacube-engine",
          "signature": "[CopyDataEntry]",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParametersUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "spuCopyDataList",
          "normalized": "[CopyDataEntry]",
          "package": "lambdacube-engine",
          "partial": "Copy Data List",
          "signature": "[CopyDataEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:spuCopyDataList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion of shared params we based the copydata on\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "spuCopyDataVersion",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParametersUsage",
          "type": "function"
        },
        "index": {
          "description": "Version of shared params we based the copydata on",
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "spuCopyDataVersion",
          "package": "lambdacube-engine",
          "partial": "Copy Data Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:spuCopyDataVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "spuSharedParams",
          "package": "lambdacube-engine",
          "signature": "GpuSharedParameters",
          "source": "src/Graphics-LambdaCube-GpuProgramParams.html#GpuSharedParametersUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramParams",
          "module": "Graphics.LambdaCube.GpuProgramParams",
          "name": "spuSharedParams",
          "package": "lambdacube-engine",
          "partial": "Shared Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramParams.html#v:spuSharedParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "GpuProgramUsage",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramUsage.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramUsage",
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "GpuProgramUsage",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Usage",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramUsage.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "GpuProgramUsage",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-GpuProgramUsage.html#GpuProgramUsage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramUsage",
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "GpuProgramUsage",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Usage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramUsage.html#t:GpuProgramUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "GpuProgramUsage",
          "package": "lambdacube-engine",
          "signature": "GpuProgramUsage",
          "source": "src/Graphics-LambdaCube-GpuProgramUsage.html#GpuProgramUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramUsage",
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "GpuProgramUsage",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramUsage.html#v:GpuProgramUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "gpuProgramName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-GpuProgramUsage.html#GpuProgramUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube GpuProgramUsage",
          "module": "Graphics.LambdaCube.GpuProgramUsage",
          "name": "gpuProgramName",
          "package": "lambdacube-engine",
          "partial": "Program Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-GpuProgramUsage.html#v:gpuProgramName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HardwareBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HardwareBuffer",
          "package": "lambdacube-engine",
          "partial": "Hardware Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HardwareBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#HardwareBuffer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HardwareBuffer",
          "package": "lambdacube-engine",
          "partial": "Hardware Buffer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#t:HardwareBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocking options\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "LockOptions",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#LockOptions",
          "type": "data"
        },
        "index": {
          "description": "Locking options",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "LockOptions",
          "package": "lambdacube-engine",
          "partial": "Lock Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#t:LockOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "Usage",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "Usage",
          "package": "lambdacube-engine",
          "partial": "Usage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#t:Usage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscards the entire buffer while locking; this allows\n optimisation to be performed because synchronisation issues are\n relaxed. Only allowed on buffers created with the HBU_DYNAMIC\n flag.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_DISCARD",
          "package": "lambdacube-engine",
          "signature": "HBL_DISCARD",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#LockOptions",
          "type": "function"
        },
        "index": {
          "description": "Discards the entire buffer while locking this allows optimisation to be performed because synchronisation issues are relaxed Only allowed on buffers created with the HBU DYNAMIC flag",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_DISCARD",
          "package": "lambdacube-engine",
          "partial": "HBL DISCARD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBL_DISCARD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal mode, ie allows read/write and contents are preserved.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_NORMAL",
          "package": "lambdacube-engine",
          "signature": "HBL_NORMAL",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#LockOptions",
          "type": "function"
        },
        "index": {
          "description": "Normal mode ie allows read write and contents are preserved",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_NORMAL",
          "package": "lambdacube-engine",
          "partial": "HBL NORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBL_NORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs HBL_NORMAL, except the application guarantees not to\n overwrite any region of the buffer which has already been used\n in this frame, can allow some optimisation on some APIs.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_NO_OVERWRITE",
          "package": "lambdacube-engine",
          "signature": "HBL_NO_OVERWRITE",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#LockOptions",
          "type": "function"
        },
        "index": {
          "description": "As HBL NORMAL except the application guarantees not to overwrite any region of the buffer which has already been used in this frame can allow some optimisation on some APIs",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_NO_OVERWRITE",
          "package": "lambdacube-engine",
          "partial": "HBL NO OVERWRITE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBL_NO_OVERWRITE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLock the buffer for reading only. Not allowed in buffers\n which are created with HBU_WRITE_ONLY.  Mandatory on static\n buffers, i.e. those created without the HBU_DYNAMIC flag.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_READ_ONLY",
          "package": "lambdacube-engine",
          "signature": "HBL_READ_ONLY",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#LockOptions",
          "type": "function"
        },
        "index": {
          "description": "Lock the buffer for reading only Not allowed in buffers which are created with HBU WRITE ONLY Mandatory on static buffers i.e those created without the HBU DYNAMIC flag",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBL_READ_ONLY",
          "package": "lambdacube-engine",
          "partial": "HBL READ ONLY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBL_READ_ONLY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates that the application will be refilling the contents\n of the buffer regularly (not just updating, but generating the\n contents from scratch), and therefore does not mind if the\n contents of the buffer are lost somehow and need to be\n recreated. This allows and additional level of optimisation on\n the buffer.  This option only really makes sense when combined\n with HBU_DYNAMIC_WRITE_ONLY.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DISCARDABLE",
          "package": "lambdacube-engine",
          "signature": "HBU_DISCARDABLE",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "function"
        },
        "index": {
          "description": "Indicates that the application will be refilling the contents of the buffer regularly not just updating but generating the contents from scratch and therefore does not mind if the contents of the buffer are lost somehow and need to be recreated This allows and additional level of optimisation on the buffer This option only really makes sense when combined with HBU DYNAMIC WRITE ONLY",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DISCARDABLE",
          "package": "lambdacube-engine",
          "partial": "HBU DISCARDABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBU_DISCARDABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates the application would like to modify this buffer\n with the CPU fairly often.  Buffers created with this flag will\n typically end up in AGP memory rather than video memory.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DYNAMIC",
          "package": "lambdacube-engine",
          "signature": "HBU_DYNAMIC",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "function"
        },
        "index": {
          "description": "Indicates the application would like to modify this buffer with the CPU fairly often Buffers created with this flag will typically end up in AGP memory rather than video memory",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DYNAMIC",
          "package": "lambdacube-engine",
          "partial": "HBU DYNAMIC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBU_DYNAMIC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombination of HBU_DYNAMIC and HBU_WRITE_ONLY. If you use\n this, strongly consider using\n HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE instead if you update the\n entire contents of the buffer very regularly.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DYNAMIC_WRITE_ONLY",
          "package": "lambdacube-engine",
          "signature": "HBU_DYNAMIC_WRITE_ONLY",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "function"
        },
        "index": {
          "description": "Combination of HBU DYNAMIC and HBU WRITE ONLY If you use this strongly consider using HBU DYNAMIC WRITE ONLY DISCARDABLE instead if you update the entire contents of the buffer very regularly",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DYNAMIC_WRITE_ONLY",
          "package": "lambdacube-engine",
          "partial": "HBU DYNAMIC WRITE ONLY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBU_DYNAMIC_WRITE_ONLY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombination of HBU_DYNAMIC, HBU_WRITE_ONLY and\n HBU_DISCARDABLE\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE",
          "package": "lambdacube-engine",
          "signature": "HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "function"
        },
        "index": {
          "description": "Combination of HBU DYNAMIC HBU WRITE ONLY and HBU DISCARDABLE",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE",
          "package": "lambdacube-engine",
          "partial": "HBU DYNAMIC WRITE ONLY DISCARDABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatic buffer which the application rarely modifies once\n created. Modifying the contents of this buffer will involve a\n performance hit.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_STATIC",
          "package": "lambdacube-engine",
          "signature": "HBU_STATIC",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "function"
        },
        "index": {
          "description": "Static buffer which the application rarely modifies once created Modifying the contents of this buffer will involve performance hit",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_STATIC",
          "package": "lambdacube-engine",
          "partial": "HBU STATIC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBU_STATIC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombination of HBU_STATIC and HBU_WRITE_ONLY\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_STATIC_WRITE_ONLY",
          "package": "lambdacube-engine",
          "signature": "HBU_STATIC_WRITE_ONLY",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "function"
        },
        "index": {
          "description": "Combination of HBU STATIC and HBU WRITE ONLY",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_STATIC_WRITE_ONLY",
          "package": "lambdacube-engine",
          "partial": "HBU STATIC WRITE ONLY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBU_STATIC_WRITE_ONLY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates the application will never read the contents of the\n buffer back, it will only ever write data. Locking a buffer\n with this flag will ALWAYS return a pointer to new, blank\n memory rather than the memory associated with the contents of\n the buffer; this avoids DMA stalls because you can write to a\n new memory area while the previous one is being used.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_WRITE_ONLY",
          "package": "lambdacube-engine",
          "signature": "HBU_WRITE_ONLY",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#Usage",
          "type": "function"
        },
        "index": {
          "description": "Indicates the application will never read the contents of the buffer back it will only ever write data Locking buffer with this flag will ALWAYS return pointer to new blank memory rather than the memory associated with the contents of the buffer this avoids DMA stalls because you can write to new memory area while the previous one is being used",
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "HBU_WRITE_ONLY",
          "package": "lambdacube-engine",
          "partial": "HBU WRITE ONLY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:HBU_WRITE_ONLY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "getSizeInBytes",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#getSizeInBytes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "getSizeInBytes",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Size In Bytes",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:getSizeInBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "getUsage",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Usage",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#getUsage",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "getUsage",
          "normalized": "a-\u003eUsage",
          "package": "lambdacube-engine",
          "partial": "Usage",
          "signature": "a-\u003eUsage",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:getUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "hasShadowBuffer",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Bool",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#hasShadowBuffer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "hasShadowBuffer",
          "normalized": "a-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Shadow Buffer",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:hasShadowBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "isLocked",
          "package": "lambdacube-engine",
          "signature": "a -\u003e IO Bool",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#isLocked",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "isLocked",
          "normalized": "a-\u003eIO Bool",
          "package": "lambdacube-engine",
          "partial": "Locked",
          "signature": "a-\u003eIO Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:isLocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "isSystemMemory",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Bool",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#isSystemMemory",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "isSystemMemory",
          "normalized": "a-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "System Memory",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:isSystemMemory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "lock",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int -\u003e Int -\u003e LockOptions -\u003e IO (Ptr Word8)",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#lock",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "lock",
          "normalized": "a-\u003eInt-\u003eInt-\u003eLockOptions-\u003eIO(Ptr Word)",
          "package": "lambdacube-engine",
          "signature": "a-\u003eInt-\u003eInt-\u003eLockOptions-\u003eIO(Ptr Word)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:lock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "unlock",
          "package": "lambdacube-engine",
          "signature": "a -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-HardwareBuffer.html#unlock",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareBuffer",
          "module": "Graphics.LambdaCube.HardwareBuffer",
          "name": "unlock",
          "normalized": "a-\u003eIO()",
          "package": "lambdacube-engine",
          "signature": "a-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareBuffer.html#v:unlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "HardwareIndexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "HardwareIndexBuffer",
          "package": "lambdacube-engine",
          "partial": "Hardware Index Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "HardwareIndexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html#HardwareIndexBuffer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "HardwareIndexBuffer",
          "package": "lambdacube-engine",
          "partial": "Hardware Index Buffer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#t:HardwareIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "IndexType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html#IndexType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "IndexType",
          "package": "lambdacube-engine",
          "partial": "Index Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#t:IndexType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "IT_16BIT",
          "package": "lambdacube-engine",
          "signature": "IT_16BIT",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html#IndexType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "IT_16BIT",
          "package": "lambdacube-engine",
          "partial": "IT BIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#v:IT_16BIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "IT_32BIT",
          "package": "lambdacube-engine",
          "signature": "IT_32BIT",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html#IndexType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "IT_32BIT",
          "package": "lambdacube-engine",
          "partial": "IT BIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#v:IT_32BIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "getIndexSize",
          "package": "lambdacube-engine",
          "signature": "getIndexSize",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html#getIndexSize",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "getIndexSize",
          "package": "lambdacube-engine",
          "partial": "Index Size",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#v:getIndexSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "getIndexType",
          "package": "lambdacube-engine",
          "signature": "getIndexType",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html#getIndexType",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "getIndexType",
          "package": "lambdacube-engine",
          "partial": "Index Type",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#v:getIndexType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "getNumIndexes",
          "package": "lambdacube-engine",
          "signature": "getNumIndexes",
          "source": "src/Graphics-LambdaCube-HardwareIndexBuffer.html#getNumIndexes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareIndexBuffer",
          "module": "Graphics.LambdaCube.HardwareIndexBuffer",
          "name": "getNumIndexes",
          "package": "lambdacube-engine",
          "partial": "Num Indexes",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareIndexBuffer.html#v:getNumIndexes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "HardwareOcclusionQuery",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareOcclusionQuery.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareOcclusionQuery",
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "HardwareOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "Hardware Occlusion Query",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareOcclusionQuery.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "HardwareOcclusionQuery",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareOcclusionQuery.html#HardwareOcclusionQuery",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareOcclusionQuery",
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "HardwareOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "Hardware Occlusion Query",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareOcclusionQuery.html#t:HardwareOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "beginOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "beginOcclusionQuery",
          "source": "src/Graphics-LambdaCube-HardwareOcclusionQuery.html#beginOcclusionQuery",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareOcclusionQuery",
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "beginOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "Occlusion Query",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareOcclusionQuery.html#v:beginOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "endOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "endOcclusionQuery",
          "source": "src/Graphics-LambdaCube-HardwareOcclusionQuery.html#endOcclusionQuery",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareOcclusionQuery",
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "endOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "Occlusion Query",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareOcclusionQuery.html#v:endOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "isStillOutstanding",
          "package": "lambdacube-engine",
          "signature": "isStillOutstanding",
          "source": "src/Graphics-LambdaCube-HardwareOcclusionQuery.html#isStillOutstanding",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareOcclusionQuery",
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "isStillOutstanding",
          "package": "lambdacube-engine",
          "partial": "Still Outstanding",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareOcclusionQuery.html#v:isStillOutstanding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "pullOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "pullOcclusionQuery",
          "source": "src/Graphics-LambdaCube-HardwareOcclusionQuery.html#pullOcclusionQuery",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareOcclusionQuery",
          "module": "Graphics.LambdaCube.HardwareOcclusionQuery",
          "name": "pullOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "Occlusion Query",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareOcclusionQuery.html#v:pullOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "HardwareVertexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "HardwareVertexBuffer",
          "package": "lambdacube-engine",
          "partial": "Hardware Vertex Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "HardwareVertexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#HardwareVertexBuffer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "HardwareVertexBuffer",
          "package": "lambdacube-engine",
          "partial": "Hardware Vertex Buffer",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#t:HardwareVertexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexBufferBinding",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexBufferBinding",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexBufferBinding",
          "package": "lambdacube-engine",
          "partial": "Vertex Buffer Binding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#t:VertexBufferBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexDeclaration",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexDeclaration",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexDeclaration",
          "package": "lambdacube-engine",
          "partial": "Vertex Declaration",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#t:VertexDeclaration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElement",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElement",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElement",
          "package": "lambdacube-engine",
          "partial": "Vertex Element",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#t:VertexElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertex element semantics, used to identify the meaning of vertex buffer contents\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElementSemantic",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "data"
        },
        "index": {
          "description": "Vertex element semantics used to identify the meaning of vertex buffer contents",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElementSemantic",
          "package": "lambdacube-engine",
          "partial": "Vertex Element Semantic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#t:VertexElementSemantic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertex element type, used to identify the base types of the vertex contents\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElementType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "data"
        },
        "index": {
          "description": "Vertex element type used to identify the base types of the vertex contents",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElementType",
          "package": "lambdacube-engine",
          "partial": "Vertex Element Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#t:VertexElementType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinormal (Y axis if normal is Z)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_BINORMAL",
          "package": "lambdacube-engine",
          "signature": "VES_BINORMAL",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Binormal axis if normal is",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_BINORMAL",
          "package": "lambdacube-engine",
          "partial": "VES BINORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_BINORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlending indices\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_BLEND_INDICES",
          "package": "lambdacube-engine",
          "signature": "VES_BLEND_INDICES",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Blending indices",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_BLEND_INDICES",
          "package": "lambdacube-engine",
          "partial": "VES BLEND INDICES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_BLEND_INDICES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlending weights\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_BLEND_WEIGHTS",
          "package": "lambdacube-engine",
          "signature": "VES_BLEND_WEIGHTS",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Blending weights",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_BLEND_WEIGHTS",
          "package": "lambdacube-engine",
          "partial": "VES BLEND WEIGHTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_BLEND_WEIGHTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiffuse colours\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_DIFFUSE",
          "package": "lambdacube-engine",
          "signature": "VES_DIFFUSE",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Diffuse colours",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_DIFFUSE",
          "package": "lambdacube-engine",
          "partial": "VES DIFFUSE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_DIFFUSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal, 3 reals per vertex\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_NORMAL",
          "package": "lambdacube-engine",
          "signature": "VES_NORMAL",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Normal reals per vertex",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_NORMAL",
          "package": "lambdacube-engine",
          "partial": "VES NORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_NORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePosition, 3 reals per vertex\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_POSITION",
          "package": "lambdacube-engine",
          "signature": "VES_POSITION",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Position reals per vertex",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_POSITION",
          "package": "lambdacube-engine",
          "partial": "VES POSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_POSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecular colours\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_SPECULAR",
          "package": "lambdacube-engine",
          "signature": "VES_SPECULAR",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Specular colours",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_SPECULAR",
          "package": "lambdacube-engine",
          "partial": "VES SPECULAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_SPECULAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTangent (X axis if normal is Z)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_TANGENT",
          "package": "lambdacube-engine",
          "signature": "VES_TANGENT",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Tangent axis if normal is",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_TANGENT",
          "package": "lambdacube-engine",
          "partial": "VES TANGENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_TANGENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture coordinates\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_TEXTURE_COORDINATES",
          "package": "lambdacube-engine",
          "signature": "VES_TEXTURE_COORDINATES",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementSemantic",
          "type": "function"
        },
        "index": {
          "description": "Texture coordinates",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VES_TEXTURE_COORDINATES",
          "package": "lambdacube-engine",
          "partial": "VES TEXTURE COORDINATES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VES_TEXTURE_COORDINATES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGL style compact colour\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_COLOUR_ABGR",
          "package": "lambdacube-engine",
          "signature": "VET_COLOUR_ABGR",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "description": "GL style compact colour",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_COLOUR_ABGR",
          "package": "lambdacube-engine",
          "partial": "VET COLOUR ABGR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_COLOUR_ABGR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eD3D style compact colour\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_COLOUR_ARGB",
          "package": "lambdacube-engine",
          "signature": "VET_COLOUR_ARGB",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "description": "D3D style compact colour",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_COLOUR_ARGB",
          "package": "lambdacube-engine",
          "partial": "VET COLOUR ARGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_COLOUR_ARGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT1",
          "package": "lambdacube-engine",
          "signature": "VET_FLOAT1",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT1",
          "package": "lambdacube-engine",
          "partial": "VET FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_FLOAT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT2",
          "package": "lambdacube-engine",
          "signature": "VET_FLOAT2",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT2",
          "package": "lambdacube-engine",
          "partial": "VET FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_FLOAT2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT3",
          "package": "lambdacube-engine",
          "signature": "VET_FLOAT3",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT3",
          "package": "lambdacube-engine",
          "partial": "VET FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_FLOAT3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT4",
          "package": "lambdacube-engine",
          "signature": "VET_FLOAT4",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_FLOAT4",
          "package": "lambdacube-engine",
          "partial": "VET FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_FLOAT4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT1",
          "package": "lambdacube-engine",
          "signature": "VET_SHORT1",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT1",
          "package": "lambdacube-engine",
          "partial": "VET SHORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_SHORT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT2",
          "package": "lambdacube-engine",
          "signature": "VET_SHORT2",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT2",
          "package": "lambdacube-engine",
          "partial": "VET SHORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_SHORT2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT3",
          "package": "lambdacube-engine",
          "signature": "VET_SHORT3",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT3",
          "package": "lambdacube-engine",
          "partial": "VET SHORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_SHORT3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT4",
          "package": "lambdacube-engine",
          "signature": "VET_SHORT4",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_SHORT4",
          "package": "lambdacube-engine",
          "partial": "VET SHORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_SHORT4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_UBYTE4",
          "package": "lambdacube-engine",
          "signature": "VET_UBYTE4",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElementType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VET_UBYTE4",
          "package": "lambdacube-engine",
          "partial": "VET UBYTE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VET_UBYTE4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexBufferBinding",
          "package": "lambdacube-engine",
          "signature": "VertexBufferBinding",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexBufferBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexBufferBinding",
          "package": "lambdacube-engine",
          "partial": "Vertex Buffer Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VertexBufferBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexDeclaration",
          "package": "lambdacube-engine",
          "signature": "VertexDeclaration",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexDeclaration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexDeclaration",
          "package": "lambdacube-engine",
          "partial": "Vertex Declaration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VertexDeclaration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElement",
          "package": "lambdacube-engine",
          "signature": "VertexElement",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "VertexElement",
          "package": "lambdacube-engine",
          "partial": "Vertex Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:VertexElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple converter function which will convert a type into its\n single-value equivalent to make switches on type easier.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getBaseType",
          "package": "lambdacube-engine",
          "signature": "VertexElementType -\u003e VertexElementType",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#getBaseType",
          "type": "function"
        },
        "index": {
          "description": "Simple converter function which will convert type into its single-value equivalent to make switches on type easier",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getBaseType",
          "normalized": "VertexElementType-\u003eVertexElementType",
          "package": "lambdacube-engine",
          "partial": "Base Type",
          "signature": "VertexElementType-\u003eVertexElementType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:getBaseType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getNumVertices",
          "package": "lambdacube-engine",
          "signature": "getNumVertices",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#getNumVertices",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getNumVertices",
          "package": "lambdacube-engine",
          "partial": "Num Vertices",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:getNumVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility method which returns the count of values in a given type\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getTypeCount",
          "package": "lambdacube-engine",
          "signature": "VertexElementType -\u003e Int",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#getTypeCount",
          "type": "function"
        },
        "index": {
          "description": "Utility method which returns the count of values in given type",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getTypeCount",
          "normalized": "VertexElementType-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Type Count",
          "signature": "VertexElementType-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:getTypeCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility method for helping to calculate offsets\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getTypeSize",
          "package": "lambdacube-engine",
          "signature": "VertexElementType -\u003e Int",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#getTypeSize",
          "type": "function"
        },
        "index": {
          "description": "Utility method for helping to calculate offsets",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getTypeSize",
          "normalized": "VertexElementType-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Type Size",
          "signature": "VertexElementType-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:getTypeSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getVertexSize",
          "package": "lambdacube-engine",
          "signature": "getVertexSize",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#getVertexSize",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "getVertexSize",
          "package": "lambdacube-engine",
          "partial": "Vertex Size",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:getVertexSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple converter function which will turn a single-value type into a multi-value type based on a parameter.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "multiplyTypeCount",
          "package": "lambdacube-engine",
          "signature": "VertexElementType -\u003e Int -\u003e VertexElementType",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#multiplyTypeCount",
          "type": "function"
        },
        "index": {
          "description": "Simple converter function which will turn single-value type into multi-value type based on parameter",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "multiplyTypeCount",
          "normalized": "VertexElementType-\u003eInt-\u003eVertexElementType",
          "package": "lambdacube-engine",
          "partial": "Type Count",
          "signature": "VertexElementType-\u003eInt-\u003eVertexElementType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:multiplyTypeCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "vbbBindingMap",
          "package": "lambdacube-engine",
          "signature": "IntMap vb",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexBufferBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "vbbBindingMap",
          "package": "lambdacube-engine",
          "partial": "Binding Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:vbbBindingMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of vertex elements that makes up this declaration\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "vdElementList",
          "package": "lambdacube-engine",
          "signature": "[VertexElement]",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexDeclaration",
          "type": "function"
        },
        "index": {
          "description": "The list of vertex elements that makes up this declaration",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "vdElementList",
          "normalized": "[VertexElement]",
          "package": "lambdacube-engine",
          "partial": "Element List",
          "signature": "[VertexElement]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:vdElementList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndex of the item, only applicable for some elements like texture coords\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElement",
          "type": "function"
        },
        "index": {
          "description": "Index of the item only applicable for some elements like texture coords",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veIndex",
          "package": "lambdacube-engine",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:veIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe offset in the buffer that this element starts at\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veOffset",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElement",
          "type": "function"
        },
        "index": {
          "description": "The offset in the buffer that this element starts at",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veOffset",
          "package": "lambdacube-engine",
          "partial": "Offset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:veOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe meaning of the element\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veSemantic",
          "package": "lambdacube-engine",
          "signature": "VertexElementSemantic",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElement",
          "type": "function"
        },
        "index": {
          "description": "The meaning of the element",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veSemantic",
          "package": "lambdacube-engine",
          "partial": "Semantic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:veSemantic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe source vertex buffer, as bound to an index using VertexBufferBinding\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veSource",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElement",
          "type": "function"
        },
        "index": {
          "description": "The source vertex buffer as bound to an index using VertexBufferBinding",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veSource",
          "package": "lambdacube-engine",
          "partial": "Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:veSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of element\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veType",
          "package": "lambdacube-engine",
          "signature": "VertexElementType",
          "source": "src/Graphics-LambdaCube-HardwareVertexBuffer.html#VertexElement",
          "type": "function"
        },
        "index": {
          "description": "The type of element",
          "hierarchy": "Graphics LambdaCube HardwareVertexBuffer",
          "module": "Graphics.LambdaCube.HardwareVertexBuffer",
          "name": "veType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-HardwareVertexBuffer.html#v:veType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "Image",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Image.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "Image",
          "package": "lambdacube-engine",
          "partial": "Image",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHas information about the size and the pixel format of the image.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Image",
          "name": "Image",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "data"
        },
        "index": {
          "description": "Has information about the size and the pixel format of the image",
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "Image",
          "package": "lambdacube-engine",
          "partial": "Image",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#t:Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImage loader function\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Image",
          "name": "ImageLoader",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Image.html#ImageLoader",
          "type": "type"
        },
        "index": {
          "description": "Image loader function",
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "ImageLoader",
          "package": "lambdacube-engine",
          "partial": "Image Loader",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#t:ImageLoader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "Image",
          "package": "lambdacube-engine",
          "signature": "Image",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "Image",
          "package": "lambdacube-engine",
          "partial": "Image",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:Image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImage can be empty\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Image",
          "name": "imData",
          "package": "lambdacube-engine",
          "signature": "ByteString",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "description": "Image can be empty",
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imData",
          "package": "lambdacube-engine",
          "partial": "Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "imDataPtr",
          "package": "lambdacube-engine",
          "signature": "Image -\u003e Ptr Word8",
          "source": "src/Graphics-LambdaCube-Image.html#imDataPtr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imDataPtr",
          "normalized": "Image-\u003ePtr Word",
          "package": "lambdacube-engine",
          "partial": "Data Ptr",
          "signature": "Image-\u003ePtr Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imDataPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "imDepth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imDepth",
          "package": "lambdacube-engine",
          "partial": "Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "imFormat",
          "package": "lambdacube-engine",
          "signature": "PixelFormat",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imFormat",
          "package": "lambdacube-engine",
          "partial": "Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "imHeight",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imHeight",
          "package": "lambdacube-engine",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "imName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "imNumMipmaps",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imNumMipmaps",
          "package": "lambdacube-engine",
          "partial": "Num Mipmaps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imNumMipmaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Image",
          "name": "imWidth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Image.html#Image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Image",
          "module": "Graphics.LambdaCube.Image",
          "name": "imWidth",
          "package": "lambdacube-engine",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Image.html#v:imWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Light",
          "name": "Light",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Light.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "Light",
          "package": "lambdacube-engine",
          "partial": "Light",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight source description.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Light",
          "name": "Light",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "data"
        },
        "index": {
          "description": "Light source description",
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "Light",
          "package": "lambdacube-engine",
          "partial": "Light",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#t:Light"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossible types of light sources.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Light",
          "name": "LightTypes",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Light.html#LightTypes",
          "type": "data"
        },
        "index": {
          "description": "Possible types of light sources",
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "LightTypes",
          "package": "lambdacube-engine",
          "partial": "Light Types",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#t:LightTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirectional lights simulate parallel light\n beams from a distant source, hence have\n direction but no position.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "LT_DIRECTIONAL",
          "package": "lambdacube-engine",
          "signature": "LT_DIRECTIONAL",
          "source": "src/Graphics-LambdaCube-Light.html#LightTypes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:LT_DIRECTIONAL\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:LT_DIRECTIONAL\"]"
        },
        "index": {
          "description": "Directional lights simulate parallel light beams from distant source hence have direction but no position",
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "LT_DIRECTIONAL",
          "package": "lambdacube-engine",
          "partial": "LT DIRECTIONAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:LT_DIRECTIONAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoint light sources give off light equally\n in all directions, so they require only\n position but no direction.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "LT_POINT",
          "package": "lambdacube-engine",
          "signature": "LT_POINT",
          "source": "src/Graphics-LambdaCube-Light.html#LightTypes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:LT_POINT\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:LT_POINT\"]"
        },
        "index": {
          "description": "Point light sources give off light equally in all directions so they require only position but no direction",
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "LT_POINT",
          "package": "lambdacube-engine",
          "partial": "LT POINT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:LT_POINT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpotlights simulate a cone of light from a\n source so require position and direction, plus\n extra values for falloff.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "LT_SPOTLIGHT",
          "package": "lambdacube-engine",
          "signature": "LT_SPOTLIGHT",
          "source": "src/Graphics-LambdaCube-Light.html#LightTypes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:LT_SPOTLIGHT\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:LT_SPOTLIGHT\"]"
        },
        "index": {
          "description": "Spotlights simulate cone of light from source so require position and direction plus extra values for falloff",
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "LT_SPOTLIGHT",
          "package": "lambdacube-engine",
          "partial": "LT SPOTLIGHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:LT_SPOTLIGHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "Light",
          "package": "lambdacube-engine",
          "signature": "Light",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:Light\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:Light\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "Light",
          "package": "lambdacube-engine",
          "partial": "Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:Light"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgAttenuationConst",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgAttenuationConst\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgAttenuationConst\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgAttenuationConst",
          "package": "lambdacube-engine",
          "partial": "Attenuation Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgAttenuationConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgAttenuationLinear",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgAttenuationLinear\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgAttenuationLinear\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgAttenuationLinear",
          "package": "lambdacube-engine",
          "partial": "Attenuation Linear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgAttenuationLinear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgAttenuationQuad",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgAttenuationQuad\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgAttenuationQuad\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgAttenuationQuad",
          "package": "lambdacube-engine",
          "partial": "Attenuation Quad",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgAttenuationQuad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgDiffuse",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgDiffuse\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgDiffuse\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgDiffuse",
          "package": "lambdacube-engine",
          "partial": "Diffuse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgDiffuse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgDirection",
          "package": "lambdacube-engine",
          "signature": "Vec3",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgDirection\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgDirection\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgDirection",
          "package": "lambdacube-engine",
          "partial": "Direction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgRange",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgRange\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgRange\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgRange",
          "package": "lambdacube-engine",
          "partial": "Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgSpecular",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgSpecular\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgSpecular\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgSpecular",
          "package": "lambdacube-engine",
          "partial": "Specular",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgSpecular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgSpotFalloff",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgSpotFalloff\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgSpotFalloff\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgSpotFalloff",
          "package": "lambdacube-engine",
          "partial": "Spot Falloff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgSpotFalloff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgSpotOuter",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgSpotOuter\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgSpotOuter\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgSpotOuter",
          "package": "lambdacube-engine",
          "partial": "Spot Outer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgSpotOuter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.Light\",\"Graphics.LambdaCube\"]",
          "name": "lgType",
          "package": "lambdacube-engine",
          "signature": "LightTypes",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgType\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:lgType\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Light",
          "module": "Graphics.LambdaCube.Light",
          "name": "lgType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Light.html#v:lgType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.CompositorScript",
          "name": "CompositorScript",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-CompositorScript.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader CompositorScript",
          "module": "Graphics.LambdaCube.Loader.CompositorScript",
          "name": "CompositorScript",
          "package": "lambdacube-engine",
          "partial": "Compositor Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-CompositorScript.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.CompositorScript",
          "name": "parseCompositor",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e IO (Maybe [Compositor t lp])",
          "source": "src/Graphics-LambdaCube-Loader-CompositorScript.html#parseCompositor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader CompositorScript",
          "module": "Graphics.LambdaCube.Loader.CompositorScript",
          "name": "parseCompositor",
          "normalized": "String-\u003eString-\u003eIO(Maybe[Compositor a b])",
          "package": "lambdacube-engine",
          "partial": "Compositor",
          "signature": "String-\u003eString-\u003eIO(Maybe[Compositor t lp])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-CompositorScript.html#v:parseCompositor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.Generated.CompositorScriptScanner",
          "name": "CompositorScriptScanner",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-Generated-CompositorScriptScanner.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader Generated CompositorScriptScanner",
          "module": "Graphics.LambdaCube.Loader.Generated.CompositorScriptScanner",
          "name": "CompositorScriptScanner",
          "package": "lambdacube-engine",
          "partial": "Compositor Script Scanner",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-Generated-CompositorScriptScanner.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.Generated.CompositorScriptScanner",
          "name": "tokenize",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e [Token]",
          "source": "src/Graphics-LambdaCube-Loader-Generated-CompositorScriptScanner.html#tokenize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader Generated CompositorScriptScanner",
          "module": "Graphics.LambdaCube.Loader.Generated.CompositorScriptScanner",
          "name": "tokenize",
          "normalized": "String-\u003eString-\u003e[Token]",
          "package": "lambdacube-engine",
          "signature": "String-\u003eString-\u003e[Token]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-Generated-CompositorScriptScanner.html#v:tokenize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.Generated.MaterialScriptScanner",
          "name": "MaterialScriptScanner",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-Generated-MaterialScriptScanner.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader Generated MaterialScriptScanner",
          "module": "Graphics.LambdaCube.Loader.Generated.MaterialScriptScanner",
          "name": "MaterialScriptScanner",
          "package": "lambdacube-engine",
          "partial": "Material Script Scanner",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-Generated-MaterialScriptScanner.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.Generated.MaterialScriptScanner",
          "name": "tokenize",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e [Token]",
          "source": "src/Graphics-LambdaCube-Loader-Generated-MaterialScriptScanner.html#tokenize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader Generated MaterialScriptScanner",
          "module": "Graphics.LambdaCube.Loader.Generated.MaterialScriptScanner",
          "name": "tokenize",
          "normalized": "String-\u003eString-\u003e[Token]",
          "package": "lambdacube-engine",
          "signature": "String-\u003eString-\u003e[Token]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-Generated-MaterialScriptScanner.html#v:tokenize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.Generated.ResourceScriptScanner",
          "name": "ResourceScriptScanner",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-Generated-ResourceScriptScanner.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader Generated ResourceScriptScanner",
          "module": "Graphics.LambdaCube.Loader.Generated.ResourceScriptScanner",
          "name": "ResourceScriptScanner",
          "package": "lambdacube-engine",
          "partial": "Resource Script Scanner",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-Generated-ResourceScriptScanner.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.Generated.ResourceScriptScanner",
          "name": "tokenize",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e [Token]",
          "source": "src/Graphics-LambdaCube-Loader-Generated-ResourceScriptScanner.html#tokenize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader Generated ResourceScriptScanner",
          "module": "Graphics.LambdaCube.Loader.Generated.ResourceScriptScanner",
          "name": "tokenize",
          "normalized": "String-\u003eString-\u003e[Token]",
          "package": "lambdacube-engine",
          "signature": "String-\u003eString-\u003e[Token]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-Generated-ResourceScriptScanner.html#v:tokenize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MaterialScript",
          "name": "MaterialScript",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-MaterialScript.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MaterialScript",
          "module": "Graphics.LambdaCube.Loader.MaterialScript",
          "name": "MaterialScript",
          "package": "lambdacube-engine",
          "partial": "Material Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MaterialScript.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MaterialScript",
          "name": "parseMaterial",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e IO (Maybe ([Material t lp], [GpuProgramDescriptor p], [GpuProgramDescriptor p]))",
          "source": "src/Graphics-LambdaCube-Loader-MaterialScript.html#parseMaterial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MaterialScript",
          "module": "Graphics.LambdaCube.Loader.MaterialScript",
          "name": "parseMaterial",
          "normalized": "String-\u003eString-\u003eIO(Maybe([Material a b],[GpuProgramDescriptor c],[GpuProgramDescriptor c]))",
          "package": "lambdacube-engine",
          "partial": "Material",
          "signature": "String-\u003eString-\u003eIO(Maybe([Material t lp],[GpuProgramDescriptor p],[GpuProgramDescriptor p]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MaterialScript.html#v:parseMaterial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "MeshXML",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "MeshXML",
          "package": "lambdacube-engine",
          "partial": "Mesh XML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "loadMesh",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FilePath -\u003e IO (Mesh vb ib)",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#loadMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "loadMesh",
          "normalized": "a-\u003eFilePath-\u003eIO(Mesh b c)",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "signature": "rs-\u003eFilePath-\u003eIO(Mesh vb ib)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:loadMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "parseMesh",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e String -\u003e IO (Mesh vb ib)",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#parseMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "parseMesh",
          "normalized": "a-\u003eString-\u003eIO(Mesh b c)",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "signature": "rs-\u003eString-\u003eIO(Mesh vb ib)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:parseMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readBoneAssignments",
          "package": "lambdacube-engine",
          "signature": "Element -\u003e ([Int], [FloatType])",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readBoneAssignments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readBoneAssignments",
          "normalized": "Element-\u003e([Int],[FloatType])",
          "package": "lambdacube-engine",
          "partial": "Bone Assignments",
          "signature": "Element-\u003e([Int],[FloatType])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readBoneAssignments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readBool",
          "package": "lambdacube-engine",
          "signature": "String -\u003e Bool -\u003e Element -\u003e Bool",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readBool",
          "normalized": "String-\u003eBool-\u003eElement-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Bool",
          "signature": "String-\u003eBool-\u003eElement-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readDecl",
          "package": "lambdacube-engine",
          "signature": "(Element, Int) -\u003e [VertexElement]",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readDecl",
          "normalized": "(Element,Int)-\u003e[VertexElement]",
          "package": "lambdacube-engine",
          "partial": "Decl",
          "signature": "(Element,Int)-\u003e[VertexElement]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readFloatType",
          "package": "lambdacube-engine",
          "signature": "String -\u003e FloatType -\u003e Element -\u003e FloatType",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readFloatType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readFloatType",
          "normalized": "String-\u003eFloatType-\u003eElement-\u003eFloatType",
          "package": "lambdacube-engine",
          "partial": "Float Type",
          "signature": "String-\u003eFloatType-\u003eElement-\u003eFloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readFloatType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readGeometry",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Element -\u003e IO (VertexData vb)",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readGeometry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readGeometry",
          "normalized": "a-\u003eElement-\u003eIO(VertexData b)",
          "package": "lambdacube-engine",
          "partial": "Geometry",
          "signature": "rs-\u003eElement-\u003eIO(VertexData vb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readGeometry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readInt",
          "package": "lambdacube-engine",
          "signature": "String -\u003e Int -\u003e Element -\u003e Int",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readInt",
          "normalized": "String-\u003eInt-\u003eElement-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Int",
          "signature": "String-\u003eInt-\u003eElement-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readMesh",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Element -\u003e IO (Mesh vb ib)",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readMesh",
          "normalized": "a-\u003eElement-\u003eIO(Mesh b c)",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "signature": "rs-\u003eElement-\u003eIO(Mesh vb ib)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readStr",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e Element -\u003e String",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readStr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readStr",
          "normalized": "String-\u003eString-\u003eElement-\u003eString",
          "package": "lambdacube-engine",
          "partial": "Str",
          "signature": "String-\u003eString-\u003eElement-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readSubMesh",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Element -\u003e IO (SubMesh vb ib)",
          "source": "src/Graphics-LambdaCube-Loader-MeshXML.html#readSubMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader MeshXML",
          "module": "Graphics.LambdaCube.Loader.MeshXML",
          "name": "readSubMesh",
          "normalized": "a-\u003eElement-\u003eIO(SubMesh b c)",
          "package": "lambdacube-engine",
          "partial": "Sub Mesh",
          "signature": "rs-\u003eElement-\u003eIO(SubMesh vb ib)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-MeshXML.html#v:readSubMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "ParserUtil",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "ParserUtil",
          "package": "lambdacube-engine",
          "partial": "Parser Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "(\u003c$=)",
          "package": "lambdacube-engine",
          "signature": "b -\u003e String -\u003e p b",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#%3C%24%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "(\u003c$=) \u003c$=",
          "normalized": "a-\u003eString-\u003eb a",
          "package": "lambdacube-engine",
          "signature": "b-\u003eString-\u003ep b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:-60--36--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "(\u003c*=)",
          "package": "lambdacube-engine",
          "signature": "p a -\u003e String -\u003e p a",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#%3C%2A%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "(\u003c*=) \u003c*=",
          "normalized": "a b-\u003eString-\u003ea b",
          "package": "lambdacube-engine",
          "signature": "p a-\u003eString-\u003ep a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:-60--42--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "blendVals",
          "package": "lambdacube-engine",
          "signature": "[(String, SceneBlendFactor)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#blendVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "blendVals",
          "normalized": "[(String,SceneBlendFactor)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,SceneBlendFactor)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:blendVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "blendopVals",
          "package": "lambdacube-engine",
          "signature": "[(String, SceneBlendOperation)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#blendopVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "blendopVals",
          "normalized": "[(String,SceneBlendOperation)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,SceneBlendOperation)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:blendopVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "boolVals",
          "package": "lambdacube-engine",
          "signature": "[(String, Bool)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#boolVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "boolVals",
          "normalized": "[(String,Bool)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,Bool)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:boolVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "btyVals",
          "package": "lambdacube-engine",
          "signature": "[(String, BindingType)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#btyVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "btyVals",
          "normalized": "[(String,BindingType)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,BindingType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:btyVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "cmpfuncVals",
          "package": "lambdacube-engine",
          "signature": "[(String, CompareFunction)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#cmpfuncVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "cmpfuncVals",
          "normalized": "[(String,CompareFunction)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,CompareFunction)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:cmpfuncVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "compositorPixelFormatVals",
          "package": "lambdacube-engine",
          "signature": "[(String, PixelFormat)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#compositorPixelFormatVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "compositorPixelFormatVals",
          "normalized": "[(String,PixelFormat)]",
          "package": "lambdacube-engine",
          "partial": "Pixel Format Vals",
          "signature": "[(String,PixelFormat)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:compositorPixelFormatVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "copVals",
          "package": "lambdacube-engine",
          "signature": "[(String, LayerBlendOperation)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#copVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "copVals",
          "normalized": "[(String,LayerBlendOperation)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,LayerBlendOperation)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:copVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "ctyVals",
          "package": "lambdacube-engine",
          "signature": "[(String, ContentType)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#ctyVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "ctyVals",
          "normalized": "[(String,ContentType)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,ContentType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:ctyVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "cullhwVals",
          "package": "lambdacube-engine",
          "signature": "[(String, CullingMode)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#cullhwVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "cullhwVals",
          "normalized": "[(String,CullingMode)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,CullingMode)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:cullhwVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "cullswVals",
          "package": "lambdacube-engine",
          "signature": "[(String, ManualCullingMode)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#cullswVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "cullswVals",
          "normalized": "[(String,ManualCullingMode)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,ManualCullingMode)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:cullswVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "def",
          "package": "lambdacube-engine",
          "signature": "a -\u003e [a] -\u003e a",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#def",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "def",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "lambdacube-engine",
          "signature": "a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:def"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "envmapVals",
          "package": "lambdacube-engine",
          "signature": "[(String, Maybe EnvMapType)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#envmapVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "envmapVals",
          "normalized": "[(String,Maybe EnvMapType)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,Maybe EnvMapType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:envmapVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "filteringVals",
          "package": "lambdacube-engine",
          "signature": "[(String, FilterOptions)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#filteringVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "filteringVals",
          "normalized": "[(String,FilterOptions)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,FilterOptions)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:filteringVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "fogmodeVals",
          "package": "lambdacube-engine",
          "signature": "[(String, FogMode)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#fogmodeVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "fogmodeVals",
          "normalized": "[(String,FogMode)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,FogMode)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:fogmodeVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "illumstageVals",
          "package": "lambdacube-engine",
          "signature": "[(String, IlluminationStage)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#illumstageVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "illumstageVals",
          "normalized": "[(String,IlluminationStage)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,IlluminationStage)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:illumstageVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "inputVals",
          "package": "lambdacube-engine",
          "signature": "[(String, InputMode)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#inputVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "inputVals",
          "normalized": "[(String,InputMode)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,InputMode)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:inputVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "layerblendopexVals",
          "package": "lambdacube-engine",
          "signature": "[(String, LayerBlendOperationEx)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#layerblendopexVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "layerblendopexVals",
          "normalized": "[(String,LayerBlendOperationEx)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,LayerBlendOperationEx)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:layerblendopexVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "layerblendsrcVals",
          "package": "lambdacube-engine",
          "signature": "[(String, LayerBlendSource)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#layerblendsrcVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "layerblendsrcVals",
          "normalized": "[(String,LayerBlendSource)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,LayerBlendSource)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:layerblendsrcVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "lighttypeVals",
          "package": "lambdacube-engine",
          "signature": "[(String, LightTypes)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#lighttypeVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "lighttypeVals",
          "normalized": "[(String,LightTypes)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,LightTypes)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:lighttypeVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "onoffVals",
          "package": "lambdacube-engine",
          "signature": "[(String, Bool)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#onoffVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "onoffVals",
          "normalized": "[(String,Bool)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,Bool)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:onoffVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pBool",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) Bool",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pBool",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)Bool",
          "package": "lambdacube-engine",
          "partial": "Bool",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pColour",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e AnaParser [Token] Pair Token (Maybe Token) (Either FloatType4 ())",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pColour",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pColour",
          "normalized": "FloatType-\u003eAnaParser[Token]Pair Token(Maybe Token)(Either FloatType())",
          "package": "lambdacube-engine",
          "partial": "Colour",
          "signature": "FloatType-\u003eAnaParser[Token]Pair Token(Maybe Token)(Either FloatType())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pEnum",
          "package": "lambdacube-engine",
          "signature": "[(String, t)] -\u003e p t",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pEnum",
          "normalized": "[(String,a)]-\u003eb a",
          "package": "lambdacube-engine",
          "partial": "Enum",
          "signature": "[(String,t)]-\u003ep t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pFloat",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) FloatType",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pFloat",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "package": "lambdacube-engine",
          "partial": "Float",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pFloat3",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) FloatType3",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pFloat3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pFloat3",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "package": "lambdacube-engine",
          "partial": "Float",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pFloat3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pFloat4",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) FloatType4",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pFloat4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pFloat4",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "package": "lambdacube-engine",
          "partial": "Float",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pFloat4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pInt",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) Int",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pInt",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)Int",
          "package": "lambdacube-engine",
          "partial": "Int",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pName",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) String",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pName",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)String",
          "package": "lambdacube-engine",
          "partial": "Name",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pOnOff",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) Bool",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pOnOff",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pOnOff",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)Bool",
          "package": "lambdacube-engine",
          "partial": "On Off",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pOnOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pRGB",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e AnaParser [Token] Pair Token (Maybe Token) FloatType4",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pRGB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pRGB",
          "normalized": "FloatType-\u003eAnaParser[Token]Pair Token(Maybe Token)FloatType",
          "package": "lambdacube-engine",
          "partial": "RGB",
          "signature": "FloatType-\u003eAnaParser[Token]Pair Token(Maybe Token)FloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pRGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pRGBA",
          "package": "lambdacube-engine",
          "signature": "AnaParser [Token] Pair Token (Maybe Token) FloatType4",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pRGBA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pRGBA",
          "normalized": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "package": "lambdacube-engine",
          "partial": "RGBA",
          "signature": "AnaParser[Token]Pair Token(Maybe Token)FloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pRGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pRGBOrRGBA",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e AnaParser [Token] Pair Token (Maybe Token) FloatType4",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pRGBOrRGBA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pRGBOrRGBA",
          "normalized": "FloatType-\u003eAnaParser[Token]Pair Token(Maybe Token)FloatType",
          "package": "lambdacube-engine",
          "partial": "RGBOr RGBA",
          "signature": "FloatType-\u003eAnaParser[Token]Pair Token(Maybe Token)FloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pRGBOrRGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pixelformatVals",
          "package": "lambdacube-engine",
          "signature": "[(String, PixelFormat)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#pixelformatVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "pixelformatVals",
          "normalized": "[(String,PixelFormat)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,PixelFormat)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:pixelformatVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "polymodeVals",
          "package": "lambdacube-engine",
          "signature": "[(String, PolygonMode)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#polymodeVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "polymodeVals",
          "normalized": "[(String,PolygonMode)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,PolygonMode)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:polymodeVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "ruleopVals",
          "package": "lambdacube-engine",
          "signature": "[(String, IncludeOrExclude)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#ruleopVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "ruleopVals",
          "normalized": "[(String,IncludeOrExclude)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,IncludeOrExclude)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:ruleopVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "sceneblendVals",
          "package": "lambdacube-engine",
          "signature": "[(String, SceneBlendType)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#sceneblendVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "sceneblendVals",
          "normalized": "[(String,SceneBlendType)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,SceneBlendType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:sceneblendVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "shadingVals",
          "package": "lambdacube-engine",
          "signature": "[(String, ShadeOptions)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#shadingVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "shadingVals",
          "normalized": "[(String,ShadeOptions)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,ShadeOptions)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:shadingVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "stencilopVals",
          "package": "lambdacube-engine",
          "signature": "[(String, StencilOperation)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#stencilopVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "stencilopVals",
          "normalized": "[(String,StencilOperation)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,StencilOperation)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:stencilopVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "texaddressVals",
          "package": "lambdacube-engine",
          "signature": "[(String, TextureAddressingMode)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#texaddressVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "texaddressVals",
          "normalized": "[(String,TextureAddressingMode)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,TextureAddressingMode)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:texaddressVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "texfilteringVals",
          "package": "lambdacube-engine",
          "signature": "[(String, (FilterOptions, FilterOptions, FilterOptions))]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#texfilteringVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "texfilteringVals",
          "normalized": "[(String,(FilterOptions,FilterOptions,FilterOptions))]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,(FilterOptions,FilterOptions,FilterOptions))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:texfilteringVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "textypeVals",
          "package": "lambdacube-engine",
          "signature": "[(String, TextureType)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#textypeVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "textypeVals",
          "normalized": "[(String,TextureType)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,TextureType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:textypeVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "wavetypeVals",
          "package": "lambdacube-engine",
          "signature": "[(String, WaveformType)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#wavetypeVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "wavetypeVals",
          "normalized": "[(String,WaveformType)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,WaveformType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:wavetypeVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "xformtypeVals",
          "package": "lambdacube-engine",
          "signature": "[(String, TextureTransformType)]",
          "source": "src/Graphics-LambdaCube-Loader-ParserUtil.html#xformtypeVals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ParserUtil",
          "module": "Graphics.LambdaCube.Loader.ParserUtil",
          "name": "xformtypeVals",
          "normalized": "[(String,TextureTransformType)]",
          "package": "lambdacube-engine",
          "partial": "Vals",
          "signature": "[(String,TextureTransformType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ParserUtil.html#v:xformtypeVals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "ResourceScript",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ResourceScript",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "ResourceScript",
          "package": "lambdacube-engine",
          "partial": "Resource Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of path leading to a resource.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "PathType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html#PathType",
          "type": "data"
        },
        "index": {
          "description": "The type of path leading to resource",
          "hierarchy": "Graphics LambdaCube Loader ResourceScript",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "PathType",
          "package": "lambdacube-engine",
          "partial": "Path Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#t:PathType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "ResourceGroup",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html#ResourceGroup",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ResourceScript",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "ResourceGroup",
          "package": "lambdacube-engine",
          "partial": "Resource Group",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#t:ResourceGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "ResourcePath",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html#ResourcePath",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ResourceScript",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "ResourcePath",
          "package": "lambdacube-engine",
          "partial": "Resource Path",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#t:ResourcePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn ordinary directory.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.Loader.ResourceScript\",\"Graphics.LambdaCube\"]",
          "name": "PathDir",
          "package": "lambdacube-engine",
          "signature": "PathDir",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html#PathType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#v:PathDir\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:PathDir\"]"
        },
        "index": {
          "description": "An ordinary directory",
          "hierarchy": "Graphics LambdaCube Loader ResourceScript",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "PathDir",
          "package": "lambdacube-engine",
          "partial": "Path Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#v:PathDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA zip compressed directory.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.Loader.ResourceScript\",\"Graphics.LambdaCube\"]",
          "name": "PathZip",
          "package": "lambdacube-engine",
          "signature": "PathZip",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html#PathType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#v:PathZip\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:PathZip\"]"
        },
        "index": {
          "description": "zip compressed directory",
          "hierarchy": "Graphics LambdaCube Loader ResourceScript",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "PathZip",
          "package": "lambdacube-engine",
          "partial": "Path Zip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#v:PathZip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "loadResourcesCfg",
          "package": "lambdacube-engine",
          "signature": "FilePath -\u003e IO (Maybe [(String, [(PathType, String)])])",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html#loadResourcesCfg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader ResourceScript",
          "module": "Graphics.LambdaCube.Loader.ResourceScript",
          "name": "loadResourcesCfg",
          "normalized": "FilePath-\u003eIO(Maybe[(String,[(PathType,String)])])",
          "package": "lambdacube-engine",
          "partial": "Resources Cfg",
          "signature": "FilePath-\u003eIO(Maybe[(String,[(PathType,String)])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-ResourceScript.html#v:loadResourcesCfg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "SkeletonXML",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "SkeletonXML",
          "package": "lambdacube-engine",
          "partial": "Skeleton XML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "loadSkeleton",
          "package": "lambdacube-engine",
          "signature": "FilePath -\u003e IO Skeleton",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#loadSkeleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "loadSkeleton",
          "normalized": "FilePath-\u003eIO Skeleton",
          "package": "lambdacube-engine",
          "partial": "Skeleton",
          "signature": "FilePath-\u003eIO Skeleton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:loadSkeleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "parseSkeleton",
          "package": "lambdacube-engine",
          "signature": "String -\u003e Skeleton",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#parseSkeleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "parseSkeleton",
          "normalized": "String-\u003eSkeleton",
          "package": "lambdacube-engine",
          "partial": "Skeleton",
          "signature": "String-\u003eSkeleton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:parseSkeleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readAnimation",
          "package": "lambdacube-engine",
          "signature": "[String] -\u003e Element -\u003e (String, Animation)",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#readAnimation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readAnimation",
          "normalized": "[String]-\u003eElement-\u003e(String,Animation)",
          "package": "lambdacube-engine",
          "partial": "Animation",
          "signature": "[String]-\u003eElement-\u003e(String,Animation)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:readAnimation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readBone",
          "package": "lambdacube-engine",
          "signature": "Element -\u003e (String, Bone)",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#readBone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readBone",
          "normalized": "Element-\u003e(String,Bone)",
          "package": "lambdacube-engine",
          "partial": "Bone",
          "signature": "Element-\u003e(String,Bone)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:readBone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readFloat",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e Element -\u003e Float",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#readFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readFloat",
          "normalized": "String-\u003eString-\u003eElement-\u003eFloat",
          "package": "lambdacube-engine",
          "partial": "Float",
          "signature": "String-\u003eString-\u003eElement-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:readFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readKeyFrame",
          "package": "lambdacube-engine",
          "signature": "Element -\u003e KeyFrame",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#readKeyFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readKeyFrame",
          "normalized": "Element-\u003eKeyFrame",
          "package": "lambdacube-engine",
          "partial": "Key Frame",
          "signature": "Element-\u003eKeyFrame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:readKeyFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readSkeleton",
          "package": "lambdacube-engine",
          "signature": "Element -\u003e Skeleton",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#readSkeleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readSkeleton",
          "normalized": "Element-\u003eSkeleton",
          "package": "lambdacube-engine",
          "partial": "Skeleton",
          "signature": "Element-\u003eSkeleton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:readSkeleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readStr",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e Element -\u003e String",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#readStr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readStr",
          "normalized": "String-\u003eString-\u003eElement-\u003eString",
          "package": "lambdacube-engine",
          "partial": "Str",
          "signature": "String-\u003eString-\u003eElement-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:readStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readTrack",
          "package": "lambdacube-engine",
          "signature": "Element -\u003e (String, [KeyFrame])",
          "source": "src/Graphics-LambdaCube-Loader-SkeletonXML.html#readTrack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader SkeletonXML",
          "module": "Graphics.LambdaCube.Loader.SkeletonXML",
          "name": "readTrack",
          "normalized": "Element-\u003e(String,[KeyFrame])",
          "package": "lambdacube-engine",
          "partial": "Track",
          "signature": "Element-\u003e(String,[KeyFrame])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-SkeletonXML.html#v:readTrack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.StbImage",
          "name": "StbImage",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-StbImage.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader StbImage",
          "module": "Graphics.LambdaCube.Loader.StbImage",
          "name": "StbImage",
          "package": "lambdacube-engine",
          "partial": "Stb Image",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-StbImage.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.StbImage",
          "name": "loadImage",
          "package": "lambdacube-engine",
          "signature": "ImageLoader",
          "source": "src/Graphics-LambdaCube-Loader-StbImage.html#loadImage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader StbImage",
          "module": "Graphics.LambdaCube.Loader.StbImage",
          "name": "loadImage",
          "package": "lambdacube-engine",
          "partial": "Image",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-StbImage.html#v:loadImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "decodeVMesh",
          "package": "lambdacube-engine",
          "signature": "ByteString -\u003e VMesh",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html#decodeVMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "decodeVMesh",
          "normalized": "ByteString-\u003eVMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "signature": "ByteString-\u003eVMesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#v:decodeVMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "encodeVMesh",
          "package": "lambdacube-engine",
          "signature": "VMesh -\u003e ByteString",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html#encodeVMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "encodeVMesh",
          "normalized": "VMesh-\u003eByteString",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "signature": "VMesh-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#v:encodeVMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "getIndices",
          "package": "lambdacube-engine",
          "signature": "Get (Maybe (Vector Int))",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html#getIndices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "getIndices",
          "package": "lambdacube-engine",
          "partial": "Indices",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#v:getIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "lift",
          "package": "lambdacube-engine",
          "signature": "IO b -\u003e Get b",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html#lift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "lift",
          "normalized": "IO a-\u003eGet a",
          "package": "lambdacube-engine",
          "signature": "IO b-\u003eGet b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "loadVMesh",
          "package": "lambdacube-engine",
          "signature": "FilePath -\u003e IO VMesh",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html#loadVMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "loadVMesh",
          "normalized": "FilePath-\u003eIO VMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "signature": "FilePath-\u003eIO VMesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#v:loadVMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "putIndices",
          "package": "lambdacube-engine",
          "signature": "Maybe (Vector Int) -\u003e Put",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html#putIndices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "putIndices",
          "normalized": "Maybe(Vector Int)-\u003ePut",
          "package": "lambdacube-engine",
          "partial": "Indices",
          "signature": "Maybe(Vector Int)-\u003ePut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#v:putIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "saveVMesh",
          "package": "lambdacube-engine",
          "signature": "FilePath -\u003e VMesh -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-Loader-VMesh.html#saveVMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Loader VMesh",
          "module": "Graphics.LambdaCube.Loader.VMesh",
          "name": "saveVMesh",
          "normalized": "FilePath-\u003eVMesh-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "signature": "FilePath-\u003eVMesh-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Loader-VMesh.html#v:saveVMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Material",
          "name": "Material",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Material.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "Material",
          "package": "lambdacube-engine",
          "partial": "Material",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Material",
          "name": "Material",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "Material",
          "package": "lambdacube-engine",
          "partial": "Material",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#t:Material"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Material",
          "name": "Material",
          "package": "lambdacube-engine",
          "signature": "Material",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "Material",
          "package": "lambdacube-engine",
          "partial": "Material",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:Material"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edistance list used to specify LOD\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtLodValues",
          "package": "lambdacube-engine",
          "signature": "[FloatType]",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "description": "distance list used to specify LOD",
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtLodValues",
          "normalized": "[FloatType]",
          "package": "lambdacube-engine",
          "partial": "Lod Values",
          "signature": "[FloatType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtLodValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Material",
          "name": "mtName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Material",
          "name": "mtReceiveShadows",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtReceiveShadows",
          "package": "lambdacube-engine",
          "partial": "Receive Shadows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtReceiveShadows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupported techniques of any sort\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtSupportedTechniques",
          "package": "lambdacube-engine",
          "signature": "Maybe [Technique t lp]",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "description": "Supported techniques of any sort",
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtSupportedTechniques",
          "normalized": "Maybe[Technique a b]",
          "package": "lambdacube-engine",
          "partial": "Supported Techniques",
          "signature": "Maybe[Technique t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtSupportedTechniques"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll techniques, supported and unsupported\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtTechniques",
          "package": "lambdacube-engine",
          "signature": "[Technique t lp]",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "description": "All techniques supported and unsupported",
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtTechniques",
          "normalized": "[Technique a b]",
          "package": "lambdacube-engine",
          "partial": "Techniques",
          "signature": "[Technique t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtTechniques"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Material",
          "name": "mtTransparencyCastsShadows",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtTransparencyCastsShadows",
          "package": "lambdacube-engine",
          "partial": "Transparency Casts Shadows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtTransparencyCastsShadows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eText description of why any techniques are not supported\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtUnsupportedReasons",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "description": "Text description of why any techniques are not supported",
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtUnsupportedReasons",
          "package": "lambdacube-engine",
          "partial": "Unsupported Reasons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtUnsupportedReasons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edistance list used to specify LOD\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtUserLodValues",
          "package": "lambdacube-engine",
          "signature": "[FloatType]",
          "source": "src/Graphics-LambdaCube-Material.html#Material",
          "type": "function"
        },
        "index": {
          "description": "distance list used to specify LOD",
          "hierarchy": "Graphics LambdaCube Material",
          "module": "Graphics.LambdaCube.Material",
          "name": "mtUserLodValues",
          "normalized": "[FloatType]",
          "package": "lambdacube-engine",
          "partial": "User Lod Values",
          "signature": "[FloatType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Material.html#v:mtUserLodValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "Mesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Mesh.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "Mesh",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "Mesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Mesh.html#Mesh",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "Mesh",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#t:Mesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "SubMesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Mesh.html#SubMesh",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "SubMesh",
          "package": "lambdacube-engine",
          "partial": "Sub Mesh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#t:SubMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "Mesh",
          "package": "lambdacube-engine",
          "signature": "Mesh",
          "source": "src/Graphics-LambdaCube-Mesh.html#Mesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "Mesh",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:Mesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "SubMesh",
          "package": "lambdacube-engine",
          "signature": "SubMesh",
          "source": "src/Graphics-LambdaCube-Mesh.html#SubMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "SubMesh",
          "package": "lambdacube-engine",
          "partial": "Sub Mesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:SubMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "calculateBoundingRadius",
          "package": "lambdacube-engine",
          "signature": "Mesh vb ib -\u003e IO FloatType",
          "source": "src/Graphics-LambdaCube-Mesh.html#calculateBoundingRadius",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "calculateBoundingRadius",
          "normalized": "Mesh a b-\u003eIO FloatType",
          "package": "lambdacube-engine",
          "partial": "Bounding Radius",
          "signature": "Mesh vb ib-\u003eIO FloatType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:calculateBoundingRadius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "msBoundRadius",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Mesh.html#Mesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "msBoundRadius",
          "package": "lambdacube-engine",
          "partial": "Bound Radius",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:msBoundRadius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "msSharedVertexData",
          "package": "lambdacube-engine",
          "signature": "Maybe (VertexData vb)",
          "source": "src/Graphics-LambdaCube-Mesh.html#Mesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "msSharedVertexData",
          "package": "lambdacube-engine",
          "partial": "Shared Vertex Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:msSharedVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Mesh",
          "name": "msSubMeshList",
          "package": "lambdacube-engine",
          "signature": "[SubMesh vb ib]",
          "source": "src/Graphics-LambdaCube-Mesh.html#Mesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "msSubMeshList",
          "normalized": "[SubMesh a b]",
          "package": "lambdacube-engine",
          "partial": "Sub Mesh List",
          "signature": "[SubMesh vb ib]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:msSubMeshList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFace index data\n    , smExtremityPoints     :: [FloatType3]\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smIndexData",
          "package": "lambdacube-engine",
          "signature": "Maybe (IndexData ib)",
          "source": "src/Graphics-LambdaCube-Mesh.html#SubMesh",
          "type": "function"
        },
        "index": {
          "description": "Face index data smExtremityPoints FloatType3",
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smIndexData",
          "package": "lambdacube-engine",
          "partial": "Index Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:smIndexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of the material this SubMesh uses.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smMaterialName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Mesh.html#SubMesh",
          "type": "function"
        },
        "index": {
          "description": "Name of the material this SubMesh uses",
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smMaterialName",
          "package": "lambdacube-engine",
          "partial": "Material Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:smMaterialName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe render operation type used to render this submesh\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smOperationType",
          "package": "lambdacube-engine",
          "signature": "OperationType",
          "source": "src/Graphics-LambdaCube-Mesh.html#SubMesh",
          "type": "function"
        },
        "index": {
          "description": "The render operation type used to render this submesh",
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smOperationType",
          "package": "lambdacube-engine",
          "partial": "Operation Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:smOperationType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicates if this submesh shares vertex data with other meshes or whether it has it's own vertices.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smVertexData",
          "package": "lambdacube-engine",
          "signature": "Maybe (VertexData vb)",
          "source": "src/Graphics-LambdaCube-Mesh.html#SubMesh",
          "type": "function"
        },
        "index": {
          "description": "Indicates if this submesh shares vertex data with other meshes or whether it has it own vertices",
          "hierarchy": "Graphics LambdaCube Mesh",
          "module": "Graphics.LambdaCube.Mesh",
          "name": "smVertexData",
          "package": "lambdacube-engine",
          "partial": "Vertex Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Mesh.html#v:smVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions for combining meshes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.LambdaCube.MeshUtil",
          "name": "MeshUtil",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-MeshUtil.html",
          "type": "module"
        },
        "index": {
          "description": "Functions for combining meshes",
          "hierarchy": "Graphics LambdaCube MeshUtil",
          "module": "Graphics.LambdaCube.MeshUtil",
          "name": "MeshUtil",
          "package": "lambdacube-engine",
          "partial": "Mesh Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-MeshUtil.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a single mesh that represents the union of a list of\n transformed meshes (given the orientation and translation for each\n constituent).  The resulting mesh is optimised with respect to\n context switches during rendering.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.MeshUtil",
          "name": "mkVMesh",
          "package": "lambdacube-engine",
          "signature": "[(U, Vec3, VMesh)] -\u003e VMesh",
          "source": "src/Graphics-LambdaCube-MeshUtil.html#mkVMesh",
          "type": "function"
        },
        "index": {
          "description": "Build single mesh that represents the union of list of transformed meshes given the orientation and translation for each constituent The resulting mesh is optimised with respect to context switches during rendering",
          "hierarchy": "Graphics LambdaCube MeshUtil",
          "module": "Graphics.LambdaCube.MeshUtil",
          "name": "mkVMesh",
          "normalized": "[(U,Vec,VMesh)]-\u003eVMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "signature": "[(U,Vec,VMesh)]-\u003eVMesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-MeshUtil.html#v:mkVMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a single mesh that represents the union of a list of\n transformed meshes (given the transformation matrix for each\n constituent).  The resulting mesh is optimised with respect to\n context switches during rendering.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.MeshUtil",
          "name": "mkVMesh'",
          "package": "lambdacube-engine",
          "signature": "[(Proj4, VMesh)] -\u003e VMesh",
          "source": "src/Graphics-LambdaCube-MeshUtil.html#mkVMesh%27",
          "type": "function"
        },
        "index": {
          "description": "Build single mesh that represents the union of list of transformed meshes given the transformation matrix for each constituent The resulting mesh is optimised with respect to context switches during rendering",
          "hierarchy": "Graphics LambdaCube MeshUtil",
          "module": "Graphics.LambdaCube.MeshUtil",
          "name": "mkVMesh'",
          "normalized": "[(Proj,VMesh)]-\u003eVMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh'",
          "signature": "[(Proj,VMesh)]-\u003eVMesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-MeshUtil.html#v:mkVMesh-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "Pass",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Pass.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "Pass",
          "package": "lambdacube-engine",
          "partial": "Pass",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCategorisation of passes for the purpose of additive lighting\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IlluminationStage",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Pass.html#IlluminationStage",
          "type": "data"
        },
        "index": {
          "description": "Categorisation of passes for the purpose of additive lighting",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IlluminationStage",
          "package": "lambdacube-engine",
          "partial": "Illumination Stage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#t:IlluminationStage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "Pass",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "Pass",
          "package": "lambdacube-engine",
          "partial": "Pass",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#t:Pass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePart of the rendering which occurs without any kind of direct lighting\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_AMBIENT",
          "package": "lambdacube-engine",
          "signature": "IS_AMBIENT",
          "source": "src/Graphics-LambdaCube-Pass.html#IlluminationStage",
          "type": "function"
        },
        "index": {
          "description": "Part of the rendering which occurs without any kind of direct lighting",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_AMBIENT",
          "package": "lambdacube-engine",
          "partial": "IS AMBIENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:IS_AMBIENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePost-lighting rendering\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_DECAL",
          "package": "lambdacube-engine",
          "signature": "IS_DECAL",
          "source": "src/Graphics-LambdaCube-Pass.html#IlluminationStage",
          "type": "function"
        },
        "index": {
          "description": "Post-lighting rendering",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_DECAL",
          "package": "lambdacube-engine",
          "partial": "IS DECAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:IS_DECAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePart of the rendering which occurs per light\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_PER_LIGHT",
          "package": "lambdacube-engine",
          "signature": "IS_PER_LIGHT",
          "source": "src/Graphics-LambdaCube-Pass.html#IlluminationStage",
          "type": "function"
        },
        "index": {
          "description": "Part of the rendering which occurs per light",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_PER_LIGHT",
          "package": "lambdacube-engine",
          "partial": "IS PER LIGHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:IS_PER_LIGHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNot determined\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_UNKNOWN",
          "package": "lambdacube-engine",
          "signature": "IS_UNKNOWN",
          "source": "src/Graphics-LambdaCube-Pass.html#IlluminationStage",
          "type": "function"
        },
        "index": {
          "description": "Not determined",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "IS_UNKNOWN",
          "package": "lambdacube-engine",
          "partial": "IS UNKNOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:IS_UNKNOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "Pass",
          "package": "lambdacube-engine",
          "signature": "Pass",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "Pass",
          "package": "lambdacube-engine",
          "partial": "Pass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:Pass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaBlendOperation",
          "package": "lambdacube-engine",
          "signature": "SceneBlendOperation",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaBlendOperation",
          "package": "lambdacube-engine",
          "partial": "Alpha Blend Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psAlphaBlendOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaRejectFunc",
          "package": "lambdacube-engine",
          "signature": "CompareFunction",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaRejectFunc",
          "package": "lambdacube-engine",
          "partial": "Alpha Reject Func",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psAlphaRejectFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaRejectVal",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaRejectVal",
          "package": "lambdacube-engine",
          "partial": "Alpha Reject Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psAlphaRejectVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaToCoverageEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAlphaToCoverageEnabled",
          "package": "lambdacube-engine",
          "partial": "Alpha To Coverage Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psAlphaToCoverageEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAmbient",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psAmbient",
          "package": "lambdacube-engine",
          "partial": "Ambient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psAmbient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psBlendOperation",
          "package": "lambdacube-engine",
          "signature": "SceneBlendOperation",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psBlendOperation",
          "package": "lambdacube-engine",
          "partial": "Blend Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psBlendOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psColourWrite",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psColourWrite",
          "package": "lambdacube-engine",
          "partial": "Colour Write",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psColourWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psCullMode",
          "package": "lambdacube-engine",
          "signature": "CullingMode",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psCullMode",
          "package": "lambdacube-engine",
          "partial": "Cull Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psCullMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthBiasConstant",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthBiasConstant",
          "package": "lambdacube-engine",
          "partial": "Depth Bias Constant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDepthBiasConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthBiasPerIteration",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthBiasPerIteration",
          "package": "lambdacube-engine",
          "partial": "Depth Bias Per Iteration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDepthBiasPerIteration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthBiasSlopeScale",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthBiasSlopeScale",
          "package": "lambdacube-engine",
          "partial": "Depth Bias Slope Scale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDepthBiasSlopeScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthCheck",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthCheck",
          "package": "lambdacube-engine",
          "partial": "Depth Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDepthCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthFunc",
          "package": "lambdacube-engine",
          "signature": "CompareFunction",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthFunc",
          "package": "lambdacube-engine",
          "partial": "Depth Func",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDepthFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthWrite",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDepthWrite",
          "package": "lambdacube-engine",
          "partial": "Depth Write",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDepthWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDestBlendFactor",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDestBlendFactor",
          "package": "lambdacube-engine",
          "partial": "Dest Blend Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDestBlendFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDestBlendFactorAlpha",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDestBlendFactorAlpha",
          "package": "lambdacube-engine",
          "partial": "Dest Blend Factor Alpha",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDestBlendFactorAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDiffuse",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psDiffuse",
          "package": "lambdacube-engine",
          "partial": "Diffuse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psDiffuse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psEmissive",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psEmissive",
          "package": "lambdacube-engine",
          "partial": "Emissive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psEmissive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogColour",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogColour",
          "package": "lambdacube-engine",
          "partial": "Fog Colour",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psFogColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogDensity",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogDensity",
          "package": "lambdacube-engine",
          "partial": "Fog Density",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psFogDensity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogEnd",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogEnd",
          "package": "lambdacube-engine",
          "partial": "Fog End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psFogEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogMode",
          "package": "lambdacube-engine",
          "signature": "FogMode",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogMode",
          "package": "lambdacube-engine",
          "partial": "Fog Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psFogMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogOverride",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogOverride",
          "package": "lambdacube-engine",
          "partial": "Fog Override",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psFogOverride"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogStart",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFogStart",
          "package": "lambdacube-engine",
          "partial": "Fog Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psFogStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFragment program details\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFragmentProgramUsage",
          "package": "lambdacube-engine",
          "signature": "Maybe GpuProgramUsage",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Fragment program details",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psFragmentProgramUsage",
          "package": "lambdacube-engine",
          "partial": "Fragment Program Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psFragmentProgramUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeometry program details\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psGeometryProgramUsage",
          "package": "lambdacube-engine",
          "signature": "Maybe GpuProgramUsage",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Geometry program details",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psGeometryProgramUsage",
          "package": "lambdacube-engine",
          "partial": "Geometry Program Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psGeometryProgramUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIllumination stage?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psIlluminationStage",
          "package": "lambdacube-engine",
          "signature": "IlluminationStage",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Illumination stage",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psIlluminationStage",
          "package": "lambdacube-engine",
          "partial": "Illumination Stage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psIlluminationStage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUser clip planes for light?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightClipPlanes",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "User clip planes for light",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightClipPlanes",
          "package": "lambdacube-engine",
          "partial": "Light Clip Planes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psLightClipPlanes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScissoring for the light?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightScissoring",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Scissoring for the light",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightScissoring",
          "package": "lambdacube-engine",
          "partial": "Light Scissoring",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psLightScissoring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLighting enabled?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightingEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Lighting enabled",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightingEnabled",
          "package": "lambdacube-engine",
          "partial": "Lighting Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psLightingEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun this pass once per light? Iterate per how many lights?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightsPerIteration",
          "package": "lambdacube-engine",
          "signature": "Maybe Int",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Run this pass once per light Iterate per how many lights",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLightsPerIteration",
          "package": "lambdacube-engine",
          "partial": "Lights Per Iteration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psLightsPerIteration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "Maybe lp",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psLinkedGpuProgram",
          "package": "lambdacube-engine",
          "partial": "Linked Gpu Program",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psManualCullMode",
          "package": "lambdacube-engine",
          "signature": "ManualCullingMode",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psManualCullMode",
          "package": "lambdacube-engine",
          "partial": "Manual Cull Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psManualCullMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax simultaneous lights\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psMaxSimultaneousLights",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Max simultaneous lights",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psMaxSimultaneousLights",
          "package": "lambdacube-engine",
          "partial": "Max Simultaneous Lights",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psMaxSimultaneousLights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional name for the pass\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "optional name for the pass",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psNormaliseNormals",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psNormaliseNormals",
          "package": "lambdacube-engine",
          "partial": "Normalise Normals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psNormaliseNormals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould it only be run for a certain light type?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psOnlyLightType",
          "package": "lambdacube-engine",
          "signature": "Maybe LightTypes",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Should it only be run for certain light type",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psOnlyLightType",
          "package": "lambdacube-engine",
          "partial": "Only Light Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psOnlyLightType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of pass iterations to perform\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPassIterationCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "number of pass iterations to perform",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPassIterationCount",
          "package": "lambdacube-engine",
          "partial": "Pass Iteration Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPassIterationCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant, linear, quadratic coeffs\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointAttenuationCoeffs",
          "package": "lambdacube-engine",
          "signature": "FloatType3",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "constant linear quadratic coeffs",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointAttenuationCoeffs",
          "package": "lambdacube-engine",
          "partial": "Point Attenuation Coeffs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPointAttenuationCoeffs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointAttenuationEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointAttenuationEnabled",
          "package": "lambdacube-engine",
          "partial": "Point Attenuation Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPointAttenuationEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointMaxSize",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointMaxSize",
          "package": "lambdacube-engine",
          "partial": "Point Max Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPointMaxSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointMinSize",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointMinSize",
          "package": "lambdacube-engine",
          "partial": "Point Min Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPointMinSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epoint size, applies when not using per-vertex point size\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointSize",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "point size applies when not using per-vertex point size",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointSize",
          "package": "lambdacube-engine",
          "partial": "Point Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPointSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointSpritesEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPointSpritesEnabled",
          "package": "lambdacube-engine",
          "partial": "Point Sprites Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPointSpritesEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePolygon mode\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPolygonMode",
          "package": "lambdacube-engine",
          "signature": "PolygonMode",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Polygon mode",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPolygonMode",
          "package": "lambdacube-engine",
          "partial": "Polygon Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPolygonMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPolygonModeOverrideable",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psPolygonModeOverrideable",
          "package": "lambdacube-engine",
          "partial": "Polygon Mode Overrideable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psPolygonModeOverrideable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to determine if separate alpha blending should be used for color and alpha channels\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSeparateBlend",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Used to determine if separate alpha blending should be used for color and alpha channels",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSeparateBlend",
          "package": "lambdacube-engine",
          "partial": "Separate Blend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psSeparateBlend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermines if we should use separate blending operations for color and alpha channels\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSeparateBlendOperation",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Determines if we should use separate blending operations for color and alpha channels",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSeparateBlendOperation",
          "package": "lambdacube-engine",
          "partial": "Separate Blend Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psSeparateBlendOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShading options\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psShadeOptions",
          "package": "lambdacube-engine",
          "signature": "ShadeOptions",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Shading options",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psShadeOptions",
          "package": "lambdacube-engine",
          "partial": "Shade Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psShadeOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psShininess",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psShininess",
          "package": "lambdacube-engine",
          "partial": "Shininess",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psShininess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSourceBlendFactor",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSourceBlendFactor",
          "package": "lambdacube-engine",
          "partial": "Source Blend Factor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psSourceBlendFactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSourceBlendFactorAlpha",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSourceBlendFactorAlpha",
          "package": "lambdacube-engine",
          "partial": "Source Blend Factor Alpha",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psSourceBlendFactorAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSpecular",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psSpecular",
          "package": "lambdacube-engine",
          "partial": "Specular",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psSpecular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStarting light index\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psStartLight",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Starting light index",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psStartLight",
          "package": "lambdacube-engine",
          "partial": "Start Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psStartLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTextureUnitStates",
          "package": "lambdacube-engine",
          "signature": "[TextureUnitState t]",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTextureUnitStates",
          "normalized": "[TextureUnitState a]",
          "package": "lambdacube-engine",
          "partial": "Texture Unit States",
          "signature": "[TextureUnitState t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psTextureUnitStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTracking",
          "package": "lambdacube-engine",
          "signature": "TrackVertexColourType",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTracking",
          "package": "lambdacube-engine",
          "partial": "Tracking",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psTracking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransparent depth sorting\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTransparentSorting",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Transparent depth sorting",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTransparentSorting",
          "package": "lambdacube-engine",
          "partial": "Transparent Sorting",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psTransparentSorting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransparent depth sorting forced\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTransparentSortingForced",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Transparent depth sorting forced",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psTransparentSortingForced",
          "package": "lambdacube-engine",
          "partial": "Transparent Sorting Forced",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psTransparentSortingForced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertex program details\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psVertexProgramUsage",
          "package": "lambdacube-engine",
          "signature": "Maybe GpuProgramUsage",
          "source": "src/Graphics-LambdaCube-Pass.html#Pass",
          "type": "function"
        },
        "index": {
          "description": "Vertex program details",
          "hierarchy": "Graphics LambdaCube Pass",
          "module": "Graphics.LambdaCube.Pass",
          "name": "psVertexProgramUsage",
          "package": "lambdacube-engine",
          "partial": "Vertex Program Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Pass.html#v:psVertexProgramUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelFormat",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-PixelFormat.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelFormat",
          "package": "lambdacube-engine",
          "partial": "Pixel Format",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePixel component format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelComponentType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelComponentType",
          "type": "data"
        },
        "index": {
          "description": "Pixel component format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelComponentType",
          "package": "lambdacube-engine",
          "partial": "Pixel Component Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#t:PixelComponentType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe pixel format used for images, textures, and render surfaces\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelFormat",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "data"
        },
        "index": {
          "description": "The pixel format used for images textures and render surfaces",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelFormat",
          "package": "lambdacube-engine",
          "partial": "Pixel Format",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#t:PixelFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlags defining some on/off properties of pixel formats\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelFormatFlags",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormatFlags",
          "type": "data"
        },
        "index": {
          "description": "Flags defining some on off properties of pixel formats",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PixelFormatFlags",
          "package": "lambdacube-engine",
          "partial": "Pixel Format Flags",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#t:PixelFormatFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eByte per component (8 bit fixed 0.0..1.0)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_BYTE",
          "package": "lambdacube-engine",
          "signature": "PCT_BYTE",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelComponentType",
          "type": "function"
        },
        "index": {
          "description": "Byte per component bit fixed",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_BYTE",
          "package": "lambdacube-engine",
          "partial": "PCT BYTE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PCT_BYTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16 bit float per component\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_FLOAT16",
          "package": "lambdacube-engine",
          "signature": "PCT_FLOAT16",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelComponentType",
          "type": "function"
        },
        "index": {
          "description": "bit float per component",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_FLOAT16",
          "package": "lambdacube-engine",
          "partial": "PCT FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PCT_FLOAT16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32 bit float per component\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_FLOAT32",
          "package": "lambdacube-engine",
          "signature": "PCT_FLOAT32",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelComponentType",
          "type": "function"
        },
        "index": {
          "description": "bit float per component",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_FLOAT32",
          "package": "lambdacube-engine",
          "partial": "PCT FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PCT_FLOAT32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShort per component (16 bit fixed 0.0..1.0))\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_SHORT",
          "package": "lambdacube-engine",
          "signature": "PCT_SHORT",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelComponentType",
          "type": "function"
        },
        "index": {
          "description": "Short per component bit fixed",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PCT_SHORT",
          "package": "lambdacube-engine",
          "partial": "PCT SHORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PCT_SHORT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis format is compressed. This invalidates the values in elemBytes, elemBits and the bit counts as these might not be fixed in a compressed format.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_COMPRESSED",
          "package": "lambdacube-engine",
          "signature": "PFF_COMPRESSED",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormatFlags",
          "type": "function"
        },
        "index": {
          "description": "This format is compressed This invalidates the values in elemBytes elemBits and the bit counts as these might not be fixed in compressed format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_COMPRESSED",
          "package": "lambdacube-engine",
          "partial": "PFF COMPRESSED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PFF_COMPRESSED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a depth format (for depth textures)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_DEPTH",
          "package": "lambdacube-engine",
          "signature": "PFF_DEPTH",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormatFlags",
          "type": "function"
        },
        "index": {
          "description": "This is depth format for depth textures",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_DEPTH",
          "package": "lambdacube-engine",
          "partial": "PFF DEPTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PFF_DEPTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a floating point format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_FLOAT",
          "package": "lambdacube-engine",
          "signature": "PFF_FLOAT",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormatFlags",
          "type": "function"
        },
        "index": {
          "description": "This is floating point format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_FLOAT",
          "package": "lambdacube-engine",
          "partial": "PFF FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PFF_FLOAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis format has an alpha channel\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_HASALPHA",
          "package": "lambdacube-engine",
          "signature": "PFF_HASALPHA",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormatFlags",
          "type": "function"
        },
        "index": {
          "description": "This format has an alpha channel",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_HASALPHA",
          "package": "lambdacube-engine",
          "partial": "PFF HASALPHA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PFF_HASALPHA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an intensity format instead of a RGB one. The luminance replaces R,G and B. (but not A)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_LUMINANCE",
          "package": "lambdacube-engine",
          "signature": "PFF_LUMINANCE",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormatFlags",
          "type": "function"
        },
        "index": {
          "description": "This is an intensity format instead of RGB one The luminance replaces and but not",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_LUMINANCE",
          "package": "lambdacube-engine",
          "partial": "PFF LUMINANCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PFF_LUMINANCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormat is in native endian. Generally true for the 16, 24 and 32 bits formats which can be represented as machine integers.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_NATIVEENDIAN",
          "package": "lambdacube-engine",
          "signature": "PFF_NATIVEENDIAN",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormatFlags",
          "type": "function"
        },
        "index": {
          "description": "Format is in native endian Generally true for the and bits formats which can be represented as machine integers",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PFF_NATIVEENDIAN",
          "package": "lambdacube-engine",
          "partial": "PFF NATIVEENDIAN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PFF_NATIVEENDIAN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A1R5G5B5",
          "package": "lambdacube-engine",
          "signature": "PF_A1R5G5B5",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for blue green red and for alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A1R5G5B5",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A1R5G5B5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A2B10G10R10",
          "package": "lambdacube-engine",
          "signature": "PF_A2B10G10R10",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for blue green and red bits for alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A2B10G10R10",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A2B10G10R10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A2R10G10B10",
          "package": "lambdacube-engine",
          "signature": "PF_A2R10G10B10",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for alpha bits for red green and blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A2R10G10B10",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A2R10G10B10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8-bit pixel format, 4 bits alpha, 4 bits luminance.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A4L4",
          "package": "lambdacube-engine",
          "signature": "PF_A4L4",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits alpha bits luminance",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A4L4",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A4L4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit pixel format, 4 bits for alpha, red, green and blue.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A4R4G4B4",
          "package": "lambdacube-engine",
          "signature": "PF_A4R4G4B4",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for alpha red green and blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A4R4G4B4",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A4R4G4B4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8-bit pixel format, all bits alpha.\n    | PF_BYTE_A = PF_A8\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A8",
          "package": "lambdacube-engine",
          "signature": "PF_A8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format all bits alpha PF BYTE PF A8",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 8 bits for blue, green, red and alpha.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A8B8G8R8",
          "package": "lambdacube-engine",
          "signature": "PF_A8B8G8R8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for blue green red and alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A8B8G8R8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A8B8G8R8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 8 bits for alpha, red, green and blue.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A8R8G8B8",
          "package": "lambdacube-engine",
          "signature": "PF_A8R8G8B8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for alpha red green and blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_A8R8G8B8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_A8R8G8B8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_B5G6R5",
          "package": "lambdacube-engine",
          "signature": "PF_B5G6R5",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits red bits green bits blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_B5G6R5",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_B5G6R5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e24-bit pixel format, 8 bits for blue, green and red.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_B8G8R8",
          "package": "lambdacube-engine",
          "signature": "PF_B8G8R8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for blue green and red",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_B8G8R8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_B8G8R8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 8 bits for blue, green, red and alpha.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_B8G8R8A8",
          "package": "lambdacube-engine",
          "signature": "PF_B8G8R8A8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for blue green red and alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_B8G8R8A8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_B8G8R8A8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2 byte pixel format, 1 byte luminance, 1 byte alpha\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_BYTE_LA",
          "package": "lambdacube-engine",
          "signature": "PF_BYTE_LA",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "byte pixel format byte luminance byte alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_BYTE_LA",
          "package": "lambdacube-engine",
          "partial": "PF BYTE LA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_BYTE_LA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDepth texture format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DEPTH",
          "package": "lambdacube-engine",
          "signature": "PF_DEPTH",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "Depth texture format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DEPTH",
          "package": "lambdacube-engine",
          "partial": "PF DEPTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_DEPTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDDS (DirectDraw Surface) DXT1 format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT1",
          "package": "lambdacube-engine",
          "signature": "PF_DXT1",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "DDS DirectDraw Surface DXT1 format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT1",
          "package": "lambdacube-engine",
          "partial": "PF DXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_DXT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDDS (DirectDraw Surface) DXT2 format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT2",
          "package": "lambdacube-engine",
          "signature": "PF_DXT2",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "DDS DirectDraw Surface DXT2 format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT2",
          "package": "lambdacube-engine",
          "partial": "PF DXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_DXT2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDDS (DirectDraw Surface) DXT3 format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT3",
          "package": "lambdacube-engine",
          "signature": "PF_DXT3",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "DDS DirectDraw Surface DXT3 format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT3",
          "package": "lambdacube-engine",
          "partial": "PF DXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_DXT3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDDS (DirectDraw Surface) DXT4 format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT4",
          "package": "lambdacube-engine",
          "signature": "PF_DXT4",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "DDS DirectDraw Surface DXT4 format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT4",
          "package": "lambdacube-engine",
          "partial": "PF DXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_DXT4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDDS (DirectDraw Surface) DXT5 format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT5",
          "package": "lambdacube-engine",
          "signature": "PF_DXT5",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "DDS DirectDraw Surface DXT5 format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_DXT5",
          "package": "lambdacube-engine",
          "partial": "PF DXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_DXT5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit, 2-channel s10e5 floating point pixel format, 16-bit green, 16-bit red\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_GR",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT16_GR",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit channel s10e5 floating point pixel format bit green bit red",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_GR",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT GR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT16_GR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit pixel format, 16 bits (float) for red\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_R",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT16_R",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits float for red",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_R",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT16_R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_RGB",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT16_RGB",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits float for red bits float for green bits float for blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_RGB",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT RGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT16_RGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_RGBA",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT16_RGBA",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits float for red bits float for green bits float for blue bits float for alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT16_RGBA",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT RGBA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT16_RGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit red\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_GR",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT32_GR",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit channel floating point pixel format bit green bit red",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_GR",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT GR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT32_GR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit pixel format, 16 bits (float) for red\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_R",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT32_R",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits float for red",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_R",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT32_R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_RGB",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT32_RGB",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits float for red bits float for green bits float for blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_RGB",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT RGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT32_RGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_RGBA",
          "package": "lambdacube-engine",
          "signature": "PF_FLOAT32_RGBA",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits float for red bits float for green bits float for blue bits float for alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_FLOAT32_RGBA",
          "package": "lambdacube-engine",
          "partial": "PF FLOAT RGBA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_FLOAT32_RGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit pixel format, all bits luminace.\n    | PF_SHORT_L = PF_L16\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_L16",
          "package": "lambdacube-engine",
          "signature": "PF_L16",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format all bits luminace PF SHORT PF L16",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_L16",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_L16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8-bit pixel format, all bits luminace.\n    | PF_BYTE_L = PF_L8\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_L8",
          "package": "lambdacube-engine",
          "signature": "PF_L8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format all bits luminace PF BYTE PF L8",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_L8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_L8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R3G3B2",
          "package": "lambdacube-engine",
          "signature": "PF_R3G3B2",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits blue bits green bits red",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R3G3B2",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_R3G3B2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R5G6B5",
          "package": "lambdacube-engine",
          "signature": "PF_R5G6B5",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits red bits green bits blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R5G6B5",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_R5G6B5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e24-bit pixel format, 8 bits for red, green and blue.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R8G8B8",
          "package": "lambdacube-engine",
          "signature": "PF_R8G8B8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for red green and blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R8G8B8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_R8G8B8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 8 bits for red, green, blue and alpha.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R8G8B8A8",
          "package": "lambdacube-engine",
          "signature": "PF_R8G8B8A8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for red green blue and alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_R8G8B8A8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_R8G8B8A8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 16-bit green, 16-bit red\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_SHORT_GR",
          "package": "lambdacube-engine",
          "signature": "PF_SHORT_GR",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bit green bit red",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_SHORT_GR",
          "package": "lambdacube-engine",
          "partial": "PF SHORT GR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_SHORT_GR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e48-bit pixel format, 16 bits for red, green and blue\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_SHORT_RGB",
          "package": "lambdacube-engine",
          "signature": "PF_SHORT_RGB",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for red green and blue",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_SHORT_RGB",
          "package": "lambdacube-engine",
          "partial": "PF SHORT RGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_SHORT_RGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e64-bit pixel format, 16 bits for red, green, blue and alpha\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_SHORT_RGBA",
          "package": "lambdacube-engine",
          "signature": "PF_SHORT_RGBA",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for red green blue and alpha",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_SHORT_RGBA",
          "package": "lambdacube-engine",
          "partial": "PF SHORT RGBA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_SHORT_RGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnknown pixel format.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_UNKNOWN",
          "package": "lambdacube-engine",
          "signature": "PF_UNKNOWN",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "Unknown pixel format",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_UNKNOWN",
          "package": "lambdacube-engine",
          "partial": "PF UNKNOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_UNKNOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red; like PF_A8B8G8R8, but alpha will get discarded\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_X8B8G8R8",
          "package": "lambdacube-engine",
          "signature": "PF_X8B8G8R8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for blue bits for green bits for red like PF A8B8G8R8 but alpha will get discarded",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_X8B8G8R8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_X8B8G8R8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue; like PF_A8R8G8B8, but alpha will get discarded\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_X8R8G8B8",
          "package": "lambdacube-engine",
          "signature": "PF_X8R8G8B8",
          "source": "src/Graphics-LambdaCube-PixelFormat.html#PixelFormat",
          "type": "function"
        },
        "index": {
          "description": "bit pixel format bits for red bits for green bits for blue like PF A8R8G8B8 but alpha will get discarded",
          "hierarchy": "Graphics LambdaCube PixelFormat",
          "module": "Graphics.LambdaCube.PixelFormat",
          "name": "PF_X8R8G8B8",
          "package": "lambdacube-engine",
          "partial": "PF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-PixelFormat.html#v:PF_X8R8G8B8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "RenderOperation",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderOperation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "RenderOperation",
          "package": "lambdacube-engine",
          "partial": "Render Operation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interpretation of a sequence of vertices.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OperationType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "data"
        },
        "index": {
          "description": "The interpretation of sequence of vertices",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OperationType",
          "package": "lambdacube-engine",
          "partial": "Operation Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#t:OperationType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "RenderOperation",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#RenderOperation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "RenderOperation",
          "package": "lambdacube-engine",
          "partial": "Render Operation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#t:RenderOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of lines, 2 vertices per line.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.RenderOperation\",\"Graphics.LambdaCube\"]",
          "name": "OT_LINE_LIST",
          "package": "lambdacube-engine",
          "signature": "OT_LINE_LIST",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_LINE_LIST\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:OT_LINE_LIST\"]"
        },
        "index": {
          "description": "list of lines vertices per line",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OT_LINE_LIST",
          "package": "lambdacube-engine",
          "partial": "OT LINE LIST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_LINE_LIST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strip of connected lines, 1 vertex per line plus 1 start vertex.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.RenderOperation\",\"Graphics.LambdaCube\"]",
          "name": "OT_LINE_STRIP",
          "package": "lambdacube-engine",
          "signature": "OT_LINE_STRIP",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_LINE_STRIP\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:OT_LINE_STRIP\"]"
        },
        "index": {
          "description": "strip of connected lines vertex per line plus start vertex",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OT_LINE_STRIP",
          "package": "lambdacube-engine",
          "partial": "OT LINE STRIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_LINE_STRIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of points, 1 vertex per point.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.RenderOperation\",\"Graphics.LambdaCube\"]",
          "name": "OT_POINT_LIST",
          "package": "lambdacube-engine",
          "signature": "OT_POINT_LIST",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_POINT_LIST\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:OT_POINT_LIST\"]"
        },
        "index": {
          "description": "list of points vertex per point",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OT_POINT_LIST",
          "package": "lambdacube-engine",
          "partial": "OT POINT LIST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_POINT_LIST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fan of triangles, 3 vertices for the first triangle, and 1 per triangle after that.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.RenderOperation\",\"Graphics.LambdaCube\"]",
          "name": "OT_TRIANGLE_FAN",
          "package": "lambdacube-engine",
          "signature": "OT_TRIANGLE_FAN",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_TRIANGLE_FAN\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:OT_TRIANGLE_FAN\"]"
        },
        "index": {
          "description": "fan of triangles vertices for the first triangle and per triangle after that",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OT_TRIANGLE_FAN",
          "package": "lambdacube-engine",
          "partial": "OT TRIANGLE FAN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_TRIANGLE_FAN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of triangles, 3 vertices per triangle.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.RenderOperation\",\"Graphics.LambdaCube\"]",
          "name": "OT_TRIANGLE_LIST",
          "package": "lambdacube-engine",
          "signature": "OT_TRIANGLE_LIST",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_TRIANGLE_LIST\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:OT_TRIANGLE_LIST\"]"
        },
        "index": {
          "description": "list of triangles vertices per triangle",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OT_TRIANGLE_LIST",
          "package": "lambdacube-engine",
          "partial": "OT TRIANGLE LIST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_TRIANGLE_LIST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strip of triangles, 3 vertices for the first triangle, and 1 per triangle after that.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.RenderOperation\",\"Graphics.LambdaCube\"]",
          "name": "OT_TRIANGLE_STRIP",
          "package": "lambdacube-engine",
          "signature": "OT_TRIANGLE_STRIP",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_TRIANGLE_STRIP\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:OT_TRIANGLE_STRIP\"]"
        },
        "index": {
          "description": "strip of triangles vertices for the first triangle and per triangle after that",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "OT_TRIANGLE_STRIP",
          "package": "lambdacube-engine",
          "partial": "OT TRIANGLE STRIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:OT_TRIANGLE_STRIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "RenderOperation",
          "package": "lambdacube-engine",
          "signature": "RenderOperation",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#RenderOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "RenderOperation",
          "package": "lambdacube-engine",
          "partial": "Render Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:RenderOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndex data - only valid if useIndexes is true\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "roIndexData",
          "package": "lambdacube-engine",
          "signature": "Maybe (IndexData ib)",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#RenderOperation",
          "type": "function"
        },
        "index": {
          "description": "Index data only valid if useIndexes is true",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "roIndexData",
          "package": "lambdacube-engine",
          "partial": "Index Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:roIndexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of operation to perform\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "roOperationType",
          "package": "lambdacube-engine",
          "signature": "OperationType",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#RenderOperation",
          "type": "function"
        },
        "index": {
          "description": "The type of operation to perform",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "roOperationType",
          "package": "lambdacube-engine",
          "partial": "Operation Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:roOperationType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertex source data\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "roVertexData",
          "package": "lambdacube-engine",
          "signature": "VertexData vb",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#RenderOperation",
          "type": "function"
        },
        "index": {
          "description": "Vertex source data",
          "hierarchy": "Graphics LambdaCube RenderOperation",
          "module": "Graphics.LambdaCube.RenderOperation",
          "name": "roVertexData",
          "package": "lambdacube-engine",
          "partial": "Vertex Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderOperation.html#v:roVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderQueue",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderQueue.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderQueue",
          "package": "lambdacube-engine",
          "partial": "Render Queue",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderGroupOptions",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderGroupOptions",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderGroupOptions",
          "package": "lambdacube-engine",
          "partial": "Render Group Options",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#t:RenderGroupOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard render queue priorities.  Note that any enumeration type\n can be used to specify render priorities (i.e. top-level drawing\n order), this is just a simple convenience type.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderQueuePriority",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "data"
        },
        "index": {
          "description": "Standard render queue priorities Note that any enumeration type can be used to specify render priorities i.e top-level drawing order this is just simple convenience type",
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderQueuePriority",
          "package": "lambdacube-engine",
          "partial": "Render Queue Priority",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#t:RenderQueuePriority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderStatistics",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderStatistics",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderStatistics",
          "package": "lambdacube-engine",
          "partial": "Render Statistics",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#t:RenderStatistics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStruct associating a single Pass with a single Renderable.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderablePass",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderablePass",
          "type": "data"
        },
        "index": {
          "description": "Struct associating single Pass with single Renderable",
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderablePass",
          "package": "lambdacube-engine",
          "partial": "Renderable Pass",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#t:RenderablePass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "RQP_Background",
          "package": "lambdacube-engine",
          "signature": "RQP_Background",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_Background\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:RQP_Background\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RQP_Background",
          "package": "lambdacube-engine",
          "partial": "RQP Background",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_Background"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "RQP_EarlySky",
          "package": "lambdacube-engine",
          "signature": "RQP_EarlySky",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_EarlySky\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:RQP_EarlySky\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RQP_EarlySky",
          "package": "lambdacube-engine",
          "partial": "RQP Early Sky",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_EarlySky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "RQP_EarlyWorld",
          "package": "lambdacube-engine",
          "signature": "RQP_EarlyWorld",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_EarlyWorld\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:RQP_EarlyWorld\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RQP_EarlyWorld",
          "package": "lambdacube-engine",
          "partial": "RQP Early World",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_EarlyWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "RQP_LateSky",
          "package": "lambdacube-engine",
          "signature": "RQP_LateSky",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_LateSky\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:RQP_LateSky\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RQP_LateSky",
          "package": "lambdacube-engine",
          "partial": "RQP Late Sky",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_LateSky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "RQP_LateWorld",
          "package": "lambdacube-engine",
          "signature": "RQP_LateWorld",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_LateWorld\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:RQP_LateWorld\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RQP_LateWorld",
          "package": "lambdacube-engine",
          "partial": "RQP Late World",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_LateWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "RQP_Main",
          "package": "lambdacube-engine",
          "signature": "RQP_Main",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_Main\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:RQP_Main\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RQP_Main",
          "package": "lambdacube-engine",
          "partial": "RQP Main",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_Main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "RQP_Overlay",
          "package": "lambdacube-engine",
          "signature": "RQP_Overlay",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_Overlay\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:RQP_Overlay\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RQP_Overlay",
          "package": "lambdacube-engine",
          "partial": "RQP Overlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RQP_Overlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderGroupOptions",
          "package": "lambdacube-engine",
          "signature": "RenderGroupOptions",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderGroupOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderGroupOptions",
          "package": "lambdacube-engine",
          "partial": "Render Group Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RenderGroupOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderStatistics",
          "package": "lambdacube-engine",
          "signature": "RenderStatistics",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderStatistics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderStatistics",
          "package": "lambdacube-engine",
          "partial": "Render Statistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RenderStatistics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderablePass",
          "package": "lambdacube-engine",
          "signature": "RenderablePass",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderablePass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "RenderablePass",
          "package": "lambdacube-engine",
          "partial": "Renderable Pass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:RenderablePass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default render queue priority.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.RenderQueue\",\"Graphics.LambdaCube\"]",
          "name": "defaultRQP",
          "package": "lambdacube-engine",
          "signature": "Maybe RenderQueuePriority",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#defaultRQP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:defaultRQP\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:defaultRQP\"]"
        },
        "index": {
          "description": "The default render queue priority",
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "defaultRQP",
          "package": "lambdacube-engine",
          "partial": "RQP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:defaultRQP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "defaultRenderGroupOptions",
          "package": "lambdacube-engine",
          "signature": "RenderGroupOptions",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#defaultRenderGroupOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "defaultRenderGroupOptions",
          "package": "lambdacube-engine",
          "partial": "Render Group Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:defaultRenderGroupOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "emptyRenderStatistics",
          "package": "lambdacube-engine",
          "signature": "RenderStatistics",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#emptyRenderStatistics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "emptyRenderStatistics",
          "package": "lambdacube-engine",
          "partial": "Render Statistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:emptyRenderStatistics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderCollection",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e rs -\u003e IntMap RenderGroupOptions -\u003e [(Proj4, Light)] -\u003e RenderStatistics -\u003e [(Proj4, [RenderEntity vb ib t lp], Int, Int)] -\u003e IO RenderStatistics",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#renderCollection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderCollection",
          "normalized": "FloatType-\u003ea-\u003eIntMap RenderGroupOptions-\u003e[(Proj,Light)]-\u003eRenderStatistics-\u003e[(Proj,[RenderEntity b c d e],Int,Int)]-\u003eIO RenderStatistics",
          "package": "lambdacube-engine",
          "partial": "Collection",
          "signature": "FloatType-\u003ers-\u003eIntMap RenderGroupOptions-\u003e[(Proj,Light)]-\u003eRenderStatistics-\u003e[(Proj,[RenderEntity vb ib t lp],Int,Int)]-\u003eIO RenderStatistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:renderCollection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderPassGroup",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e rs -\u003e RenderStatistics -\u003e [RenderablePass vb ib t lp] -\u003e IO RenderStatistics",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#renderPassGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderPassGroup",
          "normalized": "FloatType-\u003ea-\u003eRenderStatistics-\u003e[RenderablePass b c d e]-\u003eIO RenderStatistics",
          "package": "lambdacube-engine",
          "partial": "Pass Group",
          "signature": "FloatType-\u003ers-\u003eRenderStatistics-\u003e[RenderablePass vb ib t lp]-\u003eIO RenderStatistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:renderPassGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderQueue",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e rs -\u003e IntMap RenderGroupOptions -\u003e RenderStatistics -\u003e [(Proj4, Light)] -\u003e [(Proj4, [RenderEntity vb ib t lp], Int, Int)] -\u003e IO RenderStatistics",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#renderQueue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderQueue",
          "normalized": "FloatType-\u003ea-\u003eIntMap RenderGroupOptions-\u003eRenderStatistics-\u003e[(Proj,Light)]-\u003e[(Proj,[RenderEntity b c d e],Int,Int)]-\u003eIO RenderStatistics",
          "package": "lambdacube-engine",
          "partial": "Queue",
          "signature": "FloatType-\u003ers-\u003eIntMap RenderGroupOptions-\u003eRenderStatistics-\u003e[(Proj,Light)]-\u003e[(Proj,[RenderEntity vb ib t lp],Int,Int)]-\u003eIO RenderStatistics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:renderQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderableDefaultPriority",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#renderableDefaultPriority",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "renderableDefaultPriority",
          "package": "lambdacube-engine",
          "partial": "Default Priority",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:renderableDefaultPriority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpLights",
          "package": "lambdacube-engine",
          "signature": "[(Proj4, Light)]",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderablePass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpLights",
          "normalized": "[(Proj,Light)]",
          "package": "lambdacube-engine",
          "partial": "Lights",
          "signature": "[(Proj,Light)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rpLights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderablePass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpMatrix",
          "package": "lambdacube-engine",
          "partial": "Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rpMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpOperation",
          "package": "lambdacube-engine",
          "signature": "RenderOperation vb ib",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderablePass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpOperation",
          "package": "lambdacube-engine",
          "partial": "Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rpOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpPass",
          "package": "lambdacube-engine",
          "signature": "Pass t lp",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderablePass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rpPass",
          "package": "lambdacube-engine",
          "partial": "Pass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rpPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rqoShadowsEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderGroupOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rqoShadowsEnabled",
          "package": "lambdacube-engine",
          "partial": "Shadows Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rqoShadowsEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rsBatchCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderStatistics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rsBatchCount",
          "package": "lambdacube-engine",
          "partial": "Batch Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rsBatchCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rsFaceCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderStatistics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rsFaceCount",
          "package": "lambdacube-engine",
          "partial": "Face Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rsFaceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rsVertexCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderStatistics",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderQueue",
          "module": "Graphics.LambdaCube.RenderQueue",
          "name": "rsVertexCount",
          "package": "lambdacube-engine",
          "partial": "Vertex Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderQueue.html#v:rsVertexCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Capabilities",
          "name": "Capabilities",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Capabilities.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Capabilities",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Capabilities",
          "name": "Capabilities",
          "package": "lambdacube-engine",
          "partial": "Capabilities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Capabilities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Capabilities",
          "name": "mkGLCapabilities",
          "package": "lambdacube-engine",
          "signature": "IO RenderSystemCapabilities",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Capabilities.html#mkGLCapabilities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Capabilities",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Capabilities",
          "name": "mkGLCapabilities",
          "package": "lambdacube-engine",
          "partial": "GLCapabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Capabilities.html#v:mkGLCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GpuProgram",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GpuProgram",
          "package": "lambdacube-engine",
          "partial": "Gpu Program",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLGpuProgram",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#GLGpuProgram",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLGpuProgram",
          "package": "lambdacube-engine",
          "partial": "GLGpu Program",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#t:GLGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLLinkedGpuProgram",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#GLLinkedGpuProgram",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLLinkedGpuProgram",
          "package": "lambdacube-engine",
          "partial": "GLLinked Gpu Program",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#t:GLLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLGpuProgram",
          "package": "lambdacube-engine",
          "signature": "GLGpuProgram",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#GLGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLGpuProgram",
          "package": "lambdacube-engine",
          "partial": "GLGpu Program",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:GLGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "GLLinkedGpuProgram",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#GLLinkedGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "GLLinkedGpuProgram",
          "package": "lambdacube-engine",
          "partial": "GLLinked Gpu Program",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:GLLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "compileShader",
          "package": "lambdacube-engine",
          "signature": "a -\u003e String -\u003e IO (Either GLuint [Char])",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#compileShader",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "compileShader",
          "normalized": "a-\u003eString-\u003eIO(Either GLuint[Char])",
          "package": "lambdacube-engine",
          "partial": "Shader",
          "signature": "a-\u003eString-\u003eIO(Either GLuint[Char])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:compileShader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "getFixedAttributeIndex",
          "package": "lambdacube-engine",
          "signature": "VertexElementSemantic -\u003e Int -\u003e Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#getFixedAttributeIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "getFixedAttributeIndex",
          "normalized": "VertexElementSemantic-\u003eInt-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Fixed Attribute Index",
          "signature": "VertexElementSemantic-\u003eInt-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:getFixedAttributeIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "glgpShaderObject",
          "package": "lambdacube-engine",
          "signature": "GLuint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#GLGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "glgpShaderObject",
          "package": "lambdacube-engine",
          "partial": "Shader Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:glgpShaderObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "gllgpProgramObject",
          "package": "lambdacube-engine",
          "signature": "GLuint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#GLLinkedGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "gllgpProgramObject",
          "package": "lambdacube-engine",
          "partial": "Program Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:gllgpProgramObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "isAttributeValid",
          "package": "lambdacube-engine",
          "signature": "VertexElementSemantic -\u003e Int -\u003e Bool",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#isAttributeValid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "isAttributeValid",
          "normalized": "VertexElementSemantic-\u003eInt-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Attribute Valid",
          "signature": "VertexElementSemantic-\u003eInt-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:isAttributeValid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "mkGLGpuProgram",
          "package": "lambdacube-engine",
          "signature": "GpuProgramType -\u003e String -\u003e IO (Either GLGpuProgram String)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#mkGLGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "mkGLGpuProgram",
          "normalized": "GpuProgramType-\u003eString-\u003eIO(Either GLGpuProgram String)",
          "package": "lambdacube-engine",
          "partial": "GLGpu Program",
          "signature": "GpuProgramType-\u003eString-\u003eIO(Either GLGpuProgram String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:mkGLGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "mkGLLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "[GLGpuProgram] -\u003e IO (Either GLLinkedGpuProgram String)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#mkGLLinkedGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "mkGLLinkedGpuProgram",
          "normalized": "[GLGpuProgram]-\u003eIO(Either GLLinkedGpuProgram String)",
          "package": "lambdacube-engine",
          "partial": "GLLinked Gpu Program",
          "signature": "[GLGpuProgram]-\u003eIO(Either GLLinkedGpuProgram String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:mkGLLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "programInfoLog",
          "package": "lambdacube-engine",
          "signature": "GLuint -\u003e IO String",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#programInfoLog",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "programInfoLog",
          "normalized": "GLuint-\u003eIO String",
          "package": "lambdacube-engine",
          "partial": "Info Log",
          "signature": "GLuint-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:programInfoLog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "setShaderSource",
          "package": "lambdacube-engine",
          "signature": "GLuint -\u003e [String] -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#setShaderSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "setShaderSource",
          "normalized": "GLuint-\u003e[String]-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Shader Source",
          "signature": "GLuint-\u003e[String]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:setShaderSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "shaderInfoLog",
          "package": "lambdacube-engine",
          "signature": "GLuint -\u003e IO String",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#shaderInfoLog",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "shaderInfoLog",
          "normalized": "GLuint-\u003eIO String",
          "package": "lambdacube-engine",
          "partial": "Info Log",
          "signature": "GLuint-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:shaderInfoLog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "withGLStringLen",
          "package": "lambdacube-engine",
          "signature": "String -\u003e ((Ptr b, Int) -\u003e IO a) -\u003e IO a",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#withGLStringLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL GpuProgram",
          "module": "Graphics.LambdaCube.RenderSystem.GL.GpuProgram",
          "name": "withGLStringLen",
          "normalized": "String-\u003e((Ptr a,Int)-\u003eIO b)-\u003eIO b",
          "package": "lambdacube-engine",
          "partial": "GLString Len",
          "signature": "String-\u003e((Ptr b,Int)-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-GpuProgram.html#v:withGLStringLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "IndexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "IndexBuffer",
          "package": "lambdacube-engine",
          "partial": "Index Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialisation of HardwareIndexBuffer for GL\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "GLIndexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "data"
        },
        "index": {
          "description": "Specialisation of HardwareIndexBuffer for GL",
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "GLIndexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLIndex Buffer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#t:GLIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "GLIndexBuffer",
          "package": "lambdacube-engine",
          "signature": "GLIndexBuffer",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "GLIndexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLIndex Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:GLIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibBufferObject",
          "package": "lambdacube-engine",
          "signature": "GLuint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibBufferObject",
          "package": "lambdacube-engine",
          "partial": "Buffer Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibBufferObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibIsLocked",
          "package": "lambdacube-engine",
          "signature": "GLIndexBuffer -\u003e IO Bool",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#glibIsLocked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibIsLocked",
          "normalized": "GLIndexBuffer-\u003eIO Bool",
          "package": "lambdacube-engine",
          "partial": "Is Locked",
          "signature": "GLIndexBuffer-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibIsLocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibLock",
          "package": "lambdacube-engine",
          "signature": "GLIndexBuffer -\u003e Int -\u003e Int -\u003e LockOptions -\u003e IO (Ptr Word8)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#glibLock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibLock",
          "normalized": "GLIndexBuffer-\u003eInt-\u003eInt-\u003eLockOptions-\u003eIO(Ptr Word)",
          "package": "lambdacube-engine",
          "partial": "Lock",
          "signature": "GLIndexBuffer-\u003eInt-\u003eInt-\u003eLockOptions-\u003eIO(Ptr Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibLockInfo",
          "package": "lambdacube-engine",
          "signature": "IORef (Maybe (Int, Int, Bool))",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibLockInfo",
          "normalized": "IORef(Maybe(Int,Int,Bool))",
          "package": "lambdacube-engine",
          "partial": "Lock Info",
          "signature": "IORef(Maybe(Int,Int,Bool))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibLockInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibNumIndexes",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibNumIndexes",
          "package": "lambdacube-engine",
          "partial": "Num Indexes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibNumIndexes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibShadowBuffer",
          "package": "lambdacube-engine",
          "signature": "Maybe (Ptr Word8)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibShadowBuffer",
          "package": "lambdacube-engine",
          "partial": "Shadow Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibShadowBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibType",
          "package": "lambdacube-engine",
          "signature": "IndexType",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibUnlock",
          "package": "lambdacube-engine",
          "signature": "GLIndexBuffer -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#glibUnlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibUnlock",
          "normalized": "GLIndexBuffer-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Unlock",
          "signature": "GLIndexBuffer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibUnlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibUsage",
          "package": "lambdacube-engine",
          "signature": "Usage",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "glibUsage",
          "package": "lambdacube-engine",
          "partial": "Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:glibUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "mkGLIndexBuffer",
          "package": "lambdacube-engine",
          "signature": "IndexType -\u003e Int -\u003e Usage -\u003e Bool -\u003e IO GLIndexBuffer",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#mkGLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "mkGLIndexBuffer",
          "normalized": "IndexType-\u003eInt-\u003eUsage-\u003eBool-\u003eIO GLIndexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLIndex Buffer",
          "signature": "IndexType-\u003eInt-\u003eUsage-\u003eBool-\u003eIO GLIndexBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:mkGLIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "rmGLIndexBuffer",
          "package": "lambdacube-engine",
          "signature": "GLIndexBuffer -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#rmGLIndexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL IndexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.IndexBuffer",
          "name": "rmGLIndexBuffer",
          "normalized": "GLIndexBuffer-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "GLIndex Buffer",
          "signature": "GLIndexBuffer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#v:rmGLIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "OcclusionQuery",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "OcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "Occlusion Query",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "GLOcclusionQuery",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#GLOcclusionQuery",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "GLOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "GLOcclusion Query",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#t:GLOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "GLOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "GLOcclusionQuery",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#GLOcclusionQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "GLOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "GLOcclusion Query",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:GLOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glBeginOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "GLOcclusionQuery -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#glBeginOcclusionQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glBeginOcclusionQuery",
          "normalized": "GLOcclusionQuery-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Begin Occlusion Query",
          "signature": "GLOcclusionQuery-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:glBeginOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glEndOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "GLOcclusionQuery -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#glEndOcclusionQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glEndOcclusionQuery",
          "normalized": "GLOcclusionQuery-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "End Occlusion Query",
          "signature": "GLOcclusionQuery-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:glEndOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glPullOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "GLOcclusionQuery -\u003e IO Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#glPullOcclusionQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glPullOcclusionQuery",
          "normalized": "GLOcclusionQuery-\u003eIO Int",
          "package": "lambdacube-engine",
          "partial": "Pull Occlusion Query",
          "signature": "GLOcclusionQuery-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:glPullOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glStillOutstanding",
          "package": "lambdacube-engine",
          "signature": "GLOcclusionQuery -\u003e IO Bool",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#glStillOutstanding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "glStillOutstanding",
          "normalized": "GLOcclusionQuery-\u003eIO Bool",
          "package": "lambdacube-engine",
          "partial": "Still Outstanding",
          "signature": "GLOcclusionQuery-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:glStillOutstanding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "gloqQueryObject",
          "package": "lambdacube-engine",
          "signature": "GLuint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#GLOcclusionQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "gloqQueryObject",
          "package": "lambdacube-engine",
          "partial": "Query Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:gloqQueryObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "mkGLOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "IO GLOcclusionQuery",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#mkGLOcclusionQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "mkGLOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "GLOcclusion Query",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:mkGLOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "rmGLOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "GLOcclusionQuery -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#rmGLOcclusionQuery",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL OcclusionQuery",
          "module": "Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery",
          "name": "rmGLOcclusionQuery",
          "normalized": "GLOcclusionQuery-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "GLOcclusion Query",
          "signature": "GLOcclusionQuery-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-OcclusionQuery.html#v:rmGLOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "partial": "Render System",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLRenderSystem",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLRenderSystem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLRenderSystem",
          "package": "lambdacube-engine",
          "partial": "GLRender System",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#t:GLRenderSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLState",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLState",
          "package": "lambdacube-engine",
          "partial": "GLState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#t:GLState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLRenderSystem",
          "package": "lambdacube-engine",
          "signature": "GLRenderSystem",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLRenderSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLRenderSystem",
          "package": "lambdacube-engine",
          "partial": "GLRender System",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:GLRenderSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLState",
          "package": "lambdacube-engine",
          "signature": "GLState",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "GLState",
          "package": "lambdacube-engine",
          "partial": "GLState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:GLState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "bindElement",
          "package": "lambdacube-engine",
          "signature": "RenderOperation GLVertexBuffer ib -\u003e [TextureUnitState t] -\u003e VertexElement -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#bindElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "bindElement",
          "normalized": "RenderOperation GLVertexBuffer a-\u003e[TextureUnitState b]-\u003eVertexElement-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Element",
          "signature": "RenderOperation GLVertexBuffer ib-\u003e[TextureUnitState t]-\u003eVertexElement-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:bindElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glBindGeometry",
          "package": "lambdacube-engine",
          "signature": "RenderOperation GLVertexBuffer GLIndexBuffer -\u003e [TextureUnitState t] -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glBindGeometry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glBindGeometry",
          "normalized": "RenderOperation GLVertexBuffer GLIndexBuffer-\u003e[TextureUnitState a]-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Bind Geometry",
          "signature": "RenderOperation GLVertexBuffer GLIndexBuffer-\u003e[TextureUnitState t]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glBindGeometry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glBindLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "GLLinkedGpuProgram -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glBindLinkedGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glBindLinkedGpuProgram",
          "normalized": "GLLinkedGpuProgram-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Bind Linked Gpu Program",
          "signature": "GLLinkedGpuProgram-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glBindLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glClearFrameBuffer",
          "package": "lambdacube-engine",
          "signature": "FrameBufferType -\u003e FloatType4 -\u003e FloatType -\u003e Word16 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glClearFrameBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glClearFrameBuffer",
          "normalized": "FrameBufferType-\u003eFloatType-\u003eFloatType-\u003eWord-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Clear Frame Buffer",
          "signature": "FrameBufferType-\u003eFloatType-\u003eFloatType-\u003eWord-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glClearFrameBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glDirtyHackCopyTexImage",
          "package": "lambdacube-engine",
          "signature": "GLTexture -\u003e Int -\u003e Int -\u003e Int -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glDirtyHackCopyTexImage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glDirtyHackCopyTexImage",
          "normalized": "GLTexture-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Dirty Hack Copy Tex Image",
          "signature": "GLTexture-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glDirtyHackCopyTexImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glFinishRender",
          "package": "lambdacube-engine",
          "signature": "IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glFinishRender",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glFinishRender",
          "normalized": "IO()",
          "package": "lambdacube-engine",
          "partial": "Finish Render",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glFinishRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glPrepareRender",
          "package": "lambdacube-engine",
          "signature": "IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glPrepareRender",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glPrepareRender",
          "normalized": "IO()",
          "package": "lambdacube-engine",
          "partial": "Prepare Render",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glPrepareRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glRender",
          "package": "lambdacube-engine",
          "signature": "RenderOperation GLVertexBuffer GLIndexBuffer -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glRender",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glRender",
          "normalized": "RenderOperation GLVertexBuffer GLIndexBuffer-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Render",
          "signature": "RenderOperation GLVertexBuffer GLIndexBuffer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetActiveTextureUnit",
          "package": "lambdacube-engine",
          "signature": "Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetActiveTextureUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetActiveTextureUnit",
          "normalized": "Int-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Active Texture Unit",
          "signature": "Int-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetActiveTextureUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetAlphaRejectSettings",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities -\u003e CompareFunction -\u003e Int -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetAlphaRejectSettings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetAlphaRejectSettings",
          "normalized": "RenderSystemCapabilities-\u003eCompareFunction-\u003eInt-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Alpha Reject Settings",
          "signature": "RenderSystemCapabilities-\u003eCompareFunction-\u003eInt-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetAlphaRejectSettings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetColourBufferWriteEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool -\u003e Bool -\u003e Bool -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetColourBufferWriteEnabled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetColourBufferWriteEnabled",
          "normalized": "Bool-\u003eBool-\u003eBool-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Colour Buffer Write Enabled",
          "signature": "Bool-\u003eBool-\u003eBool-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetColourBufferWriteEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetCullingMode",
          "package": "lambdacube-engine",
          "signature": "CullingMode -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetCullingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetCullingMode",
          "normalized": "CullingMode-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Culling Mode",
          "signature": "CullingMode-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetCullingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBias",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetDepthBias",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBias",
          "normalized": "FloatType-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Depth Bias",
          "signature": "FloatType-\u003eFloatType-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetDepthBias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBufferCheckEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetDepthBufferCheckEnabled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBufferCheckEnabled",
          "normalized": "Bool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Depth Buffer Check Enabled",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetDepthBufferCheckEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBufferFunction",
          "package": "lambdacube-engine",
          "signature": "CompareFunction -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetDepthBufferFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBufferFunction",
          "normalized": "CompareFunction-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Depth Buffer Function",
          "signature": "CompareFunction-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetDepthBufferFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBufferWriteEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetDepthBufferWriteEnabled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetDepthBufferWriteEnabled",
          "normalized": "Bool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Depth Buffer Write Enabled",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetDepthBufferWriteEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetFog",
          "package": "lambdacube-engine",
          "signature": "FogMode -\u003e FloatType4 -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetFog",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetFog",
          "normalized": "FogMode-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Fog",
          "signature": "FogMode-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetFog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetLightingEnabled",
          "package": "lambdacube-engine",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetLightingEnabled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetLightingEnabled",
          "normalized": "Bool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Lighting Enabled",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetLightingEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetPointParameters",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FloatType -\u003e Bool -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetPointParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetPointParameters",
          "normalized": "a-\u003eFloatType-\u003eBool-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Point Parameters",
          "signature": "rs-\u003eFloatType-\u003eBool-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetPointParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetPointSpritesEnabled",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetPointSpritesEnabled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetPointSpritesEnabled",
          "normalized": "RenderSystemCapabilities-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Point Sprites Enabled",
          "signature": "RenderSystemCapabilities-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetPointSpritesEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetPolygonMode",
          "package": "lambdacube-engine",
          "signature": "PolygonMode -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetPolygonMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetPolygonMode",
          "normalized": "PolygonMode-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Polygon Mode",
          "signature": "PolygonMode-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetPolygonMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetProjectionMatrix",
          "package": "lambdacube-engine",
          "signature": "Mat4 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetProjectionMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetProjectionMatrix",
          "normalized": "Mat-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Projection Matrix",
          "signature": "Mat-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetProjectionMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetSceneBlending",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendOperation -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetSceneBlending",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetSceneBlending",
          "normalized": "SceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Scene Blending",
          "signature": "SceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetSceneBlending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetSeparateSceneBlending",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendOperation -\u003e SceneBlendOperation -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetSeparateSceneBlending",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetSeparateSceneBlending",
          "normalized": "SceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eSceneBlendOperation-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Separate Scene Blending",
          "signature": "SceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eSceneBlendOperation-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetSeparateSceneBlending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetShadingType",
          "package": "lambdacube-engine",
          "signature": "ShadeOptions -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetShadingType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetShadingType",
          "normalized": "ShadeOptions-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Shading Type",
          "signature": "ShadeOptions-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetShadingType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetSurfaceParams",
          "package": "lambdacube-engine",
          "signature": "GLRenderSystem -\u003e FloatType4 -\u003e FloatType4 -\u003e FloatType4 -\u003e FloatType4 -\u003e FloatType -\u003e TrackVertexColourType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetSurfaceParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetSurfaceParams",
          "normalized": "GLRenderSystem-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eTrackVertexColourType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Surface Params",
          "signature": "GLRenderSystem-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eTrackVertexColourType-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetSurfaceParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTexture",
          "package": "lambdacube-engine",
          "signature": "Maybe GLTexture -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTexture",
          "normalized": "Maybe GLTexture-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture",
          "signature": "Maybe GLTexture-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureAddressingMode",
          "package": "lambdacube-engine",
          "signature": "TextureType -\u003e UVWAddressingMode -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureAddressingMode",
          "normalized": "TextureType-\u003eUVWAddressingMode-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Addressing Mode",
          "signature": "TextureType-\u003eUVWAddressingMode-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureBlendMode",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities -\u003e LayerBlendModeEx -\u003e LayerBlendModeEx -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureBlendMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureBlendMode",
          "normalized": "RenderSystemCapabilities-\u003eLayerBlendModeEx-\u003eLayerBlendModeEx-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Blend Mode",
          "signature": "RenderSystemCapabilities-\u003eLayerBlendModeEx-\u003eLayerBlendModeEx-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureBlendMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureBorderColour",
          "package": "lambdacube-engine",
          "signature": "TextureType -\u003e FloatType4 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureBorderColour",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureBorderColour",
          "normalized": "TextureType-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Border Colour",
          "signature": "TextureType-\u003eFloatType-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureBorderColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureCoordCalculation",
          "package": "lambdacube-engine",
          "signature": "TexCoordCalcMethod -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureCoordCalculation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureCoordCalculation",
          "normalized": "TexCoordCalcMethod-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Coord Calculation",
          "signature": "TexCoordCalcMethod-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureCoordCalculation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureLayerAnisotropy",
          "package": "lambdacube-engine",
          "signature": "TextureType -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureLayerAnisotropy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureLayerAnisotropy",
          "normalized": "TextureType-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Layer Anisotropy",
          "signature": "TextureType-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureLayerAnisotropy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureMatrix",
          "normalized": "Proj-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Matrix",
          "signature": "Proj-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureMipmapBias",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureMipmapBias",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureMipmapBias",
          "normalized": "FloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Mipmap Bias",
          "signature": "FloatType-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureMipmapBias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureUnitFiltering",
          "package": "lambdacube-engine",
          "signature": "TextureType -\u003e FilterOptions -\u003e FilterOptions -\u003e FilterOptions -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetTextureUnitFiltering",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetTextureUnitFiltering",
          "normalized": "TextureType-\u003eFilterOptions-\u003eFilterOptions-\u003eFilterOptions-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Texture Unit Filtering",
          "signature": "TextureType-\u003eFilterOptions-\u003eFilterOptions-\u003eFilterOptions-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetTextureUnitFiltering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetViewMatrix",
          "package": "lambdacube-engine",
          "signature": "GLRenderSystem -\u003e Proj4 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetViewMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetViewMatrix",
          "normalized": "GLRenderSystem-\u003eProj-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set View Matrix",
          "signature": "GLRenderSystem-\u003eProj-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetViewMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetViewport",
          "package": "lambdacube-engine",
          "signature": "Int -\u003e Int -\u003e Int -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetViewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetViewport",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set Viewport",
          "signature": "Int-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetViewport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetWorldMatrix",
          "package": "lambdacube-engine",
          "signature": "GLRenderSystem -\u003e Proj4 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetWorldMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetWorldMatrix",
          "normalized": "GLRenderSystem-\u003eProj-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Set World Matrix",
          "signature": "GLRenderSystem-\u003eProj-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetWorldMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetupMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4 -\u003e Proj4 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glSetupMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glSetupMatrix",
          "normalized": "Proj-\u003eProj-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Setup Matrix",
          "signature": "Proj-\u003eProj-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glSetupMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glUnBindGeometry",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities -\u003e RenderOperation GLVertexBuffer GLIndexBuffer -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glUnBindGeometry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glUnBindGeometry",
          "normalized": "RenderSystemCapabilities-\u003eRenderOperation GLVertexBuffer GLIndexBuffer-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Un Bind Geometry",
          "signature": "RenderSystemCapabilities-\u003eRenderOperation GLVertexBuffer GLIndexBuffer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glUnBindGeometry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glUnBindLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glUnBindLinkedGpuProgram",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glUnBindLinkedGpuProgram",
          "normalized": "IO()",
          "package": "lambdacube-engine",
          "partial": "Un Bind Linked Gpu Program",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glUnBindLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glUseLights",
          "package": "lambdacube-engine",
          "signature": "GLRenderSystem -\u003e [(Proj4, Light)] -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glUseLights",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glUseLights",
          "normalized": "GLRenderSystem-\u003e[(Proj,Light)]-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Use Lights",
          "signature": "GLRenderSystem-\u003e[(Proj,Light)]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glUseLights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glWithFrameBuffer",
          "package": "lambdacube-engine",
          "signature": "Int -\u003e Int -\u003e Int -\u003e Int -\u003e (Ptr Word8 -\u003e IO ()) -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#glWithFrameBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glWithFrameBuffer",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eInt-\u003e(Ptr Word-\u003eIO())-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "With Frame Buffer",
          "signature": "Int-\u003eInt-\u003eInt-\u003eInt-\u003e(Ptr Word-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glWithFrameBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsCapabilities",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLRenderSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsCapabilities",
          "package": "lambdacube-engine",
          "partial": "Capabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glrsCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsState",
          "package": "lambdacube-engine",
          "signature": "IORef GLState",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLRenderSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsState",
          "package": "lambdacube-engine",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glrsState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsViewMatrix",
          "package": "lambdacube-engine",
          "signature": "IORef Proj4",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLRenderSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsViewMatrix",
          "package": "lambdacube-engine",
          "partial": "View Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glrsViewMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsWorldMatrix",
          "package": "lambdacube-engine",
          "signature": "IORef Proj4",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLRenderSystem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "glrsWorldMatrix",
          "package": "lambdacube-engine",
          "partial": "World Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:glrsWorldMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.RenderSystem.GL.RenderSystem\",\"Graphics.LambdaCube.RenderSystem.GL\"]",
          "name": "mkGLRenderSystem",
          "package": "lambdacube-engine",
          "signature": "IO GLRenderSystem",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#mkGLRenderSystem",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:mkGLRenderSystem\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL.html#v:mkGLRenderSystem\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "mkGLRenderSystem",
          "package": "lambdacube-engine",
          "partial": "GLRender System",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:mkGLRenderSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "mkGLState",
          "package": "lambdacube-engine",
          "signature": "IO (IORef GLState)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#mkGLState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "mkGLState",
          "package": "lambdacube-engine",
          "partial": "GLState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:mkGLState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "stLight",
          "package": "lambdacube-engine",
          "signature": "(Proj4, [(Proj4, Light)])",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "stLight",
          "normalized": "(Proj,[(Proj,Light)])",
          "package": "lambdacube-engine",
          "partial": "Light",
          "signature": "(Proj,[(Proj,Light)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:stLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "stSurface",
          "package": "lambdacube-engine",
          "signature": "(FloatType4, FloatType4, FloatType4, FloatType4, FloatType, TrackVertexColourType)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#GLState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem.GL.RenderSystem",
          "name": "stSurface",
          "normalized": "(FloatType,FloatType,FloatType,FloatType,FloatType,TrackVertexColourType)",
          "package": "lambdacube-engine",
          "partial": "Surface",
          "signature": "(FloatType,FloatType,FloatType,FloatType,FloatType,TrackVertexColourType)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-RenderSystem.html#v:stSurface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "Texture",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "Texture",
          "package": "lambdacube-engine",
          "partial": "Texture",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "GLTexture",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "GLTexture",
          "package": "lambdacube-engine",
          "partial": "GLTexture",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#t:GLTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "GLTexture",
          "package": "lambdacube-engine",
          "signature": "GLTexture",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "GLTexture",
          "package": "lambdacube-engine",
          "partial": "GLTexture",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:GLTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDepth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDepth",
          "package": "lambdacube-engine",
          "partial": "Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDesiredFloatBitDepth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDesiredFloatBitDepth",
          "package": "lambdacube-engine",
          "partial": "Desired Float Bit Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxDesiredFloatBitDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDesiredFormat",
          "package": "lambdacube-engine",
          "signature": "PixelFormat",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDesiredFormat",
          "package": "lambdacube-engine",
          "partial": "Desired Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxDesiredFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDesiredIntegerBitDepth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxDesiredIntegerBitDepth",
          "package": "lambdacube-engine",
          "partial": "Desired Integer Bit Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxDesiredIntegerBitDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxFSAA",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxFSAA",
          "package": "lambdacube-engine",
          "partial": "FSAA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxFSAA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxFSAAHint",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxFSAAHint",
          "package": "lambdacube-engine",
          "partial": "FSAAHint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxFSAAHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxFormat",
          "package": "lambdacube-engine",
          "signature": "PixelFormat",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxFormat",
          "package": "lambdacube-engine",
          "partial": "Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxGamma",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxGamma",
          "package": "lambdacube-engine",
          "partial": "Gamma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxHeight",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxHeight",
          "package": "lambdacube-engine",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxHwGamma",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxHwGamma",
          "package": "lambdacube-engine",
          "partial": "Hw Gamma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxHwGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxMipmapsHardwareGenerated",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxMipmapsHardwareGenerated",
          "package": "lambdacube-engine",
          "partial": "Mipmaps Hardware Generated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxMipmapsHardwareGenerated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxNumMipmaps",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxNumMipmaps",
          "package": "lambdacube-engine",
          "partial": "Num Mipmaps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxNumMipmaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxNumRequestedMipmaps",
          "package": "lambdacube-engine",
          "signature": "TextureMipmap",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxNumRequestedMipmaps",
          "package": "lambdacube-engine",
          "partial": "Num Requested Mipmaps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxNumRequestedMipmaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcDepth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcDepth",
          "package": "lambdacube-engine",
          "partial": "Src Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxSrcDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcFormat",
          "package": "lambdacube-engine",
          "signature": "PixelFormat",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcFormat",
          "package": "lambdacube-engine",
          "partial": "Src Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxSrcFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcHeight",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcHeight",
          "package": "lambdacube-engine",
          "partial": "Src Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxSrcHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcWidth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxSrcWidth",
          "package": "lambdacube-engine",
          "partial": "Src Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxSrcWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxTextureObject",
          "package": "lambdacube-engine",
          "signature": "GLuint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxTextureObject",
          "package": "lambdacube-engine",
          "partial": "Texture Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxTextureObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxTextureType",
          "package": "lambdacube-engine",
          "signature": "TextureType",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxTextureType",
          "package": "lambdacube-engine",
          "partial": "Texture Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxTextureType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxTreatLuminanceAsAlpha",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxTreatLuminanceAsAlpha",
          "package": "lambdacube-engine",
          "partial": "Treat Luminance As Alpha",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxTreatLuminanceAsAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxUsage",
          "package": "lambdacube-engine",
          "signature": "TextureUsage",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxUsage",
          "package": "lambdacube-engine",
          "partial": "Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxWidth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#GLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "gltxWidth",
          "package": "lambdacube-engine",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:gltxWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "mkGLTexture",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities -\u003e String -\u003e TextureType -\u003e Int -\u003e Int -\u003e Int -\u003e TextureMipmap -\u003e PixelFormat -\u003e TextureUsage -\u003e Bool -\u003e Int -\u003e String -\u003e Maybe [Image] -\u003e IO GLTexture",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Texture.html#mkGLTexture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Texture",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Texture",
          "name": "mkGLTexture",
          "normalized": "RenderSystemCapabilities-\u003eString-\u003eTextureType-\u003eInt-\u003eInt-\u003eInt-\u003eTextureMipmap-\u003ePixelFormat-\u003eTextureUsage-\u003eBool-\u003eInt-\u003eString-\u003eMaybe[Image]-\u003eIO GLTexture",
          "package": "lambdacube-engine",
          "partial": "GLTexture",
          "signature": "RenderSystemCapabilities-\u003eString-\u003eTextureType-\u003eInt-\u003eInt-\u003eInt-\u003eTextureMipmap-\u003ePixelFormat-\u003eTextureUsage-\u003eBool-\u003eInt-\u003eString-\u003eMaybe[Image]-\u003eIO GLTexture",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Texture.html#v:mkGLTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "Utils",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "Utils",
          "package": "lambdacube-engine",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "convertCompareFunction",
          "package": "lambdacube-engine",
          "signature": "CompareFunction -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#convertCompareFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "convertCompareFunction",
          "normalized": "CompareFunction-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "Compare Function",
          "signature": "CompareFunction-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:convertCompareFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBlendEquation",
          "package": "lambdacube-engine",
          "signature": "SceneBlendOperation -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getBlendEquation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBlendEquation",
          "normalized": "SceneBlendOperation-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "Blend Equation",
          "signature": "SceneBlendOperation-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getBlendEquation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBlendMode",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getBlendMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBlendMode",
          "normalized": "SceneBlendFactor-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "Blend Mode",
          "signature": "SceneBlendFactor-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getBlendMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBoolean",
          "package": "lambdacube-engine",
          "signature": "GLenum -\u003e IO GLboolean",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getBoolean",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBoolean",
          "normalized": "GLenum-\u003eIO GLboolean",
          "package": "lambdacube-engine",
          "partial": "Boolean",
          "signature": "GLenum-\u003eIO GLboolean",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getBoolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBoolean4",
          "package": "lambdacube-engine",
          "signature": "GLenum -\u003e IO (GLboolean, GLboolean, GLboolean, GLboolean)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getBoolean4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getBoolean4",
          "normalized": "GLenum-\u003eIO(GLboolean,GLboolean,GLboolean,GLboolean)",
          "package": "lambdacube-engine",
          "partial": "Boolean",
          "signature": "GLenum-\u003eIO(GLboolean,GLboolean,GLboolean,GLboolean)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getBoolean4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getClosestGLInternalFormat",
          "package": "lambdacube-engine",
          "signature": "PixelFormat -\u003e Bool -\u003e GLint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getClosestGLInternalFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getClosestGLInternalFormat",
          "normalized": "PixelFormat-\u003eBool-\u003eGLint",
          "package": "lambdacube-engine",
          "partial": "Closest GLInternal Format",
          "signature": "PixelFormat-\u003eBool-\u003eGLint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getClosestGLInternalFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getFloat",
          "package": "lambdacube-engine",
          "signature": "GLenum -\u003e IO GLfloat",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getFloat",
          "normalized": "GLenum-\u003eIO GLfloat",
          "package": "lambdacube-engine",
          "partial": "Float",
          "signature": "GLenum-\u003eIO GLfloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLExtensions",
          "package": "lambdacube-engine",
          "signature": "IO [String]",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getGLExtensions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLExtensions",
          "normalized": "IO[String]",
          "package": "lambdacube-engine",
          "partial": "GLExtensions",
          "signature": "IO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getGLExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLTextureTarget",
          "package": "lambdacube-engine",
          "signature": "TextureType -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getGLTextureTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLTextureTarget",
          "normalized": "TextureType-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "GLTexture Target",
          "signature": "TextureType-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getGLTextureTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLType",
          "package": "lambdacube-engine",
          "signature": "VertexElementType -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getGLType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLType",
          "normalized": "VertexElementType-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "GLType",
          "signature": "VertexElementType-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getGLType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLUsage",
          "package": "lambdacube-engine",
          "signature": "Usage -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getGLUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLUsage",
          "normalized": "Usage-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "GLUsage",
          "signature": "Usage-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getGLUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLVersion",
          "package": "lambdacube-engine",
          "signature": "IO (Int, Int)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getGLVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getGLVersion",
          "normalized": "IO(Int,Int)",
          "package": "lambdacube-engine",
          "partial": "GLVersion",
          "signature": "IO(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getGLVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getInteger",
          "package": "lambdacube-engine",
          "signature": "GLenum -\u003e IO GLint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getInteger",
          "normalized": "GLenum-\u003eIO GLint",
          "package": "lambdacube-engine",
          "partial": "Integer",
          "signature": "GLenum-\u003eIO GLint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getInteger4",
          "package": "lambdacube-engine",
          "signature": "GLenum -\u003e IO (GLint, GLint, GLint, GLint)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getInteger4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getInteger4",
          "normalized": "GLenum-\u003eIO(GLint,GLint,GLint,GLint)",
          "package": "lambdacube-engine",
          "partial": "Integer",
          "signature": "GLenum-\u003eIO(GLint,GLint,GLint,GLint)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getInteger4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getLayerBlendSource",
          "package": "lambdacube-engine",
          "signature": "LayerBlendSource -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getLayerBlendSource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getLayerBlendSource",
          "normalized": "LayerBlendSource-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "Layer Blend Source",
          "signature": "LayerBlendSource-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getLayerBlendSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getMaxMipmaps",
          "package": "lambdacube-engine",
          "signature": "Int -\u003e Int -\u003e Int -\u003e PixelFormat -\u003e GLint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getMaxMipmaps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getMaxMipmaps",
          "normalized": "Int-\u003eInt-\u003eInt-\u003ePixelFormat-\u003eGLint",
          "package": "lambdacube-engine",
          "partial": "Max Mipmaps",
          "signature": "Int-\u003eInt-\u003eInt-\u003ePixelFormat-\u003eGLint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getMaxMipmaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getNativeFormat",
          "package": "lambdacube-engine",
          "signature": "TextureType -\u003e PixelFormat -\u003e Bool -\u003e PixelFormat",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getNativeFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getNativeFormat",
          "normalized": "TextureType-\u003ePixelFormat-\u003eBool-\u003ePixelFormat",
          "package": "lambdacube-engine",
          "partial": "Native Format",
          "signature": "TextureType-\u003ePixelFormat-\u003eBool-\u003ePixelFormat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getNativeFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getString",
          "package": "lambdacube-engine",
          "signature": "GLenum -\u003e IO String",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getString",
          "normalized": "GLenum-\u003eIO String",
          "package": "lambdacube-engine",
          "partial": "String",
          "signature": "GLenum-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getTextureAddressingMode",
          "package": "lambdacube-engine",
          "signature": "TextureAddressingMode -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getTextureAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getTextureAddressingMode",
          "normalized": "TextureAddressingMode-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "Texture Addressing Mode",
          "signature": "TextureAddressingMode-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getTextureAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getTextureCombineFunction",
          "package": "lambdacube-engine",
          "signature": "Bool -\u003e LayerBlendOperationEx -\u003e GLenum",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#getTextureCombineFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "getTextureCombineFunction",
          "normalized": "Bool-\u003eLayerBlendOperationEx-\u003eGLenum",
          "package": "lambdacube-engine",
          "partial": "Texture Combine Function",
          "signature": "Bool-\u003eLayerBlendOperationEx-\u003eGLenum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:getTextureCombineFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "optionalPO2",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities -\u003e Int -\u003e Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#optionalPO2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "optionalPO2",
          "normalized": "RenderSystemCapabilities-\u003eInt-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "PO",
          "signature": "RenderSystemCapabilities-\u003eInt-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:optionalPO2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "peek4",
          "package": "lambdacube-engine",
          "signature": "(a -\u003e a -\u003e a -\u003e a -\u003e b) -\u003e Ptr a -\u003e IO b",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#peek4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "peek4",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003eb)-\u003ePtr a-\u003eIO b",
          "package": "lambdacube-engine",
          "signature": "(a-\u003ea-\u003ea-\u003ea-\u003eb)-\u003ePtr a-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:peek4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "peek4M",
          "package": "lambdacube-engine",
          "signature": "(a -\u003e a -\u003e a -\u003e a -\u003e IO b) -\u003e Ptr a -\u003e IO b",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-Utils.html#peek4M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL Utils",
          "module": "Graphics.LambdaCube.RenderSystem.GL.Utils",
          "name": "peek4M",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003eIO b)-\u003ePtr a-\u003eIO b",
          "package": "lambdacube-engine",
          "signature": "(a-\u003ea-\u003ea-\u003ea-\u003eIO b)-\u003ePtr a-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-Utils.html#v:peek4M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "VertexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "VertexBuffer",
          "package": "lambdacube-engine",
          "partial": "Vertex Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialisation of HardwareVertexBuffer for GL\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "GLVertexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "data"
        },
        "index": {
          "description": "Specialisation of HardwareVertexBuffer for GL",
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "GLVertexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLVertex Buffer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#t:GLVertexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "GLVertexBuffer",
          "package": "lambdacube-engine",
          "signature": "GLVertexBuffer",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "GLVertexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLVertex Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:GLVertexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbBufferObject",
          "package": "lambdacube-engine",
          "signature": "GLuint",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbBufferObject",
          "package": "lambdacube-engine",
          "partial": "Buffer Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbBufferObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbIsLocked",
          "package": "lambdacube-engine",
          "signature": "GLVertexBuffer -\u003e IO Bool",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#glvbIsLocked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbIsLocked",
          "normalized": "GLVertexBuffer-\u003eIO Bool",
          "package": "lambdacube-engine",
          "partial": "Is Locked",
          "signature": "GLVertexBuffer-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbIsLocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbLock",
          "package": "lambdacube-engine",
          "signature": "GLVertexBuffer -\u003e Int -\u003e Int -\u003e LockOptions -\u003e IO (Ptr Word8)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#glvbLock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbLock",
          "normalized": "GLVertexBuffer-\u003eInt-\u003eInt-\u003eLockOptions-\u003eIO(Ptr Word)",
          "package": "lambdacube-engine",
          "partial": "Lock",
          "signature": "GLVertexBuffer-\u003eInt-\u003eInt-\u003eLockOptions-\u003eIO(Ptr Word)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbLockInfo",
          "package": "lambdacube-engine",
          "signature": "IORef (Maybe (Int, Int, Bool))",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbLockInfo",
          "normalized": "IORef(Maybe(Int,Int,Bool))",
          "package": "lambdacube-engine",
          "partial": "Lock Info",
          "signature": "IORef(Maybe(Int,Int,Bool))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbLockInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbNumVertices",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbNumVertices",
          "package": "lambdacube-engine",
          "partial": "Num Vertices",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbNumVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbShadowBuffer",
          "package": "lambdacube-engine",
          "signature": "Maybe (Ptr Word8)",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbShadowBuffer",
          "package": "lambdacube-engine",
          "partial": "Shadow Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbShadowBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbUnlock",
          "package": "lambdacube-engine",
          "signature": "GLVertexBuffer -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#glvbUnlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbUnlock",
          "normalized": "GLVertexBuffer-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Unlock",
          "signature": "GLVertexBuffer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbUnlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbUsage",
          "package": "lambdacube-engine",
          "signature": "Usage",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbUsage",
          "package": "lambdacube-engine",
          "partial": "Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbVertexSize",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "glvbVertexSize",
          "package": "lambdacube-engine",
          "partial": "Vertex Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:glvbVertexSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "mkGLVertexBuffer",
          "package": "lambdacube-engine",
          "signature": "Int -\u003e Int -\u003e Usage -\u003e Bool -\u003e IO GLVertexBuffer",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#mkGLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "mkGLVertexBuffer",
          "normalized": "Int-\u003eInt-\u003eUsage-\u003eBool-\u003eIO GLVertexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLVertex Buffer",
          "signature": "Int-\u003eInt-\u003eUsage-\u003eBool-\u003eIO GLVertexBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:mkGLVertexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "rmGLVertexBuffer",
          "package": "lambdacube-engine",
          "signature": "GLVertexBuffer -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#rmGLVertexBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL VertexBuffer",
          "module": "Graphics.LambdaCube.RenderSystem.GL.VertexBuffer",
          "name": "rmGLVertexBuffer",
          "normalized": "GLVertexBuffer-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "GLVertex Buffer",
          "signature": "GLVertexBuffer-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#v:rmGLVertexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GL",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL",
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GL",
          "package": "lambdacube-engine",
          "partial": "GL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLEntity",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL.html#GLEntity",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL",
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLEntity",
          "package": "lambdacube-engine",
          "partial": "GLEntity",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL.html#t:GLEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialisation of HardwareIndexBuffer for GL\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLIndexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-IndexBuffer.html#GLIndexBuffer",
          "type": "data"
        },
        "index": {
          "description": "Specialisation of HardwareIndexBuffer for GL",
          "hierarchy": "Graphics LambdaCube RenderSystem GL",
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLIndexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLIndex Buffer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL.html#t:GLIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLRenderEntity",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL.html#GLRenderEntity",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem GL",
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLRenderEntity",
          "package": "lambdacube-engine",
          "partial": "GLRender Entity",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL.html#t:GLRenderEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialisation of HardwareVertexBuffer for GL\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLVertexBuffer",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem-GL-VertexBuffer.html#GLVertexBuffer",
          "type": "data"
        },
        "index": {
          "description": "Specialisation of HardwareVertexBuffer for GL",
          "hierarchy": "Graphics LambdaCube RenderSystem GL",
          "module": "Graphics.LambdaCube.RenderSystem.GL",
          "name": "GLVertexBuffer",
          "package": "lambdacube-engine",
          "partial": "GLVertex Buffer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem-GL.html#t:GLVertexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "partial": "Render System",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderEntity",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderEntity",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderEntity",
          "package": "lambdacube-engine",
          "partial": "Render Entity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#t:RenderEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderSystem",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "partial": "Render System",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#t:RenderSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "Renderable",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#Renderable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "Renderable",
          "package": "lambdacube-engine",
          "partial": "Renderable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#t:Renderable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "StencilOperation",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "StencilOperation",
          "package": "lambdacube-engine",
          "partial": "Stencil Operation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#t:StencilOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TexCoordCalcMethod",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#TexCoordCalcMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TexCoordCalcMethod",
          "package": "lambdacube-engine",
          "partial": "Tex Coord Calc Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#t:TexCoordCalcMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderEntity",
          "package": "lambdacube-engine",
          "signature": "RenderEntity",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "RenderEntity",
          "package": "lambdacube-engine",
          "partial": "Render Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:RenderEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrease the stencil value by 1, clamping at 0\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_DECREMENT",
          "package": "lambdacube-engine",
          "signature": "SOP_DECREMENT",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Decrease the stencil value by clamping at",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_DECREMENT",
          "package": "lambdacube-engine",
          "partial": "SOP DECREMENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_DECREMENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrease the stencil value by 1, wrapping when decrementing 0\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_DECREMENT_WRAP",
          "package": "lambdacube-engine",
          "signature": "SOP_DECREMENT_WRAP",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Decrease the stencil value by wrapping when decrementing",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_DECREMENT_WRAP",
          "package": "lambdacube-engine",
          "partial": "SOP DECREMENT WRAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_DECREMENT_WRAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrease the stencil value by 1, clamping at the maximum value\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_INCREMENT",
          "package": "lambdacube-engine",
          "signature": "SOP_INCREMENT",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Increase the stencil value by clamping at the maximum value",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_INCREMENT",
          "package": "lambdacube-engine",
          "partial": "SOP INCREMENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_INCREMENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrease the stencil value by 1, wrapping back to 0 when incrementing the maximum value\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_INCREMENT_WRAP",
          "package": "lambdacube-engine",
          "signature": "SOP_INCREMENT_WRAP",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Increase the stencil value by wrapping back to when incrementing the maximum value",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_INCREMENT_WRAP",
          "package": "lambdacube-engine",
          "partial": "SOP INCREMENT WRAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_INCREMENT_WRAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert the bits of the stencil buffer\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_INVERT",
          "package": "lambdacube-engine",
          "signature": "SOP_INVERT",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Invert the bits of the stencil buffer",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_INVERT",
          "package": "lambdacube-engine",
          "partial": "SOP INVERT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_INVERT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeave the stencil buffer unchanged\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_KEEP",
          "package": "lambdacube-engine",
          "signature": "SOP_KEEP",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Leave the stencil buffer unchanged",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_KEEP",
          "package": "lambdacube-engine",
          "partial": "SOP KEEP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_KEEP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the stencil value to the reference value\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_REPLACE",
          "package": "lambdacube-engine",
          "signature": "SOP_REPLACE",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Set the stencil value to the reference value",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_REPLACE",
          "package": "lambdacube-engine",
          "partial": "SOP REPLACE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_REPLACE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the stencil value to zero\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_ZERO",
          "package": "lambdacube-engine",
          "signature": "SOP_ZERO",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#StencilOperation",
          "type": "function"
        },
        "index": {
          "description": "Set the stencil value to zero",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "SOP_ZERO",
          "package": "lambdacube-engine",
          "partial": "SOP ZERO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:SOP_ZERO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironment map based on vertex normals\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP",
          "package": "lambdacube-engine",
          "signature": "TEXCALC_ENVIRONMENT_MAP",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#TexCoordCalcMethod",
          "type": "function"
        },
        "index": {
          "description": "Environment map based on vertex normals",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP",
          "package": "lambdacube-engine",
          "partial": "TEXCALC ENVIRONMENT MAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:TEXCALC_ENVIRONMENT_MAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironment map based on vertex positions\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP_NORMAL",
          "package": "lambdacube-engine",
          "signature": "TEXCALC_ENVIRONMENT_MAP_NORMAL",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#TexCoordCalcMethod",
          "type": "function"
        },
        "index": {
          "description": "Environment map based on vertex positions",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP_NORMAL",
          "package": "lambdacube-engine",
          "partial": "TEXCALC ENVIRONMENT MAP NORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:TEXCALC_ENVIRONMENT_MAP_NORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironment map based on vertex positions\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP_PLANAR",
          "package": "lambdacube-engine",
          "signature": "TEXCALC_ENVIRONMENT_MAP_PLANAR",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#TexCoordCalcMethod",
          "type": "function"
        },
        "index": {
          "description": "Environment map based on vertex positions",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP_PLANAR",
          "package": "lambdacube-engine",
          "partial": "TEXCALC ENVIRONMENT MAP PLANAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:TEXCALC_ENVIRONMENT_MAP_PLANAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvironment map based on vertex positions\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP_REFLECTION",
          "package": "lambdacube-engine",
          "signature": "TEXCALC_ENVIRONMENT_MAP_REFLECTION",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#TexCoordCalcMethod",
          "type": "function"
        },
        "index": {
          "description": "Environment map based on vertex positions",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_ENVIRONMENT_MAP_REFLECTION",
          "package": "lambdacube-engine",
          "partial": "TEXCALC ENVIRONMENT MAP REFLECTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:TEXCALC_ENVIRONMENT_MAP_REFLECTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo calculated texture coordinates\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_NONE",
          "package": "lambdacube-engine",
          "signature": "TEXCALC_NONE",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#TexCoordCalcMethod",
          "type": "function"
        },
        "index": {
          "description": "No calculated texture coordinates",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_NONE",
          "package": "lambdacube-engine",
          "partial": "TEXCALC NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:TEXCALC_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjective texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_PROJECTIVE_TEXTURE",
          "package": "lambdacube-engine",
          "signature": "TEXCALC_PROJECTIVE_TEXTURE",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#TexCoordCalcMethod",
          "type": "function"
        },
        "index": {
          "description": "Projective texture",
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "TEXCALC_PROJECTIVE_TEXTURE",
          "package": "lambdacube-engine",
          "partial": "TEXCALC PROJECTIVE TEXTURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:TEXCALC_PROJECTIVE_TEXTURE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "bindGeometry",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e RenderOperation vb ib -\u003e [TextureUnitState t] -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#bindGeometry",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "bindGeometry",
          "normalized": "a-\u003eRenderOperation b c-\u003e[TextureUnitState d]-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Geometry",
          "signature": "rs-\u003eRenderOperation vb ib-\u003e[TextureUnitState t]-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:bindGeometry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "bindLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e lp -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#bindLinkedGpuProgram",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "bindLinkedGpuProgram",
          "normalized": "a-\u003eb-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Linked Gpu Program",
          "signature": "rs-\u003elp-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:bindLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "clearFrameBuffer",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FrameBufferType -\u003e ColourValue -\u003e FloatType -\u003e Word16 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#clearFrameBuffer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "clearFrameBuffer",
          "normalized": "a-\u003eFrameBufferType-\u003eColourValue-\u003eFloatType-\u003eWord-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Frame Buffer",
          "signature": "rs-\u003eFrameBufferType-\u003eColourValue-\u003eFloatType-\u003eWord-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:clearFrameBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createGpuProgram",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e GpuProgramType -\u003e String -\u003e IO (Either p String)",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#createGpuProgram",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createGpuProgram",
          "normalized": "a-\u003eGpuProgramType-\u003eString-\u003eIO(Either b String)",
          "package": "lambdacube-engine",
          "partial": "Gpu Program",
          "signature": "rs-\u003eGpuProgramType-\u003eString-\u003eIO(Either p String)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:createGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createIndexBuffer",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e IndexType -\u003e Int -\u003e Usage -\u003e Bool -\u003e IO ib",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#createIndexBuffer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createIndexBuffer",
          "normalized": "a-\u003eIndexType-\u003eInt-\u003eUsage-\u003eBool-\u003eIO b",
          "package": "lambdacube-engine",
          "partial": "Index Buffer",
          "signature": "rs-\u003eIndexType-\u003eInt-\u003eUsage-\u003eBool-\u003eIO ib",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:createIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e [p] -\u003e IO (Either lp String)",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#createLinkedGpuProgram",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createLinkedGpuProgram",
          "normalized": "a-\u003e[b]-\u003eIO(Either c String)",
          "package": "lambdacube-engine",
          "partial": "Linked Gpu Program",
          "signature": "rs-\u003e[p]-\u003eIO(Either lp String)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:createLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createOcclusionQuery",
          "package": "lambdacube-engine",
          "signature": "createOcclusionQuery",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#createOcclusionQuery",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createOcclusionQuery",
          "package": "lambdacube-engine",
          "partial": "Occlusion Query",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:createOcclusionQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createTexture",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e String -\u003e TextureType -\u003e Int -\u003e Int -\u003e Int -\u003e TextureMipmap -\u003e PixelFormat -\u003e TextureUsage -\u003e Bool -\u003e Int -\u003e String -\u003e Maybe [Image] -\u003e IO t",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#createTexture",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createTexture",
          "normalized": "a-\u003eString-\u003eTextureType-\u003eInt-\u003eInt-\u003eInt-\u003eTextureMipmap-\u003ePixelFormat-\u003eTextureUsage-\u003eBool-\u003eInt-\u003eString-\u003eMaybe[Image]-\u003eIO b",
          "package": "lambdacube-engine",
          "partial": "Texture",
          "signature": "rs-\u003eString-\u003eTextureType-\u003eInt-\u003eInt-\u003eInt-\u003eTextureMipmap-\u003ePixelFormat-\u003eTextureUsage-\u003eBool-\u003eInt-\u003eString-\u003eMaybe[Image]-\u003eIO t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:createTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createVertexBuffer",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Int -\u003e Int -\u003e Usage -\u003e Bool -\u003e IO vb",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#createVertexBuffer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "createVertexBuffer",
          "normalized": "a-\u003eInt-\u003eInt-\u003eUsage-\u003eBool-\u003eIO b",
          "package": "lambdacube-engine",
          "partial": "Vertex Buffer",
          "signature": "rs-\u003eInt-\u003eInt-\u003eUsage-\u003eBool-\u003eIO vb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:createVertexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "dirtyHackCopyTexImage",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e t -\u003e Int -\u003e Int -\u003e Int -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#dirtyHackCopyTexImage",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "dirtyHackCopyTexImage",
          "normalized": "a-\u003eb-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Hack Copy Tex Image",
          "signature": "rs-\u003et-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:dirtyHackCopyTexImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "finishRender",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#finishRender",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "finishRender",
          "normalized": "a-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Render",
          "signature": "rs-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:finishRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getCapabilities",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e RenderSystemCapabilities",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#getCapabilities",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getCapabilities",
          "normalized": "a-\u003eRenderSystemCapabilities",
          "package": "lambdacube-engine",
          "partial": "Capabilities",
          "signature": "rs-\u003eRenderSystemCapabilities",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:getCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getHorizontalTexelOffset",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e IO FloatType",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#getHorizontalTexelOffset",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getHorizontalTexelOffset",
          "normalized": "a-\u003eIO FloatType",
          "package": "lambdacube-engine",
          "partial": "Horizontal Texel Offset",
          "signature": "rs-\u003eIO FloatType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:getHorizontalTexelOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getMaximumDepthInputValue",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FloatType",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#getMaximumDepthInputValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getMaximumDepthInputValue",
          "normalized": "a-\u003eFloatType",
          "package": "lambdacube-engine",
          "partial": "Maximum Depth Input Value",
          "signature": "rs-\u003eFloatType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:getMaximumDepthInputValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getMinimumDepthInputValue",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FloatType",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#getMinimumDepthInputValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getMinimumDepthInputValue",
          "normalized": "a-\u003eFloatType",
          "package": "lambdacube-engine",
          "partial": "Minimum Depth Input Value",
          "signature": "rs-\u003eFloatType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:getMinimumDepthInputValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getName",
          "package": "lambdacube-engine",
          "signature": "getName",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#getName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:getName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getVerticalTexelOffset",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e IO FloatType",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#getVerticalTexelOffset",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "getVerticalTexelOffset",
          "normalized": "a-\u003eIO FloatType",
          "package": "lambdacube-engine",
          "partial": "Vertical Texel Offset",
          "signature": "rs-\u003eIO FloatType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:getVerticalTexelOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "prepare",
          "package": "lambdacube-engine",
          "signature": "Proj4 -\u003e r -\u003e [RenderEntity vb ib t lp]",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#prepare",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "prepare",
          "normalized": "Proj-\u003ea-\u003e[RenderEntity b c d e]",
          "package": "lambdacube-engine",
          "signature": "Proj-\u003er-\u003e[RenderEntity vb ib t lp]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:prepare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "prepareRender",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#prepareRender",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "prepareRender",
          "normalized": "a-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Render",
          "signature": "rs-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:prepareRender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "reBoundRadius",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "reBoundRadius",
          "package": "lambdacube-engine",
          "partial": "Bound Radius",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:reBoundRadius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "reMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "reMatrix",
          "package": "lambdacube-engine",
          "partial": "Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:reMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "reOperation",
          "package": "lambdacube-engine",
          "signature": "RenderOperation vb ib",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "reOperation",
          "package": "lambdacube-engine",
          "partial": "Operation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:reOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "rePassList",
          "package": "lambdacube-engine",
          "signature": "[Pass t lp]",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "rePassList",
          "normalized": "[Pass a b]",
          "package": "lambdacube-engine",
          "partial": "Pass List",
          "signature": "[Pass t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:rePassList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "render",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e RenderOperation vb ib -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#render",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "render",
          "normalized": "a-\u003eRenderOperation b c-\u003eIO()",
          "package": "lambdacube-engine",
          "signature": "rs-\u003eRenderOperation vb ib-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:render"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setActiveTextureUnit",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setActiveTextureUnit",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setActiveTextureUnit",
          "normalized": "a-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Active Texture Unit",
          "signature": "rs-\u003eInt-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setActiveTextureUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setAlphaRejectSettings",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e CompareFunction -\u003e Int -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setAlphaRejectSettings",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setAlphaRejectSettings",
          "normalized": "a-\u003eCompareFunction-\u003eInt-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Alpha Reject Settings",
          "signature": "rs-\u003eCompareFunction-\u003eInt-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setAlphaRejectSettings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setAmbientLight",
          "package": "lambdacube-engine",
          "signature": "setAmbientLight",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setAmbientLight",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setAmbientLight",
          "package": "lambdacube-engine",
          "partial": "Ambient Light",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setAmbientLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setColourBufferWriteEnabled",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e Bool -\u003e Bool -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setColourBufferWriteEnabled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setColourBufferWriteEnabled",
          "normalized": "a-\u003eBool-\u003eBool-\u003eBool-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Colour Buffer Write Enabled",
          "signature": "rs-\u003eBool-\u003eBool-\u003eBool-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setColourBufferWriteEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setCullingMode",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e CullingMode -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setCullingMode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setCullingMode",
          "normalized": "a-\u003eCullingMode-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Culling Mode",
          "signature": "rs-\u003eCullingMode-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setCullingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBias",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FloatType -\u003e FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setDepthBias",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBias",
          "normalized": "a-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Depth Bias",
          "signature": "rs-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setDepthBias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferCheckEnabled",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setDepthBufferCheckEnabled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferCheckEnabled",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Depth Buffer Check Enabled",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setDepthBufferCheckEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferFunction",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e CompareFunction -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setDepthBufferFunction",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferFunction",
          "normalized": "a-\u003eCompareFunction-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Depth Buffer Function",
          "signature": "rs-\u003eCompareFunction-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setDepthBufferFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferParams",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e Bool -\u003e CompareFunction -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setDepthBufferParams",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferParams",
          "normalized": "a-\u003eBool-\u003eBool-\u003eCompareFunction-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Depth Buffer Params",
          "signature": "rs-\u003eBool-\u003eBool-\u003eCompareFunction-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setDepthBufferParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferWriteEnabled",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setDepthBufferWriteEnabled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setDepthBufferWriteEnabled",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Depth Buffer Write Enabled",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setDepthBufferWriteEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setFog",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FogMode -\u003e ColourValue -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setFog",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setFog",
          "normalized": "a-\u003eFogMode-\u003eColourValue-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Fog",
          "signature": "rs-\u003eFogMode-\u003eColourValue-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setFog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setLightingEnabled",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setLightingEnabled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setLightingEnabled",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Lighting Enabled",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setLightingEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setNormaliseNormals",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setNormaliseNormals",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setNormaliseNormals",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Normalise Normals",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setNormaliseNormals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPass",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e rs -\u003e Pass t lp -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setPass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPass",
          "normalized": "FloatType-\u003ea-\u003ePass b c-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Pass",
          "signature": "FloatType-\u003ers-\u003ePass t lp-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setPass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPointParameters",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FloatType -\u003e Bool -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setPointParameters",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPointParameters",
          "normalized": "a-\u003eFloatType-\u003eBool-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Point Parameters",
          "signature": "rs-\u003eFloatType-\u003eBool-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setPointParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPointSpritesEnabled",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setPointSpritesEnabled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPointSpritesEnabled",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Point Sprites Enabled",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setPointSpritesEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPolygonMode",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e PolygonMode -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setPolygonMode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setPolygonMode",
          "normalized": "a-\u003ePolygonMode-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Polygon Mode",
          "signature": "rs-\u003ePolygonMode-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setPolygonMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setProjectionMatrix",
          "package": "lambdacube-engine",
          "signature": "setProjectionMatrix",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setProjectionMatrix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setProjectionMatrix",
          "package": "lambdacube-engine",
          "partial": "Projection Matrix",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setProjectionMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setSceneBlending",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendOperation -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setSceneBlending",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setSceneBlending",
          "normalized": "a-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Scene Blending",
          "signature": "rs-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setSceneBlending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setScissorTest",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e Int -\u003e Int -\u003e Int -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setScissorTest",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setScissorTest",
          "normalized": "a-\u003eBool-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Scissor Test",
          "signature": "rs-\u003eBool-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setScissorTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setSeparateSceneBlending",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendFactor -\u003e SceneBlendOperation -\u003e SceneBlendOperation -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setSeparateSceneBlending",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setSeparateSceneBlending",
          "normalized": "a-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eSceneBlendOperation-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Separate Scene Blending",
          "signature": "rs-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendFactor-\u003eSceneBlendOperation-\u003eSceneBlendOperation-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setSeparateSceneBlending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setShadingType",
          "package": "lambdacube-engine",
          "signature": "setShadingType",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setShadingType",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setShadingType",
          "package": "lambdacube-engine",
          "partial": "Shading Type",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setShadingType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setStencilBufferParams",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e CompareFunction -\u003e Word32 -\u003e Word32 -\u003e StencilOperation -\u003e StencilOperation -\u003e StencilOperation -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setStencilBufferParams",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setStencilBufferParams",
          "normalized": "a-\u003eCompareFunction-\u003eWord-\u003eWord-\u003eStencilOperation-\u003eStencilOperation-\u003eStencilOperation-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Stencil Buffer Params",
          "signature": "rs-\u003eCompareFunction-\u003eWord-\u003eWord-\u003eStencilOperation-\u003eStencilOperation-\u003eStencilOperation-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setStencilBufferParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setStencilCheckEnabled",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setStencilCheckEnabled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setStencilCheckEnabled",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Stencil Check Enabled",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setStencilCheckEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setSurfaceParams",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e ColourValue -\u003e ColourValue -\u003e ColourValue -\u003e ColourValue -\u003e FloatType -\u003e TrackVertexColourType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setSurfaceParams",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setSurfaceParams",
          "normalized": "a-\u003eColourValue-\u003eColourValue-\u003eColourValue-\u003eColourValue-\u003eFloatType-\u003eTrackVertexColourType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Surface Params",
          "signature": "rs-\u003eColourValue-\u003eColourValue-\u003eColourValue-\u003eColourValue-\u003eFloatType-\u003eTrackVertexColourType-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setSurfaceParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTexture",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Maybe t -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTexture",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTexture",
          "normalized": "a-\u003eMaybe b-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture",
          "signature": "rs-\u003eMaybe t-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureAddressingMode",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e TextureType -\u003e UVWAddressingMode -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureAddressingMode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureAddressingMode",
          "normalized": "a-\u003eTextureType-\u003eUVWAddressingMode-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Addressing Mode",
          "signature": "rs-\u003eTextureType-\u003eUVWAddressingMode-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureBlendMode",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e LayerBlendModeEx -\u003e LayerBlendModeEx -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureBlendMode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureBlendMode",
          "normalized": "a-\u003eLayerBlendModeEx-\u003eLayerBlendModeEx-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Blend Mode",
          "signature": "rs-\u003eLayerBlendModeEx-\u003eLayerBlendModeEx-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureBlendMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureBorderColour",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e TextureType -\u003e ColourValue -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureBorderColour",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureBorderColour",
          "normalized": "a-\u003eTextureType-\u003eColourValue-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Border Colour",
          "signature": "rs-\u003eTextureType-\u003eColourValue-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureBorderColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureCoordCalculation",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e TexCoordCalcMethod -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureCoordCalculation",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureCoordCalculation",
          "normalized": "a-\u003eTexCoordCalcMethod-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Coord Calculation",
          "signature": "rs-\u003eTexCoordCalcMethod-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureCoordCalculation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureLayerAnisotropy",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e TextureType -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureLayerAnisotropy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureLayerAnisotropy",
          "normalized": "a-\u003eTextureType-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Layer Anisotropy",
          "signature": "rs-\u003eTextureType-\u003eInt-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureLayerAnisotropy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureMatrix",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Proj4 -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureMatrix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureMatrix",
          "normalized": "a-\u003eProj-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Matrix",
          "signature": "rs-\u003eProj-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureMipmapBias",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e FloatType -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureMipmapBias",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureMipmapBias",
          "normalized": "a-\u003eFloatType-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Mipmap Bias",
          "signature": "rs-\u003eFloatType-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureMipmapBias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureUnitFiltering",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e TextureType -\u003e FilterOptions -\u003e FilterOptions -\u003e FilterOptions -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureUnitFiltering",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureUnitFiltering",
          "normalized": "a-\u003eTextureType-\u003eFilterOptions-\u003eFilterOptions-\u003eFilterOptions-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Unit Filtering",
          "signature": "rs-\u003eTextureType-\u003eFilterOptions-\u003eFilterOptions-\u003eFilterOptions-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureUnitFiltering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureUnitSettings",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e rs -\u003e Int -\u003e TextureUnitState t -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setTextureUnitSettings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setTextureUnitSettings",
          "normalized": "FloatType-\u003ea-\u003eInt-\u003eTextureUnitState b-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Texture Unit Settings",
          "signature": "FloatType-\u003ers-\u003eInt-\u003eTextureUnitState t-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setTextureUnitSettings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setVertexTexture",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Maybe t -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setVertexTexture",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setVertexTexture",
          "normalized": "a-\u003eMaybe b-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Vertex Texture",
          "signature": "rs-\u003eMaybe t-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setVertexTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setViewMatrix",
          "package": "lambdacube-engine",
          "signature": "setViewMatrix",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setViewMatrix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setViewMatrix",
          "package": "lambdacube-engine",
          "partial": "View Matrix",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setViewMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setViewport",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Int -\u003e Int -\u003e Int -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setViewport",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setViewport",
          "normalized": "a-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Viewport",
          "signature": "rs-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setViewport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setWBufferEnabled",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setWBufferEnabled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setWBufferEnabled",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "WBuffer Enabled",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setWBufferEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setWaitForVerticalBlank",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Bool -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setWaitForVerticalBlank",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setWaitForVerticalBlank",
          "normalized": "a-\u003eBool-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Wait For Vertical Blank",
          "signature": "rs-\u003eBool-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setWaitForVerticalBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setWorldMatrix",
          "package": "lambdacube-engine",
          "signature": "setWorldMatrix",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#setWorldMatrix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "setWorldMatrix",
          "package": "lambdacube-engine",
          "partial": "World Matrix",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:setWorldMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "unbindGeometry",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e RenderOperation vb ib -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#unbindGeometry",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "unbindGeometry",
          "normalized": "a-\u003eRenderOperation b c-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Geometry",
          "signature": "rs-\u003eRenderOperation vb ib-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:unbindGeometry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "unbindLinkedGpuProgram",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#unbindLinkedGpuProgram",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "unbindLinkedGpuProgram",
          "normalized": "a-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Linked Gpu Program",
          "signature": "rs-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:unbindLinkedGpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "useLights",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e [(Proj4, Light)] -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#useLights",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "useLights",
          "normalized": "a-\u003e[(Proj,Light)]-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Lights",
          "signature": "rs-\u003e[(Proj,Light)]-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:useLights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "withFrameBuffer",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Int -\u003e Int -\u003e Int -\u003e Int -\u003e (Ptr Word8 -\u003e IO ()) -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#withFrameBuffer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystem",
          "module": "Graphics.LambdaCube.RenderSystem",
          "name": "withFrameBuffer",
          "normalized": "a-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003e(Ptr Word-\u003eIO())-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "Frame Buffer",
          "signature": "rs-\u003eInt-\u003eInt-\u003eInt-\u003eInt-\u003e(Ptr Word-\u003eIO())-\u003eIO()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystem.html#v:withFrameBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RenderSystemCapabilities",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RenderSystemCapabilities",
          "package": "lambdacube-engine",
          "partial": "Render System Capabilities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "Capabilities",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "Capabilities",
          "package": "lambdacube-engine",
          "partial": "Capabilities",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#t:Capabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "DriverVersion",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#DriverVersion",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "DriverVersion",
          "package": "lambdacube-engine",
          "partial": "Driver Version",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#t:DriverVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumeration of GPU vendors.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPUVendor",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "data"
        },
        "index": {
          "description": "Enumeration of GPU vendors",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPUVendor",
          "package": "lambdacube-engine",
          "partial": "GPUVendor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#t:GPUVendor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RenderSystemCapabilities",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RenderSystemCapabilities",
          "package": "lambdacube-engine",
          "partial": "Render System Capabilities",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#t:RenderSystemCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "DriverVersion",
          "package": "lambdacube-engine",
          "signature": "DriverVersion",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#DriverVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "DriverVersion",
          "package": "lambdacube-engine",
          "partial": "Driver Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:DriverVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_3DLABS",
          "package": "lambdacube-engine",
          "signature": "GPU_3DLABS",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_3DLABS",
          "package": "lambdacube-engine",
          "partial": "GPU DLABS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_3DLABS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApple Software Renderer\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_APPLE",
          "package": "lambdacube-engine",
          "signature": "GPU_APPLE",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "description": "Apple Software Renderer",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_APPLE",
          "package": "lambdacube-engine",
          "partial": "GPU APPLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_APPLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_ATI",
          "package": "lambdacube-engine",
          "signature": "GPU_ATI",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_ATI",
          "package": "lambdacube-engine",
          "partial": "GPU ATI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_ATI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_IMAGINATION_TECHNOLOGIES",
          "package": "lambdacube-engine",
          "signature": "GPU_IMAGINATION_TECHNOLOGIES",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_IMAGINATION_TECHNOLOGIES",
          "package": "lambdacube-engine",
          "partial": "GPU IMAGINATION TECHNOLOGIES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_IMAGINATION_TECHNOLOGIES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_INTEL",
          "package": "lambdacube-engine",
          "signature": "GPU_INTEL",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_INTEL",
          "package": "lambdacube-engine",
          "partial": "GPU INTEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_INTEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_MATROX",
          "package": "lambdacube-engine",
          "signature": "GPU_MATROX",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_MATROX",
          "package": "lambdacube-engine",
          "partial": "GPU MATROX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_MATROX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_NVIDIA",
          "package": "lambdacube-engine",
          "signature": "GPU_NVIDIA",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_NVIDIA",
          "package": "lambdacube-engine",
          "partial": "GPU NVIDIA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_NVIDIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_S3",
          "package": "lambdacube-engine",
          "signature": "GPU_S3",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_S3",
          "package": "lambdacube-engine",
          "partial": "GPU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_S3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_SIS",
          "package": "lambdacube-engine",
          "signature": "GPU_SIS",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_SIS",
          "package": "lambdacube-engine",
          "partial": "GPU SIS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_SIS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_UNKNOWN",
          "package": "lambdacube-engine",
          "signature": "GPU_UNKNOWN",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#GPUVendor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "GPU_UNKNOWN",
          "package": "lambdacube-engine",
          "partial": "GPU UNKNOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:GPU_UNKNOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports Blending operations other than +\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_ADVANCED_BLEND_OPERATIONS",
          "package": "lambdacube-engine",
          "signature": "RSC_ADVANCED_BLEND_OPERATIONS",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports Blending operations other than",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_ADVANCED_BLEND_OPERATIONS",
          "package": "lambdacube-engine",
          "partial": "RSC ADVANCED BLEND OPERATIONS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_ADVANCED_BLEND_OPERATIONS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports Alpha to Coverage (A2C)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_ALPHA_TO_COVERAGE",
          "package": "lambdacube-engine",
          "signature": "RSC_ALPHA_TO_COVERAGE",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports Alpha to Coverage A2C",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_ALPHA_TO_COVERAGE",
          "package": "lambdacube-engine",
          "partial": "RSC ALPHA TO COVERAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_ALPHA_TO_COVERAGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports anisotropic texture filtering\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_ANISOTROPY",
          "package": "lambdacube-engine",
          "signature": "RSC_ANISOTROPY",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports anisotropic texture filtering",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_ANISOTROPY",
          "package": "lambdacube-engine",
          "partial": "RSC ANISOTROPY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_ANISOTROPY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports generating mipmaps in hardware\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_AUTOMIPMAP",
          "package": "lambdacube-engine",
          "signature": "RSC_AUTOMIPMAP",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports generating mipmaps in hardware",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_AUTOMIPMAP",
          "package": "lambdacube-engine",
          "partial": "RSC AUTOMIPMAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_AUTOMIPMAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_BLENDING",
          "package": "lambdacube-engine",
          "signature": "RSC_BLENDING",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_BLENDING",
          "package": "lambdacube-engine",
          "partial": "RSC BLENDING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_BLENDING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports cube mapping\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_CUBEMAPPING",
          "package": "lambdacube-engine",
          "signature": "RSC_CUBEMAPPING",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports cube mapping",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_CUBEMAPPING",
          "package": "lambdacube-engine",
          "partial": "RSC CUBEMAPPING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_CUBEMAPPING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports fixed-function DOT3 texture blend\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_DOT3",
          "package": "lambdacube-engine",
          "signature": "RSC_DOT3",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports fixed-function DOT3 texture blend",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_DOT3",
          "package": "lambdacube-engine",
          "partial": "RSC DOT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_DOT3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for Frame Buffer Objects (FBOs)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FBO",
          "package": "lambdacube-engine",
          "signature": "RSC_FBO",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Support for Frame Buffer Objects FBOs",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FBO",
          "package": "lambdacube-engine",
          "partial": "RSC FBO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_FBO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FBO_ARB",
          "package": "lambdacube-engine",
          "signature": "RSC_FBO_ARB",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Support for Frame Buffer Objects ARB implementation regular FBO is higher precedence",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FBO_ARB",
          "package": "lambdacube-engine",
          "partial": "RSC FBO ARB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_FBO_ARB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FBO_ATI",
          "package": "lambdacube-engine",
          "signature": "RSC_FBO_ATI",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Support for Frame Buffer Objects ATI implementation ARB FBO is higher precedence",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FBO_ATI",
          "package": "lambdacube-engine",
          "partial": "RSC FBO ATI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_FBO_ATI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports fixed-function pipeline\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FIXED_FUNCTION",
          "package": "lambdacube-engine",
          "signature": "RSC_FIXED_FUNCTION",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports fixed-function pipeline",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FIXED_FUNCTION",
          "package": "lambdacube-engine",
          "partial": "RSC FIXED FUNCTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_FIXED_FUNCTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports fragment programs (pixel shaders)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FRAGMENT_PROGRAM",
          "package": "lambdacube-engine",
          "signature": "RSC_FRAGMENT_PROGRAM",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports fragment programs pixel shaders",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_FRAGMENT_PROGRAM",
          "package": "lambdacube-engine",
          "partial": "RSC FRAGMENT PROGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_FRAGMENT_PROGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports hardware geometry programs\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_GEOMETRY_PROGRAM",
          "package": "lambdacube-engine",
          "signature": "RSC_GEOMETRY_PROGRAM",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports hardware geometry programs",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_GEOMETRY_PROGRAM",
          "package": "lambdacube-engine",
          "partial": "RSC GEOMETRY PROGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_GEOMETRY_PROGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for GL 1.5 but without HW occlusion workaround\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_GL1_5_NOHWOCCLUSION",
          "package": "lambdacube-engine",
          "signature": "RSC_GL1_5_NOHWOCCLUSION",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Support for GL but without HW occlusion workaround",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_GL1_5_NOHWOCCLUSION",
          "package": "lambdacube-engine",
          "partial": "RSC GL NOHWOCCLUSION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_GL1_5_NOHWOCCLUSION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports openGL GLEW version 1.5\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_GL1_5_NOVBO",
          "package": "lambdacube-engine",
          "signature": "RSC_GL1_5_NOVBO",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports openGL GLEW version",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_GL1_5_NOVBO",
          "package": "lambdacube-engine",
          "partial": "RSC GL NOVBO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_GL1_5_NOVBO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports hardware occlusion queries\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWOCCLUSION",
          "package": "lambdacube-engine",
          "signature": "RSC_HWOCCLUSION",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports hardware occlusion queries",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWOCCLUSION",
          "package": "lambdacube-engine",
          "partial": "RSC HWOCCLUSION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_HWOCCLUSION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports hardware render-to-texture (bigger than framebuffer)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWRENDER_TO_TEXTURE",
          "package": "lambdacube-engine",
          "signature": "RSC_HWRENDER_TO_TEXTURE",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports hardware render-to-texture bigger than framebuffer",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWRENDER_TO_TEXTURE",
          "package": "lambdacube-engine",
          "partial": "RSC HWRENDER TO TEXTURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_HWRENDER_TO_TEXTURE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports rendering to vertex buffers\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWRENDER_TO_VERTEX_BUFFER",
          "package": "lambdacube-engine",
          "signature": "RSC_HWRENDER_TO_VERTEX_BUFFER",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports rendering to vertex buffers",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWRENDER_TO_VERTEX_BUFFER",
          "package": "lambdacube-engine",
          "partial": "RSC HWRENDER TO VERTEX BUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_HWRENDER_TO_VERTEX_BUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports hardware stencil buffer\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWSTENCIL",
          "package": "lambdacube-engine",
          "signature": "RSC_HWSTENCIL",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports hardware stencil buffer",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_HWSTENCIL",
          "package": "lambdacube-engine",
          "partial": "RSC HWSTENCIL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_HWSTENCIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports infinite far plane projection\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_INFINITE_FAR_PLANE",
          "package": "lambdacube-engine",
          "signature": "RSC_INFINITE_FAR_PLANE",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports infinite far plane projection",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_INFINITE_FAR_PLANE",
          "package": "lambdacube-engine",
          "partial": "RSC INFINITE FAR PLANE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_INFINITE_FAR_PLANE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports mipmap LOD biasing\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_MIPMAP_LOD_BIAS",
          "package": "lambdacube-engine",
          "signature": "RSC_MIPMAP_LOD_BIAS",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports mipmap LOD biasing",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_MIPMAP_LOD_BIAS",
          "package": "lambdacube-engine",
          "partial": "RSC MIPMAP LOD BIAS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_MIPMAP_LOD_BIAS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports MRTs with different bit depths\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_MRT_DIFFERENT_BIT_DEPTHS",
          "package": "lambdacube-engine",
          "signature": "RSC_MRT_DIFFERENT_BIT_DEPTHS",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports MRTs with different bit depths",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_MRT_DIFFERENT_BIT_DEPTHS",
          "package": "lambdacube-engine",
          "partial": "RSC MRT DIFFERENT BIT DEPTHS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_MRT_DIFFERENT_BIT_DEPTHS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports non-power of two textures\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_NON_POWER_OF_2_TEXTURES",
          "package": "lambdacube-engine",
          "signature": "RSC_NON_POWER_OF_2_TEXTURES",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports non-power of two textures",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_NON_POWER_OF_2_TEXTURES",
          "package": "lambdacube-engine",
          "partial": "RSC NON POWER OF TEXTURES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_NON_POWER_OF_2_TEXTURES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for PBuffer\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_PBUFFER",
          "package": "lambdacube-engine",
          "signature": "RSC_PBUFFER",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Support for PBuffer",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_PBUFFER",
          "package": "lambdacube-engine",
          "partial": "RSC PBUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_PBUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs DirectX feature \u003ca\u003eper stage constants\u003c/a\u003e supported\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_PERSTAGECONSTANT",
          "package": "lambdacube-engine",
          "signature": "RSC_PERSTAGECONSTANT",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Is DirectX feature per stage constants supported",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_PERSTAGECONSTANT",
          "package": "lambdacube-engine",
          "partial": "RSC PERSTAGECONSTANT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_PERSTAGECONSTANT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports extra point parameters (minsize, maxsize, attenuation)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_EXTENDED_PARAMETERS",
          "package": "lambdacube-engine",
          "signature": "RSC_POINT_EXTENDED_PARAMETERS",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports extra point parameters minsize maxsize attenuation",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_EXTENDED_PARAMETERS",
          "package": "lambdacube-engine",
          "partial": "RSC POINT EXTENDED PARAMETERS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_POINT_EXTENDED_PARAMETERS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for point parameters ARB implementation\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_EXTENDED_PARAMETERS_ARB",
          "package": "lambdacube-engine",
          "signature": "RSC_POINT_EXTENDED_PARAMETERS_ARB",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Support for point parameters ARB implementation",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_EXTENDED_PARAMETERS_ARB",
          "package": "lambdacube-engine",
          "partial": "RSC POINT EXTENDED PARAMETERS ARB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_POINT_EXTENDED_PARAMETERS_ARB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for point parameters EXT implementation\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_EXTENDED_PARAMETERS_EXT",
          "package": "lambdacube-engine",
          "signature": "RSC_POINT_EXTENDED_PARAMETERS_EXT",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Support for point parameters EXT implementation",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_EXTENDED_PARAMETERS_EXT",
          "package": "lambdacube-engine",
          "partial": "RSC POINT EXTENDED PARAMETERS EXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_POINT_EXTENDED_PARAMETERS_EXT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports basic point sprite rendering\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_SPRITES",
          "package": "lambdacube-engine",
          "signature": "RSC_POINT_SPRITES",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports basic point sprite rendering",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_POINT_SPRITES",
          "package": "lambdacube-engine",
          "partial": "RSC POINT SPRITES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_POINT_SPRITES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports performing a scissor test to exclude areas of the screen\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_SCISSOR_TEST",
          "package": "lambdacube-engine",
          "signature": "RSC_SCISSOR_TEST",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports performing scissor test to exclude areas of the screen",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_SCISSOR_TEST",
          "package": "lambdacube-engine",
          "partial": "RSC SCISSOR TEST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_SCISSOR_TEST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports wrapping the stencil value at the range extremeties\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_STENCIL_WRAP",
          "package": "lambdacube-engine",
          "signature": "RSC_STENCIL_WRAP",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports wrapping the stencil value at the range extremeties",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_STENCIL_WRAP",
          "package": "lambdacube-engine",
          "partial": "RSC STENCIL WRAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_STENCIL_WRAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports 3d (volume) textures\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_3D",
          "package": "lambdacube-engine",
          "signature": "RSC_TEXTURE_3D",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports volume textures",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_3D",
          "package": "lambdacube-engine",
          "partial": "RSC TEXTURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_TEXTURE_3D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports compressed textures\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION",
          "package": "lambdacube-engine",
          "signature": "RSC_TEXTURE_COMPRESSION",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports compressed textures",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION",
          "package": "lambdacube-engine",
          "partial": "RSC TEXTURE COMPRESSION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_TEXTURE_COMPRESSION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports compressed textures in the DXT/ST3C formats\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION_DXT",
          "package": "lambdacube-engine",
          "signature": "RSC_TEXTURE_COMPRESSION_DXT",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports compressed textures in the DXT ST3C formats",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION_DXT",
          "package": "lambdacube-engine",
          "partial": "RSC TEXTURE COMPRESSION DXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_TEXTURE_COMPRESSION_DXT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports compressed textures in the PVRTC format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION_PVRTC",
          "package": "lambdacube-engine",
          "signature": "RSC_TEXTURE_COMPRESSION_PVRTC",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports compressed textures in the PVRTC format",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION_PVRTC",
          "package": "lambdacube-engine",
          "partial": "RSC TEXTURE COMPRESSION PVRTC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_TEXTURE_COMPRESSION_PVRTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports compressed textures in the VTC format\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION_VTC",
          "package": "lambdacube-engine",
          "signature": "RSC_TEXTURE_COMPRESSION_VTC",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports compressed textures in the VTC format",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_COMPRESSION_VTC",
          "package": "lambdacube-engine",
          "partial": "RSC TEXTURE COMPRESSION VTC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_TEXTURE_COMPRESSION_VTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports float textures and render targets\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_FLOAT",
          "package": "lambdacube-engine",
          "signature": "RSC_TEXTURE_FLOAT",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports float textures and render targets",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TEXTURE_FLOAT",
          "package": "lambdacube-engine",
          "partial": "RSC TEXTURE FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_TEXTURE_FLOAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports separate stencil updates for both front and back faces\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TWO_SIDED_STENCIL",
          "package": "lambdacube-engine",
          "signature": "RSC_TWO_SIDED_STENCIL",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports separate stencil updates for both front and back faces",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_TWO_SIDED_STENCIL",
          "package": "lambdacube-engine",
          "partial": "RSC TWO SIDED STENCIL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_TWO_SIDED_STENCIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports user clipping planes\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_USER_CLIP_PLANES",
          "package": "lambdacube-engine",
          "signature": "RSC_USER_CLIP_PLANES",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports user clipping planes",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_USER_CLIP_PLANES",
          "package": "lambdacube-engine",
          "partial": "RSC USER CLIP PLANES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_USER_CLIP_PLANES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports hardware vertex and index buffers\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VBO",
          "package": "lambdacube-engine",
          "signature": "RSC_VBO",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports hardware vertex and index buffers",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VBO",
          "package": "lambdacube-engine",
          "partial": "RSC VBO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_VBO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports the VET_UBYTE4 vertex element type\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VERTEX_FORMAT_UBYTE4",
          "package": "lambdacube-engine",
          "signature": "RSC_VERTEX_FORMAT_UBYTE4",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports the VET UBYTE4 vertex element type",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VERTEX_FORMAT_UBYTE4",
          "package": "lambdacube-engine",
          "partial": "RSC VERTEX FORMAT UBYTE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_VERTEX_FORMAT_UBYTE4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports vertex programs (vertex shaders)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VERTEX_PROGRAM",
          "package": "lambdacube-engine",
          "signature": "RSC_VERTEX_PROGRAM",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports vertex programs vertex shaders",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VERTEX_PROGRAM",
          "package": "lambdacube-engine",
          "partial": "RSC VERTEX PROGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_VERTEX_PROGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupports vertex texture fetch\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VERTEX_TEXTURE_FETCH",
          "package": "lambdacube-engine",
          "signature": "RSC_VERTEX_TEXTURE_FETCH",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#Capabilities",
          "type": "function"
        },
        "index": {
          "description": "Supports vertex texture fetch",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RSC_VERTEX_TEXTURE_FETCH",
          "package": "lambdacube-engine",
          "partial": "RSC VERTEX TEXTURE FETCH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RSC_VERTEX_TEXTURE_FETCH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RenderSystemCapabilities",
          "package": "lambdacube-engine",
          "signature": "RenderSystemCapabilities",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "RenderSystemCapabilities",
          "package": "lambdacube-engine",
          "partial": "Render System Capabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:RenderSystemCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvBuild",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#DriverVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvBuild",
          "package": "lambdacube-engine",
          "partial": "Build",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:dvBuild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvMajor",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#DriverVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvMajor",
          "package": "lambdacube-engine",
          "partial": "Major",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:dvMajor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvMinor",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#DriverVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvMinor",
          "package": "lambdacube-engine",
          "partial": "Minor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:dvMinor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvRelease",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#DriverVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "dvRelease",
          "package": "lambdacube-engine",
          "partial": "Release",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:dvRelease"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStores the capabilities flags.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscCapabilities",
          "package": "lambdacube-engine",
          "signature": "Set Capabilities",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "Stores the capabilities flags",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscCapabilities",
          "package": "lambdacube-engine",
          "partial": "Capabilities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the device as reported by the render system\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscDeviceName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The name of the device as reported by the render system",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscDeviceName",
          "package": "lambdacube-engine",
          "partial": "Device Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscDeviceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscDriverVersion",
          "package": "lambdacube-engine",
          "signature": "DriverVersion",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscDriverVersion",
          "package": "lambdacube-engine",
          "partial": "Driver Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscDriverVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of boolean constants fragment programs support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscFragmentProgramConstantBoolCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of boolean constants fragment programs support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscFragmentProgramConstantBoolCount",
          "package": "lambdacube-engine",
          "partial": "Fragment Program Constant Bool Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscFragmentProgramConstantBoolCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of floating-point constants fragment programs support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscFragmentProgramConstantFloatCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of floating-point constants fragment programs support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscFragmentProgramConstantFloatCount",
          "package": "lambdacube-engine",
          "partial": "Fragment Program Constant Float Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscFragmentProgramConstantFloatCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of integer constants fragment programs support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscFragmentProgramConstantIntCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of integer constants fragment programs support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscFragmentProgramConstantIntCount",
          "package": "lambdacube-engine",
          "partial": "Fragment Program Constant Int Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscFragmentProgramConstantIntCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of boolean constants vertex geometry support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramConstantBoolCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of boolean constants vertex geometry support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramConstantBoolCount",
          "package": "lambdacube-engine",
          "partial": "Geometry Program Constant Bool Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscGeometryProgramConstantBoolCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of floating-point constants geometry programs support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramConstantFloatCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of floating-point constants geometry programs support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramConstantFloatCount",
          "package": "lambdacube-engine",
          "partial": "Geometry Program Constant Float Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscGeometryProgramConstantFloatCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of integer constants vertex geometry support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramConstantIntCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of integer constants vertex geometry support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramConstantIntCount",
          "package": "lambdacube-engine",
          "partial": "Geometry Program Constant Int Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscGeometryProgramConstantIntCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of vertices a geometry program can emit in a single run\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramNumOutputVertices",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of vertices geometry program can emit in single run",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscGeometryProgramNumOutputVertices",
          "package": "lambdacube-engine",
          "partial": "Geometry Program Num Output Vertices",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscGeometryProgramNumOutputVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe maximum point size\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscMaxPointSize",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The maximum point size",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscMaxPointSize",
          "package": "lambdacube-engine",
          "partial": "Max Point Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscMaxPointSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre non-POW2 textures feature-limited?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNonPOW2TexturesLimited",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "Are non-POW2 textures feature-limited",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNonPOW2TexturesLimited",
          "package": "lambdacube-engine",
          "partial": "Non POW Textures Limited",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscNonPOW2TexturesLimited"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of simultaneous render targets supported\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNumMultiRenderTargets",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of simultaneous render targets supported",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNumMultiRenderTargets",
          "package": "lambdacube-engine",
          "partial": "Num Multi Render Targets",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscNumMultiRenderTargets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of texture units available\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNumTextureUnits",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of texture units available",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNumTextureUnits",
          "package": "lambdacube-engine",
          "partial": "Num Texture Units",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscNumTextureUnits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of vertex texture units supported\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNumVertexTextureUnits",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of vertex texture units supported",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscNumVertexTextureUnits",
          "package": "lambdacube-engine",
          "partial": "Num Vertex Texture Units",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscNumVertexTextureUnits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identifier associated with the render system for which these capabilities are valid\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscRenderSystemName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The identifier associated with the render system for which these capabilities are valid",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscRenderSystemName",
          "package": "lambdacube-engine",
          "partial": "Render System Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscRenderSystemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe stencil buffer bit depth\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscStencilBufferBitDepth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The stencil buffer bit depth",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscStencilBufferBitDepth",
          "package": "lambdacube-engine",
          "partial": "Stencil Buffer Bit Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscStencilBufferBitDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of supported shader profiles\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscSupportedShaderProfiles",
          "package": "lambdacube-engine",
          "signature": "Set String",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The list of supported shader profiles",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscSupportedShaderProfiles",
          "package": "lambdacube-engine",
          "partial": "Supported Shader Profiles",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscSupportedShaderProfiles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGPU Vendor\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVendor",
          "package": "lambdacube-engine",
          "signature": "GPUVendor",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "GPU Vendor",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVendor",
          "package": "lambdacube-engine",
          "partial": "Vendor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscVendor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of boolean constants vertex programs support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexProgramConstantBoolCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of boolean constants vertex programs support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexProgramConstantBoolCount",
          "package": "lambdacube-engine",
          "partial": "Vertex Program Constant Bool Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscVertexProgramConstantBoolCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of floating-point constants vertex programs support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexProgramConstantFloatCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of floating-point constants vertex programs support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexProgramConstantFloatCount",
          "package": "lambdacube-engine",
          "partial": "Vertex Program Constant Float Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscVertexProgramConstantFloatCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of integer constants vertex programs support\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexProgramConstantIntCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "The number of integer constants vertex programs support",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexProgramConstantIntCount",
          "package": "lambdacube-engine",
          "partial": "Vertex Program Constant Int Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscVertexProgramConstantIntCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAre vertex texture units shared with fragment processor?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexTextureUnitsShared",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-RenderSystemCapabilities.html#RenderSystemCapabilities",
          "type": "function"
        },
        "index": {
          "description": "Are vertex texture units shared with fragment processor",
          "hierarchy": "Graphics LambdaCube RenderSystemCapabilities",
          "module": "Graphics.LambdaCube.RenderSystemCapabilities",
          "name": "rscVertexTextureUnitsShared",
          "package": "lambdacube-engine",
          "partial": "Vertex Texture Units Shared",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-RenderSystemCapabilities.html#v:rscVertexTextureUnitsShared"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Resource",
          "name": "Resource",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Resource.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Resource",
          "module": "Graphics.LambdaCube.Resource",
          "name": "Resource",
          "package": "lambdacube-engine",
          "partial": "Resource",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Resource",
          "name": "ResourceItem",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Resource.html#ResourceItem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Resource",
          "module": "Graphics.LambdaCube.Resource",
          "name": "ResourceItem",
          "package": "lambdacube-engine",
          "partial": "Resource Item",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#t:ResourceItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Resource",
          "name": "RI_Compositor",
          "package": "lambdacube-engine",
          "signature": "RI_Compositor (String, Compositor t lp)",
          "source": "src/Graphics-LambdaCube-Resource.html#ResourceItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Resource",
          "module": "Graphics.LambdaCube.Resource",
          "name": "RI_Compositor",
          "normalized": "RI_Compositor(String,Compositor a b)",
          "package": "lambdacube-engine",
          "partial": "RI Compositor",
          "signature": "RI_Compositor(String,Compositor t lp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#v:RI_Compositor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Resource",
          "name": "RI_GpuProgram",
          "package": "lambdacube-engine",
          "signature": "RI_GpuProgram (String, GpuProgramDescriptor p)",
          "source": "src/Graphics-LambdaCube-Resource.html#ResourceItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Resource",
          "module": "Graphics.LambdaCube.Resource",
          "name": "RI_GpuProgram",
          "normalized": "RI_GpuProgram(String,GpuProgramDescriptor a)",
          "package": "lambdacube-engine",
          "partial": "RI Gpu Program",
          "signature": "RI_GpuProgram(String,GpuProgramDescriptor p)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#v:RI_GpuProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Resource",
          "name": "RI_Material",
          "package": "lambdacube-engine",
          "signature": "RI_Material (String, Material t lp)",
          "source": "src/Graphics-LambdaCube-Resource.html#ResourceItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Resource",
          "module": "Graphics.LambdaCube.Resource",
          "name": "RI_Material",
          "normalized": "RI_Material(String,Material a b)",
          "package": "lambdacube-engine",
          "partial": "RI Material",
          "signature": "RI_Material(String,Material t lp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#v:RI_Material"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Resource",
          "name": "addConfig",
          "package": "lambdacube-engine",
          "signature": "FilePath -\u003e LCM (World r vb ib q t p lp) e ()",
          "source": "src/Graphics-LambdaCube-Resource.html#addConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Resource",
          "module": "Graphics.LambdaCube.Resource",
          "name": "addConfig",
          "normalized": "FilePath-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Config",
          "signature": "FilePath-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#v:addConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a resource library (essentially a collection of paths) to the\n current set of search paths stored in the world.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.Resource\",\"Graphics.LambdaCube\"]",
          "name": "addResourceLibrary",
          "package": "lambdacube-engine",
          "signature": "[ResourceGroup] -\u003e LCM (World r vb ib q t p lp) e ()",
          "source": "src/Graphics-LambdaCube-Resource.html#addResourceLibrary",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#v:addResourceLibrary\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:addResourceLibrary\"]"
        },
        "index": {
          "description": "Add resource library essentially collection of paths to the current set of search paths stored in the world",
          "hierarchy": "Graphics LambdaCube Resource",
          "module": "Graphics.LambdaCube.Resource",
          "name": "addResourceLibrary",
          "normalized": "[ResourceGroup]-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Resource Library",
          "signature": "[ResourceGroup]-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Resource.html#v:addResourceLibrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "SceneGraph",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-SceneGraph.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "SceneGraph",
          "package": "lambdacube-engine",
          "partial": "Scene Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "MkNodeAction",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#MkNodeAction",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "MkNodeAction",
          "package": "lambdacube-engine",
          "partial": "Mk Node Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#t:MkNodeAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "MkSceneObjectAction",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#MkSceneObjectAction",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "MkSceneObjectAction",
          "package": "lambdacube-engine",
          "partial": "Mk Scene Object Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#t:MkSceneObjectAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a list of new nodes to the global scene.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "addScene",
          "package": "lambdacube-engine",
          "signature": "[MkNodeAction r vb ib q t p lp e] -\u003e LCM (World r vb ib q t p lp) e ()",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#addScene",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:addScene\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:addScene\"]"
        },
        "index": {
          "description": "Add list of new nodes to the global scene",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "addScene",
          "normalized": "[MkNodeAction a b c d e f g h]-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Scene",
          "signature": "[MkNodeAction r vb ib q t p lp e]-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:addScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a scene object representing a camera with the given\n specification.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "camera",
          "package": "lambdacube-engine",
          "signature": "Camera -\u003e MkSceneObjectAction r vb ib q t p lp e",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:camera\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:camera\"]"
        },
        "index": {
          "description": "Construct scene object representing camera with the given specification",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "camera",
          "normalized": "Camera-\u003eMkSceneObjectAction a b c d e f g h",
          "package": "lambdacube-engine",
          "signature": "Camera-\u003eMkSceneObjectAction r vb ib q t p lp e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:camera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a scene object representing a basic light source.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "defaultLight",
          "package": "lambdacube-engine",
          "signature": "MkSceneObjectAction r vb ib q t p lp e",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#defaultLight",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:defaultLight\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:defaultLight\"]"
        },
        "index": {
          "description": "Construct scene object representing basic light source",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "defaultLight",
          "package": "lambdacube-engine",
          "partial": "Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:defaultLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "flattenScene",
          "package": "lambdacube-engine",
          "signature": "Scene vb ib t lp -\u003e FlattenScene vb ib t lp",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#flattenScene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "flattenScene",
          "normalized": "Scene a b c d-\u003eFlattenScene a b c d",
          "package": "lambdacube-engine",
          "partial": "Scene",
          "signature": "Scene vb ib t lp-\u003eFlattenScene vb ib t lp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:flattenScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a scene object representing a light source with the\n given specification.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "light",
          "package": "lambdacube-engine",
          "signature": "Light -\u003e MkSceneObjectAction r vb ib q t p lp e",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#light",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:light\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:light\"]"
        },
        "index": {
          "description": "Construct scene object representing light source with the given specification",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "light",
          "normalized": "Light-\u003eMkSceneObjectAction a b c d e f g h",
          "package": "lambdacube-engine",
          "signature": "Light-\u003eMkSceneObjectAction r vb ib q t p lp e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:light"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a scene object representing a polygon mesh.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "mesh",
          "package": "lambdacube-engine",
          "signature": "Maybe rqp-\u003e Maybe [String]-\u003e String-\u003e MkSceneObjectAction rs vb ib q t p lp e",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:mesh\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:mesh\"]"
        },
        "index": {
          "description": "Construct scene object representing polygon mesh",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "mesh",
          "normalized": "Maybe a-\u003eMaybe[String]-\u003eString-\u003eMkSceneObjectAction b c d e f g h i",
          "package": "lambdacube-engine",
          "signature": "Maybe rqp-\u003eMaybe[String]-\u003eString-\u003eMkSceneObjectAction rs vb ib q t p lp e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:mesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a scene graph node description.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "node",
          "package": "lambdacube-engine",
          "signature": "String-\u003e String-\u003e Proj4-\u003e [MkSceneObjectAction r vb ib q t p lp e]-\u003e MkNodeAction r vb ib q t p lp e",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:node\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:node\"]"
        },
        "index": {
          "description": "Construct scene graph node description",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "node",
          "normalized": "String-\u003eString-\u003eProj-\u003e[MkSceneObjectAction a b c d e f g h]-\u003eMkNodeAction a b c d e f g h",
          "package": "lambdacube-engine",
          "signature": "String-\u003eString-\u003eProj-\u003e[MkSceneObjectAction r vb ib q t p lp e]-\u003eMkNodeAction r vb ib q t p lp e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender the given target.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "renderWorld",
          "package": "lambdacube-engine",
          "signature": "FloatType-\u003e String-\u003e LCM (World r vb ib q t p lp) e ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:renderWorld\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:renderWorld\"]"
        },
        "index": {
          "description": "Render the given target",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "renderWorld",
          "normalized": "FloatType-\u003eString-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "World",
          "signature": "FloatType-\u003eString-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:renderWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a scene object representing a basic camera with the\n given name.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "simpleCamera",
          "package": "lambdacube-engine",
          "signature": "String -\u003e MkSceneObjectAction r vb ib q t p lp e",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#simpleCamera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:simpleCamera\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:simpleCamera\"]"
        },
        "index": {
          "description": "Construct scene object representing basic camera with the given name",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "simpleCamera",
          "normalized": "String-\u003eMkSceneObjectAction a b c d e f g h",
          "package": "lambdacube-engine",
          "partial": "Camera",
          "signature": "String-\u003eMkSceneObjectAction r vb ib q t p lp e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:simpleCamera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the objects associated with the given nodes.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "updateObjects",
          "package": "lambdacube-engine",
          "signature": "[(String, [MkSceneObjectAction rs vb ib q t p lp e])] -\u003e LCM (World rs vb ib q t p lp) e ()",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#updateObjects",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:updateObjects\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:updateObjects\"]"
        },
        "index": {
          "description": "Update the objects associated with the given nodes",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "updateObjects",
          "normalized": "[(String,[MkSceneObjectAction a b c d e f g h])]-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Objects",
          "signature": "[(String,[MkSceneObjectAction rs vb ib q t p lp e])]-\u003eLCM(World rs vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:updateObjects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the transformation matrices of the given nodes.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "updateTransforms",
          "package": "lambdacube-engine",
          "signature": "[(String, Proj4)] -\u003e LCM (World r vb ib q t p lp) e ()",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#updateTransforms",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:updateTransforms\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:updateTransforms\"]"
        },
        "index": {
          "description": "Update the transformation matrices of the given nodes",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "updateTransforms",
          "normalized": "[(String,Proj)]-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Transforms",
          "signature": "[(String,Proj)]-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:updateTransforms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a scene object representing a wireframe-mode camera\n with the given name.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.SceneGraph\",\"Graphics.LambdaCube\"]",
          "name": "wireCamera",
          "package": "lambdacube-engine",
          "signature": "String -\u003e MkSceneObjectAction r vb ib q t p lp e",
          "source": "src/Graphics-LambdaCube-SceneGraph.html#wireCamera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:wireCamera\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:wireCamera\"]"
        },
        "index": {
          "description": "Construct scene object representing wireframe-mode camera with the given name",
          "hierarchy": "Graphics LambdaCube SceneGraph",
          "module": "Graphics.LambdaCube.SceneGraph",
          "name": "wireCamera",
          "normalized": "String-\u003eMkSceneObjectAction a b c d e f g h",
          "package": "lambdacube-engine",
          "partial": "Camera",
          "signature": "String-\u003eMkSceneObjectAction r vb ib q t p lp e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-SceneGraph.html#v:wireCamera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Skeleton",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Skeleton.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Skeleton",
          "package": "lambdacube-engine",
          "partial": "Skeleton",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Animation",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Animation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Animation",
          "package": "lambdacube-engine",
          "partial": "Animation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#t:Animation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Bone",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Bone",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Bone",
          "package": "lambdacube-engine",
          "partial": "Bone",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#t:Bone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "KeyFrame",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Skeleton.html#KeyFrame",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "KeyFrame",
          "package": "lambdacube-engine",
          "partial": "Key Frame",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#t:KeyFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "PoseData",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Skeleton.html#PoseData",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "PoseData",
          "package": "lambdacube-engine",
          "partial": "Pose Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#t:PoseData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Skeleton",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Skeleton",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Skeleton",
          "package": "lambdacube-engine",
          "partial": "Skeleton",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#t:Skeleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Animation",
          "package": "lambdacube-engine",
          "signature": "Animation",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Animation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Animation",
          "package": "lambdacube-engine",
          "partial": "Animation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:Animation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Bone",
          "package": "lambdacube-engine",
          "signature": "Bone",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Bone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Bone",
          "package": "lambdacube-engine",
          "partial": "Bone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:Bone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "KeyFrame",
          "package": "lambdacube-engine",
          "signature": "KeyFrame",
          "source": "src/Graphics-LambdaCube-Skeleton.html#KeyFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "KeyFrame",
          "package": "lambdacube-engine",
          "partial": "Key Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:KeyFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "PoseData",
          "package": "lambdacube-engine",
          "signature": "PoseData",
          "source": "src/Graphics-LambdaCube-Skeleton.html#PoseData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "PoseData",
          "package": "lambdacube-engine",
          "partial": "Pose Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:PoseData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Skeleton",
          "package": "lambdacube-engine",
          "signature": "Skeleton",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Skeleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "Skeleton",
          "package": "lambdacube-engine",
          "partial": "Skeleton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:Skeleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "anLength",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Animation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "anLength",
          "package": "lambdacube-engine",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:anLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "anName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Animation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "anName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:anName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "anTracks",
          "package": "lambdacube-engine",
          "signature": "Vector [KeyFrame]",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Animation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "anTracks",
          "normalized": "Vector[KeyFrame]",
          "package": "lambdacube-engine",
          "partial": "Tracks",
          "signature": "Vector[KeyFrame]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:anTracks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "bnPosition",
          "package": "lambdacube-engine",
          "signature": "Vec3",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Bone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "bnPosition",
          "package": "lambdacube-engine",
          "partial": "Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:bnPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "bnRotation",
          "package": "lambdacube-engine",
          "signature": "U",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Bone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "bnRotation",
          "package": "lambdacube-engine",
          "partial": "Rotation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:bnRotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "kfPosition",
          "package": "lambdacube-engine",
          "signature": "Vec3",
          "source": "src/Graphics-LambdaCube-Skeleton.html#KeyFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "kfPosition",
          "package": "lambdacube-engine",
          "partial": "Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:kfPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "kfRotation",
          "package": "lambdacube-engine",
          "signature": "U",
          "source": "src/Graphics-LambdaCube-Skeleton.html#KeyFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "kfRotation",
          "package": "lambdacube-engine",
          "partial": "Rotation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:kfRotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "kfTime",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-Skeleton.html#KeyFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "kfTime",
          "package": "lambdacube-engine",
          "partial": "Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:kfTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdInverseBindMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4",
          "source": "src/Graphics-LambdaCube-Skeleton.html#PoseData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdInverseBindMatrix",
          "package": "lambdacube-engine",
          "partial": "Inverse Bind Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:pdInverseBindMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdJointMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4",
          "source": "src/Graphics-LambdaCube-Skeleton.html#PoseData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdJointMatrix",
          "package": "lambdacube-engine",
          "partial": "Joint Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:pdJointMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdSkinningMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4",
          "source": "src/Graphics-LambdaCube-Skeleton.html#PoseData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdSkinningMatrix",
          "package": "lambdacube-engine",
          "partial": "Skinning Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:pdSkinningMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdWorldMatrix",
          "package": "lambdacube-engine",
          "signature": "Proj4",
          "source": "src/Graphics-LambdaCube-Skeleton.html#PoseData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "pdWorldMatrix",
          "package": "lambdacube-engine",
          "partial": "World Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:pdWorldMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "skAnimations",
          "package": "lambdacube-engine",
          "signature": "Map String Animation",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Skeleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "skAnimations",
          "package": "lambdacube-engine",
          "partial": "Animations",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:skAnimations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "skBoneTree",
          "package": "lambdacube-engine",
          "signature": "Tree Int",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Skeleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "skBoneTree",
          "package": "lambdacube-engine",
          "partial": "Bone Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:skBoneTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "skBones",
          "package": "lambdacube-engine",
          "signature": "Vector Bone",
          "source": "src/Graphics-LambdaCube-Skeleton.html#Skeleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Skeleton",
          "module": "Graphics.LambdaCube.Skeleton",
          "name": "skBones",
          "package": "lambdacube-engine",
          "partial": "Bones",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Skeleton.html#v:skBones"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "Technique",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Technique.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "Technique",
          "package": "lambdacube-engine",
          "partial": "Technique",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUDeviceNameRule",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUDeviceNameRule",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUDeviceNameRule",
          "package": "lambdacube-engine",
          "partial": "GPUDevice Name Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#t:GPUDeviceNameRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUVendorRule",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUVendorRule",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUVendorRule",
          "package": "lambdacube-engine",
          "partial": "GPUVendor Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#t:GPUVendorRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "IlluminationPassesState",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Technique.html#IlluminationPassesState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "IlluminationPassesState",
          "package": "lambdacube-engine",
          "partial": "Illumination Passes State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#t:IlluminationPassesState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "IncludeOrExclude",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Technique.html#IncludeOrExclude",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "IncludeOrExclude",
          "package": "lambdacube-engine",
          "partial": "Include Or Exclude",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#t:IncludeOrExclude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "Technique",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "Technique",
          "package": "lambdacube-engine",
          "partial": "Technique",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#t:Technique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExclusive - do not support if present\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Technique",
          "name": "EXCLUDE",
          "package": "lambdacube-engine",
          "signature": "EXCLUDE",
          "source": "src/Graphics-LambdaCube-Technique.html#IncludeOrExclude",
          "type": "function"
        },
        "index": {
          "description": "Exclusive do not support if present",
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "EXCLUDE",
          "package": "lambdacube-engine",
          "partial": "EXCLUDE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:EXCLUDE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUDeviceNameRule",
          "package": "lambdacube-engine",
          "signature": "GPUDeviceNameRule",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUDeviceNameRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUDeviceNameRule",
          "package": "lambdacube-engine",
          "partial": "GPUDevice Name Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:GPUDeviceNameRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUVendorRule",
          "package": "lambdacube-engine",
          "signature": "GPUVendorRule",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUVendorRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "GPUVendorRule",
          "package": "lambdacube-engine",
          "partial": "GPUVendor Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:GPUVendorRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInclusive - only support if present\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Technique",
          "name": "INCLUDE",
          "package": "lambdacube-engine",
          "signature": "INCLUDE",
          "source": "src/Graphics-LambdaCube-Technique.html#IncludeOrExclude",
          "type": "function"
        },
        "index": {
          "description": "Inclusive only support if present",
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "INCLUDE",
          "package": "lambdacube-engine",
          "partial": "INCLUDE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:INCLUDE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "IPS_COMPILED",
          "package": "lambdacube-engine",
          "signature": "IPS_COMPILED",
          "source": "src/Graphics-LambdaCube-Technique.html#IlluminationPassesState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "IPS_COMPILED",
          "package": "lambdacube-engine",
          "partial": "IPS COMPILED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:IPS_COMPILED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "IPS_COMPILE_DISABLED",
          "package": "lambdacube-engine",
          "signature": "IPS_COMPILE_DISABLED",
          "source": "src/Graphics-LambdaCube-Technique.html#IlluminationPassesState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "IPS_COMPILE_DISABLED",
          "package": "lambdacube-engine",
          "partial": "IPS COMPILE DISABLED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:IPS_COMPILE_DISABLED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "IPS_NOT_COMPILED",
          "package": "lambdacube-engine",
          "signature": "IPS_NOT_COMPILED",
          "source": "src/Graphics-LambdaCube-Technique.html#IlluminationPassesState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "IPS_NOT_COMPILED",
          "package": "lambdacube-engine",
          "partial": "IPS NOT COMPILED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:IPS_NOT_COMPILED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "Technique",
          "package": "lambdacube-engine",
          "signature": "Technique",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "Technique",
          "package": "lambdacube-engine",
          "partial": "Technique",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:Technique"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "gdrCaseSensitive",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUDeviceNameRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "gdrCaseSensitive",
          "package": "lambdacube-engine",
          "partial": "Case Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:gdrCaseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "gdrDevicePattern",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUDeviceNameRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "gdrDevicePattern",
          "package": "lambdacube-engine",
          "partial": "Device Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:gdrDevicePattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "gdrIncludeOrExclude",
          "package": "lambdacube-engine",
          "signature": "IncludeOrExclude",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUDeviceNameRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "gdrIncludeOrExclude",
          "package": "lambdacube-engine",
          "partial": "Include Or Exclude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:gdrIncludeOrExclude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "gvrIncludeOrExclude",
          "package": "lambdacube-engine",
          "signature": "IncludeOrExclude",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUVendorRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "gvrIncludeOrExclude",
          "package": "lambdacube-engine",
          "partial": "Include Or Exclude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:gvrIncludeOrExclude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "gvrVendor",
          "package": "lambdacube-engine",
          "signature": "GPUVendor",
          "source": "src/Graphics-LambdaCube-Technique.html#GPUVendorRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "gvrVendor",
          "package": "lambdacube-engine",
          "partial": "Vendor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:gvrVendor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchGPUDeviceNameRules",
          "package": "lambdacube-engine",
          "signature": "[GPUDeviceNameRule]",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchGPUDeviceNameRules",
          "normalized": "[GPUDeviceNameRule]",
          "package": "lambdacube-engine",
          "partial": "GPUDevice Name Rules",
          "signature": "[GPUDeviceNameRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:tchGPUDeviceNameRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchGPUVendorRules",
          "package": "lambdacube-engine",
          "signature": "[GPUVendorRule]",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchGPUVendorRules",
          "normalized": "[GPUVendorRule]",
          "package": "lambdacube-engine",
          "partial": "GPUVendor Rules",
          "signature": "[GPUVendorRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:tchGPUVendorRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLOD level\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchLodIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "function"
        },
        "index": {
          "description": "LOD level",
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchLodIndex",
          "package": "lambdacube-engine",
          "partial": "Lod Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:tchLodIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional name for the technique\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "function"
        },
        "index": {
          "description": "optional name for the technique",
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:tchName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of primary passes\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchPasses",
          "package": "lambdacube-engine",
          "signature": "[Pass t lp]",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "function"
        },
        "index": {
          "description": "List of primary passes",
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchPasses",
          "normalized": "[Pass a b]",
          "package": "lambdacube-engine",
          "partial": "Passes",
          "signature": "[Pass t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:tchPasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScheme index, derived from scheme name but the names are held on MaterialManager, for speed an index is used here.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchSchemeIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-Technique.html#Technique",
          "type": "function"
        },
        "index": {
          "description": "Scheme index derived from scheme name but the names are held on MaterialManager for speed an index is used here",
          "hierarchy": "Graphics LambdaCube Technique",
          "module": "Graphics.LambdaCube.Technique",
          "name": "tchSchemeIndex",
          "package": "lambdacube-engine",
          "partial": "Scheme Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Technique.html#v:tchSchemeIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "Texture",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Texture.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "Texture",
          "package": "lambdacube-engine",
          "partial": "Texture",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "Texture",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Texture.html#Texture",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "Texture",
          "package": "lambdacube-engine",
          "partial": "Texture",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#t:Texture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureMipmap",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureMipmap",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureMipmap",
          "package": "lambdacube-engine",
          "partial": "Texture Mipmap",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#t:TextureMipmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureType",
          "package": "lambdacube-engine",
          "partial": "Texture Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#t:TextureType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureUsage",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureUsage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureUsage",
          "package": "lambdacube-engine",
          "partial": "Texture Usage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#t:TextureUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse TextureManager default\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "MIP_DEFAULT",
          "package": "lambdacube-engine",
          "signature": "MIP_DEFAULT",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureMipmap",
          "type": "function"
        },
        "index": {
          "description": "Use TextureManager default",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "MIP_DEFAULT",
          "package": "lambdacube-engine",
          "partial": "MIP DEFAULT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:MIP_DEFAULT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "MIP_NUMBER",
          "package": "lambdacube-engine",
          "signature": "MIP_NUMBER Int",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureMipmap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "MIP_NUMBER",
          "package": "lambdacube-engine",
          "partial": "MIP NUMBER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:MIP_NUMBER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate mipmaps up to 1x1\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "MIP_UNLIMITED",
          "package": "lambdacube-engine",
          "signature": "MIP_UNLIMITED",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureMipmap",
          "type": "function"
        },
        "index": {
          "description": "Generate mipmaps up to x1",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "MIP_UNLIMITED",
          "package": "lambdacube-engine",
          "partial": "MIP UNLIMITED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:MIP_UNLIMITED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e1D texture, used in combination with 1D texture coordinates\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_1D",
          "package": "lambdacube-engine",
          "signature": "TEX_TYPE_1D",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureType",
          "type": "function"
        },
        "index": {
          "description": "texture used in combination with texture coordinates",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_1D",
          "package": "lambdacube-engine",
          "partial": "TEX TYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:TEX_TYPE_1D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2D texture, used in combination with 2D texture coordinates (default)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_2D",
          "package": "lambdacube-engine",
          "signature": "TEX_TYPE_2D",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureType",
          "type": "function"
        },
        "index": {
          "description": "texture used in combination with texture coordinates default",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_2D",
          "package": "lambdacube-engine",
          "partial": "TEX TYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:TEX_TYPE_2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e3D volume texture, used in combination with 3D texture coordinates\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_3D",
          "package": "lambdacube-engine",
          "signature": "TEX_TYPE_3D",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureType",
          "type": "function"
        },
        "index": {
          "description": "volume texture used in combination with texture coordinates",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_3D",
          "package": "lambdacube-engine",
          "partial": "TEX TYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:TEX_TYPE_3D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e3D cube map, used in combination with 3D texture coordinates\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_CUBE_MAP",
          "package": "lambdacube-engine",
          "signature": "TEX_TYPE_CUBE_MAP",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureType",
          "type": "function"
        },
        "index": {
          "description": "cube map used in combination with texture coordinates",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TEX_TYPE_CUBE_MAP",
          "package": "lambdacube-engine",
          "partial": "TEX TYPE CUBE MAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:TEX_TYPE_CUBE_MAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureUsage",
          "package": "lambdacube-engine",
          "signature": "TextureUsage",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "TextureUsage",
          "package": "lambdacube-engine",
          "partial": "Texture Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:TextureUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emipmaps will be automatically generated for this texture\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "tuAutoMipmap",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureUsage",
          "type": "function"
        },
        "index": {
          "description": "mipmaps will be automatically generated for this texture",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "tuAutoMipmap",
          "package": "lambdacube-engine",
          "partial": "Auto Mipmap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:tuAutoMipmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethis texture will be a render target, i.e. used as a target for render to texture setting this flag will ignore all other texture usages except TU_AUTOMIPMAP\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Texture",
          "name": "tuRenderTarget",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureUsage",
          "type": "function"
        },
        "index": {
          "description": "this texture will be render target i.e used as target for render to texture setting this flag will ignore all other texture usages except TU AUTOMIPMAP",
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "tuRenderTarget",
          "package": "lambdacube-engine",
          "partial": "Render Target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:tuRenderTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "tuUsage",
          "package": "lambdacube-engine",
          "signature": "Usage",
          "source": "src/Graphics-LambdaCube-Texture.html#TextureUsage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "tuUsage",
          "package": "lambdacube-engine",
          "partial": "Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:tuUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDepth",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txDepth",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDepth",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Depth",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDesiredFloatBitDepth",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txDesiredFloatBitDepth",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDesiredFloatBitDepth",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Desired Float Bit Depth",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txDesiredFloatBitDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDesiredFormat",
          "package": "lambdacube-engine",
          "signature": "a -\u003e PixelFormat",
          "source": "src/Graphics-LambdaCube-Texture.html#txDesiredFormat",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDesiredFormat",
          "normalized": "a-\u003ePixelFormat",
          "package": "lambdacube-engine",
          "partial": "Desired Format",
          "signature": "a-\u003ePixelFormat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txDesiredFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDesiredIntegerBitDepth",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txDesiredIntegerBitDepth",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txDesiredIntegerBitDepth",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Desired Integer Bit Depth",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txDesiredIntegerBitDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txFSAA",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txFSAA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txFSAA",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "FSAA",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txFSAA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txFSAAHint",
          "package": "lambdacube-engine",
          "signature": "a -\u003e String",
          "source": "src/Graphics-LambdaCube-Texture.html#txFSAAHint",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txFSAAHint",
          "normalized": "a-\u003eString",
          "package": "lambdacube-engine",
          "partial": "FSAAHint",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txFSAAHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txFormat",
          "package": "lambdacube-engine",
          "signature": "a -\u003e PixelFormat",
          "source": "src/Graphics-LambdaCube-Texture.html#txFormat",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txFormat",
          "normalized": "a-\u003ePixelFormat",
          "package": "lambdacube-engine",
          "partial": "Format",
          "signature": "a-\u003ePixelFormat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txGamma",
          "package": "lambdacube-engine",
          "signature": "a -\u003e FloatType",
          "source": "src/Graphics-LambdaCube-Texture.html#txGamma",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txGamma",
          "normalized": "a-\u003eFloatType",
          "package": "lambdacube-engine",
          "partial": "Gamma",
          "signature": "a-\u003eFloatType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txHeight",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txHeight",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txHeight",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Height",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txHwGamma",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Bool",
          "source": "src/Graphics-LambdaCube-Texture.html#txHwGamma",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txHwGamma",
          "normalized": "a-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Hw Gamma",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txHwGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txMipmapsHardwareGenerated",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Bool",
          "source": "src/Graphics-LambdaCube-Texture.html#txMipmapsHardwareGenerated",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txMipmapsHardwareGenerated",
          "normalized": "a-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Mipmaps Hardware Generated",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txMipmapsHardwareGenerated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txName",
          "package": "lambdacube-engine",
          "signature": "a -\u003e String",
          "source": "src/Graphics-LambdaCube-Texture.html#txName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txName",
          "normalized": "a-\u003eString",
          "package": "lambdacube-engine",
          "partial": "Name",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txNumMipmaps",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txNumMipmaps",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txNumMipmaps",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Num Mipmaps",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txNumMipmaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txNumRequestedMipmaps",
          "package": "lambdacube-engine",
          "signature": "a -\u003e TextureMipmap",
          "source": "src/Graphics-LambdaCube-Texture.html#txNumRequestedMipmaps",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txNumRequestedMipmaps",
          "normalized": "a-\u003eTextureMipmap",
          "package": "lambdacube-engine",
          "partial": "Num Requested Mipmaps",
          "signature": "a-\u003eTextureMipmap",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txNumRequestedMipmaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcDepth",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txSrcDepth",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcDepth",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Src Depth",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txSrcDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcFormat",
          "package": "lambdacube-engine",
          "signature": "a -\u003e PixelFormat",
          "source": "src/Graphics-LambdaCube-Texture.html#txSrcFormat",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcFormat",
          "normalized": "a-\u003ePixelFormat",
          "package": "lambdacube-engine",
          "partial": "Src Format",
          "signature": "a-\u003ePixelFormat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txSrcFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcHeight",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txSrcHeight",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcHeight",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Src Height",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txSrcHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcWidth",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txSrcWidth",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txSrcWidth",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Src Width",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txSrcWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txTextureType",
          "package": "lambdacube-engine",
          "signature": "a -\u003e TextureType",
          "source": "src/Graphics-LambdaCube-Texture.html#txTextureType",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txTextureType",
          "normalized": "a-\u003eTextureType",
          "package": "lambdacube-engine",
          "partial": "Texture Type",
          "signature": "a-\u003eTextureType",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txTextureType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txTreatLuminanceAsAlpha",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Bool",
          "source": "src/Graphics-LambdaCube-Texture.html#txTreatLuminanceAsAlpha",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txTreatLuminanceAsAlpha",
          "normalized": "a-\u003eBool",
          "package": "lambdacube-engine",
          "partial": "Treat Luminance As Alpha",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txTreatLuminanceAsAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Texture",
          "name": "txWidth",
          "package": "lambdacube-engine",
          "signature": "a -\u003e Int",
          "source": "src/Graphics-LambdaCube-Texture.html#txWidth",
          "type": "method"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Texture",
          "module": "Graphics.LambdaCube.Texture",
          "name": "txWidth",
          "normalized": "a-\u003eInt",
          "package": "lambdacube-engine",
          "partial": "Width",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Texture.html#v:txWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureUnitState",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureUnitState",
          "package": "lambdacube-engine",
          "partial": "Texture Unit State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "BindingType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#BindingType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "BindingType",
          "package": "lambdacube-engine",
          "partial": "Binding Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:BindingType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ContentType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#ContentType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ContentType",
          "package": "lambdacube-engine",
          "partial": "Content Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:ContentType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "EnvMapType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#EnvMapType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "EnvMapType",
          "package": "lambdacube-engine",
          "partial": "Env Map Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:EnvMapType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureAddressingMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureAddressingMode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureAddressingMode",
          "package": "lambdacube-engine",
          "partial": "Texture Addressing Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:TextureAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureCubeFace",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureCubeFace",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureCubeFace",
          "package": "lambdacube-engine",
          "partial": "Texture Cube Face",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:TextureCubeFace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureEffect",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureEffect",
          "package": "lambdacube-engine",
          "partial": "Texture Effect",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:TextureEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureEffectType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureEffectType",
          "package": "lambdacube-engine",
          "partial": "Texture Effect Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:TextureEffectType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureTransformType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureTransformType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureTransformType",
          "package": "lambdacube-engine",
          "partial": "Texture Transform Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:TextureTransformType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureUnitState",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureUnitState",
          "package": "lambdacube-engine",
          "partial": "Texture Unit State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:TextureUnitState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "UVWAddressingMode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#UVWAddressingMode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "UVWAddressingMode",
          "package": "lambdacube-engine",
          "partial": "UVWAddressing Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#t:UVWAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegular fragment processing unit - the default.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "BT_FRAGMENT",
          "package": "lambdacube-engine",
          "signature": "BT_FRAGMENT",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#BindingType",
          "type": "function"
        },
        "index": {
          "description": "Regular fragment processing unit the default",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "BT_FRAGMENT",
          "package": "lambdacube-engine",
          "partial": "BT FRAGMENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:BT_FRAGMENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertex processing unit - indicates this unit will be used for\n   a vertex texture fetch.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "BT_VERTEX",
          "package": "lambdacube-engine",
          "signature": "BT_VERTEX",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#BindingType",
          "type": "function"
        },
        "index": {
          "description": "Vertex processing unit indicates this unit will be used for vertex texture fetch",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "BT_VERTEX",
          "package": "lambdacube-engine",
          "partial": "BT VERTEX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:BT_VERTEX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal texture identified by name\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CONTENT_NAMED",
          "package": "lambdacube-engine",
          "signature": "CONTENT_NAMED",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#ContentType",
          "type": "function"
        },
        "index": {
          "description": "Normal texture identified by name",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CONTENT_NAMED",
          "package": "lambdacube-engine",
          "partial": "CONTENT NAMED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CONTENT_NAMED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA shadow texture, automatically bound by engine\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CONTENT_SHADOW",
          "package": "lambdacube-engine",
          "signature": "CONTENT_SHADOW",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#ContentType",
          "type": "function"
        },
        "index": {
          "description": "shadow texture automatically bound by engine",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CONTENT_SHADOW",
          "package": "lambdacube-engine",
          "partial": "CONTENT SHADOW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CONTENT_SHADOW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_BACK",
          "package": "lambdacube-engine",
          "signature": "CUBE_BACK",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureCubeFace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_BACK",
          "package": "lambdacube-engine",
          "partial": "CUBE BACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CUBE_BACK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_DOWN",
          "package": "lambdacube-engine",
          "signature": "CUBE_DOWN",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureCubeFace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_DOWN",
          "package": "lambdacube-engine",
          "partial": "CUBE DOWN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CUBE_DOWN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_FRONT",
          "package": "lambdacube-engine",
          "signature": "CUBE_FRONT",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureCubeFace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_FRONT",
          "package": "lambdacube-engine",
          "partial": "CUBE FRONT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CUBE_FRONT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_LEFT",
          "package": "lambdacube-engine",
          "signature": "CUBE_LEFT",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureCubeFace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_LEFT",
          "package": "lambdacube-engine",
          "partial": "CUBE LEFT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CUBE_LEFT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_RIGHT",
          "package": "lambdacube-engine",
          "signature": "CUBE_RIGHT",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureCubeFace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_RIGHT",
          "package": "lambdacube-engine",
          "partial": "CUBE RIGHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CUBE_RIGHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_UP",
          "package": "lambdacube-engine",
          "signature": "CUBE_UP",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureCubeFace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "CUBE_UP",
          "package": "lambdacube-engine",
          "partial": "CUBE UP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:CUBE_UP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvmap based on dot of vector from camera to vertex and vertex normal, good for curves\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_CURVED",
          "package": "lambdacube-engine",
          "signature": "ENV_CURVED",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#EnvMapType",
          "type": "function"
        },
        "index": {
          "description": "Envmap based on dot of vector from camera to vertex and vertex normal good for curves",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_CURVED",
          "package": "lambdacube-engine",
          "partial": "ENV CURVED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ENV_CURVED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvmap intended to supply normal vectors for cube mapping\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_NORMAL",
          "package": "lambdacube-engine",
          "signature": "ENV_NORMAL",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#EnvMapType",
          "type": "function"
        },
        "index": {
          "description": "Envmap intended to supply normal vectors for cube mapping",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_NORMAL",
          "package": "lambdacube-engine",
          "partial": "ENV NORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ENV_NORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvmap based on vector from camera to vertex position, good for planar geometry\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_PLANAR",
          "package": "lambdacube-engine",
          "signature": "ENV_PLANAR",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#EnvMapType",
          "type": "function"
        },
        "index": {
          "description": "Envmap based on vector from camera to vertex position good for planar geometry",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_PLANAR",
          "package": "lambdacube-engine",
          "partial": "ENV PLANAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ENV_PLANAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnvmap intended to supply reflection vectors for cube mapping\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_REFLECTION",
          "package": "lambdacube-engine",
          "signature": "ENV_REFLECTION",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#EnvMapType",
          "type": "function"
        },
        "index": {
          "description": "Envmap intended to supply reflection vectors for cube mapping",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ENV_REFLECTION",
          "package": "lambdacube-engine",
          "partial": "ENV REFLECTION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ENV_REFLECTION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate all texture coords based on angle between camera and vertex\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_ENVIRONMENT_MAP",
          "package": "lambdacube-engine",
          "signature": "ET_ENVIRONMENT_MAP",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "function"
        },
        "index": {
          "description": "Generate all texture coords based on angle between camera and vertex",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_ENVIRONMENT_MAP",
          "package": "lambdacube-engine",
          "partial": "ET ENVIRONMENT MAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ET_ENVIRONMENT_MAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate texture coords based on a frustum\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_PROJECTIVE_TEXTURE",
          "package": "lambdacube-engine",
          "signature": "ET_PROJECTIVE_TEXTURE",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "function"
        },
        "index": {
          "description": "Generate texture coords based on frustum",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_PROJECTIVE_TEXTURE",
          "package": "lambdacube-engine",
          "partial": "ET PROJECTIVE TEXTURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ET_PROJECTIVE_TEXTURE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant rotation\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_ROTATE",
          "package": "lambdacube-engine",
          "signature": "ET_ROTATE",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "function"
        },
        "index": {
          "description": "Constant rotation",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_ROTATE",
          "package": "lambdacube-engine",
          "partial": "ET ROTATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ET_ROTATE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMore complex transform\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_TRANSFORM",
          "package": "lambdacube-engine",
          "signature": "ET_TRANSFORM",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "function"
        },
        "index": {
          "description": "More complex transform",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_TRANSFORM",
          "package": "lambdacube-engine",
          "partial": "ET TRANSFORM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ET_TRANSFORM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant u scrolling effect\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_USCROLL",
          "package": "lambdacube-engine",
          "signature": "ET_USCROLL",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "function"
        },
        "index": {
          "description": "Constant scrolling effect",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_USCROLL",
          "package": "lambdacube-engine",
          "partial": "ET USCROLL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ET_USCROLL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant u/v scrolling effect\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_UVSCROLL",
          "package": "lambdacube-engine",
          "signature": "ET_UVSCROLL",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "function"
        },
        "index": {
          "description": "Constant scrolling effect",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_UVSCROLL",
          "package": "lambdacube-engine",
          "partial": "ET UVSCROLL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ET_UVSCROLL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant u/v scrolling effect\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_VSCROLL",
          "package": "lambdacube-engine",
          "signature": "ET_VSCROLL",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffectType",
          "type": "function"
        },
        "index": {
          "description": "Constant scrolling effect",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "ET_VSCROLL",
          "package": "lambdacube-engine",
          "partial": "ET VSCROLL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:ET_VSCROLL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture coordinates outside the range [0.0, 1.0] are set to the border colour\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_BORDER",
          "package": "lambdacube-engine",
          "signature": "TAM_BORDER",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureAddressingMode",
          "type": "function"
        },
        "index": {
          "description": "Texture coordinates outside the range are set to the border colour",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_BORDER",
          "package": "lambdacube-engine",
          "partial": "TAM BORDER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TAM_BORDER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture clamps at 1.0\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_CLAMP",
          "package": "lambdacube-engine",
          "signature": "TAM_CLAMP",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureAddressingMode",
          "type": "function"
        },
        "index": {
          "description": "Texture clamps at",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_CLAMP",
          "package": "lambdacube-engine",
          "partial": "TAM CLAMP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TAM_CLAMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture mirrors (flips) at joins over 1.0\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_MIRROR",
          "package": "lambdacube-engine",
          "signature": "TAM_MIRROR",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureAddressingMode",
          "type": "function"
        },
        "index": {
          "description": "Texture mirrors flips at joins over",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_MIRROR",
          "package": "lambdacube-engine",
          "partial": "TAM MIRROR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TAM_MIRROR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture wraps at values over 1.0\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_WRAP",
          "package": "lambdacube-engine",
          "signature": "TAM_WRAP",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureAddressingMode",
          "type": "function"
        },
        "index": {
          "description": "Texture wraps at values over",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TAM_WRAP",
          "package": "lambdacube-engine",
          "partial": "TAM WRAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TAM_WRAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_ROTATE",
          "package": "lambdacube-engine",
          "signature": "TT_ROTATE",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureTransformType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_ROTATE",
          "package": "lambdacube-engine",
          "partial": "TT ROTATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TT_ROTATE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_SCALE_U",
          "package": "lambdacube-engine",
          "signature": "TT_SCALE_U",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureTransformType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_SCALE_U",
          "package": "lambdacube-engine",
          "partial": "TT SCALE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TT_SCALE_U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_SCALE_V",
          "package": "lambdacube-engine",
          "signature": "TT_SCALE_V",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureTransformType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_SCALE_V",
          "package": "lambdacube-engine",
          "partial": "TT SCALE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TT_SCALE_V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_TRANSLATE_U",
          "package": "lambdacube-engine",
          "signature": "TT_TRANSLATE_U",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureTransformType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_TRANSLATE_U",
          "package": "lambdacube-engine",
          "partial": "TT TRANSLATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TT_TRANSLATE_U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_TRANSLATE_V",
          "package": "lambdacube-engine",
          "signature": "TT_TRANSLATE_V",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureTransformType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TT_TRANSLATE_V",
          "package": "lambdacube-engine",
          "partial": "TT TRANSLATE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TT_TRANSLATE_V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureEffect",
          "package": "lambdacube-engine",
          "signature": "TextureEffect",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureEffect",
          "package": "lambdacube-engine",
          "partial": "Texture Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TextureEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureUnitState",
          "package": "lambdacube-engine",
          "signature": "TextureUnitState",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "TextureUnitState",
          "package": "lambdacube-engine",
          "partial": "Texture Unit State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:TextureUnitState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "UVWAddressingMode",
          "package": "lambdacube-engine",
          "signature": "UVWAddressingMode",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#UVWAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "UVWAddressingMode",
          "package": "lambdacube-engine",
          "partial": "UVWAddressing Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:UVWAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "amU",
          "package": "lambdacube-engine",
          "signature": "TextureAddressingMode",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#UVWAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "amU",
          "package": "lambdacube-engine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:amU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "amV",
          "package": "lambdacube-engine",
          "signature": "TextureAddressingMode",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#UVWAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "amV",
          "package": "lambdacube-engine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:amV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "amW",
          "package": "lambdacube-engine",
          "signature": "TextureAddressingMode",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#UVWAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "amW",
          "package": "lambdacube-engine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:amW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teAmplitude",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teAmplitude",
          "package": "lambdacube-engine",
          "partial": "Amplitude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teAmplitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teArg1",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teArg1",
          "package": "lambdacube-engine",
          "partial": "Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teArg1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teArg2",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teArg2",
          "package": "lambdacube-engine",
          "partial": "Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teArg2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teBase",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teBase",
          "package": "lambdacube-engine",
          "partial": "Base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teFrequency",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teFrequency",
          "package": "lambdacube-engine",
          "partial": "Frequency",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teFrequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tePhase",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tePhase",
          "package": "lambdacube-engine",
          "partial": "Phase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tePhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teSubType",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teSubType",
          "package": "lambdacube-engine",
          "partial": "Sub Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teSubType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teType",
          "package": "lambdacube-engine",
          "signature": "TextureEffectType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teType",
          "package": "lambdacube-engine",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teWaveType",
          "package": "lambdacube-engine",
          "signature": "WaveformType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "teWaveType",
          "package": "lambdacube-engine",
          "partial": "Wave Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:teWaveType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusAddressMode",
          "package": "lambdacube-engine",
          "signature": "UVWAddressingMode",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusAddressMode",
          "package": "lambdacube-engine",
          "partial": "Address Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusAddressMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusAlphaBlendMode",
          "package": "lambdacube-engine",
          "signature": "LayerBlendModeEx",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusAlphaBlendMode",
          "package": "lambdacube-engine",
          "partial": "Alpha Blend Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusAlphaBlendMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuration of animation in seconds\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusAnimDuration",
          "package": "lambdacube-engine",
          "signature": "Maybe FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Duration of animation in seconds",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusAnimDuration",
          "package": "lambdacube-engine",
          "partial": "Anim Duration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusAnimDuration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinding type (fragment or vertex pipeline)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusBindingType",
          "package": "lambdacube-engine",
          "signature": "BindingType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Binding type fragment or vertex pipeline",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusBindingType",
          "package": "lambdacube-engine",
          "partial": "Binding Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusBindingType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusBorderColour",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusBorderColour",
          "package": "lambdacube-engine",
          "partial": "Border Colour",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusBorderColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusColourBlendFallbackDest",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusColourBlendFallbackDest",
          "package": "lambdacube-engine",
          "partial": "Colour Blend Fallback Dest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusColourBlendFallbackDest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusColourBlendFallbackSrc",
          "package": "lambdacube-engine",
          "signature": "SceneBlendFactor",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusColourBlendFallbackSrc",
          "package": "lambdacube-engine",
          "partial": "Colour Blend Fallback Src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusColourBlendFallbackSrc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusColourBlendMode",
          "package": "lambdacube-engine",
          "signature": "LayerBlendModeEx",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusColourBlendMode",
          "package": "lambdacube-engine",
          "partial": "Colour Blend Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusColourBlendMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContent type of texture (normal loaded texture, auto-texture)\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusContentType",
          "package": "lambdacube-engine",
          "signature": "ContentType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Content type of texture normal loaded texture auto-texture",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusContentType",
          "package": "lambdacube-engine",
          "partial": "Content Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusContentType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis this a series of 6 2D textures to make up a cube?\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusCubic",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "is this series of textures to make up cube",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusCubic",
          "package": "lambdacube-engine",
          "partial": "Cubic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusCubic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusDesiredFormat",
          "package": "lambdacube-engine",
          "signature": "PixelFormat",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusDesiredFormat",
          "package": "lambdacube-engine",
          "partial": "Desired Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusDesiredFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusEffects",
          "package": "lambdacube-engine",
          "signature": "[TextureEffect]",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusEffects",
          "normalized": "[TextureEffect]",
          "package": "lambdacube-engine",
          "partial": "Effects",
          "signature": "[TextureEffect]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusFrameNames",
          "package": "lambdacube-engine",
          "signature": "[String]",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusFrameNames",
          "normalized": "[String]",
          "package": "lambdacube-engine",
          "partial": "Frame Names",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusFrameNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusFrames",
          "package": "lambdacube-engine",
          "signature": "Maybe [t]",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusFrames",
          "normalized": "Maybe[a]",
          "package": "lambdacube-engine",
          "partial": "Frames",
          "signature": "Maybe[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusFrames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusHwGamma",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusHwGamma",
          "package": "lambdacube-engine",
          "partial": "Hw Gamma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusHwGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusIsAlpha",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusIsAlpha",
          "package": "lambdacube-engine",
          "partial": "Is Alpha",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusIsAlpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture filtering - magnification\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMagFilter",
          "package": "lambdacube-engine",
          "signature": "FilterOptions",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Texture filtering magnification",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMagFilter",
          "package": "lambdacube-engine",
          "partial": "Mag Filter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusMagFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture anisotropy\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMaxAniso",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Texture anisotropy",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMaxAniso",
          "package": "lambdacube-engine",
          "partial": "Max Aniso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusMaxAniso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture filtering - minification\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMinFilter",
          "package": "lambdacube-engine",
          "signature": "FilterOptions",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Texture filtering minification",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMinFilter",
          "package": "lambdacube-engine",
          "partial": "Min Filter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusMinFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTexture filtering - mipmapping\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMipFilter",
          "package": "lambdacube-engine",
          "signature": "FilterOptions",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Texture filtering mipmapping",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMipFilter",
          "package": "lambdacube-engine",
          "partial": "Mip Filter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusMipFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMipmap bias\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMipmapBias",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Mipmap bias",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusMipmapBias",
          "package": "lambdacube-engine",
          "partial": "Mipmap Bias",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusMipmapBias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional name for the TUS\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "optional name for the TUS",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusRotate",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusRotate",
          "package": "lambdacube-engine",
          "partial": "Rotate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusRotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional alias for texture frames\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureAlias",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "optional alias for texture frames",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureAlias",
          "package": "lambdacube-engine",
          "partial": "Texture Alias",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusTextureAlias"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureCoordSetIndex",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureCoordSetIndex",
          "package": "lambdacube-engine",
          "partial": "Texture Coord Set Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusTextureCoordSetIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRequest number of mipmaps\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureSrcMipmaps",
          "package": "lambdacube-engine",
          "signature": "TextureMipmap",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "description": "Request number of mipmaps",
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureSrcMipmaps",
          "package": "lambdacube-engine",
          "partial": "Texture Src Mipmaps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusTextureSrcMipmaps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureType",
          "package": "lambdacube-engine",
          "signature": "TextureType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusTextureType",
          "package": "lambdacube-engine",
          "partial": "Texture Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusTextureType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusUMod",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusUMod",
          "package": "lambdacube-engine",
          "partial": "UMod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusUMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusUScale",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusUScale",
          "package": "lambdacube-engine",
          "partial": "UScale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusUScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusVMod",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusVMod",
          "package": "lambdacube-engine",
          "partial": "VMod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusVMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusVScale",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-TextureUnitState.html#TextureUnitState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube TextureUnitState",
          "module": "Graphics.LambdaCube.TextureUnitState",
          "name": "tusVScale",
          "package": "lambdacube-engine",
          "partial": "VScale",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-TextureUnitState.html#v:tusVScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "Tree",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Tree.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "Tree",
          "package": "lambdacube-engine",
          "partial": "Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "IndexedTree",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Tree.html#IndexedTree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "IndexedTree",
          "package": "lambdacube-engine",
          "partial": "Indexed Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#t:IndexedTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "IT",
          "package": "lambdacube-engine",
          "signature": "IT String (Trie a) (Trie ByteString)",
          "source": "src/Graphics-LambdaCube-Tree.html#IndexedTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "IT",
          "package": "lambdacube-engine",
          "partial": "IT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:IT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "addNode",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e a -\u003e IndexedTree a -\u003e Maybe (IndexedTree a)",
          "source": "src/Graphics-LambdaCube-Tree.html#addNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "addNode",
          "normalized": "String-\u003eString-\u003ea-\u003eIndexedTree a-\u003eMaybe(IndexedTree a)",
          "package": "lambdacube-engine",
          "partial": "Node",
          "signature": "String-\u003eString-\u003ea-\u003eIndexedTree a-\u003eMaybe(IndexedTree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:addNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "deleteNode",
          "package": "lambdacube-engine",
          "signature": "String -\u003e IndexedTree a -\u003e IndexedTree a",
          "source": "src/Graphics-LambdaCube-Tree.html#deleteNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "deleteNode",
          "normalized": "String-\u003eIndexedTree a-\u003eIndexedTree a",
          "package": "lambdacube-engine",
          "partial": "Node",
          "signature": "String-\u003eIndexedTree a-\u003eIndexedTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:deleteNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "flattenTree",
          "package": "lambdacube-engine",
          "signature": "(a -\u003e b -\u003e a) -\u003e (a -\u003e b -\u003e r) -\u003e a -\u003e IndexedTree b -\u003e [r]",
          "source": "src/Graphics-LambdaCube-Tree.html#flattenTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "flattenTree",
          "normalized": "(a-\u003eb-\u003ea)-\u003e(a-\u003eb-\u003ec)-\u003ea-\u003eIndexedTree b-\u003e[c]",
          "package": "lambdacube-engine",
          "partial": "Tree",
          "signature": "(a-\u003eb-\u003ea)-\u003e(a-\u003eb-\u003er)-\u003ea-\u003eIndexedTree b-\u003e[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:flattenTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "getDataAt",
          "package": "lambdacube-engine",
          "signature": "String -\u003e IndexedTree a -\u003e Maybe a",
          "source": "src/Graphics-LambdaCube-Tree.html#getDataAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "getDataAt",
          "normalized": "String-\u003eIndexedTree a-\u003eMaybe a",
          "package": "lambdacube-engine",
          "partial": "Data At",
          "signature": "String-\u003eIndexedTree a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:getDataAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "nextName",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String",
          "source": "src/Graphics-LambdaCube-Tree.html#nextName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "nextName",
          "normalized": "String-\u003eString",
          "package": "lambdacube-engine",
          "partial": "Name",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:nextName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "root",
          "package": "lambdacube-engine",
          "signature": "String -\u003e a -\u003e IndexedTree a",
          "source": "src/Graphics-LambdaCube-Tree.html#root",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "root",
          "normalized": "String-\u003ea-\u003eIndexedTree a",
          "package": "lambdacube-engine",
          "signature": "String-\u003ea-\u003eIndexedTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "sep",
          "package": "lambdacube-engine",
          "signature": "Char",
          "source": "src/Graphics-LambdaCube-Tree.html#sep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "sep",
          "package": "lambdacube-engine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:sep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "separator",
          "package": "lambdacube-engine",
          "signature": "ByteString",
          "source": "src/Graphics-LambdaCube-Tree.html#separator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "separator",
          "package": "lambdacube-engine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:separator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Tree",
          "name": "updateNode",
          "package": "lambdacube-engine",
          "signature": "(a -\u003e a) -\u003e String -\u003e IndexedTree a -\u003e IndexedTree a",
          "source": "src/Graphics-LambdaCube-Tree.html#updateNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Tree",
          "module": "Graphics.LambdaCube.Tree",
          "name": "updateNode",
          "normalized": "(a-\u003ea)-\u003eString-\u003eIndexedTree a-\u003eIndexedTree a",
          "package": "lambdacube-engine",
          "partial": "Node",
          "signature": "(a-\u003ea)-\u003eString-\u003eIndexedTree a-\u003eIndexedTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Tree.html#v:updateNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Types",
          "name": "Types",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Types",
          "module": "Graphics.LambdaCube.Types",
          "name": "Types",
          "package": "lambdacube-engine",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Types",
          "name": "ColourValue",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Types.html#ColourValue",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Types",
          "module": "Graphics.LambdaCube.Types",
          "name": "ColourValue",
          "package": "lambdacube-engine",
          "partial": "Colour Value",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Types.html#t:ColourValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe floating point type used throughout the engine.  It is\n recommended to use this synonym ubiquitously in code interfacing\n with LambdaCube.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Types.html#FloatType",
          "type": "type"
        },
        "index": {
          "description": "The floating point type used throughout the engine It is recommended to use this synonym ubiquitously in code interfacing with LambdaCube",
          "hierarchy": "Graphics LambdaCube Types",
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType",
          "package": "lambdacube-engine",
          "partial": "Float Type",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Types.html#t:FloatType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType2",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Types.html#FloatType2",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Types",
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType2",
          "package": "lambdacube-engine",
          "partial": "Float Type",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Types.html#t:FloatType2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType3",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Types.html#FloatType3",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Types",
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType3",
          "package": "lambdacube-engine",
          "partial": "Float Type",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Types.html#t:FloatType3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType4",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Types.html#FloatType4",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Types",
          "module": "Graphics.LambdaCube.Types",
          "name": "FloatType4",
          "package": "lambdacube-engine",
          "partial": "Float Type",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Types.html#t:FloatType4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Types",
          "name": "RGB",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Types.html#RGB",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Types",
          "module": "Graphics.LambdaCube.Types",
          "name": "RGB",
          "package": "lambdacube-engine",
          "partial": "RGB",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Types.html#t:RGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Utility",
          "name": "Utility",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Utility.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Utility",
          "module": "Graphics.LambdaCube.Utility",
          "name": "Utility",
          "package": "lambdacube-engine",
          "partial": "Utility",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Utility.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Utility",
          "name": "foldM'",
          "package": "lambdacube-engine",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e [b] -\u003e m a",
          "source": "src/Graphics-LambdaCube-Utility.html#foldM%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Utility",
          "module": "Graphics.LambdaCube.Utility",
          "name": "foldM'",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003e[b]-\u003ec a",
          "package": "lambdacube-engine",
          "partial": "M'",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003e[b]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Utility.html#v:foldM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.Utility",
          "name": "groupSetBy",
          "package": "lambdacube-engine",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e [[a]]",
          "source": "src/Graphics-LambdaCube-Utility.html#groupSetBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube Utility",
          "module": "Graphics.LambdaCube.Utility",
          "name": "groupSetBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[[a]]",
          "package": "lambdacube-engine",
          "partial": "Set By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Utility.html#v:groupSetBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCamera transformation matrix.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Utility",
          "name": "lookat",
          "package": "lambdacube-engine",
          "signature": "Vec3-\u003e Vec3-\u003e Vec3-\u003e Proj4",
          "type": "function"
        },
        "index": {
          "description": "Camera transformation matrix",
          "hierarchy": "Graphics LambdaCube Utility",
          "module": "Graphics.LambdaCube.Utility",
          "name": "lookat",
          "normalized": "Vec-\u003eVec-\u003eVec-\u003eProj",
          "package": "lambdacube-engine",
          "signature": "Vec-\u003eVec-\u003eVec-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Utility.html#v:lookat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerspective transformation matrix.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Utility",
          "name": "perspective",
          "package": "lambdacube-engine",
          "signature": "FloatType-\u003e FloatType-\u003e FloatType-\u003e FloatType-\u003e Mat4",
          "type": "function"
        },
        "index": {
          "description": "Perspective transformation matrix",
          "hierarchy": "Graphics LambdaCube Utility",
          "module": "Graphics.LambdaCube.Utility",
          "name": "perspective",
          "normalized": "FloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eMat",
          "package": "lambdacube-engine",
          "signature": "FloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Utility.html#v:perspective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePure orientation matrix defined by Euler angles.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.Utility",
          "name": "rotationEuler",
          "package": "lambdacube-engine",
          "signature": "Vec3 -\u003e Proj4",
          "source": "src/Graphics-LambdaCube-Utility.html#rotationEuler",
          "type": "function"
        },
        "index": {
          "description": "Pure orientation matrix defined by Euler angles",
          "hierarchy": "Graphics LambdaCube Utility",
          "module": "Graphics.LambdaCube.Utility",
          "name": "rotationEuler",
          "normalized": "Vec-\u003eProj",
          "package": "lambdacube-engine",
          "partial": "Euler",
          "signature": "Vec-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-Utility.html#v:rotationEuler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VertexBufferVector",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VertexBufferVector",
          "package": "lambdacube-engine",
          "partial": "Vertex Buffer Vector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VIB",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VIB",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VIB",
          "package": "lambdacube-engine",
          "partial": "VIB",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#t:VIB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultimaterial geometry, including a default geometry for\n submeshes that don't provide their own.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VMesh",
          "type": "data"
        },
        "index": {
          "description": "Multimaterial geometry including default geometry for submeshes that don provide their own",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#t:VMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeometry with associated material.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VSubMesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VSubMesh",
          "type": "data"
        },
        "index": {
          "description": "Geometry with associated material",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VSubMesh",
          "package": "lambdacube-engine",
          "partial": "VSub Mesh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#t:VSubMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVB",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VVB",
          "type": "type"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVB",
          "package": "lambdacube-engine",
          "partial": "VVB",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#t:VVB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive buffer data\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VectorVertexData",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "data"
        },
        "index": {
          "description": "Primitive buffer data",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VectorVertexData",
          "package": "lambdacube-engine",
          "partial": "Vector Vertex Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#t:VectorVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe types of \u003ccode\u003e\u003ca\u003eVectorVertexData\u003c/a\u003e\u003c/code\u003e without the data.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VectorVertexType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "data"
        },
        "index": {
          "description": "The types of VectorVertexData without the data",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VectorVertexType",
          "package": "lambdacube-engine",
          "partial": "Vector Vertex Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#t:VectorVertexType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "signature": "VMesh",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VMesh\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VMesh\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VSubMesh",
          "package": "lambdacube-engine",
          "signature": "VSubMesh",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VSubMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VSubMesh\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VSubMesh\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VSubMesh",
          "package": "lambdacube-engine",
          "partial": "VSub Mesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VSubMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_BINORMAL",
          "package": "lambdacube-engine",
          "signature": "VVD_BINORMAL (Vector Vec3)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_BINORMAL\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_BINORMAL\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_BINORMAL",
          "package": "lambdacube-engine",
          "partial": "VVD BINORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_BINORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_BLEND_INDICES",
          "package": "lambdacube-engine",
          "signature": "VVD_BLEND_INDICES (Vector Int)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_BLEND_INDICES\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_BLEND_INDICES\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_BLEND_INDICES",
          "package": "lambdacube-engine",
          "partial": "VVD BLEND INDICES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_BLEND_INDICES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_BLEND_WEIGHTS",
          "package": "lambdacube-engine",
          "signature": "VVD_BLEND_WEIGHTS (Vector FloatType)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_BLEND_WEIGHTS\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_BLEND_WEIGHTS\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_BLEND_WEIGHTS",
          "package": "lambdacube-engine",
          "partial": "VVD BLEND WEIGHTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_BLEND_WEIGHTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_DIFFUSE",
          "package": "lambdacube-engine",
          "signature": "VVD_DIFFUSE (Vector Vec4)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_DIFFUSE\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_DIFFUSE\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_DIFFUSE",
          "package": "lambdacube-engine",
          "partial": "VVD DIFFUSE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_DIFFUSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_NORMAL",
          "package": "lambdacube-engine",
          "signature": "VVD_NORMAL (Vector Vec3)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_NORMAL\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_NORMAL\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_NORMAL",
          "package": "lambdacube-engine",
          "partial": "VVD NORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_NORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_POSITION",
          "package": "lambdacube-engine",
          "signature": "VVD_POSITION (Vector Vec3)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_POSITION\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_POSITION\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_POSITION",
          "package": "lambdacube-engine",
          "partial": "VVD POSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_POSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_SPECULAR",
          "package": "lambdacube-engine",
          "signature": "VVD_SPECULAR (Vector Vec3)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_SPECULAR\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_SPECULAR\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_SPECULAR",
          "package": "lambdacube-engine",
          "partial": "VVD SPECULAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_SPECULAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_TANGENT",
          "package": "lambdacube-engine",
          "signature": "VVD_TANGENT (Vector Vec3)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TANGENT\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_TANGENT\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_TANGENT",
          "package": "lambdacube-engine",
          "partial": "VVD TANGENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TANGENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_TEXTURE_COORDINATES1",
          "package": "lambdacube-engine",
          "signature": "VVD_TEXTURE_COORDINATES1 (Vector FloatType)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TEXTURE_COORDINATES1\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_TEXTURE_COORDINATES1\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_TEXTURE_COORDINATES1",
          "package": "lambdacube-engine",
          "partial": "VVD TEXTURE COORDINATES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TEXTURE_COORDINATES1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_TEXTURE_COORDINATES2",
          "package": "lambdacube-engine",
          "signature": "VVD_TEXTURE_COORDINATES2 (Vector Vec2)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TEXTURE_COORDINATES2\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_TEXTURE_COORDINATES2\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_TEXTURE_COORDINATES2",
          "package": "lambdacube-engine",
          "partial": "VVD TEXTURE COORDINATES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TEXTURE_COORDINATES2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVD_TEXTURE_COORDINATES3",
          "package": "lambdacube-engine",
          "signature": "VVD_TEXTURE_COORDINATES3 (Vector Vec3)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TEXTURE_COORDINATES3\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVD_TEXTURE_COORDINATES3\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVD_TEXTURE_COORDINATES3",
          "package": "lambdacube-engine",
          "partial": "VVD TEXTURE COORDINATES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVD_TEXTURE_COORDINATES3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_BINORMAL",
          "package": "lambdacube-engine",
          "signature": "VVT_BINORMAL",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_BINORMAL\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_BINORMAL\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_BINORMAL",
          "package": "lambdacube-engine",
          "partial": "VVT BINORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_BINORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_BLEND_INDICES",
          "package": "lambdacube-engine",
          "signature": "VVT_BLEND_INDICES",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_BLEND_INDICES\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_BLEND_INDICES\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_BLEND_INDICES",
          "package": "lambdacube-engine",
          "partial": "VVT BLEND INDICES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_BLEND_INDICES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_BLEND_WEIGHTS",
          "package": "lambdacube-engine",
          "signature": "VVT_BLEND_WEIGHTS",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_BLEND_WEIGHTS\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_BLEND_WEIGHTS\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_BLEND_WEIGHTS",
          "package": "lambdacube-engine",
          "partial": "VVT BLEND WEIGHTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_BLEND_WEIGHTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_DIFFUSE",
          "package": "lambdacube-engine",
          "signature": "VVT_DIFFUSE",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_DIFFUSE\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_DIFFUSE\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_DIFFUSE",
          "package": "lambdacube-engine",
          "partial": "VVT DIFFUSE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_DIFFUSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_NORMAL",
          "package": "lambdacube-engine",
          "signature": "VVT_NORMAL",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_NORMAL\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_NORMAL\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_NORMAL",
          "package": "lambdacube-engine",
          "partial": "VVT NORMAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_NORMAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_POSITION",
          "package": "lambdacube-engine",
          "signature": "VVT_POSITION",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_POSITION\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_POSITION\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_POSITION",
          "package": "lambdacube-engine",
          "partial": "VVT POSITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_POSITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_SPECULAR",
          "package": "lambdacube-engine",
          "signature": "VVT_SPECULAR",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_SPECULAR\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_SPECULAR\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_SPECULAR",
          "package": "lambdacube-engine",
          "partial": "VVT SPECULAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_SPECULAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_TANGENT",
          "package": "lambdacube-engine",
          "signature": "VVT_TANGENT",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TANGENT\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_TANGENT\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_TANGENT",
          "package": "lambdacube-engine",
          "partial": "VVT TANGENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TANGENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_TEXTURE_COORDINATES1",
          "package": "lambdacube-engine",
          "signature": "VVT_TEXTURE_COORDINATES1",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TEXTURE_COORDINATES1\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_TEXTURE_COORDINATES1\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_TEXTURE_COORDINATES1",
          "package": "lambdacube-engine",
          "partial": "VVT TEXTURE COORDINATES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TEXTURE_COORDINATES1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_TEXTURE_COORDINATES2",
          "package": "lambdacube-engine",
          "signature": "VVT_TEXTURE_COORDINATES2",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TEXTURE_COORDINATES2\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_TEXTURE_COORDINATES2\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_TEXTURE_COORDINATES2",
          "package": "lambdacube-engine",
          "partial": "VVT TEXTURE COORDINATES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TEXTURE_COORDINATES2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "VVT_TEXTURE_COORDINATES3",
          "package": "lambdacube-engine",
          "signature": "VVT_TEXTURE_COORDINATES3",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TEXTURE_COORDINATES3\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:VVT_TEXTURE_COORDINATES3\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "VVT_TEXTURE_COORDINATES3",
          "package": "lambdacube-engine",
          "partial": "VVT TEXTURE COORDINATES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:VVT_TEXTURE_COORDINATES3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "fromVectorIndexData",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e VIB -\u003e IO (IndexData ib)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#fromVectorIndexData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "fromVectorIndexData",
          "normalized": "a-\u003eVIB-\u003eIO(IndexData b)",
          "package": "lambdacube-engine",
          "partial": "Vector Index Data",
          "signature": "rs-\u003eVIB-\u003eIO(IndexData ib)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:fromVectorIndexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "fromVectorVertexData",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e Vector VectorVertexData -\u003e IO (VertexData vb)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#fromVectorVertexData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "fromVectorVertexData",
          "normalized": "a-\u003eVector VectorVertexData-\u003eIO(VertexData b)",
          "package": "lambdacube-engine",
          "partial": "Vector Vertex Data",
          "signature": "rs-\u003eVector VectorVertexData-\u003eIO(VertexData vb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:fromVectorVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "meshFromV",
          "package": "lambdacube-engine",
          "signature": "rs -\u003e VMesh -\u003e IO (Mesh vb ib)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#meshFromV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "meshFromV",
          "normalized": "a-\u003eVMesh-\u003eIO(Mesh b c)",
          "package": "lambdacube-engine",
          "partial": "From",
          "signature": "rs-\u003eVMesh-\u003eIO(Mesh vb ib)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:meshFromV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "toVectorIndexData",
          "package": "lambdacube-engine",
          "signature": "IndexData ib -\u003e IO VIB",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#toVectorIndexData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "toVectorIndexData",
          "normalized": "IndexData a-\u003eIO VIB",
          "package": "lambdacube-engine",
          "partial": "Vector Index Data",
          "signature": "IndexData ib-\u003eIO VIB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:toVectorIndexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "toVectorVertexData",
          "package": "lambdacube-engine",
          "signature": "VertexData vb -\u003e IO (Vector VectorVertexData)",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#toVectorVertexData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "toVectorVertexData",
          "normalized": "VertexData a-\u003eIO(Vector VectorVertexData)",
          "package": "lambdacube-engine",
          "partial": "Vector Vertex Data",
          "signature": "VertexData vb-\u003eIO(Vector VectorVertexData)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:toVectorVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vFromMesh",
          "package": "lambdacube-engine",
          "signature": "Mesh vb ib -\u003e IO VMesh",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#vFromMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vFromMesh",
          "normalized": "Mesh a b-\u003eIO VMesh",
          "package": "lambdacube-engine",
          "partial": "From Mesh",
          "signature": "Mesh vb ib-\u003eIO VMesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vFromMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the type of the vertex data.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "vectorVertexType",
          "package": "lambdacube-engine",
          "signature": "VectorVertexData -\u003e VectorVertexType",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#vectorVertexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vectorVertexType\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:vectorVertexType\"]"
        },
        "index": {
          "description": "Extract the type of the vertex data",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vectorVertexType",
          "normalized": "VectorVertexData-\u003eVectorVertexType",
          "package": "lambdacube-engine",
          "partial": "Vertex Type",
          "signature": "VectorVertexData-\u003eVectorVertexType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vectorVertexType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault geometry for submeshes.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "vmSharedVertexData",
          "package": "lambdacube-engine",
          "signature": "Maybe VVB",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vmSharedVertexData\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:vmSharedVertexData\"]"
        },
        "index": {
          "description": "Default geometry for submeshes",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vmSharedVertexData",
          "package": "lambdacube-engine",
          "partial": "Shared Vertex Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vmSharedVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe collection of single-material submeshes making up the mesh.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "vmSubMeshList",
          "package": "lambdacube-engine",
          "signature": "[VSubMesh]",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vmSubMeshList\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:vmSubMeshList\"]"
        },
        "index": {
          "description": "The collection of single-material submeshes making up the mesh",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vmSubMeshList",
          "normalized": "[VSubMesh]",
          "package": "lambdacube-engine",
          "partial": "Sub Mesh List",
          "signature": "[VSubMesh]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vmSubMeshList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional index buffer.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "vsmIndexData",
          "package": "lambdacube-engine",
          "signature": "Maybe VIB",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VSubMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmIndexData\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:vsmIndexData\"]"
        },
        "index": {
          "description": "Optional index buffer",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vsmIndexData",
          "package": "lambdacube-engine",
          "partial": "Index Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmIndexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe material associated with the submesh.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "vsmMaterialName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VSubMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmMaterialName\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:vsmMaterialName\"]"
        },
        "index": {
          "description": "The material associated with the submesh",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vsmMaterialName",
          "package": "lambdacube-engine",
          "partial": "Material Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmMaterialName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of primitives making up the geometry.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "vsmOperationType",
          "package": "lambdacube-engine",
          "signature": "OperationType",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VSubMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmOperationType\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:vsmOperationType\"]"
        },
        "index": {
          "description": "The type of primitives making up the geometry",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vsmOperationType",
          "package": "lambdacube-engine",
          "partial": "Operation Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmOperationType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional vertex buffer (supplied by the containing mesh if absent).\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.VertexBufferVector\",\"Graphics.LambdaCube\"]",
          "name": "vsmVertexData",
          "package": "lambdacube-engine",
          "signature": "Maybe VVB",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VSubMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmVertexData\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:vsmVertexData\"]"
        },
        "index": {
          "description": "Optional vertex buffer supplied by the containing mesh if absent",
          "hierarchy": "Graphics LambdaCube VertexBufferVector",
          "module": "Graphics.LambdaCube.VertexBufferVector",
          "name": "vsmVertexData",
          "package": "lambdacube-engine",
          "partial": "Vertex Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexBufferVector.html#v:vsmVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "VertexIndexData",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "VertexIndexData",
          "package": "lambdacube-engine",
          "partial": "Vertex Index Data",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "IndexData",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#IndexData",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "IndexData",
          "package": "lambdacube-engine",
          "partial": "Index Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#t:IndexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "VertexData",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#VertexData",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "VertexData",
          "package": "lambdacube-engine",
          "partial": "Vertex Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#t:VertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "IndexData",
          "package": "lambdacube-engine",
          "signature": "IndexData",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#IndexData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "IndexData",
          "package": "lambdacube-engine",
          "partial": "Index Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:IndexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "VertexData",
          "package": "lambdacube-engine",
          "signature": "VertexData",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#VertexData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "VertexData",
          "package": "lambdacube-engine",
          "partial": "Vertex Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:VertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epointer to the HardwareIndexBuffer to use, must be specified if useIndexes = true\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "idIndexBuffer",
          "package": "lambdacube-engine",
          "signature": "ib",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#IndexData",
          "type": "function"
        },
        "index": {
          "description": "pointer to the HardwareIndexBuffer to use must be specified if useIndexes true",
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "idIndexBuffer",
          "package": "lambdacube-engine",
          "partial": "Index Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:idIndexBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of indexes to use from the buffer\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "idIndexCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#IndexData",
          "type": "function"
        },
        "index": {
          "description": "The number of indexes to use from the buffer",
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "idIndexCount",
          "package": "lambdacube-engine",
          "partial": "Index Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:idIndexCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindex in the buffer to start from for this operation\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "idIndexStart",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#IndexData",
          "type": "function"
        },
        "index": {
          "description": "index in the buffer to start from for this operation",
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "idIndexStart",
          "package": "lambdacube-engine",
          "partial": "Index Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:idIndexStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe vertex buffer bindings to be used. remarks Note that this is created for you on construction.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexBufferBinding",
          "package": "lambdacube-engine",
          "signature": "VertexBufferBinding vb",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#VertexData",
          "type": "function"
        },
        "index": {
          "description": "The vertex buffer bindings to be used remarks Note that this is created for you on construction",
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexBufferBinding",
          "package": "lambdacube-engine",
          "partial": "Vertex Buffer Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:vdVertexBufferBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of vertices used in this operation\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexCount",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#VertexData",
          "type": "function"
        },
        "index": {
          "description": "The number of vertices used in this operation",
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexCount",
          "package": "lambdacube-engine",
          "partial": "Vertex Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:vdVertexCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclaration of the vertex to be used in this operation. remarks Note that this is created for you on construction.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexDeclaration",
          "package": "lambdacube-engine",
          "signature": "VertexDeclaration",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#VertexData",
          "type": "function"
        },
        "index": {
          "description": "Declaration of the vertex to be used in this operation remarks Note that this is created for you on construction",
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexDeclaration",
          "package": "lambdacube-engine",
          "partial": "Vertex Declaration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:vdVertexDeclaration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe base vertex index to start from\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexStart",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-VertexIndexData.html#VertexData",
          "type": "function"
        },
        "index": {
          "description": "The base vertex index to start from",
          "hierarchy": "Graphics LambdaCube VertexIndexData",
          "module": "Graphics.LambdaCube.VertexIndexData",
          "name": "vdVertexStart",
          "package": "lambdacube-engine",
          "partial": "Vertex Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-VertexIndexData.html#v:vdVertexStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "World",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "World",
          "package": "lambdacube-engine",
          "partial": "World",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCamera description.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.World",
          "name": "Camera",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "data"
        },
        "index": {
          "description": "Camera description",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "Camera",
          "package": "lambdacube-engine",
          "partial": "Camera",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:Camera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "FlattenScene",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#FlattenScene",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "FlattenScene",
          "package": "lambdacube-engine",
          "partial": "Flatten Scene",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:FlattenScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "LCM",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#LCM",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "LCM",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:LCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "RenderTarget",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#RenderTarget",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "RenderTarget",
          "package": "lambdacube-engine",
          "partial": "Render Target",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:RenderTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "ResourceLibrary",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "ResourceLibrary",
          "package": "lambdacube-engine",
          "partial": "Resource Library",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:ResourceLibrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "Scene",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#Scene",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "Scene",
          "package": "lambdacube-engine",
          "partial": "Scene",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:Scene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SceneNode",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#SceneNode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SceneNode",
          "package": "lambdacube-engine",
          "partial": "Scene Node",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:SceneNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SceneObject",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#SceneObject",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SceneObject",
          "package": "lambdacube-engine",
          "partial": "Scene Object",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:SceneObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "Sky",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#Sky",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "Sky",
          "package": "lambdacube-engine",
          "partial": "Sky",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:Sky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "Viewport",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "Viewport",
          "package": "lambdacube-engine",
          "partial": "Viewport",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:Viewport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "World",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "World",
          "package": "lambdacube-engine",
          "partial": "World",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#t:World"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "Camera",
          "package": "lambdacube-engine",
          "signature": "Camera",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:Camera\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:Camera\"]"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "Camera",
          "package": "lambdacube-engine",
          "partial": "Camera",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:Camera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "FlattenScene",
          "package": "lambdacube-engine",
          "signature": "FlattenScene",
          "source": "src/Graphics-LambdaCube-World.html#FlattenScene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "FlattenScene",
          "package": "lambdacube-engine",
          "partial": "Flatten Scene",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:FlattenScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "LCM",
          "package": "lambdacube-engine",
          "signature": "LCM",
          "source": "src/Graphics-LambdaCube-World.html#LCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "LCM",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:LCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "RenderTarget",
          "package": "lambdacube-engine",
          "signature": "RenderTarget",
          "source": "src/Graphics-LambdaCube-World.html#RenderTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "RenderTarget",
          "package": "lambdacube-engine",
          "partial": "Render Target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:RenderTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "ResourceLibrary",
          "package": "lambdacube-engine",
          "signature": "ResourceLibrary",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "ResourceLibrary",
          "package": "lambdacube-engine",
          "partial": "Resource Library",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:ResourceLibrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SO_Camera",
          "package": "lambdacube-engine",
          "signature": "SO_Camera Camera",
          "source": "src/Graphics-LambdaCube-World.html#SceneObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SO_Camera",
          "package": "lambdacube-engine",
          "partial": "SO Camera",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:SO_Camera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SO_Entity",
          "package": "lambdacube-engine",
          "signature": "SO_Entity (Entity vb ib t lp)",
          "source": "src/Graphics-LambdaCube-World.html#SceneObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SO_Entity",
          "package": "lambdacube-engine",
          "partial": "SO Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:SO_Entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SO_Light",
          "package": "lambdacube-engine",
          "signature": "SO_Light Light",
          "source": "src/Graphics-LambdaCube-World.html#SceneObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SO_Light",
          "package": "lambdacube-engine",
          "partial": "SO Light",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:SO_Light"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "Scene",
          "package": "lambdacube-engine",
          "signature": "Scene",
          "source": "src/Graphics-LambdaCube-World.html#Scene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "Scene",
          "package": "lambdacube-engine",
          "partial": "Scene",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:Scene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SceneNode",
          "package": "lambdacube-engine",
          "signature": "SceneNode",
          "source": "src/Graphics-LambdaCube-World.html#SceneNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SceneNode",
          "package": "lambdacube-engine",
          "partial": "Scene Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:SceneNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SkyBox",
          "package": "lambdacube-engine",
          "signature": "SkyBox",
          "source": "src/Graphics-LambdaCube-World.html#Sky",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SkyBox",
          "package": "lambdacube-engine",
          "partial": "Sky Box",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:SkyBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SkyDome",
          "package": "lambdacube-engine",
          "signature": "SkyDome",
          "source": "src/Graphics-LambdaCube-World.html#Sky",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SkyDome",
          "package": "lambdacube-engine",
          "partial": "Sky Dome",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:SkyDome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "SkyPlane",
          "package": "lambdacube-engine",
          "signature": "SkyPlane",
          "source": "src/Graphics-LambdaCube-World.html#Sky",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "SkyPlane",
          "package": "lambdacube-engine",
          "partial": "Sky Plane",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:SkyPlane"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "Viewport",
          "package": "lambdacube-engine",
          "signature": "Viewport",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "Viewport",
          "package": "lambdacube-engine",
          "partial": "Viewport",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:Viewport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "World",
          "package": "lambdacube-engine",
          "signature": "World",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "World",
          "package": "lambdacube-engine",
          "partial": "World",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:World"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "addMesh",
          "package": "lambdacube-engine",
          "signature": "String -\u003e Mesh vb ib -\u003e World r vb ib q t p lp -\u003e World r vb ib q1 t p lp",
          "source": "src/Graphics-LambdaCube-World.html#addMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "addMesh",
          "normalized": "String-\u003eMesh a b-\u003eWorld c a b d e f g-\u003eWorld c a b d e f g",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "signature": "String-\u003eMesh vb ib-\u003eWorld r vb ib q t p lp-\u003eWorld r vb ib q t p lp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:addMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new texture.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "addRenderTexture",
          "package": "lambdacube-engine",
          "signature": "String-\u003e Int-\u003e Int-\u003e LCM (World r vb ib q a p lp) e ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:addRenderTexture\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:addRenderTexture\"]"
        },
        "index": {
          "description": "Create new texture",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "addRenderTexture",
          "normalized": "String-\u003eInt-\u003eInt-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Render Texture",
          "signature": "String-\u003eInt-\u003eInt-\u003eLCM(World r vb ib q a p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:addRenderTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the viewports to display in the window.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "addRenderWindow",
          "package": "lambdacube-engine",
          "signature": "String-\u003e Int-\u003e Int-\u003e [LCM (World r vb ib q t p lp) e (Viewport t lp)]-\u003e LCM (World r vb ib q t p lp) e ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:addRenderWindow\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:addRenderWindow\"]"
        },
        "index": {
          "description": "Specify the viewports to display in the window",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "addRenderWindow",
          "normalized": "String-\u003eInt-\u003eInt-\u003e[LCM(World a b c d e f g)h(Viewport e g)]-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Render Window",
          "signature": "String-\u003eInt-\u003eInt-\u003e[LCM(World r vb ib q t p lp)e(Viewport t lp)]-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:addRenderWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a new vector mesh to the world.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "addVMesh",
          "package": "lambdacube-engine",
          "signature": "String-\u003e VMesh-\u003e LCM (World r vb ib q t p lp) e ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:addVMesh\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:addVMesh\"]"
        },
        "index": {
          "description": "Add new vector mesh to the world",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "addVMesh",
          "normalized": "String-\u003eVMesh-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "signature": "String-\u003eVMesh-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:addVMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "cameraProjectionMatrix",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e Camera -\u003e Mat4",
          "source": "src/Graphics-LambdaCube-World.html#cameraProjectionMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "cameraProjectionMatrix",
          "normalized": "FloatType-\u003eCamera-\u003eMat",
          "package": "lambdacube-engine",
          "partial": "Projection Matrix",
          "signature": "FloatType-\u003eCamera-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cameraProjectionMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "catchLCM",
          "package": "lambdacube-engine",
          "signature": "LCM w a a -\u003e LCM w e a",
          "source": "src/Graphics-LambdaCube-World.html#catchLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "catchLCM",
          "normalized": "LCM a b b-\u003eLCM a c b",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "LCM w a a-\u003eLCM w e a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:catchLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCamera aspect ratio (width/height).\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "cmAspectRatio",
          "package": "lambdacube-engine",
          "signature": "Maybe FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmAspectRatio\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:cmAspectRatio\"]"
        },
        "index": {
          "description": "Camera aspect ratio width height",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "cmAspectRatio",
          "package": "lambdacube-engine",
          "partial": "Aspect Ratio",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmAspectRatio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFar plane clipping distance.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "cmFar",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmFar\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:cmFar\"]"
        },
        "index": {
          "description": "Far plane clipping distance",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "cmFar",
          "package": "lambdacube-engine",
          "partial": "Far",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmFar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField of view in radians.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "cmFov",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmFov\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:cmFov\"]"
        },
        "index": {
          "description": "Field of view in radians",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "cmFov",
          "package": "lambdacube-engine",
          "partial": "Fov",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmFov"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the camera.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "cmName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmName\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:cmName\"]"
        },
        "index": {
          "description": "The name of the camera",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "cmName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNear plane clipping distance.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "cmNear",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmNear\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:cmNear\"]"
        },
        "index": {
          "description": "Near plane clipping distance",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "cmNear",
          "package": "lambdacube-engine",
          "partial": "Near",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmNear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRendering type.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "cmPolygonMode",
          "package": "lambdacube-engine",
          "signature": "PolygonMode",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmPolygonMode\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:cmPolygonMode\"]"
        },
        "index": {
          "description": "Rendering type",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "cmPolygonMode",
          "package": "lambdacube-engine",
          "partial": "Polygon Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:cmPolygonMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "createEntity",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e rqp -\u003e LCM (World r vb ib q t p lp) e (Entity vb ib t lp)",
          "source": "src/Graphics-LambdaCube-World.html#createEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "createEntity",
          "normalized": "String-\u003eString-\u003ea-\u003eLCM(World b c d e f g h)i(Entity c d f h)",
          "package": "lambdacube-engine",
          "partial": "Entity",
          "signature": "String-\u003eString-\u003erqp-\u003eLCM(World r vb ib q t p lp)e(Entity vb ib t lp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:createEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "debugLCM",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e LCM w e ()",
          "source": "src/Graphics-LambdaCube-World.html#debugLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "debugLCM",
          "normalized": "String-\u003eString-\u003eLCM a b()",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "String-\u003eString-\u003eLCM w e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:debugLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "errorLCM",
          "package": "lambdacube-engine",
          "signature": "String -\u003e String -\u003e LCM w e ()",
          "source": "src/Graphics-LambdaCube-World.html#errorLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "errorLCM",
          "normalized": "String-\u003eString-\u003eLCM a b()",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "String-\u003eString-\u003eLCM w e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:errorLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "fsCamera",
          "package": "lambdacube-engine",
          "signature": "[(Proj4, Camera)]",
          "source": "src/Graphics-LambdaCube-World.html#FlattenScene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "fsCamera",
          "normalized": "[(Proj,Camera)]",
          "package": "lambdacube-engine",
          "partial": "Camera",
          "signature": "[(Proj,Camera)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:fsCamera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "fsLight",
          "package": "lambdacube-engine",
          "signature": "[(Proj4, Light)]",
          "source": "src/Graphics-LambdaCube-World.html#FlattenScene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "fsLight",
          "normalized": "[(Proj,Light)]",
          "package": "lambdacube-engine",
          "partial": "Light",
          "signature": "[(Proj,Light)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:fsLight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of Renderable information including WorldMatrix RenderQueueID and RenderPriority\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.World",
          "name": "fsRenderable",
          "package": "lambdacube-engine",
          "signature": "[(Proj4, [RenderEntity vb ib t lp], Int, Int)]",
          "source": "src/Graphics-LambdaCube-World.html#FlattenScene",
          "type": "function"
        },
        "index": {
          "description": "List of Renderable information including WorldMatrix RenderQueueID and RenderPriority",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "fsRenderable",
          "normalized": "[(Proj,[RenderEntity a b c d],Int,Int)]",
          "package": "lambdacube-engine",
          "partial": "Renderable",
          "signature": "[(Proj,[RenderEntity vb ib t lp],Int,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:fsRenderable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "getLoadedMaterial",
          "package": "lambdacube-engine",
          "signature": "String -\u003e LCM (World r vb ib q t p lp) e (Maybe (Material t lp))",
          "source": "src/Graphics-LambdaCube-World.html#getLoadedMaterial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "getLoadedMaterial",
          "normalized": "String-\u003eLCM(World a b c d e f g)h(Maybe(Material e g))",
          "package": "lambdacube-engine",
          "partial": "Loaded Material",
          "signature": "String-\u003eLCM(World r vb ib q t p lp)e(Maybe(Material t lp))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:getLoadedMaterial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "getMesh",
          "package": "lambdacube-engine",
          "signature": "String -\u003e LCM (World r vb ib q t p lp) e (Mesh vb ib)",
          "source": "src/Graphics-LambdaCube-World.html#getMesh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "getMesh",
          "normalized": "String-\u003eLCM(World a b c d e f g)h(Mesh b c)",
          "package": "lambdacube-engine",
          "partial": "Mesh",
          "signature": "String-\u003eLCM(World r vb ib q t p lp)e(Mesh vb ib)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:getMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve a vector mesh from the world by name.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "getVMesh",
          "package": "lambdacube-engine",
          "signature": "String -\u003e LCM (World r vb ib q t p lp) e VMesh",
          "source": "src/Graphics-LambdaCube-World.html#getVMesh",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:getVMesh\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:getVMesh\"]"
        },
        "index": {
          "description": "Retrieve vector mesh from the world by name",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "getVMesh",
          "normalized": "String-\u003eLCM(World a b c d e f g)h VMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "signature": "String-\u003eLCM(World r vb ib q t p lp)e VMesh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:getVMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "getViewportSize",
          "package": "lambdacube-engine",
          "signature": "RenderTarget t lp -\u003e Viewport t lp -\u003e (Int, Int, Int, Int)",
          "source": "src/Graphics-LambdaCube-World.html#getViewportSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "getViewportSize",
          "normalized": "RenderTarget a b-\u003eViewport a b-\u003e(Int,Int,Int,Int)",
          "package": "lambdacube-engine",
          "partial": "Viewport Size",
          "signature": "RenderTarget t lp-\u003eViewport t lp-\u003e(Int,Int,Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:getViewportSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "inLCM",
          "package": "lambdacube-engine",
          "signature": "(w -\u003e IO w) -\u003e LCM w e ()",
          "source": "src/Graphics-LambdaCube-World.html#inLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "inLCM",
          "normalized": "(a-\u003eIO a)-\u003eLCM a b()",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "(w-\u003eIO w)-\u003eLCM w e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:inLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "loadFile",
          "package": "lambdacube-engine",
          "signature": "[ResourceGroup] -\u003e FilePath -\u003e IO (Maybe ByteString)",
          "source": "src/Graphics-LambdaCube-World.html#loadFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "loadFile",
          "normalized": "[ResourceGroup]-\u003eFilePath-\u003eIO(Maybe ByteString)",
          "package": "lambdacube-engine",
          "partial": "File",
          "signature": "[ResourceGroup]-\u003eFilePath-\u003eIO(Maybe ByteString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:loadFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "loadMaterialResources",
          "package": "lambdacube-engine",
          "signature": "Material t lp -\u003e LCM (World rs vb ib q t p lp) e (Material t lp)",
          "source": "src/Graphics-LambdaCube-World.html#loadMaterialResources",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "loadMaterialResources",
          "normalized": "Material a b-\u003eLCM(World c d e f a g b)h(Material a b)",
          "package": "lambdacube-engine",
          "partial": "Material Resources",
          "signature": "Material t lp-\u003eLCM(World rs vb ib q t p lp)e(Material t lp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:loadMaterialResources"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "mapScene",
          "package": "lambdacube-engine",
          "signature": "(Scene vb ib t lp -\u003e Scene vb ib t lp) -\u003e World r vb ib q t p lp -\u003e World r vb ib q t p lp",
          "source": "src/Graphics-LambdaCube-World.html#mapScene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "mapScene",
          "normalized": "(Scene a b c d-\u003eScene a b c d)-\u003eWorld e a b f c g d-\u003eWorld e a b f c g d",
          "package": "lambdacube-engine",
          "partial": "Scene",
          "signature": "(Scene vb ib t lp-\u003eScene vb ib t lp)-\u003eWorld r vb ib q t p lp-\u003eWorld r vb ib q t p lp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:mapScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "mapTargets",
          "package": "lambdacube-engine",
          "signature": "(Map String (RenderTarget t lp) -\u003e Map String (RenderTarget t lp)) -\u003e World r vb ib q t p lp -\u003e World r vb ib q t p lp",
          "source": "src/Graphics-LambdaCube-World.html#mapTargets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "mapTargets",
          "normalized": "(Map String(RenderTarget a b)-\u003eMap String(RenderTarget a b))-\u003eWorld c d e f a g b-\u003eWorld c d e f a g b",
          "package": "lambdacube-engine",
          "partial": "Targets",
          "signature": "(Map String(RenderTarget t lp)-\u003eMap String(RenderTarget t lp))-\u003eWorld r vb ib q t p lp-\u003eWorld r vb ib q t p lp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:mapTargets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate render textures, and setup compositor chain.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube.World",
          "name": "mkCompositorChain",
          "package": "lambdacube-engine",
          "signature": "[Compositor t lp] -\u003e LCM (World r vb ib q t p lp) e [Compositor t lp]",
          "source": "src/Graphics-LambdaCube-World.html#mkCompositorChain",
          "type": "function"
        },
        "index": {
          "description": "Create render textures and setup compositor chain",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "mkCompositorChain",
          "normalized": "[Compositor a b]-\u003eLCM(World c d e f a g b)h[Compositor a b]",
          "package": "lambdacube-engine",
          "partial": "Compositor Chain",
          "signature": "[Compositor t lp]-\u003eLCM(World r vb ib q t p lp)e[Compositor t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:mkCompositorChain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "mkResource",
          "package": "lambdacube-engine",
          "signature": "ResourceLibrary vb ib t p lp",
          "source": "src/Graphics-LambdaCube-World.html#mkResource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "mkResource",
          "package": "lambdacube-engine",
          "partial": "Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:mkResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "mkScene",
          "package": "lambdacube-engine",
          "signature": "Scene vb ib t lp",
          "source": "src/Graphics-LambdaCube-World.html#mkScene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "mkScene",
          "package": "lambdacube-engine",
          "partial": "Scene",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:mkScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "mkWorld",
          "package": "lambdacube-engine",
          "signature": "r -\u003e [ImageLoader] -\u003e World r vb ib q t p lp",
          "source": "src/Graphics-LambdaCube-World.html#mkWorld",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "mkWorld",
          "normalized": "a-\u003e[ImageLoader]-\u003eWorld a b c d e f g",
          "package": "lambdacube-engine",
          "partial": "World",
          "signature": "r-\u003e[ImageLoader]-\u003eWorld r vb ib q t p lp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:mkWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "peekLCM",
          "package": "lambdacube-engine",
          "signature": "LCM w e w",
          "source": "src/Graphics-LambdaCube-World.html#peekLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "peekLCM",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:peekLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "pokeLCM",
          "package": "lambdacube-engine",
          "signature": "w -\u003e LCM w e ()",
          "source": "src/Graphics-LambdaCube-World.html#pokeLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "pokeLCM",
          "normalized": "a-\u003eLCM a b()",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "w-\u003eLCM w e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:pokeLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the raw data for a resource in a lazy bytestring given its\n path.  The data is cached, so this does not necessarily require\n disk I/O.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "readFile",
          "package": "lambdacube-engine",
          "signature": "FilePath -\u003e LCM (World r vb ib q t p lp) e ByteString",
          "source": "src/Graphics-LambdaCube-World.html#readFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:readFile\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:readFile\"]"
        },
        "index": {
          "description": "Get the raw data for resource in lazy bytestring given its path The data is cached so this does not necessarily require disk",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "readFile",
          "normalized": "FilePath-\u003eLCM(World a b c d e f g)h ByteString",
          "package": "lambdacube-engine",
          "partial": "File",
          "signature": "FilePath-\u003eLCM(World r vb ib q t p lp)e ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:readFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the raw data for a resource in a strict bytestring given its\n path.  The data is cached, so this does not necessarily require\n disk I/O.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "readFile'",
          "package": "lambdacube-engine",
          "signature": "FilePath -\u003e LCM (World r vb ib q t p lp) e ByteString",
          "source": "src/Graphics-LambdaCube-World.html#readFile%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:readFile-39-\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:readFile-39-\"]"
        },
        "index": {
          "description": "Get the raw data for resource in strict bytestring given its path The data is cached so this does not necessarily require disk",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "readFile'",
          "normalized": "FilePath-\u003eLCM(World a b c d e f g)h ByteString",
          "package": "lambdacube-engine",
          "partial": "File'",
          "signature": "FilePath-\u003eLCM(World r vb ib q t p lp)e ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:readFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "renderFlatScene",
          "package": "lambdacube-engine",
          "signature": "FloatType -\u003e String -\u003e FlattenScene vb ib t lp -\u003e LCM (World r vb ib q t p lp) e ()",
          "source": "src/Graphics-LambdaCube-World.html#renderFlatScene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "renderFlatScene",
          "normalized": "FloatType-\u003eString-\u003eFlattenScene a b c d-\u003eLCM(World e a b f c g d)h()",
          "package": "lambdacube-engine",
          "partial": "Flat Scene",
          "signature": "FloatType-\u003eString-\u003eFlattenScene vb ib t lp-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:renderFlatScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rlCompositorMap",
          "package": "lambdacube-engine",
          "signature": "Map String (Compositor t lp)",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rlCompositorMap",
          "package": "lambdacube-engine",
          "partial": "Compositor Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rlCompositorMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rlGpuProgramMap",
          "package": "lambdacube-engine",
          "signature": "Map String (GpuProgramDescriptor p)",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rlGpuProgramMap",
          "package": "lambdacube-engine",
          "partial": "Gpu Program Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rlGpuProgramMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rlLinkedGpuProgramMap",
          "package": "lambdacube-engine",
          "signature": "Map (String, String, String) lp",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rlLinkedGpuProgramMap",
          "normalized": "Map(String,String,String)a",
          "package": "lambdacube-engine",
          "partial": "Linked Gpu Program Map",
          "signature": "Map(String,String,String)lp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rlLinkedGpuProgramMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rlMaterialMap",
          "package": "lambdacube-engine",
          "signature": "Map String (Material t lp)",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rlMaterialMap",
          "package": "lambdacube-engine",
          "partial": "Material Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rlMaterialMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rlMeshMap",
          "package": "lambdacube-engine",
          "signature": "Map String (Mesh vb ib)",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rlMeshMap",
          "package": "lambdacube-engine",
          "partial": "Mesh Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rlMeshMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rlResourceGroups",
          "package": "lambdacube-engine",
          "signature": "[ResourceGroup]",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rlResourceGroups",
          "normalized": "[ResourceGroup]",
          "package": "lambdacube-engine",
          "partial": "Resource Groups",
          "signature": "[ResourceGroup]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rlResourceGroups"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rlTextureMap",
          "package": "lambdacube-engine",
          "signature": "Map String t",
          "source": "src/Graphics-LambdaCube-World.html#ResourceLibrary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rlTextureMap",
          "package": "lambdacube-engine",
          "partial": "Texture Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rlTextureMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rtHeight",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-World.html#RenderTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rtHeight",
          "package": "lambdacube-engine",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rtHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rtName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-World.html#RenderTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rtName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rtName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rtTexture",
          "package": "lambdacube-engine",
          "signature": "Maybe String",
          "source": "src/Graphics-LambdaCube-World.html#RenderTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rtTexture",
          "package": "lambdacube-engine",
          "partial": "Texture",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rtTexture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rtViewport",
          "package": "lambdacube-engine",
          "signature": "[Viewport t lp]",
          "source": "src/Graphics-LambdaCube-World.html#RenderTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rtViewport",
          "normalized": "[Viewport a b]",
          "package": "lambdacube-engine",
          "partial": "Viewport",
          "signature": "[Viewport t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rtViewport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "rtWidth",
          "package": "lambdacube-engine",
          "signature": "Int",
          "source": "src/Graphics-LambdaCube-World.html#RenderTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "rtWidth",
          "package": "lambdacube-engine",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:rtWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmbed a LambdaCube program in IO. The embedding manages a world,\n therefore it requires all the information to create one: the render\n system and a list of image loaders.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "runLCM",
          "package": "lambdacube-engine",
          "signature": "r -\u003e [ImageLoader] -\u003e LCM (World r vb ib q t1 p lp) e a -\u003e IO ()",
          "source": "src/Graphics-LambdaCube-World.html#runLCM",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:runLCM\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:runLCM\"]"
        },
        "index": {
          "description": "Embed LambdaCube program in IO The embedding manages world therefore it requires all the information to create one the render system and list of image loaders",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "runLCM",
          "normalized": "a-\u003e[ImageLoader]-\u003eLCM(World a b c d e f g)h i-\u003eIO()",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "r-\u003e[ImageLoader]-\u003eLCM(World r vb ib q t p lp)e a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:runLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "scGraph",
          "package": "lambdacube-engine",
          "signature": "IndexedTree (SceneNode vb ib t lp)",
          "source": "src/Graphics-LambdaCube-World.html#Scene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "scGraph",
          "package": "lambdacube-engine",
          "partial": "Graph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:scGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "scSky",
          "package": "lambdacube-engine",
          "signature": "Maybe Sky",
          "source": "src/Graphics-LambdaCube-World.html#Scene",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "scSky",
          "package": "lambdacube-engine",
          "partial": "Sky",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:scSky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "setEntityMaterial",
          "package": "lambdacube-engine",
          "signature": "[String] -\u003e Entity vb ib t lp -\u003e LCM (World r vb ib q t p lp) e (Entity vb ib t lp)",
          "source": "src/Graphics-LambdaCube-World.html#setEntityMaterial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "setEntityMaterial",
          "normalized": "[String]-\u003eEntity a b c d-\u003eLCM(World e a b f c g d)h(Entity a b c d)",
          "package": "lambdacube-engine",
          "partial": "Entity Material",
          "signature": "[String]-\u003eEntity vb ib t lp-\u003eLCM(World r vb ib q t p lp)e(Entity vb ib t lp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:setEntityMaterial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "snName",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-World.html#SceneNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "snName",
          "package": "lambdacube-engine",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:snName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "snObject",
          "package": "lambdacube-engine",
          "signature": "[SceneObject vb ib t lp]",
          "source": "src/Graphics-LambdaCube-World.html#SceneNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "snObject",
          "normalized": "[SceneObject a b c d]",
          "package": "lambdacube-engine",
          "partial": "Object",
          "signature": "[SceneObject vb ib t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:snObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "snTransform",
          "package": "lambdacube-engine",
          "signature": "Proj4",
          "source": "src/Graphics-LambdaCube-World.html#SceneNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "snTransform",
          "package": "lambdacube-engine",
          "partial": "Transform",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:snTransform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "throwLCM",
          "package": "lambdacube-engine",
          "signature": "e -\u003e LCM w e a",
          "source": "src/Graphics-LambdaCube-World.html#throwLCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "throwLCM",
          "normalized": "a-\u003eLCM b a c",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "e-\u003eLCM w e a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:throwLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "unLCM",
          "package": "lambdacube-engine",
          "signature": "forall r.  (a -\u003e w -\u003e IO r) -\u003e (e -\u003e w -\u003e IO r) -\u003e w -\u003e IO r",
          "source": "src/Graphics-LambdaCube-World.html#LCM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "unLCM",
          "normalized": "a b(c-\u003ed-\u003eIO e)-\u003e(f-\u003ed-\u003eIO e)-\u003ed-\u003eIO e",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "signature": "forall r.(a-\u003ew-\u003eIO r)-\u003e(e-\u003ew-\u003eIO r)-\u003ew-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:unLCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "updateResource",
          "package": "lambdacube-engine",
          "signature": "(ResourceLibrary vb ib t p lp -\u003e ResourceLibrary vb ib t p lp) -\u003e LCM (World r vb ib q t p lp) e ()",
          "source": "src/Graphics-LambdaCube-World.html#updateResource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "updateResource",
          "normalized": "(ResourceLibrary a b c d e-\u003eResourceLibrary a b c d e)-\u003eLCM(World f a b g c d e)h()",
          "package": "lambdacube-engine",
          "partial": "Resource",
          "signature": "(ResourceLibrary vb ib t p lp-\u003eResourceLibrary vb ib t p lp)-\u003eLCM(World r vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:updateResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the dimensions of a given render target.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "updateTargetSize",
          "package": "lambdacube-engine",
          "signature": "String-\u003e Int-\u003e Int-\u003e LCM (World rs vb ib q t p lp) e ()",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:updateTargetSize\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:updateTargetSize\"]"
        },
        "index": {
          "description": "Adjust the dimensions of given render target",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "updateTargetSize",
          "normalized": "String-\u003eInt-\u003eInt-\u003eLCM(World a b c d e f g)h()",
          "package": "lambdacube-engine",
          "partial": "Target Size",
          "signature": "String-\u003eInt-\u003eInt-\u003eLCM(World rs vb ib q t p lp)e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:updateTargetSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "updateWorld",
          "package": "lambdacube-engine",
          "signature": "(w -\u003e w) -\u003e LCM w e ()",
          "source": "src/Graphics-LambdaCube-World.html#updateWorld",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "updateWorld",
          "normalized": "(a-\u003ea)-\u003eLCM a b()",
          "package": "lambdacube-engine",
          "partial": "World",
          "signature": "(w-\u003ew)-\u003eLCM w e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:updateWorld"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a viewport and attach given compositors.\n\u003c/p\u003e",
          "module": "[\"Graphics.LambdaCube.World\",\"Graphics.LambdaCube\"]",
          "name": "viewport",
          "package": "lambdacube-engine",
          "signature": "FloatType-\u003e FloatType-\u003e FloatType-\u003e FloatType-\u003e String-\u003e [String]-\u003e LCM (World r vb ib q t p lp) e (Viewport t lp)",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:viewport\",\"http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#v:viewport\"]"
        },
        "index": {
          "description": "Create viewport and attach given compositors",
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "viewport",
          "normalized": "FloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eString-\u003e[String]-\u003eLCM(World a b c d e f g)h(Viewport e g)",
          "package": "lambdacube-engine",
          "signature": "FloatType-\u003eFloatType-\u003eFloatType-\u003eFloatType-\u003eString-\u003e[String]-\u003eLCM(World r vb ib q t p lp)e(Viewport t lp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:viewport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpBackColour",
          "package": "lambdacube-engine",
          "signature": "ColourValue",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpBackColour",
          "package": "lambdacube-engine",
          "partial": "Back Colour",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpBackColour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpCamera",
          "package": "lambdacube-engine",
          "signature": "String",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpCamera",
          "package": "lambdacube-engine",
          "partial": "Camera",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpCamera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpClearBuffers",
          "package": "lambdacube-engine",
          "signature": "FrameBufferType",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpClearBuffers",
          "package": "lambdacube-engine",
          "partial": "Clear Buffers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpClearBuffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpClearEveryFrame",
          "package": "lambdacube-engine",
          "signature": "Bool",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpClearEveryFrame",
          "package": "lambdacube-engine",
          "partial": "Clear Every Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpClearEveryFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpCompositors",
          "package": "lambdacube-engine",
          "signature": "[Compositor t lp]",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpCompositors",
          "normalized": "[Compositor a b]",
          "package": "lambdacube-engine",
          "partial": "Compositors",
          "signature": "[Compositor t lp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpCompositors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpHeight",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpHeight",
          "package": "lambdacube-engine",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpLeft",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpLeft",
          "package": "lambdacube-engine",
          "partial": "Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpTop",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpTop",
          "package": "lambdacube-engine",
          "partial": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "vpWidth",
          "package": "lambdacube-engine",
          "signature": "FloatType",
          "source": "src/Graphics-LambdaCube-World.html#Viewport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "vpWidth",
          "package": "lambdacube-engine",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:vpWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "wrImageLoaders",
          "package": "lambdacube-engine",
          "signature": "[ImageLoader]",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "wrImageLoaders",
          "normalized": "[ImageLoader]",
          "package": "lambdacube-engine",
          "partial": "Image Loaders",
          "signature": "[ImageLoader]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:wrImageLoaders"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "wrRenderOptions",
          "package": "lambdacube-engine",
          "signature": "IntMap RenderGroupOptions",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "wrRenderOptions",
          "package": "lambdacube-engine",
          "partial": "Render Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:wrRenderOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "wrRenderSystem",
          "package": "lambdacube-engine",
          "signature": "r",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "wrRenderSystem",
          "package": "lambdacube-engine",
          "partial": "Render System",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:wrRenderSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "wrResource",
          "package": "lambdacube-engine",
          "signature": "ResourceLibrary vb ib t p lp",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "wrResource",
          "package": "lambdacube-engine",
          "partial": "Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:wrResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "wrScene",
          "package": "lambdacube-engine",
          "signature": "Scene vb ib t lp",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "wrScene",
          "package": "lambdacube-engine",
          "partial": "Scene",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:wrScene"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube.World",
          "name": "wrTargets",
          "package": "lambdacube-engine",
          "signature": "Map String (RenderTarget t lp)",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube World",
          "module": "Graphics.LambdaCube.World",
          "name": "wrTargets",
          "package": "lambdacube-engine",
          "partial": "Targets",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube-World.html#v:wrTargets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the public interface of LambdaCube.  All the other modules are\nexposed for the benefit of library writers, but if you feel the need\nto use any of them as a simple user, that should be considered a\ndefect and reported in the issue tracker.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.LambdaCube",
          "name": "LambdaCube",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube.html",
          "type": "module"
        },
        "index": {
          "description": "This is the public interface of LambdaCube All the other modules are exposed for the benefit of library writers but if you feel the need to use any of them as simple user that should be considered defect and reported in the issue tracker",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "LambdaCube",
          "package": "lambdacube-engine",
          "partial": "Lambda Cube",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCamera description.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "Camera",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#Camera",
          "type": "data"
        },
        "index": {
          "description": "Camera description",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "Camera",
          "package": "lambdacube-engine",
          "partial": "Camera",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:Camera"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube",
          "name": "LCM",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#LCM",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "LCM",
          "package": "lambdacube-engine",
          "partial": "LCM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:LCM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLight source description.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "Light",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Light.html#Light",
          "type": "data"
        },
        "index": {
          "description": "Light source description",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "Light",
          "package": "lambdacube-engine",
          "partial": "Light",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:Light"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossible types of light sources.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "LightTypes",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Light.html#LightTypes",
          "type": "data"
        },
        "index": {
          "description": "Possible types of light sources",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "LightTypes",
          "package": "lambdacube-engine",
          "partial": "Light Types",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:LightTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interpretation of a sequence of vertices.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "OperationType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderOperation.html#OperationType",
          "type": "data"
        },
        "index": {
          "description": "The interpretation of sequence of vertices",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "OperationType",
          "package": "lambdacube-engine",
          "partial": "Operation Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:OperationType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of path leading to a resource.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "PathType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-Loader-ResourceScript.html#PathType",
          "type": "data"
        },
        "index": {
          "description": "The type of path leading to resource",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "PathType",
          "package": "lambdacube-engine",
          "partial": "Path Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:PathType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard render queue priorities.  Note that any enumeration type\n can be used to specify render priorities (i.e. top-level drawing\n order), this is just a simple convenience type.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "RenderQueuePriority",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderQueue.html#RenderQueuePriority",
          "type": "data"
        },
        "index": {
          "description": "Standard render queue priorities Note that any enumeration type can be used to specify render priorities i.e top-level drawing order this is just simple convenience type",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "RenderQueuePriority",
          "package": "lambdacube-engine",
          "partial": "Render Queue Priority",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:RenderQueuePriority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-RenderSystem.html#RenderSystem",
          "type": "class"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "RenderSystem",
          "package": "lambdacube-engine",
          "partial": "Render System",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:RenderSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultimaterial geometry, including a default geometry for\n submeshes that don't provide their own.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VMesh",
          "type": "data"
        },
        "index": {
          "description": "Multimaterial geometry including default geometry for submeshes that don provide their own",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "VMesh",
          "package": "lambdacube-engine",
          "partial": "VMesh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:VMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeometry with associated material.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "VSubMesh",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VSubMesh",
          "type": "data"
        },
        "index": {
          "description": "Geometry with associated material",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "VSubMesh",
          "package": "lambdacube-engine",
          "partial": "VSub Mesh",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:VSubMesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive buffer data\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "VectorVertexData",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexData",
          "type": "data"
        },
        "index": {
          "description": "Primitive buffer data",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "VectorVertexData",
          "package": "lambdacube-engine",
          "partial": "Vector Vertex Data",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:VectorVertexData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe types of \u003ccode\u003e\u003ca\u003eVectorVertexData\u003c/a\u003e\u003c/code\u003e without the data.\n\u003c/p\u003e",
          "module": "Graphics.LambdaCube",
          "name": "VectorVertexType",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-VertexBufferVector.html#VectorVertexType",
          "type": "data"
        },
        "index": {
          "description": "The types of VectorVertexData without the data",
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "VectorVertexType",
          "package": "lambdacube-engine",
          "partial": "Vector Vertex Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:VectorVertexType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.LambdaCube",
          "name": "World",
          "package": "lambdacube-engine",
          "source": "src/Graphics-LambdaCube-World.html#World",
          "type": "data"
        },
        "index": {
          "hierarchy": "Graphics LambdaCube",
          "module": "Graphics.LambdaCube",
          "name": "World",
          "package": "lambdacube-engine",
          "partial": "World",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lambdacube-engine/docs/Graphics-LambdaCube.html#t:World"
      }
    }
  ]
]