[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hint"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "Extension",
          "package": "hint",
          "source": "src/Language-Haskell-Interpreter-Extension.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "Extension",
          "package": "hint",
          "partial": "Extension",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis represents language extensions beyond Haskell 98\n   that are supported by GHC (it was taken from\n   Cabal's \u003ccode\u003eLanguage.Haskell.Extension\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "Extension",
          "package": "hint",
          "source": "src/Hint-Extension.html#Extension",
          "type": "data"
        },
        "index": {
          "description": "This represents language extensions beyond Haskell that are supported by GHC it was taken from Cabal Language.Haskell.Extension",
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "Extension",
          "package": "hint",
          "partial": "Extension",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#t:Extension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "Arrows",
          "package": "hint",
          "signature": "Arrows",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:Arrows\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:Arrows\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "Arrows",
          "package": "hint",
          "partial": "Arrows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:Arrows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "BangPatterns",
          "package": "hint",
          "signature": "BangPatterns",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:BangPatterns\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:BangPatterns\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "BangPatterns",
          "package": "hint",
          "partial": "Bang Patterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:BangPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "CPP",
          "package": "hint",
          "signature": "CPP",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:CPP\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:CPP\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "CPP",
          "package": "hint",
          "partial": "CPP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:CPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ConstrainedClassMethods",
          "package": "hint",
          "signature": "ConstrainedClassMethods",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ConstrainedClassMethods\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ConstrainedClassMethods\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ConstrainedClassMethods",
          "package": "hint",
          "partial": "Constrained Class Methods",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ConstrainedClassMethods"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DatatypeContexts",
          "package": "hint",
          "signature": "DatatypeContexts",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DatatypeContexts\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DatatypeContexts\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DatatypeContexts",
          "package": "hint",
          "partial": "Datatype Contexts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DatatypeContexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DeriveDataTypeable",
          "package": "hint",
          "signature": "DeriveDataTypeable",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveDataTypeable\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DeriveDataTypeable\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DeriveDataTypeable",
          "package": "hint",
          "partial": "Derive Data Typeable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveDataTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DeriveFoldable",
          "package": "hint",
          "signature": "DeriveFoldable",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveFoldable\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DeriveFoldable\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DeriveFoldable",
          "package": "hint",
          "partial": "Derive Foldable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DeriveFunctor",
          "package": "hint",
          "signature": "DeriveFunctor",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveFunctor\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DeriveFunctor\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DeriveFunctor",
          "package": "hint",
          "partial": "Derive Functor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DeriveTraversable",
          "package": "hint",
          "signature": "DeriveTraversable",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveTraversable\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DeriveTraversable\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DeriveTraversable",
          "package": "hint",
          "partial": "Derive Traversable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DeriveTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DisambiguateRecordFields",
          "package": "hint",
          "signature": "DisambiguateRecordFields",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DisambiguateRecordFields\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DisambiguateRecordFields\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DisambiguateRecordFields",
          "package": "hint",
          "partial": "Disambiguate Record Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DisambiguateRecordFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DoAndIfThenElse",
          "package": "hint",
          "signature": "DoAndIfThenElse",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DoAndIfThenElse\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DoAndIfThenElse\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DoAndIfThenElse",
          "package": "hint",
          "partial": "Do And If Then Else",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DoAndIfThenElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "DoRec",
          "package": "hint",
          "signature": "DoRec",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DoRec\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:DoRec\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "DoRec",
          "package": "hint",
          "partial": "Do Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:DoRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "EmptyDataDecls",
          "package": "hint",
          "signature": "EmptyDataDecls",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:EmptyDataDecls\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:EmptyDataDecls\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "EmptyDataDecls",
          "package": "hint",
          "partial": "Empty Data Decls",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:EmptyDataDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ExistentialQuantification",
          "package": "hint",
          "signature": "ExistentialQuantification",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExistentialQuantification\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ExistentialQuantification\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ExistentialQuantification",
          "package": "hint",
          "partial": "Existential Quantification",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExistentialQuantification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ExplicitForAll",
          "package": "hint",
          "signature": "ExplicitForAll",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExplicitForAll\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ExplicitForAll\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ExplicitForAll",
          "package": "hint",
          "partial": "Explicit For All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExplicitForAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ExtendedDefaultRules",
          "package": "hint",
          "signature": "ExtendedDefaultRules",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExtendedDefaultRules\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ExtendedDefaultRules\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ExtendedDefaultRules",
          "package": "hint",
          "partial": "Extended Default Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExtendedDefaultRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ExtensibleRecords",
          "package": "hint",
          "signature": "ExtensibleRecords",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExtensibleRecords\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ExtensibleRecords\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ExtensibleRecords",
          "package": "hint",
          "partial": "Extensible Records",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ExtensibleRecords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "FlexibleContexts",
          "package": "hint",
          "signature": "FlexibleContexts",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:FlexibleContexts\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:FlexibleContexts\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "FlexibleContexts",
          "package": "hint",
          "partial": "Flexible Contexts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:FlexibleContexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "FlexibleInstances",
          "package": "hint",
          "signature": "FlexibleInstances",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:FlexibleInstances\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:FlexibleInstances\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "FlexibleInstances",
          "package": "hint",
          "partial": "Flexible Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:FlexibleInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ForeignFunctionInterface",
          "package": "hint",
          "signature": "ForeignFunctionInterface",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ForeignFunctionInterface\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ForeignFunctionInterface\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ForeignFunctionInterface",
          "package": "hint",
          "partial": "Foreign Function Interface",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ForeignFunctionInterface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "FunctionalDependencies",
          "package": "hint",
          "signature": "FunctionalDependencies",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:FunctionalDependencies\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:FunctionalDependencies\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "FunctionalDependencies",
          "package": "hint",
          "partial": "Functional Dependencies",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:FunctionalDependencies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "GADTs",
          "package": "hint",
          "signature": "GADTs",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:GADTs\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:GADTs\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "GADTs",
          "package": "hint",
          "partial": "GADTs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:GADTs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "GHCForeignImportPrim",
          "package": "hint",
          "signature": "GHCForeignImportPrim",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:GHCForeignImportPrim\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:GHCForeignImportPrim\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "GHCForeignImportPrim",
          "package": "hint",
          "partial": "GHCForeign Import Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:GHCForeignImportPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "GeneralizedNewtypeDeriving",
          "package": "hint",
          "signature": "GeneralizedNewtypeDeriving",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:GeneralizedNewtypeDeriving\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:GeneralizedNewtypeDeriving\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "GeneralizedNewtypeDeriving",
          "package": "hint",
          "partial": "Generalized Newtype Deriving",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:GeneralizedNewtypeDeriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "Generics",
          "package": "hint",
          "signature": "Generics",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:Generics\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:Generics\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "Generics",
          "package": "hint",
          "partial": "Generics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:Generics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "HereDocuments",
          "package": "hint",
          "signature": "HereDocuments",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:HereDocuments\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:HereDocuments\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "HereDocuments",
          "package": "hint",
          "partial": "Here Documents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:HereDocuments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ImplicitParams",
          "package": "hint",
          "signature": "ImplicitParams",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ImplicitParams\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ImplicitParams\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ImplicitParams",
          "package": "hint",
          "partial": "Implicit Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ImplicitParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ImpredicativeTypes",
          "package": "hint",
          "signature": "ImpredicativeTypes",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ImpredicativeTypes\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ImpredicativeTypes\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ImpredicativeTypes",
          "package": "hint",
          "partial": "Impredicative Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ImpredicativeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "IncoherentInstances",
          "package": "hint",
          "signature": "IncoherentInstances",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:IncoherentInstances\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:IncoherentInstances\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "IncoherentInstances",
          "package": "hint",
          "partial": "Incoherent Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:IncoherentInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "KindSignatures",
          "package": "hint",
          "signature": "KindSignatures",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:KindSignatures\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:KindSignatures\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "KindSignatures",
          "package": "hint",
          "partial": "Kind Signatures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:KindSignatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "LiberalTypeSynonyms",
          "package": "hint",
          "signature": "LiberalTypeSynonyms",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:LiberalTypeSynonyms\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:LiberalTypeSynonyms\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "LiberalTypeSynonyms",
          "package": "hint",
          "partial": "Liberal Type Synonyms",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:LiberalTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "MagicHash",
          "package": "hint",
          "signature": "MagicHash",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:MagicHash\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:MagicHash\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "MagicHash",
          "package": "hint",
          "partial": "Magic Hash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:MagicHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "MonoLocalBinds",
          "package": "hint",
          "signature": "MonoLocalBinds",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:MonoLocalBinds\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:MonoLocalBinds\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "MonoLocalBinds",
          "package": "hint",
          "partial": "Mono Local Binds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:MonoLocalBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "MultiParamTypeClasses",
          "package": "hint",
          "signature": "MultiParamTypeClasses",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:MultiParamTypeClasses\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:MultiParamTypeClasses\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "MultiParamTypeClasses",
          "package": "hint",
          "partial": "Multi Param Type Classes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:MultiParamTypeClasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "NPlusKPatterns",
          "package": "hint",
          "signature": "NPlusKPatterns",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NPlusKPatterns\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:NPlusKPatterns\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "NPlusKPatterns",
          "package": "hint",
          "partial": "NPlus KPatterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NPlusKPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "NamedFieldPuns",
          "package": "hint",
          "signature": "NamedFieldPuns",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NamedFieldPuns\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:NamedFieldPuns\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "NamedFieldPuns",
          "package": "hint",
          "partial": "Named Field Puns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NamedFieldPuns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "NewQualifiedOperators",
          "package": "hint",
          "signature": "NewQualifiedOperators",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NewQualifiedOperators\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:NewQualifiedOperators\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "NewQualifiedOperators",
          "package": "hint",
          "partial": "New Qualified Operators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NewQualifiedOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "NoImplicitPrelude",
          "package": "hint",
          "signature": "NoImplicitPrelude",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NoImplicitPrelude\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:NoImplicitPrelude\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "NoImplicitPrelude",
          "package": "hint",
          "partial": "No Implicit Prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NoImplicitPrelude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "NoMonoPatBinds",
          "package": "hint",
          "signature": "NoMonoPatBinds",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NoMonoPatBinds\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:NoMonoPatBinds\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "NoMonoPatBinds",
          "package": "hint",
          "partial": "No Mono Pat Binds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NoMonoPatBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "NoMonomorphismRestriction",
          "package": "hint",
          "signature": "NoMonomorphismRestriction",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NoMonomorphismRestriction\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:NoMonomorphismRestriction\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "NoMonomorphismRestriction",
          "package": "hint",
          "partial": "No Monomorphism Restriction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:NoMonomorphismRestriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "OverlappingInstances",
          "package": "hint",
          "signature": "OverlappingInstances",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:OverlappingInstances\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:OverlappingInstances\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "OverlappingInstances",
          "package": "hint",
          "partial": "Overlapping Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:OverlappingInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "OverloadedStrings",
          "package": "hint",
          "signature": "OverloadedStrings",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:OverloadedStrings\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:OverloadedStrings\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "OverloadedStrings",
          "package": "hint",
          "partial": "Overloaded Strings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:OverloadedStrings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "PackageImports",
          "package": "hint",
          "signature": "PackageImports",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PackageImports\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:PackageImports\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "PackageImports",
          "package": "hint",
          "partial": "Package Imports",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PackageImports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ParallelListComp",
          "package": "hint",
          "signature": "ParallelListComp",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ParallelListComp\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ParallelListComp\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ParallelListComp",
          "package": "hint",
          "partial": "Parallel List Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ParallelListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "PatternGuards",
          "package": "hint",
          "signature": "PatternGuards",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PatternGuards\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:PatternGuards\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "PatternGuards",
          "package": "hint",
          "partial": "Pattern Guards",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PatternGuards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "PatternSignatures",
          "package": "hint",
          "signature": "PatternSignatures",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PatternSignatures\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:PatternSignatures\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "PatternSignatures",
          "package": "hint",
          "partial": "Pattern Signatures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PatternSignatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "PolymorphicComponents",
          "package": "hint",
          "signature": "PolymorphicComponents",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PolymorphicComponents\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:PolymorphicComponents\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "PolymorphicComponents",
          "package": "hint",
          "partial": "Polymorphic Components",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PolymorphicComponents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "PostfixOperators",
          "package": "hint",
          "signature": "PostfixOperators",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PostfixOperators\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:PostfixOperators\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "PostfixOperators",
          "package": "hint",
          "partial": "Postfix Operators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:PostfixOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "QuasiQuotes",
          "package": "hint",
          "signature": "QuasiQuotes",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:QuasiQuotes\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:QuasiQuotes\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "QuasiQuotes",
          "package": "hint",
          "partial": "Quasi Quotes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:QuasiQuotes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "Rank2Types",
          "package": "hint",
          "signature": "Rank2Types",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:Rank2Types\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:Rank2Types\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "Rank2Types",
          "package": "hint",
          "partial": "Rank Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:Rank2Types"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RankNTypes",
          "package": "hint",
          "signature": "RankNTypes",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RankNTypes\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RankNTypes\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RankNTypes",
          "package": "hint",
          "partial": "Rank NTypes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RankNTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RebindableSyntax",
          "package": "hint",
          "signature": "RebindableSyntax",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RebindableSyntax\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RebindableSyntax\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RebindableSyntax",
          "package": "hint",
          "partial": "Rebindable Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RebindableSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RecordPuns",
          "package": "hint",
          "signature": "RecordPuns",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RecordPuns\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RecordPuns\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RecordPuns",
          "package": "hint",
          "partial": "Record Puns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RecordPuns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RecordWildCards",
          "package": "hint",
          "signature": "RecordWildCards",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RecordWildCards\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RecordWildCards\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RecordWildCards",
          "package": "hint",
          "partial": "Record Wild Cards",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RecordWildCards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RecursiveDo",
          "package": "hint",
          "signature": "RecursiveDo",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RecursiveDo\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RecursiveDo\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RecursiveDo",
          "package": "hint",
          "partial": "Recursive Do",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RecursiveDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RegularPatterns",
          "package": "hint",
          "signature": "RegularPatterns",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RegularPatterns\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RegularPatterns\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RegularPatterns",
          "package": "hint",
          "partial": "Regular Patterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RegularPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RelaxedPolyRec",
          "package": "hint",
          "signature": "RelaxedPolyRec",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RelaxedPolyRec\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RelaxedPolyRec\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RelaxedPolyRec",
          "package": "hint",
          "partial": "Relaxed Poly Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RelaxedPolyRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "RestrictedTypeSynonyms",
          "package": "hint",
          "signature": "RestrictedTypeSynonyms",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RestrictedTypeSynonyms\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:RestrictedTypeSynonyms\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "RestrictedTypeSynonyms",
          "package": "hint",
          "partial": "Restricted Type Synonyms",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:RestrictedTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ScopedTypeVariables",
          "package": "hint",
          "signature": "ScopedTypeVariables",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ScopedTypeVariables\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ScopedTypeVariables\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ScopedTypeVariables",
          "package": "hint",
          "partial": "Scoped Type Variables",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ScopedTypeVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "StandaloneDeriving",
          "package": "hint",
          "signature": "StandaloneDeriving",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:StandaloneDeriving\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:StandaloneDeriving\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "StandaloneDeriving",
          "package": "hint",
          "partial": "Standalone Deriving",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:StandaloneDeriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "TemplateHaskell",
          "package": "hint",
          "signature": "TemplateHaskell",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TemplateHaskell\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:TemplateHaskell\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "TemplateHaskell",
          "package": "hint",
          "partial": "Template Haskell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TemplateHaskell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "TransformListComp",
          "package": "hint",
          "signature": "TransformListComp",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TransformListComp\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:TransformListComp\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "TransformListComp",
          "package": "hint",
          "partial": "Transform List Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TransformListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "TupleSections",
          "package": "hint",
          "signature": "TupleSections",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TupleSections\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:TupleSections\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "TupleSections",
          "package": "hint",
          "partial": "Tuple Sections",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TupleSections"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "TypeFamilies",
          "package": "hint",
          "signature": "TypeFamilies",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TypeFamilies\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:TypeFamilies\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "TypeFamilies",
          "package": "hint",
          "partial": "Type Families",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TypeFamilies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "TypeOperators",
          "package": "hint",
          "signature": "TypeOperators",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TypeOperators\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:TypeOperators\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "TypeOperators",
          "package": "hint",
          "partial": "Type Operators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TypeOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "TypeSynonymInstances",
          "package": "hint",
          "signature": "TypeSynonymInstances",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TypeSynonymInstances\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:TypeSynonymInstances\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "TypeSynonymInstances",
          "package": "hint",
          "partial": "Type Synonym Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:TypeSynonymInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "UnboxedTuples",
          "package": "hint",
          "signature": "UnboxedTuples",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnboxedTuples\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:UnboxedTuples\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "UnboxedTuples",
          "package": "hint",
          "partial": "Unboxed Tuples",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnboxedTuples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "UndecidableInstances",
          "package": "hint",
          "signature": "UndecidableInstances",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UndecidableInstances\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:UndecidableInstances\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "UndecidableInstances",
          "package": "hint",
          "partial": "Undecidable Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UndecidableInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "UnicodeSyntax",
          "package": "hint",
          "signature": "UnicodeSyntax",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnicodeSyntax\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:UnicodeSyntax\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "UnicodeSyntax",
          "package": "hint",
          "partial": "Unicode Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnicodeSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "UnknownExtension",
          "package": "hint",
          "signature": "UnknownExtension String",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnknownExtension\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:UnknownExtension\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "UnknownExtension",
          "package": "hint",
          "partial": "Unknown Extension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnknownExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "UnliftedFFITypes",
          "package": "hint",
          "signature": "UnliftedFFITypes",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnliftedFFITypes\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:UnliftedFFITypes\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "UnliftedFFITypes",
          "package": "hint",
          "partial": "Unlifted FFITypes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:UnliftedFFITypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "ViewPatterns",
          "package": "hint",
          "signature": "ViewPatterns",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ViewPatterns\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ViewPatterns\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "ViewPatterns",
          "package": "hint",
          "partial": "View Patterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:ViewPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "XmlSyntax",
          "package": "hint",
          "signature": "XmlSyntax",
          "source": "src/Hint-Extension.html#Extension",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:XmlSyntax\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:XmlSyntax\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "XmlSyntax",
          "package": "hint",
          "partial": "Xml Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:XmlSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "asExtension",
          "package": "hint",
          "signature": "String -\u003e Extension",
          "source": "src/Hint-Extension.html#asExtension",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "asExtension",
          "normalized": "String-\u003eExtension",
          "package": "hint",
          "partial": "Extension",
          "signature": "String-\u003eExtension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:asExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of the extensions known by the interpreter.\n\u003c/p\u003e",
          "module": "[\"Language.Haskell.Interpreter.Extension\",\"Language.Haskell.Interpreter\"]",
          "name": "availableExtensions",
          "package": "hint",
          "signature": "[Extension]",
          "source": "src/Hint-Extension.html#availableExtensions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:availableExtensions\",\"http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:availableExtensions\"]"
        },
        "index": {
          "description": "List of the extensions known by the interpreter",
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "availableExtensions",
          "normalized": "[Extension]",
          "package": "hint",
          "partial": "Extensions",
          "signature": "[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:availableExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "knownExtensions",
          "package": "hint",
          "signature": "[Extension]",
          "source": "src/Hint-Extension.html#knownExtensions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Extension",
          "module": "Language.Haskell.Interpreter.Extension",
          "name": "knownExtensions",
          "normalized": "[Extension]",
          "package": "hint",
          "partial": "Extensions",
          "signature": "[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Extension.html#v:knownExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Import Language.Haskell.Interpreter.Unsafe instead.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eDEPRECATED: use \u003ccode\u003eLanguage.Haskell.Interpreter.Unsafe\u003c/code\u003e instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Interpreter.GHC.Unsafe",
          "name": "Unsafe",
          "package": "hint",
          "source": "src/Language-Haskell-Interpreter-GHC-Unsafe.html",
          "type": "module"
        },
        "index": {
          "description": "Deprecated Import Language.Haskell.Interpreter.Unsafe instead DEPRECATED use Language.Haskell.Interpreter.Unsafe instead",
          "hierarchy": "Language Haskell Interpreter GHC Unsafe",
          "module": "Language.Haskell.Interpreter.GHC.Unsafe",
          "name": "Unsafe",
          "package": "hint",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-GHC-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Import Language.Haskell.Interpreter instead.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eDEPRECATED: use \u003ccode\u003eLanguage.Haskell.Interpreter.Unsafe\u003c/code\u003e instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Interpreter.GHC",
          "name": "GHC",
          "package": "hint",
          "source": "src/Language-Haskell-Interpreter-GHC.html",
          "type": "module"
        },
        "index": {
          "description": "Deprecated Import Language.Haskell.Interpreter instead DEPRECATED use Language.Haskell.Interpreter.Unsafe instead",
          "hierarchy": "Language Haskell Interpreter GHC",
          "module": "Language.Haskell.Interpreter.GHC",
          "name": "GHC",
          "package": "hint",
          "partial": "GHC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-GHC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter.Unsafe",
          "name": "Unsafe",
          "package": "hint",
          "source": "src/Language-Haskell-Interpreter-Unsafe.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter Unsafe",
          "module": "Language.Haskell.Interpreter.Unsafe",
          "name": "Unsafe",
          "package": "hint",
          "partial": "Unsafe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Unsafe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecutes the interpreter, setting the args as though they were\n   command-line args.  In particular, this means args that have no\n   effect with :set in ghci might function properly from this\n   context.\n\u003c/p\u003e\u003cp\u003eWarning: Some options may interact badly with the Interpreter.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter.Unsafe",
          "name": "unsafeRunInterpreterWithArgs",
          "package": "hint",
          "signature": "[String] -\u003e InterpreterT m a -\u003e m (Either InterpreterError a)",
          "source": "src/Language-Haskell-Interpreter-Unsafe.html#unsafeRunInterpreterWithArgs",
          "type": "function"
        },
        "index": {
          "description": "Executes the interpreter setting the args as though they were command-line args In particular this means args that have no effect with set in ghci might function properly from this context Warning Some options may interact badly with the Interpreter",
          "hierarchy": "Language Haskell Interpreter Unsafe",
          "module": "Language.Haskell.Interpreter.Unsafe",
          "name": "unsafeRunInterpreterWithArgs",
          "normalized": "[String]-\u003eInterpreterT a b-\u003ea(Either InterpreterError b)",
          "package": "hint",
          "partial": "Run Interpreter With Args",
          "signature": "[String]-\u003eInterpreterT m a-\u003em(Either InterpreterError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Unsafe.html#v:unsafeRunInterpreterWithArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet a GHC option for the current session,\n   eg. \u003ccode\u003eunsafeSetGhcOption \"-XNoMonomorphismRestriction\"\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWarning: Some options may interact badly with the Interpreter.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter.Unsafe",
          "name": "unsafeSetGhcOption",
          "package": "hint",
          "signature": "String -\u003e m ()",
          "source": "src/Language-Haskell-Interpreter-Unsafe.html#unsafeSetGhcOption",
          "type": "function"
        },
        "index": {
          "description": "Set GHC option for the current session eg unsafeSetGhcOption XNoMonomorphismRestriction Warning Some options may interact badly with the Interpreter",
          "hierarchy": "Language Haskell Interpreter Unsafe",
          "module": "Language.Haskell.Interpreter.Unsafe",
          "name": "unsafeSetGhcOption",
          "normalized": "String-\u003ea()",
          "package": "hint",
          "partial": "Set Ghc Option",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter-Unsafe.html#v:unsafeSetGhcOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Haskell interpreter built on top of the GHC API\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "Interpreter",
          "package": "hint",
          "source": "src/Language-Haskell-Interpreter.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell interpreter built on top of the GHC API",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Interpreter",
          "package": "hint",
          "partial": "Interpreter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis represents language extensions beyond Haskell 98\n   that are supported by GHC (it was taken from\n   Cabal's \u003ccode\u003eLanguage.Haskell.Extension\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "Extension",
          "package": "hint",
          "source": "src/Hint-Extension.html#Extension",
          "type": "data"
        },
        "index": {
          "description": "This represents language extensions beyond Haskell that are supported by GHC it was taken from Cabal Language.Haskell.Extension",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Extension",
          "package": "hint",
          "partial": "Extension",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:Extension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "GhcError",
          "package": "hint",
          "source": "src/Hint-Base.html#GhcError",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "GhcError",
          "package": "hint",
          "partial": "Ghc Error",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:GhcError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn Id for a class, a type constructor, a data constructor, a binding, etc\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "Id",
          "package": "hint",
          "source": "src/Hint-Reflection.html#Id",
          "type": "type"
        },
        "index": {
          "description": "An Id for class type constructor data constructor binding etc",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Id",
          "package": "hint",
          "partial": "Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "Interpreter",
          "package": "hint",
          "source": "src/Hint-InterpreterT.html#Interpreter",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Interpreter",
          "package": "hint",
          "partial": "Interpreter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:Interpreter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "InterpreterError",
          "package": "hint",
          "source": "src/Hint-Base.html#InterpreterError",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "InterpreterError",
          "package": "hint",
          "partial": "Interpreter Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:InterpreterError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "InterpreterT",
          "package": "hint",
          "source": "src/Hint-InterpreterT.html#InterpreterT",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "InterpreterT",
          "package": "hint",
          "partial": "Interpreter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:InterpreterT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "ModuleElem",
          "package": "hint",
          "source": "src/Hint-Reflection.html#ModuleElem",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "ModuleElem",
          "package": "hint",
          "partial": "Module Elem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:ModuleElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModule names are _not_ filepaths.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "ModuleName",
          "package": "hint",
          "source": "src/Hint-Base.html#ModuleName",
          "type": "type"
        },
        "index": {
          "description": "Module names are not filepaths",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "ModuleName",
          "package": "hint",
          "partial": "Module Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:ModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "MonadInterpreter",
          "package": "hint",
          "source": "src/Hint-Base.html#MonadInterpreter",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "MonadInterpreter",
          "package": "hint",
          "partial": "Monad Interpreter",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:MonadInterpreter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe installed version of ghc is not thread-safe. This exception\n   is thrown whenever you try to execute \u003ccode\u003erunInterpreter\u003c/code\u003e while another\n   instance is already running.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "MultipleInstancesNotAllowed",
          "package": "hint",
          "source": "src/Hint-InterpreterT.html#MultipleInstancesNotAllowed",
          "type": "data"
        },
        "index": {
          "description": "The installed version of ghc is not thread-safe This exception is thrown whenever you try to execute runInterpreter while another instance is already running",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "MultipleInstancesNotAllowed",
          "package": "hint",
          "partial": "Multiple Instances Not Allowed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:MultipleInstancesNotAllowed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAvailable options are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003elanguageExtensions\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003einstalledModulesInScope\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003esearchPath\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "Option",
          "package": "hint",
          "source": "src/Hint-Configuration.html#Option",
          "type": "data"
        },
        "index": {
          "description": "Available options are languageExtensions installedModulesInScope searchPath",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Option",
          "package": "hint",
          "partial": "Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:Option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "OptionVal",
          "package": "hint",
          "source": "src/Hint-Configuration.html#OptionVal",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "OptionVal",
          "package": "hint",
          "partial": "Option Val",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#t:OptionVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": ":=",
          "package": "hint",
          "signature": "forall a . (Option m a) := a",
          "source": "src/Hint-Configuration.html#OptionVal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": ":=",
          "package": "hint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v::-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "Class",
          "package": "hint",
          "signature": "Class Id [Id]",
          "source": "src/Hint-Reflection.html#ModuleElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Class",
          "normalized": "Class Id[Id]",
          "package": "hint",
          "partial": "Class",
          "signature": "Class Id[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:Class"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "Data",
          "package": "hint",
          "signature": "Data Id [Id]",
          "source": "src/Hint-Reflection.html#ModuleElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Data",
          "normalized": "Data Id[Id]",
          "package": "hint",
          "partial": "Data",
          "signature": "Data Id[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:Data"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "Fun",
          "package": "hint",
          "signature": "Fun Id",
          "source": "src/Hint-Reflection.html#ModuleElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "Fun",
          "package": "hint",
          "partial": "Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:Fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "GhcError",
          "package": "hint",
          "signature": "GhcError",
          "source": "src/Hint-Base.html#GhcError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "GhcError",
          "package": "hint",
          "partial": "Ghc Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:GhcError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGhcExceptions from the underlying GHC API are caught\n and rethrown as this.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "GhcException",
          "package": "hint",
          "signature": "GhcException String",
          "source": "src/Hint-Base.html#InterpreterError",
          "type": "function"
        },
        "index": {
          "description": "GhcExceptions from the underlying GHC API are caught and rethrown as this",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "GhcException",
          "package": "hint",
          "partial": "Ghc Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:GhcException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "MultipleInstancesNotAllowed",
          "package": "hint",
          "signature": "MultipleInstancesNotAllowed",
          "source": "src/Hint-InterpreterT.html#MultipleInstancesNotAllowed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "MultipleInstancesNotAllowed",
          "package": "hint",
          "partial": "Multiple Instances Not Allowed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:MultipleInstancesNotAllowed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "NotAllowed",
          "package": "hint",
          "signature": "NotAllowed String",
          "source": "src/Hint-Base.html#InterpreterError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "NotAllowed",
          "package": "hint",
          "partial": "Not Allowed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:NotAllowed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "UnknownError",
          "package": "hint",
          "signature": "UnknownError String",
          "source": "src/Hint-Base.html#InterpreterError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "UnknownError",
          "package": "hint",
          "partial": "Unknown Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:UnknownError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "WontCompile",
          "package": "hint",
          "signature": "WontCompile [GhcError]",
          "source": "src/Hint-Base.html#InterpreterError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "WontCompile",
          "normalized": "WontCompile[GhcError]",
          "package": "hint",
          "partial": "Wont Compile",
          "signature": "WontCompile[GhcError]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:WontCompile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenience functions to be used with \u003ccode\u003einterpret\u003c/code\u003e to provide witnesses.\n   Example:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003einterpret \"head [True,False]\" (as :: Bool)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003einterpret \"head $ map show [True,False]\" infer \u003e\u003e= flip interpret (as :: Bool)\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "as",
          "package": "hint",
          "signature": "a",
          "source": "src/Hint-Eval.html#as",
          "type": "function"
        },
        "index": {
          "description": "Convenience functions to be used with interpret to provide witnesses Example interpret head True False as Bool interpret head map show True False infer flip interpret as Bool",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "as",
          "package": "hint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:as"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "children",
          "package": "hint",
          "signature": "ModuleElem -\u003e [Id]",
          "source": "src/Hint-Reflection.html#children",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "children",
          "normalized": "ModuleElem-\u003e[Id]",
          "package": "hint",
          "signature": "ModuleElem-\u003e[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:children"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "errMsg",
          "package": "hint",
          "signature": "String",
          "source": "src/Hint-Base.html#GhcError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "errMsg",
          "package": "hint",
          "partial": "Msg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:errMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eeval expr\u003c/code\u003e will evaluate \u003ccode\u003eshow expr\u003c/code\u003e.\n  It will succeed only if \u003ccode\u003eexpr\u003c/code\u003e has type t and there is a \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e\n  instance for t.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "eval",
          "package": "hint",
          "signature": "String -\u003e m String",
          "source": "src/Hint-Eval.html#eval",
          "type": "function"
        },
        "index": {
          "description": "eval expr will evaluate show expr It will succeed only if expr has type and there is Show instance for",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "eval",
          "normalized": "String-\u003ea String",
          "package": "hint",
          "signature": "String-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "fromSession",
          "package": "hint",
          "signature": "FromSession m a",
          "source": "src/Hint-Base.html#fromSession",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "fromSession",
          "package": "hint",
          "partial": "Session",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:fromSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieves the value of an option.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "get",
          "package": "hint",
          "signature": "Option m a -\u003e m a",
          "source": "src/Hint-Configuration.html#get",
          "type": "function"
        },
        "index": {
          "description": "Retrieves the value of an option",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "get",
          "normalized": "Option a b-\u003ea b",
          "package": "hint",
          "signature": "Option m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the list of modules loaded with \u003ccode\u003e\u003ca\u003eloadModules\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "getLoadedModules",
          "package": "hint",
          "signature": "m [ModuleName]",
          "source": "src/Hint-Context.html#getLoadedModules",
          "type": "function"
        },
        "index": {
          "description": "Returns the list of modules loaded with loadModules",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "getLoadedModules",
          "normalized": "a[ModuleName]",
          "package": "hint",
          "partial": "Loaded Modules",
          "signature": "m[ModuleName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:getLoadedModules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the annotations associated with a particular module.\n\u003c/p\u003e\u003cp\u003eFor example, given:\n\u003c/p\u003e\u003cpre\u003e\n   RBRACE-# ANN module (1 :: Int) #-LBRACE\n   module SomeModule(g, h) where\n   ...\n\u003c/pre\u003e\u003cp\u003eThen after using \u003ccode\u003eloadModule\u003c/code\u003e to load SomeModule into scope:\n\u003c/p\u003e\u003cpre\u003e\n   x \u003c- getModuleAnnotations (as :: Int) \u003ca\u003eSomeModule\u003c/a\u003e\n   liftIO $ print x\n   -- result is [1]\n\u003c/pre\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "getModuleAnnotations",
          "package": "hint",
          "signature": "a -\u003e String -\u003e m [a]",
          "source": "src/Hint-Annotations.html#getModuleAnnotations",
          "type": "function"
        },
        "index": {
          "description": "Get the annotations associated with particular module For example given RBRACE ANN module Int LBRACE module SomeModule where Then after using loadModule to load SomeModule into scope getModuleAnnotations as Int SomeModule liftIO print result is",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "getModuleAnnotations",
          "normalized": "a-\u003eString-\u003eb[a]",
          "package": "hint",
          "partial": "Module Annotations",
          "signature": "a-\u003eString-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:getModuleAnnotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets an abstract representation of all the entities exported by the module.\n   It is similar to the \u003ccode\u003e:browse\u003c/code\u003e command in GHCi.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "getModuleExports",
          "package": "hint",
          "signature": "ModuleName -\u003e m [ModuleElem]",
          "source": "src/Hint-Reflection.html#getModuleExports",
          "type": "function"
        },
        "index": {
          "description": "Gets an abstract representation of all the entities exported by the module It is similar to the browse command in GHCi",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "getModuleExports",
          "normalized": "ModuleName-\u003ea[ModuleElem]",
          "package": "hint",
          "partial": "Module Exports",
          "signature": "ModuleName-\u003em[ModuleElem]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:getModuleExports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the annotations associated with a particular function\n\u003c/p\u003e\u003cp\u003eFor example, given:\n\u003c/p\u003e\u003cpre\u003e\n   module SomeModule(g, h) where\n\nLBRACE-# ANN g (Just 1 :: Maybe Int) #-RBRACE\n   g = f [f]\n\nLBRACE-# ANN h (Just 2 :: Maybe Int) #-RBRACE\n   h = f\n\u003c/pre\u003e\u003cp\u003eThen after using \u003ccode\u003eloadModule\u003c/code\u003e to bring SomeModule into scope:\n\u003c/p\u003e\u003cpre\u003e\n   x \u003c- liftM concat $ mapM (getValAnnotations (as :: Maybe Int)) [\"g\",\"h\"]\n   liftIO $ print x\n   -- result is [Just 2, Just 1]\n\u003c/pre\u003e\u003cp\u003eThis can also work on data constructors and types with annotations.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "getValAnnotations",
          "package": "hint",
          "signature": "a -\u003e String -\u003e m [a]",
          "source": "src/Hint-Annotations.html#getValAnnotations",
          "type": "function"
        },
        "index": {
          "description": "Get the annotations associated with particular function For example given module SomeModule where LBRACE ANN Just Maybe Int RBRACE LBRACE ANN Just Maybe Int RBRACE Then after using loadModule to bring SomeModule into scope liftM concat mapM getValAnnotations as Maybe Int liftIO print result is Just Just This can also work on data constructors and types with annotations",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "getValAnnotations",
          "normalized": "a-\u003eString-\u003eb[a]",
          "package": "hint",
          "partial": "Val Annotations",
          "signature": "a-\u003eString-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:getValAnnotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion of the underlying ghc api. Values are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e606\u003c/code\u003e for GHC 6.6.x\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e608\u003c/code\u003e for GHC 6.8.x\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e610\u003c/code\u003e for GHC 6.10.x\n\u003c/li\u003e\u003cli\u003e etc...\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "ghcVersion",
          "package": "hint",
          "signature": "Int",
          "source": "src/Hint-Base.html#ghcVersion",
          "type": "function"
        },
        "index": {
          "description": "Version of the underlying ghc api Values are for GHC for GHC for GHC etc",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "ghcVersion",
          "package": "hint",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:ghcVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: glasgowExtensions list is no longer maintained, will be removed soon\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eList of extensions turned on when the \u003ccode\u003e-fglasgow-exts\u003c/code\u003e flag is used\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "glasgowExtensions",
          "package": "hint",
          "signature": "[Extension]",
          "source": "src/Hint-Configuration.html#glasgowExtensions",
          "type": "function"
        },
        "index": {
          "description": "Deprecated glasgowExtensions list is no longer maintained will be removed soon List of extensions turned on when the fglasgow-exts flag is used",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "glasgowExtensions",
          "normalized": "[Extension]",
          "package": "hint",
          "partial": "Extensions",
          "signature": "[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:glasgowExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenience functions to be used with \u003ccode\u003einterpret\u003c/code\u003e to provide witnesses.\n   Example:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003einterpret \"head [True,False]\" (as :: Bool)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003einterpret \"head $ map show [True,False]\" infer \u003e\u003e= flip interpret (as :: Bool)\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "infer",
          "package": "hint",
          "signature": "a",
          "source": "src/Hint-Eval.html#infer",
          "type": "function"
        },
        "index": {
          "description": "Convenience functions to be used with interpret to provide witnesses Example interpret head True False as Bool interpret head map show True False infer flip interpret as Bool",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "infer",
          "package": "hint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:infer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen set to \u003ccode\u003eTrue\u003c/code\u003e, every module in every available package is implicitly\n   imported qualified. This is very convenient for interactive\n   evaluation, but can be a problem in sandboxed environments\n   (e.g. \u003ccode\u003e\u003ca\u003eunsafePerformIO\u003c/a\u003e\u003c/code\u003e is in scope).\n\u003c/p\u003e\u003cp\u003eDefault value is \u003ccode\u003eTrue\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eObserve that due to limitations in the GHC-API, when set to \u003ccode\u003eFalse\u003c/code\u003e, the\n   private symbols in interpreted modules will not be in scope.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "installedModulesInScope",
          "package": "hint",
          "signature": "Option m Bool",
          "source": "src/Hint-Configuration.html#installedModulesInScope",
          "type": "function"
        },
        "index": {
          "description": "When set to True every module in every available package is implicitly imported qualified This is very convenient for interactive evaluation but can be problem in sandboxed environments e.g unsafePerformIO is in scope Default value is True Observe that due to limitations in the GHC-API when set to False the private symbols in interpreted modules will not be in scope",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "installedModulesInScope",
          "package": "hint",
          "partial": "Modules In Scope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:installedModulesInScope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluates an expression, given a witness for its monomorphic type.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "interpret",
          "package": "hint",
          "signature": "String -\u003e a -\u003e m a",
          "source": "src/Hint-Eval.html#interpret",
          "type": "function"
        },
        "index": {
          "description": "Evaluates an expression given witness for its monomorphic type",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "interpret",
          "normalized": "String-\u003ea-\u003eb a",
          "package": "hint",
          "signature": "String-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:interpret"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns True if the module was interpreted.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "isModuleInterpreted",
          "package": "hint",
          "signature": "ModuleName -\u003e m Bool",
          "source": "src/Hint-Context.html#isModuleInterpreted",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the module was interpreted",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "isModuleInterpreted",
          "normalized": "ModuleName-\u003ea Bool",
          "package": "hint",
          "partial": "Module Interpreted",
          "signature": "ModuleName-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:isModuleInterpreted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a string representation of the kind of the type expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "kindOf",
          "package": "hint",
          "signature": "String -\u003e m String",
          "source": "src/Hint-Typecheck.html#kindOf",
          "type": "function"
        },
        "index": {
          "description": "Returns string representation of the kind of the type expression",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "kindOf",
          "normalized": "String-\u003ea String",
          "package": "hint",
          "partial": "Of",
          "signature": "String-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:kindOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLanguage extensions in use by the interpreter.\n\u003c/p\u003e\u003cp\u003eDefault is: \u003ccode\u003e[]\u003c/code\u003e (i.e. none, pure Haskell 98)\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "languageExtensions",
          "package": "hint",
          "signature": "Option m [Extension]",
          "source": "src/Hint-Configuration.html#languageExtensions",
          "type": "function"
        },
        "index": {
          "description": "Language extensions in use by the interpreter Default is i.e none pure Haskell",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "languageExtensions",
          "normalized": "Option a[Extension]",
          "package": "hint",
          "partial": "Extensions",
          "signature": "Option m[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:languageExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to load all the requested modules from their source file.\n   Modules my be indicated by their ModuleName (e.g. \"My.Module\") or\n   by the full path to its source file.\n\u003c/p\u003e\u003cp\u003eThe interpreter is \u003ccode\u003e\u003ca\u003ereset\u003c/a\u003e\u003c/code\u003e both before loading the modules and in the event\n of an error.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "loadModules",
          "package": "hint",
          "signature": "[String] -\u003e m ()",
          "source": "src/Hint-Context.html#loadModules",
          "type": "function"
        },
        "index": {
          "description": "Tries to load all the requested modules from their source file Modules my be indicated by their ModuleName e.g My.Module or by the full path to its source file The interpreter is reset both before loading the modules and in the event of an error",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "loadModules",
          "normalized": "[String]-\u003ea()",
          "package": "hint",
          "partial": "Modules",
          "signature": "[String]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:loadModules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "modifySessionRef",
          "package": "hint",
          "signature": "ModifySessionRef m a",
          "source": "src/Hint-Base.html#modifySessionRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "modifySessionRef",
          "package": "hint",
          "partial": "Session Ref",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:modifySessionRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "name",
          "package": "hint",
          "signature": "ModuleElem -\u003e Id",
          "source": "src/Hint-Reflection.html#name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "name",
          "normalized": "ModuleElem-\u003eId",
          "package": "hint",
          "signature": "ModuleElem-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConceptually, \u003ccode\u003eparens s = \"(\" ++ s ++ \")\"\u003c/code\u003e, where s is any valid haskell\n expression. In practice, it is harder than this.\n Observe that if \u003ccode\u003es\u003c/code\u003e ends with a trailing comment, then \u003ccode\u003eparens s\u003c/code\u003e would\n be a malformed expression. The straightforward solution for this is to\n put the closing parenthesis in a different line. However, now we are\n messing with the layout rules and we don't know where \u003ccode\u003es\u003c/code\u003e is going to\n be used!\n Solution: \u003ccode\u003eparens s = \"(let {foo =n\" ++ s ++ \"\\n ;} in foo)\"\u003c/code\u003e where \u003ccode\u003efoo\u003c/code\u003e does not occur in \u003ccode\u003es\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "parens",
          "package": "hint",
          "signature": "String -\u003e String",
          "source": "src/Hint-Eval.html#parens",
          "type": "function"
        },
        "index": {
          "description": "Conceptually parens where is any valid haskell expression In practice it is harder than this Observe that if ends with trailing comment then parens would be malformed expression The straightforward solution for this is to put the closing parenthesis in different line However now we are messing with the layout rules and we don know where is going to be used Solution parens let foo in foo where foo does not occur in",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "parens",
          "normalized": "String-\u003eString",
          "package": "hint",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:parens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll imported modules are cleared from the context, and\n   loaded modules are unloaded. It is similar to a \u003ccode\u003e:load\u003c/code\u003e in\n   GHCi, but observe that not even the Prelude will be in\n   context after a reset.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "reset",
          "package": "hint",
          "signature": "m ()",
          "source": "src/Hint-Context.html#reset",
          "type": "function"
        },
        "index": {
          "description": "All imported modules are cleared from the context and loaded modules are unloaded It is similar to load in GHCi but observe that not even the Prelude will be in context after reset",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "reset",
          "normalized": "a()",
          "package": "hint",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:reset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Interpreter",
          "name": "runGhc",
          "package": "hint",
          "signature": "RunGhc m a",
          "source": "src/Hint-Base.html#runGhc",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "runGhc",
          "package": "hint",
          "partial": "Ghc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:runGhc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecutes the interpreter. Returns \u003ccode\u003eLeft InterpreterError\u003c/code\u003e in case of error.\n\u003c/p\u003e\u003cp\u003eNB. The underlying ghc will overwrite certain signal handlers\n (SIGINT, SIGHUP, SIGTERM, SIGQUIT on Posix systems, Ctrl-C handler on Windows).\n In future versions of hint, this might be controlled by the user.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "runInterpreter",
          "package": "hint",
          "signature": "InterpreterT m a -\u003e m (Either InterpreterError a)",
          "source": "src/Hint-InterpreterT.html#runInterpreter",
          "type": "function"
        },
        "index": {
          "description": "Executes the interpreter Returns Left InterpreterError in case of error NB The underlying ghc will overwrite certain signal handlers SIGINT SIGHUP SIGTERM SIGQUIT on Posix systems Ctrl-C handler on Windows In future versions of hint this might be controlled by the user",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "runInterpreter",
          "normalized": "InterpreterT a b-\u003ea(Either InterpreterError b)",
          "package": "hint",
          "partial": "Interpreter",
          "signature": "InterpreterT m a-\u003em(Either InterpreterError a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:runInterpreter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe search path for source files. Observe that every time it is set,\n   it overrides the previous search path. The default is \u003ccode\u003e[\".\"]\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eKeep in mind that by a limitation in ghc, \u003ccode\u003e\".\"\u003c/code\u003e is always in scope.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "searchPath",
          "package": "hint",
          "signature": "Option m [FilePath]",
          "source": "src/Hint-Configuration.html#searchPath",
          "type": "function"
        },
        "index": {
          "description": "The search path for source files Observe that every time it is set it overrides the previous search path The default is Keep in mind that by limitation in ghc is always in scope",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "searchPath",
          "normalized": "Option a[FilePath]",
          "package": "hint",
          "partial": "Path",
          "signature": "Option m[FilePath]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:searchPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse this function to set or modify the value of any option. It is\n   invoked like this:\n\u003c/p\u003e\u003cpre\u003eset [opt1 := val1, opt2 := val2,... optk := valk]\u003c/pre\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "set",
          "package": "hint",
          "signature": "[OptionVal m] -\u003e m ()",
          "source": "src/Hint-Configuration.html#set",
          "type": "function"
        },
        "index": {
          "description": "Use this function to set or modify the value of any option It is invoked like this set opt1 val1 opt2 val2 optk valk",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "set",
          "normalized": "[OptionVal a]-\u003ea()",
          "package": "hint",
          "signature": "[OptionVal m]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the modules whose exports must be in context.\n\u003c/p\u003e\u003cp\u003eWarning: \u003ccode\u003e\u003ca\u003esetImports\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esetImportsQ\u003c/a\u003e\u003c/code\u003e are mutually exclusive.\n   If you have a list of modules to be used qualified and another list\n   unqualified, then you need to do something like\n\u003c/p\u003e\u003cpre\u003e  setImportsQ ((zip unqualified $ repeat Nothing) ++ qualifieds)\n\u003c/pre\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "setImports",
          "package": "hint",
          "signature": "[ModuleName] -\u003e m ()",
          "source": "src/Hint-Context.html#setImports",
          "type": "function"
        },
        "index": {
          "description": "Sets the modules whose exports must be in context Warning setImports and setImportsQ are mutually exclusive If you have list of modules to be used qualified and another list unqualified then you need to do something like setImportsQ zip unqualified repeat Nothing qualifieds",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "setImports",
          "normalized": "[ModuleName]-\u003ea()",
          "package": "hint",
          "partial": "Imports",
          "signature": "[ModuleName]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:setImports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the modules whose exports must be in context; some\n   of them may be qualified. E.g.:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003esetImportsQ [(\u003ca\u003ePrelude\u003c/a\u003e, Nothing), (\u003ca\u003eData.Map\u003c/a\u003e, Just \u003ca\u003eM\u003c/a\u003e)]\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eHere, \u003ca\u003emap\u003c/a\u003e will refer to Prelude.map and \u003ca\u003eM.map\u003c/a\u003e to Data.Map.map.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "setImportsQ",
          "package": "hint",
          "signature": "[(ModuleName, Maybe String)] -\u003e m ()",
          "source": "src/Hint-Context.html#setImportsQ",
          "type": "function"
        },
        "index": {
          "description": "Sets the modules whose exports must be in context some of them may be qualified E.g setImportsQ Prelude Nothing Data.Map Just Here map will refer to Prelude.map and M.map to Data.Map.map",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "setImportsQ",
          "normalized": "[(ModuleName,Maybe String)]-\u003ea()",
          "package": "hint",
          "partial": "Imports",
          "signature": "[(ModuleName,Maybe String)]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:setImportsQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use set [installedModulesInScope := b] instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "setInstalledModsAreInScopeQualified",
          "package": "hint",
          "signature": "Bool -\u003e m ()",
          "source": "src/Hint-Configuration.html#setInstalledModsAreInScopeQualified",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use set installedModulesInScope instead",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "setInstalledModsAreInScopeQualified",
          "normalized": "Bool-\u003ea()",
          "package": "hint",
          "partial": "Installed Mods Are In Scope Qualified",
          "signature": "Bool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:setInstalledModsAreInScopeQualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the modules whose context is used during evaluation. All bindings\n   of these modules are in scope, not only those exported.\n\u003c/p\u003e\u003cp\u003eModules must be interpreted to use this function.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "setTopLevelModules",
          "package": "hint",
          "signature": "[ModuleName] -\u003e m ()",
          "source": "src/Hint-Context.html#setTopLevelModules",
          "type": "function"
        },
        "index": {
          "description": "Sets the modules whose context is used during evaluation All bindings of these modules are in scope not only those exported Modules must be interpreted to use this function",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "setTopLevelModules",
          "normalized": "[ModuleName]-\u003ea()",
          "package": "hint",
          "partial": "Top Level Modules",
          "signature": "[ModuleName]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:setTopLevelModules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use set [languageExtensions := (ExtendedDefaultRules:glasgowExtensions)] instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "setUseLanguageExtensions",
          "package": "hint",
          "signature": "Bool -\u003e m ()",
          "source": "src/Hint-Configuration.html#setUseLanguageExtensions",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use set languageExtensions ExtendedDefaultRules glasgowExtensions instead",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "setUseLanguageExtensions",
          "normalized": "Bool-\u003ea()",
          "package": "hint",
          "partial": "Use Language Extensions",
          "signature": "Bool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:setUseLanguageExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTests if the expression type checks.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "typeChecks",
          "package": "hint",
          "signature": "String -\u003e m Bool",
          "source": "src/Hint-Typecheck.html#typeChecks",
          "type": "function"
        },
        "index": {
          "description": "Tests if the expression type checks",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "typeChecks",
          "normalized": "String-\u003ea Bool",
          "package": "hint",
          "partial": "Checks",
          "signature": "String-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:typeChecks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a string representation of the type of the expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Interpreter",
          "name": "typeOf",
          "package": "hint",
          "signature": "String -\u003e m String",
          "source": "src/Hint-Typecheck.html#typeOf",
          "type": "function"
        },
        "index": {
          "description": "Returns string representation of the type of the expression",
          "hierarchy": "Language Haskell Interpreter",
          "module": "Language.Haskell.Interpreter",
          "name": "typeOf",
          "normalized": "String-\u003ea String",
          "package": "hint",
          "partial": "Of",
          "signature": "String-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hint/docs/Language-Haskell-Interpreter.html#v:typeOf"
      }
    }
  ]
]