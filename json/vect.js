[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "vect"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Base",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Base",
          "package": "vect",
          "partial": "Base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "AbelianGroup",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#AbelianGroup",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "AbelianGroup",
          "package": "vect",
          "partial": "Abelian Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:AbelianGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCross product\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "CrossProd",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#CrossProd",
          "type": "class"
        },
        "index": {
          "description": "Cross product",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "CrossProd",
          "package": "vect",
          "partial": "Cross Prod",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:CrossProd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Determinant",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Determinant",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Determinant",
          "package": "vect",
          "partial": "Determinant",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Determinant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emakes a diagonal matrix from a vector\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Diagonal",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Diagonal",
          "type": "class"
        },
        "index": {
          "description": "makes diagonal matrix from vector",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Diagonal",
          "package": "vect",
          "partial": "Diagonal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Diagonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Dimension",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Dimension",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Dimension",
          "package": "vect",
          "partial": "Dimension",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "DotProd",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#DotProd",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "DotProd",
          "package": "vect",
          "partial": "Dot Prod",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:DotProd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econversion between vectors (and matrices) of different dimensions\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Extend",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Extend",
          "type": "class"
        },
        "index": {
          "description": "conversion between vectors and matrices of different dimensions",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Extend",
          "package": "vect",
          "partial": "Extend",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "HasCoordinates",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#HasCoordinates",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "HasCoordinates",
          "package": "vect",
          "partial": "Has Coordinates",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:HasCoordinates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "LeftModule",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#LeftModule",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "LeftModule",
          "package": "vect",
          "partial": "Left Module",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:LeftModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe components are \u003cem\u003erow\u003c/em\u003e vectors \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Mat2",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Mat2",
          "type": "data"
        },
        "index": {
          "description": "The components are row vectors",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Mat2",
          "package": "vect",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Mat2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Mat3",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Mat3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Mat3",
          "package": "vect",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Mat3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Mat4",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Mat4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Mat4",
          "package": "vect",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Mat4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Matrix",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Matrix",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Matrix",
          "package": "vect",
          "partial": "Matrix",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "MatrixNorms",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#MatrixNorms",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "MatrixNorms",
          "package": "vect",
          "partial": "Matrix Norms",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:MatrixNorms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "MultSemiGroup",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#MultSemiGroup",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "MultSemiGroup",
          "package": "vect",
          "partial": "Mult Semi Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:MultSemiGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe assumption when dealing with these is always that they are of unit length.\n Also, interpolation works differently.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Normal2",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Normal2",
          "type": "data"
        },
        "index": {
          "description": "The assumption when dealing with these is always that they are of unit length Also interpolation works differently",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Normal2",
          "package": "vect",
          "partial": "Normal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Normal2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Normal3",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Normal3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Normal3",
          "package": "vect",
          "partial": "Normal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Normal3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Normal4",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Normal4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Normal4",
          "package": "vect",
          "partial": "Normal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Normal4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrthogonal matrices.\n\u003c/p\u003e\u003cp\u003eNote: the \u003ca\u003eRandom\u003c/a\u003e instances generates orthogonal matrices with determinant 1\n (that is, orientation-preserving orthogonal transformations)!\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Ortho2",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Ortho2",
          "type": "data"
        },
        "index": {
          "description": "Orthogonal matrices Note the Random instances generates orthogonal matrices with determinant that is orientation-preserving orthogonal transformations",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Ortho2",
          "package": "vect",
          "partial": "Ortho",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Ortho2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Ortho3",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Ortho3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Ortho3",
          "package": "vect",
          "partial": "Ortho",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Ortho3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Ortho4",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Ortho4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Ortho4",
          "package": "vect",
          "partial": "Ortho",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Ortho4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Orthogonal",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Orthogonal",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Orthogonal",
          "package": "vect",
          "partial": "Orthogonal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Orthogonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePointwise multiplication \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Pointwise",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Pointwise",
          "type": "class"
        },
        "index": {
          "description": "Pointwise multiplication",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Pointwise",
          "package": "vect",
          "partial": "Pointwise",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Pointwise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjective matrices, encoding affine transformations in dimension one less.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Proj3",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Proj3",
          "type": "data"
        },
        "index": {
          "description": "Projective matrices encoding affine transformations in dimension one less",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Proj3",
          "package": "vect",
          "partial": "Proj",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Proj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Proj4",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Proj4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Proj4",
          "package": "vect",
          "partial": "Proj",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Proj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Projective\" matrices have the following form: the top left corner\n is an any matrix, the bottom right corner is 1, and the top-right\n column is zero. These describe the affine orthogonal transformation of\n the space one dimension less.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Projective",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Projective",
          "type": "class"
        },
        "index": {
          "description": "Projective matrices have the following form the top left corner is an any matrix the bottom right corner is and the top-right column is zero These describe the affine orthogonal transformation of the space one dimension less",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Projective",
          "package": "vect",
          "partial": "Projective",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Projective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "RightModule",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#RightModule",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "RightModule",
          "package": "vect",
          "partial": "Right Module",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:RightModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Ring",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Ring",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Ring",
          "package": "vect",
          "partial": "Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Ring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOuter product (could be unified with Diagonal?)\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "Tensor",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Tensor",
          "type": "class"
        },
        "index": {
          "description": "Outer product could be unified with Diagonal",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Tensor",
          "package": "vect",
          "partial": "Tensor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Tensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "UnitVector",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#UnitVector",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "UnitVector",
          "package": "vect",
          "partial": "Unit Vector",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:UnitVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Vec2",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Vec2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Vec2",
          "package": "vect",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Vec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Vec3",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Vec3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Vec3",
          "package": "vect",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Vec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Vec4",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Vec4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Vec4",
          "package": "vect",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Vec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Vector",
          "package": "vect",
          "source": "src/Data-Vect-Double-Base.html#Vector",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Vector",
          "package": "vect",
          "partial": "Vector",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(&!)",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#%26%21",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(&!) &!",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-38--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(&*)",
          "package": "vect",
          "signature": "v -\u003e Double -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#%26%2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(&*) &*",
          "normalized": "a-\u003eDouble-\u003ea",
          "package": "vect",
          "signature": "v-\u003eDouble-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-38--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(&+)",
          "package": "vect",
          "signature": "g -\u003e g -\u003e g",
          "source": "src/Data-Vect-Double-Base.html#%26%2B",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(&+) &+",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "g-\u003eg-\u003eg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-38--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(&-)",
          "package": "vect",
          "signature": "g -\u003e g -\u003e g",
          "source": "src/Data-Vect-Double-Base.html#%26-",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(&-) &-",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "g-\u003eg-\u003eg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-38--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(&^)",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#%26%5E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(&^) &^",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-38--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(&.)",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#%26.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(&.) &.",
          "normalized": "a-\u003ea-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003ev-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-38-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(*&)",
          "package": "vect",
          "signature": "Double -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#%2A%26",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(*&) *&",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "vect",
          "signature": "Double-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-42--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(*.)",
          "package": "vect",
          "signature": "r -\u003e m -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#%2A.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(*.) *.",
          "normalized": "a-\u003eb-\u003eb",
          "package": "vect",
          "signature": "r-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(.*)",
          "package": "vect",
          "signature": "m -\u003e r -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#.%2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(.*) .*",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vect",
          "signature": "m-\u003er-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:.-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "(.*.)",
          "package": "vect",
          "signature": "r -\u003e r -\u003e r",
          "source": "src/Data-Vect-Double-Base.html#.%2A.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "(.*.) .*.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "r-\u003er-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:.-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Mat2",
          "package": "vect",
          "signature": "Mat2 !Vec2 !Vec2",
          "source": "src/Data-Vect-Double-Base.html#Mat2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Mat2",
          "package": "vect",
          "partial": "Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:Mat2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Mat3",
          "package": "vect",
          "signature": "Mat3 !Vec3 !Vec3 !Vec3",
          "source": "src/Data-Vect-Double-Base.html#Mat3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Mat3",
          "package": "vect",
          "partial": "Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:Mat3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Mat4",
          "package": "vect",
          "signature": "Mat4 !Vec4 !Vec4 !Vec4 !Vec4",
          "source": "src/Data-Vect-Double-Base.html#Mat4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Mat4",
          "package": "vect",
          "partial": "Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:Mat4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Vec2",
          "package": "vect",
          "signature": "Vec2 !Double !Double",
          "source": "src/Data-Vect-Double-Base.html#Vec2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Vec2",
          "package": "vect",
          "partial": "Vec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:Vec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Vec3",
          "package": "vect",
          "signature": "Vec3 !Double !Double !Double",
          "source": "src/Data-Vect-Double-Base.html#Vec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Vec3",
          "package": "vect",
          "partial": "Vec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:Vec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "Vec4",
          "package": "vect",
          "signature": "Vec4 !Double !Double !Double !Double",
          "source": "src/Data-Vect-Double-Base.html#Vec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "Vec4",
          "package": "vect",
          "partial": "Vec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:Vec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "_1",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Double-Base.html#_1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "_1",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "_2",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Double-Base.html#_2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "_2",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "_3",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Double-Base.html#_3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "_3",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "_4",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Double-Base.html#_4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "_4",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe angle between two vectors\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "angle",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#angle",
          "type": "function"
        },
        "index": {
          "description": "the angle between two vectors",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "angle",
          "normalized": "a-\u003ea-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003ev-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe angle between two unit vectors\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "angle'",
          "package": "vect",
          "signature": "u -\u003e u -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#angle%27",
          "type": "function"
        },
        "index": {
          "description": "the angle between two unit vectors",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "angle'",
          "normalized": "a-\u003ea-\u003eDouble",
          "package": "vect",
          "signature": "u-\u003eu-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:angle-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "crossprod",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#crossprod",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "crossprod",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:crossprod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "det",
          "package": "vect",
          "signature": "m -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#det",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "det",
          "normalized": "a-\u003eDouble",
          "package": "vect",
          "signature": "m-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:det"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "diag",
          "package": "vect",
          "signature": "s -\u003e t",
          "source": "src/Data-Vect-Double-Base.html#diag",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "diag",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "s-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:diag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "dim",
          "package": "vect",
          "signature": "a -\u003e Int",
          "source": "src/Data-Vect-Double-Base.html#dim",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "dim",
          "normalized": "a-\u003eInt",
          "package": "vect",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:dim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "distance",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#distance",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "distance",
          "normalized": "a-\u003ea-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003ev-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:distance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "dotprod",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#dotprod",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "dotprod",
          "normalized": "a-\u003ea-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003ev-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:dotprod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "extendWith",
          "package": "vect",
          "signature": "extendWith",
          "source": "src/Data-Vect-Double-Base.html#extendWith",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "extendWith",
          "package": "vect",
          "partial": "With",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:extendWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "extendZero",
          "package": "vect",
          "signature": "extendZero",
          "source": "src/Data-Vect-Double-Base.html#extendZero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "extendZero",
          "package": "vect",
          "partial": "Zero",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:extendZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSince unit vectors are not a group, we need a separate function.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "flipNormal",
          "package": "vect",
          "signature": "n -\u003e n",
          "source": "src/Data-Vect-Double-Base.html#flipNormal",
          "type": "function"
        },
        "index": {
          "description": "Since unit vectors are not group we need separate function",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "flipNormal",
          "normalized": "a-\u003ea",
          "package": "vect",
          "partial": "Normal",
          "signature": "n-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:flipNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "frobeniusNorm",
          "package": "vect",
          "signature": "frobeniusNorm",
          "source": "src/Data-Vect-Double-Base.html#frobeniusNorm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "frobeniusNorm",
          "package": "vect",
          "partial": "Norm",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:frobeniusNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "fromNormal",
          "package": "vect",
          "signature": "u -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#fromNormal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "fromNormal",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Normal",
          "signature": "u-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:fromNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "fromNormalRadius",
          "package": "vect",
          "signature": "Double -\u003e u -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#fromNormalRadius",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "fromNormalRadius",
          "normalized": "Double-\u003ea-\u003eb",
          "package": "vect",
          "partial": "Normal Radius",
          "signature": "Double-\u003eu-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:fromNormalRadius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "fromOrtho",
          "package": "vect",
          "signature": "o -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#fromOrtho",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "fromOrtho",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Ortho",
          "signature": "o-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:fromOrtho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "fromProjective",
          "package": "vect",
          "signature": "p -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#fromProjective",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "fromProjective",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Projective",
          "signature": "p-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:fromProjective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHouseholder matrix, see \u003ca\u003ehttp://en.wikipedia.org/wiki/Householder_transformation\u003c/a\u003e.  \n In plain words, it is the reflection to the hyperplane orthogonal to the input vector.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "householder",
          "package": "vect",
          "signature": "u -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#householder",
          "type": "function"
        },
        "index": {
          "description": "Householder matrix see http en.wikipedia.org wiki Householder transformation In plain words it is the reflection to the hyperplane orthogonal to the input vector",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "householder",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "u-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:householder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "householderOrtho",
          "package": "vect",
          "signature": "u -\u003e o",
          "source": "src/Data-Vect-Double-Base.html#householderOrtho",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "householderOrtho",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Ortho",
          "signature": "u-\u003eo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:householderOrtho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "idmtx",
          "package": "vect",
          "signature": "m",
          "source": "src/Data-Vect-Double-Base.html#idmtx",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "idmtx",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:idmtx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "inverse",
          "package": "vect",
          "signature": "m -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#inverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "inverse",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "len",
          "package": "vect",
          "signature": "v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#len",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "len",
          "normalized": "a-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:len"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "lensqr",
          "package": "vect",
          "signature": "v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#lensqr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "lensqr",
          "normalized": "a-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:lensqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "linear",
          "package": "vect",
          "signature": "n -\u003e p",
          "source": "src/Data-Vect-Double-Base.html#linear",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "linear",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "n-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "lmul",
          "package": "vect",
          "signature": "r -\u003e m -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#lmul",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "lmul",
          "normalized": "a-\u003eb-\u003eb",
          "package": "vect",
          "signature": "r-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:lmul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "mapVec",
          "package": "vect",
          "signature": "(Double -\u003e Double) -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#mapVec",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "mapVec",
          "normalized": "(Double-\u003eDouble)-\u003ea-\u003ea",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Double-\u003eDouble)-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:mapVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "matrixDistance",
          "package": "vect",
          "signature": "matrixDistance",
          "source": "src/Data-Vect-Double-Base.html#matrixDistance",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "matrixDistance",
          "package": "vect",
          "partial": "Distance",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:matrixDistance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "mkNormal",
          "package": "vect",
          "signature": "mkNormal",
          "source": "src/Data-Vect-Double-Base.html#mkNormal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "mkNormal",
          "package": "vect",
          "partial": "Normal",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:mkNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "mkVec2",
          "package": "vect",
          "signature": "(Double, Double) -\u003e Vec2",
          "source": "src/Data-Vect-Double-Base.html#mkVec2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "mkVec2",
          "normalized": "(Double,Double)-\u003eVec",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Double,Double)-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:mkVec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "mkVec3",
          "package": "vect",
          "signature": "(Double, Double, Double) -\u003e Vec3",
          "source": "src/Data-Vect-Double-Base.html#mkVec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "mkVec3",
          "normalized": "(Double,Double,Double)-\u003eVec",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Double,Double,Double)-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:mkVec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "mkVec4",
          "package": "vect",
          "signature": "(Double, Double, Double, Double) -\u003e Vec4",
          "source": "src/Data-Vect-Double-Base.html#mkVec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "mkVec4",
          "normalized": "(Double,Double,Double,Double)-\u003eVec",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Double,Double,Double,Double)-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:mkVec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "neg",
          "package": "vect",
          "signature": "g -\u003e g",
          "source": "src/Data-Vect-Double-Base.html#neg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "neg",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "g-\u003eg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "norm",
          "package": "vect",
          "signature": "v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#norm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "norm",
          "normalized": "a-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "normalize",
          "package": "vect",
          "signature": "v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#normalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "normalize",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "normsqr",
          "package": "vect",
          "signature": "v -\u003e Double",
          "source": "src/Data-Vect-Double-Base.html#normsqr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "normsqr",
          "normalized": "a-\u003eDouble",
          "package": "vect",
          "signature": "v-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:normsqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "one",
          "package": "vect",
          "signature": "r",
          "source": "src/Data-Vect-Double-Base.html#one",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "one",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "operatorNorm",
          "package": "vect",
          "signature": "operatorNorm",
          "source": "src/Data-Vect-Double-Base.html#operatorNorm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "operatorNorm",
          "package": "vect",
          "partial": "Norm",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:operatorNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "orthogonal",
          "package": "vect",
          "signature": "o -\u003e p",
          "source": "src/Data-Vect-Double-Base.html#orthogonal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "orthogonal",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "o-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:orthogonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "outer",
          "package": "vect",
          "signature": "v -\u003e v -\u003e t",
          "source": "src/Data-Vect-Double-Base.html#outer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "outer",
          "normalized": "a-\u003ea-\u003eb",
          "package": "vect",
          "signature": "v-\u003ev-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:outer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "pointwise",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#pointwise",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "pointwise",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:pointwise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "project",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#project",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "project",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjects the first vector down to the hyperplane orthogonal to the second (unit) vector\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "project'",
          "package": "vect",
          "signature": "v -\u003e u -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#project%27",
          "type": "function"
        },
        "index": {
          "description": "Projects the first vector down to the hyperplane orthogonal to the second unit vector",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "project'",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vect",
          "signature": "v-\u003eu-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:project-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirection (second argument) is assumed to be a \u003cem\u003eunit\u003c/em\u003e vector!\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Base",
          "name": "projectUnsafe",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#projectUnsafe",
          "type": "function"
        },
        "index": {
          "description": "Direction second argument is assumed to be unit vector",
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "projectUnsafe",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "partial": "Unsafe",
          "signature": "v-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:projectUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "rmul",
          "package": "vect",
          "signature": "m -\u003e r -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#rmul",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "rmul",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vect",
          "signature": "m-\u003er-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:rmul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "scalarMul",
          "package": "vect",
          "signature": "Double -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Base.html#scalarMul",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "scalarMul",
          "normalized": "Double-\u003ea-\u003ea",
          "package": "vect",
          "partial": "Mul",
          "signature": "Double-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:scalarMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "scaling",
          "package": "vect",
          "signature": "v -\u003e p",
          "source": "src/Data-Vect-Double-Base.html#scaling",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "scaling",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:scaling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "semigroupProduct",
          "package": "vect",
          "signature": "[r] -\u003e r",
          "source": "src/Data-Vect-Double-Base.html#semigroupProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "semigroupProduct",
          "normalized": "[a]-\u003ea",
          "package": "vect",
          "partial": "Product",
          "signature": "[r]-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:semigroupProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "toNormalUnsafe",
          "package": "vect",
          "signature": "toNormalUnsafe",
          "source": "src/Data-Vect-Double-Base.html#toNormalUnsafe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "toNormalUnsafe",
          "package": "vect",
          "partial": "Normal Unsafe",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:toNormalUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "toOrthoUnsafe",
          "package": "vect",
          "signature": "m -\u003e o",
          "source": "src/Data-Vect-Double-Base.html#toOrthoUnsafe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "toOrthoUnsafe",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Ortho Unsafe",
          "signature": "m-\u003eo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:toOrthoUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "toProjectiveUnsafe",
          "package": "vect",
          "signature": "m -\u003e p",
          "source": "src/Data-Vect-Double-Base.html#toProjectiveUnsafe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "toProjectiveUnsafe",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Projective Unsafe",
          "signature": "m-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:toProjectiveUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "translation",
          "package": "vect",
          "signature": "v -\u003e p",
          "source": "src/Data-Vect-Double-Base.html#translation",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "translation",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:translation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "transpose",
          "package": "vect",
          "signature": "m -\u003e m",
          "source": "src/Data-Vect-Double-Base.html#transpose",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "transpose",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "trim",
          "package": "vect",
          "signature": "trim",
          "source": "src/Data-Vect-Double-Base.html#trim",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "trim",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:trim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "vecSum",
          "package": "vect",
          "signature": "[g] -\u003e g",
          "source": "src/Data-Vect-Double-Base.html#vecSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "vecSum",
          "normalized": "[a]-\u003ea",
          "package": "vect",
          "partial": "Sum",
          "signature": "[g]-\u003eg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:vecSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Base",
          "name": "zero",
          "package": "vect",
          "signature": "g",
          "source": "src/Data-Vect-Double-Base.html#zero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Base",
          "module": "Data.Vect.Double.Base",
          "name": "zero",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Base.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGram-Schmidt orthogonalization.\n This module is not re-exported by \u003ca\u003eData.Vect\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "source": "src/Data-Vect-Double-GramSchmidt.html",
          "type": "module"
        },
        "index": {
          "description": "Gram-Schmidt orthogonalization This module is not re-exported by Data.Vect",
          "hierarchy": "Data Vect Double GramSchmidt",
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "partial": "Gram Schmidt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-GramSchmidt.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eproduces orthogonal/orthonormal vectors from a set of vectors    \n\u003c/p\u003e",
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "source": "src/Data-Vect-Double-GramSchmidt.html#GramSchmidt",
          "type": "class"
        },
        "index": {
          "description": "produces orthogonal orthonormal vectors from set of vectors",
          "hierarchy": "Data Vect Double GramSchmidt",
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "partial": "Gram Schmidt",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-GramSchmidt.html#t:GramSchmidt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "gramSchmidt",
          "package": "vect",
          "signature": "gramSchmidt",
          "source": "src/Data-Vect-Double-GramSchmidt.html#gramSchmidt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double GramSchmidt",
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "gramSchmidt",
          "package": "vect",
          "partial": "Schmidt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-GramSchmidt.html#v:gramSchmidt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "gramSchmidtNormalize",
          "package": "vect",
          "signature": "gramSchmidtNormalize",
          "source": "src/Data-Vect-Double-GramSchmidt.html#gramSchmidtNormalize",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double GramSchmidt",
          "module": "Data.Vect.Double.GramSchmidt",
          "name": "gramSchmidtNormalize",
          "package": "vect",
          "partial": "Schmidt Normalize",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-GramSchmidt.html#v:gramSchmidtNormalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e instances for vectors and matrices.\n These make writing code much more convenient, but also much more \n dangerous; thus you have to import this module explicitely.\n\u003c/p\u003e\u003cp\u003eIn the case of Vector instances, all operations are pointwise\n (including multiplication and division), and scalars are implicitly\n converted to vectors so that all components of the resulting vectors\n are the equal to the given scalar. This gives a set of consistent\n instances.\n\u003c/p\u003e\u003cp\u003eIn the case of Matrices, multiplication is usual matrix multiplication,\n division is not implemented, and scalars are converted to diagonal \n matrices.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e are implemented to be \u003ccode\u003e\u003ca\u003enormalize\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003enorm\u003c/a\u003e\u003c/code\u003e\n (in the case of matrices, Frobenius norm).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Double.Instances",
          "name": "Instances",
          "package": "vect",
          "source": "src/Data-Vect-Double-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "Eq Num and Fractional instances for vectors and matrices These make writing code much more convenient but also much more dangerous thus you have to import this module explicitely In the case of Vector instances all operations are pointwise including multiplication and division and scalars are implicitly converted to vectors so that all components of the resulting vectors are the equal to the given scalar This gives set of consistent instances In the case of Matrices multiplication is usual matrix multiplication division is not implemented and scalars are converted to diagonal matrices abs and signum are implemented to be normalize and norm in the case of matrices Frobenius norm",
          "hierarchy": "Data Vect Double Instances",
          "module": "Data.Vect.Double.Instances",
          "name": "Instances",
          "package": "vect",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterpolation of vectors. \n Note: we interpolate unit vectors differently from ordinary vectors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Double.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "source": "src/Data-Vect-Double-Interpolate.html",
          "type": "module"
        },
        "index": {
          "description": "Interpolation of vectors Note we interpolate unit vectors differently from ordinary vectors",
          "hierarchy": "Data Vect Double Interpolate",
          "module": "Data.Vect.Double.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "partial": "Interpolate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Interpolate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "source": "src/Data-Vect-Double-Interpolate.html#Interpolate",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Double Interpolate",
          "module": "Data.Vect.Double.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "partial": "Interpolate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Interpolate.html#t:Interpolate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Interpolate",
          "name": "interpolate",
          "package": "vect",
          "signature": "Double -\u003e v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Double-Interpolate.html#interpolate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Double Interpolate",
          "module": "Data.Vect.Double.Interpolate",
          "name": "interpolate",
          "normalized": "Double-\u003ea-\u003ea-\u003ea",
          "package": "vect",
          "signature": "Double-\u003ev-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Interpolate.html#v:interpolate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpherical linear interpolation.\n See \u003ca\u003ehttp://en.wikipedia.org/wiki/Slerp\u003c/a\u003e    \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Interpolate",
          "name": "slerp",
          "package": "vect",
          "signature": "Double -\u003e u -\u003e u -\u003e u",
          "source": "src/Data-Vect-Double-Interpolate.html#slerp",
          "type": "function"
        },
        "index": {
          "description": "Spherical linear interpolation See http en.wikipedia.org wiki Slerp",
          "hierarchy": "Data Vect Double Interpolate",
          "module": "Data.Vect.Double.Interpolate",
          "name": "slerp",
          "normalized": "Double-\u003ea-\u003ea-\u003ea",
          "package": "vect",
          "signature": "Double-\u003eu-\u003eu-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Interpolate.html#v:slerp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "Dim2",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Dim2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "Dim2",
          "package": "vect",
          "partial": "Dim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe angle relative to the positive X axis\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "angle2",
          "package": "vect",
          "signature": "Vec2 -\u003e Double",
          "source": "src/Data-Vect-Double-Util-Dim2.html#angle2",
          "type": "function"
        },
        "index": {
          "description": "The angle relative to the positive axis",
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "angle2",
          "normalized": "Vec-\u003eDouble",
          "package": "vect",
          "signature": "Vec-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:angle2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "angle2'",
          "package": "vect",
          "signature": "Normal2 -\u003e Double",
          "source": "src/Data-Vect-Double-Util-Dim2.html#angle2%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "angle2'",
          "normalized": "Normal-\u003eDouble",
          "package": "vect",
          "signature": "Normal-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:angle2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe opposite of \u003ca\u003estructVec2\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "destructVec2",
          "package": "vect",
          "signature": "[Vec2] -\u003e [Double]",
          "source": "src/Data-Vect-Double-Util-Dim2.html#destructVec2",
          "type": "function"
        },
        "index": {
          "description": "The opposite of structVec2",
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "destructVec2",
          "normalized": "[Vec]-\u003e[Double]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Vec]-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:destructVec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "det2",
          "package": "vect",
          "signature": "Vec2 -\u003e Vec2 -\u003e Double",
          "source": "src/Data-Vect-Double-Util-Dim2.html#det2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "det2",
          "normalized": "Vec-\u003eVec-\u003eDouble",
          "package": "vect",
          "signature": "Vec-\u003eVec-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:det2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation matrix by a given angle (in radians), counterclockwise.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotMatrix2",
          "package": "vect",
          "signature": "Double -\u003e Mat2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#rotMatrix2",
          "type": "function"
        },
        "index": {
          "description": "Rotation matrix by given angle in radians counterclockwise",
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotMatrix2",
          "normalized": "Double-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Double-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:rotMatrix2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotMatrixOrtho2",
          "package": "vect",
          "signature": "Double -\u003e Ortho2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#rotMatrixOrtho2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotMatrixOrtho2",
          "normalized": "Double-\u003eOrtho",
          "package": "vect",
          "partial": "Matrix Ortho",
          "signature": "Double-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:rotMatrixOrtho2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotate2",
          "package": "vect",
          "signature": "Double -\u003e Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#rotate2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotate2",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:rotate2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotates counterclockwise by 90 degrees.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotateCCW",
          "package": "vect",
          "signature": "Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#rotateCCW",
          "type": "function"
        },
        "index": {
          "description": "Rotates counterclockwise by degrees",
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotateCCW",
          "normalized": "Vec-\u003eVec",
          "package": "vect",
          "partial": "CCW",
          "signature": "Vec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:rotateCCW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotates clockwise by 90 degrees.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotateCW",
          "package": "vect",
          "signature": "Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#rotateCW",
          "type": "function"
        },
        "index": {
          "description": "Rotates clockwise by degrees",
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "rotateCW",
          "normalized": "Vec-\u003eVec",
          "package": "vect",
          "partial": "CW",
          "signature": "Vec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:rotateCW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunit vector with given angle relative to the positive X axis (in the positive direction, that is, CCW).\n A more precise name would be \u003ccode\u003ecosSin\u003c/code\u003e, but that sounds bad :)\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "sinCos",
          "package": "vect",
          "signature": "Double -\u003e Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#sinCos",
          "type": "function"
        },
        "index": {
          "description": "unit vector with given angle relative to the positive axis in the positive direction that is CCW more precise name would be cosSin but that sounds bad",
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "sinCos",
          "normalized": "Double-\u003eVec",
          "package": "vect",
          "partial": "Cos",
          "signature": "Double-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:sinCos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "sinCos'",
          "package": "vect",
          "signature": "Double -\u003e Normal2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#sinCos%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "sinCos'",
          "normalized": "Double-\u003eNormal",
          "package": "vect",
          "partial": "Cos'",
          "signature": "Double-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:sinCos-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "sinCosRadius",
          "package": "vect",
          "signature": "Double-\u003e Double-\u003e Vec2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "sinCosRadius",
          "normalized": "Double-\u003eDouble-\u003eVec",
          "package": "vect",
          "partial": "Cos Radius",
          "signature": "Double-\u003eDouble-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:sinCosRadius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample: \u003ccode\u003estructVec2 [1,2,3,4] = [ Vec2 1 2 , Vec2 3 4 ]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "structVec2",
          "package": "vect",
          "signature": "[Double] -\u003e [Vec2]",
          "source": "src/Data-Vect-Double-Util-Dim2.html#structVec2",
          "type": "function"
        },
        "index": {
          "description": "Example structVec2 Vec2 Vec2",
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "structVec2",
          "normalized": "[Double]-\u003e[Vec]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Double]-\u003e[Vec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:structVec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "translate2X",
          "package": "vect",
          "signature": "Double -\u003e Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#translate2X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "translate2X",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:translate2X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "translate2Y",
          "package": "vect",
          "signature": "Double -\u003e Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#translate2Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "translate2Y",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:translate2Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "vec2X",
          "package": "vect",
          "signature": "Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#vec2X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "vec2X",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:vec2X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "vec2Y",
          "package": "vect",
          "signature": "Vec2",
          "source": "src/Data-Vect-Double-Util-Dim2.html#vec2Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim2",
          "module": "Data.Vect.Double.Util.Dim2",
          "name": "vec2Y",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim2.html#v:vec2Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "Dim3",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Dim3.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "Dim3",
          "package": "vect",
          "partial": "Dim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe opposite of \u003ca\u003estructVec3\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "destructVec3",
          "package": "vect",
          "signature": "[Vec3] -\u003e [Double]",
          "source": "src/Data-Vect-Double-Util-Dim3.html#destructVec3",
          "type": "function"
        },
        "index": {
          "description": "The opposite of structVec3",
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "destructVec3",
          "normalized": "[Vec]-\u003e[Double]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Vec]-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:destructVec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "det3",
          "package": "vect",
          "signature": "Vec3 -\u003e Vec3 -\u003e Vec3 -\u003e Double",
          "source": "src/Data-Vect-Double-Util-Dim3.html#det3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "det3",
          "normalized": "Vec-\u003eVec-\u003eVec-\u003eDouble",
          "package": "vect",
          "signature": "Vec-\u003eVec-\u003eVec-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:det3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReflects a vector to an axis: that is, the result of \u003ccode\u003ereflect n v\u003c/code\u003e is\n 2\u003cn,v\u003en - v\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "reflect",
          "package": "vect",
          "signature": "Normal3 -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#reflect",
          "type": "function"
        },
        "index": {
          "description": "Reflects vector to an axis that is the result of reflect is",
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "reflect",
          "normalized": "Normal-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Normal-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:reflect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "reflect'",
          "package": "vect",
          "signature": "Normal3 -\u003e Normal3 -\u003e Normal3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#reflect%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "reflect'",
          "normalized": "Normal-\u003eNormal-\u003eNormal",
          "package": "vect",
          "signature": "Normal-\u003eNormal-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:reflect-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "refract",
          "package": "vect",
          "signature": "Double -\u003e Normal3 -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#refract",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "refract",
          "normalized": "Double-\u003eNormal-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eNormal-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:refract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRefraction.\n First parameter (\u003ccode\u003eeta\u003c/code\u003e) is the relative refraction index \n\u003c/p\u003e\u003cpre\u003e        refl_inside\n eta = --------------\n        refl_outside\n\u003c/pre\u003e\u003cp\u003ewhere \"inside\" is the direction of the second argument \n (to vector normal to plane which models the boundary \n between the two materials). That is, total internal reflection\n can occur when \u003ccode\u003eeta\u003e1\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe convention is that the origin is the point of intersection\n of the ray and the surface, and all the vectors \"point away\"\n from here (unlike, say, GLSL's \u003ccode\u003erefract\u003c/code\u003e, where the incident\n vector \"points towards\" the material)\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "refract'",
          "package": "vect",
          "signature": "Double -\u003e Normal3 -\u003e Normal3 -\u003e Normal3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#refract%27",
          "type": "function"
        },
        "index": {
          "description": "Refraction First parameter eta is the relative refraction index refl inside eta refl outside where inside is the direction of the second argument to vector normal to plane which models the boundary between the two materials That is total internal reflection can occur when eta The convention is that the origin is the point of intersection of the ray and the surface and all the vectors point away from here unlike say GLSL refract where the incident vector points towards the material",
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "refract'",
          "normalized": "Double-\u003eNormal-\u003eNormal-\u003eNormal",
          "package": "vect",
          "signature": "Double-\u003eNormal-\u003eNormal-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:refract-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen total internal reflection would occur, we return \u003ca\u003eNothing\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "refractOnly'",
          "package": "vect",
          "signature": "Double -\u003e Normal3 -\u003e Normal3 -\u003e Maybe Normal3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#refractOnly%27",
          "type": "function"
        },
        "index": {
          "description": "When total internal reflection would occur we return Nothing",
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "refractOnly'",
          "normalized": "Double-\u003eNormal-\u003eNormal-\u003eMaybe Normal",
          "package": "vect",
          "partial": "Only'",
          "signature": "Double-\u003eNormal-\u003eNormal-\u003eMaybe Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:refractOnly-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation around an arbitrary 3D vector. The resulting 3x3 matrix is intended for multiplication on the \u003cem\u003eright\u003c/em\u003e. \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrix3",
          "package": "vect",
          "signature": "Vec3 -\u003e Double -\u003e Mat3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#rotMatrix3",
          "type": "function"
        },
        "index": {
          "description": "Rotation around an arbitrary vector The resulting x3 matrix is intended for multiplication on the right",
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrix3",
          "normalized": "Vec-\u003eDouble-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Vec-\u003eDouble-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotMatrix3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation around an arbitrary 3D \u003cem\u003eunit\u003c/em\u003e vector. The resulting 3x3 matrix is intended for multiplication on the \u003cem\u003eright\u003c/em\u003e. \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrix3'",
          "package": "vect",
          "signature": "Normal3 -\u003e Double -\u003e Mat3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#rotMatrix3%27",
          "type": "function"
        },
        "index": {
          "description": "Rotation around an arbitrary unit vector The resulting x3 matrix is intended for multiplication on the right",
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrix3'",
          "normalized": "Normal-\u003eDouble-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Normal-\u003eDouble-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotMatrix3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixOrtho3",
          "package": "vect",
          "signature": "Vec3 -\u003e Double -\u003e Ortho3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#rotMatrixOrtho3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixOrtho3",
          "normalized": "Vec-\u003eDouble-\u003eOrtho",
          "package": "vect",
          "partial": "Matrix Ortho",
          "signature": "Vec-\u003eDouble-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotMatrixOrtho3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixOrtho3'",
          "package": "vect",
          "signature": "Normal3 -\u003e Double -\u003e Ortho3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#rotMatrixOrtho3%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixOrtho3'",
          "normalized": "Normal-\u003eDouble-\u003eOrtho",
          "package": "vect",
          "partial": "Matrix Ortho",
          "signature": "Normal-\u003eDouble-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotMatrixOrtho3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixX",
          "package": "vect",
          "signature": "Double -\u003e Mat3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#rotMatrixX",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixX",
          "normalized": "Double-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Double-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotMatrixX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixY",
          "package": "vect",
          "signature": "Double -\u003e Mat3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#rotMatrixY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixY",
          "normalized": "Double-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Double-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotMatrixY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixZ",
          "package": "vect",
          "signature": "Double -\u003e Mat3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#rotMatrixZ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotMatrixZ",
          "normalized": "Double-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Double-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotMatrixZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotate3",
          "package": "vect",
          "signature": "Double-\u003e Vec3-\u003e Vec3-\u003e Vec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotate3",
          "normalized": "Double-\u003eVec-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotate3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotate3'",
          "package": "vect",
          "signature": "Double-\u003e Normal3-\u003e Vec3-\u003e Vec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "rotate3'",
          "normalized": "Double-\u003eNormal-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eNormal-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:rotate3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample: \u003ccode\u003estructVec3 [1,2,3,4,5,6] = [ Vec3 1 2 3 , Vec3 4 5 6]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "structVec3",
          "package": "vect",
          "signature": "[Double] -\u003e [Vec3]",
          "source": "src/Data-Vect-Double-Util-Dim3.html#structVec3",
          "type": "function"
        },
        "index": {
          "description": "Example structVec3 Vec3 Vec3",
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "structVec3",
          "normalized": "[Double]-\u003e[Vec]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Double]-\u003e[Vec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:structVec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "translate3X",
          "package": "vect",
          "signature": "Double -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#translate3X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "translate3X",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:translate3X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "translate3Y",
          "package": "vect",
          "signature": "Double -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#translate3Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "translate3Y",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:translate3Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "translate3Z",
          "package": "vect",
          "signature": "Double -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#translate3Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "translate3Z",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:translate3Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "vec3X",
          "package": "vect",
          "signature": "Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#vec3X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "vec3X",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:vec3X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "vec3Y",
          "package": "vect",
          "signature": "Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#vec3Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "vec3Y",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:vec3Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "vec3Z",
          "package": "vect",
          "signature": "Vec3",
          "source": "src/Data-Vect-Double-Util-Dim3.html#vec3Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim3",
          "module": "Data.Vect.Double.Util.Dim3",
          "name": "vec3Z",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim3.html#v:vec3Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRotation around an arbitrary plane in four dimensions, and other miscellanea.\n Not very useful for most people, and not re-exported by \u003ca\u003eData.Vect\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "Dim4",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Dim4.html",
          "type": "module"
        },
        "index": {
          "description": "Rotation around an arbitrary plane in four dimensions and other miscellanea Not very useful for most people and not re-exported by Data.Vect",
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "Dim4",
          "package": "vect",
          "partial": "Dim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003e(x,y,u,v)\u003c/code\u003e is an orthonormal system, then (written in pseudo-code)\n \u003ccode\u003ebiVector4 (x,y) = plusMinus (reverse $ biVector4 (u,v))\u003c/code\u003e.\n This is a helper function for the 4 dimensional rotation code.\n If \u003ccode\u003e(x,y,z,p,q,r) = biVector4 a b\u003c/code\u003e, then the corresponding antisymmetric tensor is\n\u003c/p\u003e\u003cpre\u003e [  0  r  q  p ]\n [ -r  0  z -y ]\n [ -q -z  0  x ]\n [ -p  y -x  0 ]\n\u003c/pre\u003e",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "biVector4",
          "package": "vect",
          "signature": "Vec4 -\u003e Vec4 -\u003e (Double, Double, Double, Double, Double, Double)",
          "source": "src/Data-Vect-Double-Util-Dim4.html#biVector4",
          "type": "function"
        },
        "index": {
          "description": "If is an orthonormal system then written in pseudo-code biVector4 plusMinus reverse biVector4 This is helper function for the dimensional rotation code If biVector4 then the corresponding antisymmetric tensor is",
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "biVector4",
          "normalized": "Vec-\u003eVec-\u003e(Double,Double,Double,Double,Double,Double)",
          "package": "vect",
          "partial": "Vector",
          "signature": "Vec-\u003eVec-\u003e(Double,Double,Double,Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:biVector4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe corresponding antisymmetric tensor\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "biVector4AsTensor",
          "package": "vect",
          "signature": "Vec4 -\u003e Vec4 -\u003e Mat4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#biVector4AsTensor",
          "type": "function"
        },
        "index": {
          "description": "the corresponding antisymmetric tensor",
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "biVector4AsTensor",
          "normalized": "Vec-\u003eVec-\u003eMat",
          "package": "vect",
          "partial": "Vector As Tensor",
          "signature": "Vec-\u003eVec-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:biVector4AsTensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "destructVec4",
          "package": "vect",
          "signature": "[Vec4] -\u003e [Double]",
          "source": "src/Data-Vect-Double-Util-Dim4.html#destructVec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "destructVec4",
          "normalized": "[Vec]-\u003e[Double]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Vec]-\u003e[Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:destructVec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe assume only that the axes are independent vectors.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotMatrix4",
          "package": "vect",
          "signature": "Double -\u003e (Vec4, Vec4) -\u003e Mat4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#rotMatrix4",
          "type": "function"
        },
        "index": {
          "description": "We assume only that the axes are independent vectors",
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotMatrix4",
          "normalized": "Double-\u003e(Vec,Vec)-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Double-\u003e(Vec,Vec)-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:rotMatrix4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation matrix around a plane specified by two normalized and \u003cem\u003eorthogonal\u003c/em\u003e vectors.\n Intended for multiplication on the \u003cem\u003eright\u003c/em\u003e!\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotMatrix4'",
          "package": "vect",
          "signature": "Double -\u003e (Normal4, Normal4) -\u003e Mat4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#rotMatrix4%27",
          "type": "function"
        },
        "index": {
          "description": "Rotation matrix around plane specified by two normalized and orthogonal vectors Intended for multiplication on the right",
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotMatrix4'",
          "normalized": "Double-\u003e(Normal,Normal)-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Double-\u003e(Normal,Normal)-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:rotMatrix4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe assume only that the axes are independent vectors.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotate4",
          "package": "vect",
          "signature": "Double -\u003e (Vec4, Vec4) -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#rotate4",
          "type": "function"
        },
        "index": {
          "description": "We assume only that the axes are independent vectors",
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotate4",
          "normalized": "Double-\u003e(Vec,Vec)-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003e(Vec,Vec)-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:rotate4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe assume that the axes are normalized and \u003cem\u003eorthogonal\u003c/em\u003e to each other!\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotate4'",
          "package": "vect",
          "signature": "Double -\u003e (Normal4, Normal4) -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#rotate4%27",
          "type": "function"
        },
        "index": {
          "description": "We assume that the axes are normalized and orthogonal to each other",
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "rotate4'",
          "normalized": "Double-\u003e(Normal,Normal)-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003e(Normal,Normal)-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:rotate4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "structVec4",
          "package": "vect",
          "signature": "[Double] -\u003e [Vec4]",
          "source": "src/Data-Vect-Double-Util-Dim4.html#structVec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "structVec4",
          "normalized": "[Double]-\u003e[Vec]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Double]-\u003e[Vec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:structVec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4W",
          "package": "vect",
          "signature": "Double -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#translate4W",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4W",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:translate4W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4X",
          "package": "vect",
          "signature": "Double -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#translate4X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4X",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:translate4X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4Y",
          "package": "vect",
          "signature": "Double -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#translate4Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4Y",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:translate4Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4Z",
          "package": "vect",
          "signature": "Double -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#translate4Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "translate4Z",
          "normalized": "Double-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Double-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:translate4Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4W",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#vec4W",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4W",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:vec4W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4X",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#vec4X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4X",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:vec4X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4Y",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#vec4Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4Y",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:vec4Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4Z",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Double-Util-Dim4.html#vec4Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Dim4",
          "module": "Data.Vect.Double.Util.Dim4",
          "name": "vec4Z",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Dim4.html#v:vec4Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClassic 4x4 projective matrices, encoding the affine transformations of R^3.\n Our convention is that they are intended for multiplication on\n the \u003cem\u003eright\u003c/em\u003e, that is, they are of the form\n\u003c/p\u003e\u003cpre\u003e     _____\n [  |     |  0  ]\n [  | 3x3 |  0  ]\n [  |_____|  0  ]\n [  p  q  r  1  ]\n\u003c/pre\u003e\u003cp\u003ePlease note that by default, OpenGL stores the matrices (in memory) by columns, while we \n store them by rows; but OpenGL also use the opposite convention (so the OpenGL projective matrices \n are intended for multiplication on the \u003cem\u003eleft\u003c/em\u003e). So in effect, they are the same when stored in the memory,\n say with \u003ccode\u003epoke :: Ptr Mat4 -\u003e Mat4 -\u003e IO ()\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWarning: The naming conventions will probably change in the future.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "Projective",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Projective.html",
          "type": "module"
        },
        "index": {
          "description": "Classic x4 projective matrices encoding the affine transformations of Our convention is that they are intended for multiplication on the right that is they are of the form x3 Please note that by default OpenGL stores the matrices in memory by columns while we store them by rows but OpenGL also use the opposite convention so the OpenGL projective matrices are intended for multiplication on the left So in effect they are the same when stored in the memory say with poke Ptr Mat4 Mat4 IO Warning The naming conventions will probably change in the future",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "Projective",
          "package": "vect",
          "partial": "Projective",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotMatrixProj4",
          "package": "vect",
          "signature": "Double -\u003e Vec3 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#rotMatrixProj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotMatrixProj4",
          "normalized": "Double-\u003eVec-\u003eProj",
          "package": "vect",
          "partial": "Matrix Proj",
          "signature": "Double-\u003eVec-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:rotMatrixProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotMatrixProj4'",
          "package": "vect",
          "signature": "Double -\u003e Normal3 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#rotMatrixProj4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotMatrixProj4'",
          "normalized": "Double-\u003eNormal-\u003eProj",
          "package": "vect",
          "partial": "Matrix Proj",
          "signature": "Double-\u003eNormal-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:rotMatrixProj4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003em -\u003e m .*. rotMatrixProj4 angle axis\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotateAfterProj4",
          "package": "vect",
          "signature": "Double -\u003e Normal3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#rotateAfterProj4",
          "type": "function"
        },
        "index": {
          "description": "Synonym for rotMatrixProj4 angle axis",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotateAfterProj4",
          "normalized": "Double-\u003eNormal-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "After Proj",
          "signature": "Double-\u003eNormal-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:rotateAfterProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003em -\u003e rotMatrixProj4 angle axis .*. m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotateBeforeProj4",
          "package": "vect",
          "signature": "Double -\u003e Normal3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#rotateBeforeProj4",
          "type": "function"
        },
        "index": {
          "description": "Synonym for rotMatrixProj4 angle axis",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotateBeforeProj4",
          "normalized": "Double-\u003eNormal-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Before Proj",
          "signature": "Double-\u003eNormal-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:rotateBeforeProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esynonym for \u003ca\u003erotateAfterProj4\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotateProj4",
          "package": "vect",
          "signature": "Double -\u003e Normal3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#rotateProj4",
          "type": "function"
        },
        "index": {
          "description": "synonym for rotateAfterProj4",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "rotateProj4",
          "normalized": "Double-\u003eNormal-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Proj",
          "signature": "Double-\u003eNormal-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:rotateProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e m .*. scaling v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "scaleAfterProj4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#scaleAfterProj4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to scaling",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "scaleAfterProj4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "After Proj",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:scaleAfterProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e scaling v .*. m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "scaleBeforeProj4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#scaleBeforeProj4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to scaling",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "scaleBeforeProj4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Before Proj",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:scaleBeforeProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Projective",
          "name": "scalingUniformProj4",
          "package": "vect",
          "signature": "Double -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#scalingUniformProj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "scalingUniformProj4",
          "normalized": "Double-\u003eProj",
          "package": "vect",
          "partial": "Uniform Proj",
          "signature": "Double-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:scalingUniformProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ca\u003etranslateAfter4\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "translate4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#translate4",
          "type": "function"
        },
        "index": {
          "description": "Synonym for translateAfter4",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "translate4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:translate4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e m .*. translation v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "translateAfter4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#translateAfter4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to translation",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "translateAfter4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "After",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:translateAfter4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e translation v .*. m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "translateBefore4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Double-Util-Projective.html#translateBefore4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to translation",
          "hierarchy": "Data Vect Double Util Projective",
          "module": "Data.Vect.Double.Util.Projective",
          "name": "translateBefore4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Before",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Projective.html#v:translateBefore4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe unit sphere in the space of quaternions has the group structure\n SU(2) coming from the quaternion multiplication, which is the double\n cover of the group SO(3) of rotations in R^3. Thus, unit quaternions can\n be used to encode rotations in 3D, which is a more compact encoding \n (4 floats) than a 3x3 matrix; however, there are \u003cem\u003etwo\u003c/em\u003e quaternions\n corresponding to each rotation.\n\u003c/p\u003e\u003cp\u003eSee \u003ca\u003ehttp://en.wikipedia.org/wiki/Quaternion\u003c/a\u003e and \n \u003ca\u003ehttp://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation\u003c/a\u003e\n for more information.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Quaternion.html",
          "type": "module"
        },
        "index": {
          "description": "The unit sphere in the space of quaternions has the group structure SU coming from the quaternion multiplication which is the double cover of the group SO of rotations in Thus unit quaternions can be used to encode rotations in which is more compact encoding floats than x3 matrix however there are two quaternions corresponding to each rotation See http en.wikipedia.org wiki Quaternion and http en.wikipedia.org wiki Quaternions and spatial rotation for more information",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "partial": "Quaternion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abbreviated type synonym for quaternions\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#Q",
          "type": "type"
        },
        "index": {
          "description": "An abbreviated type synonym for quaternions",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#t:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type for quaternions. \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#Quaternion",
          "type": "newtype"
        },
        "index": {
          "description": "The type for quaternions",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "partial": "Quaternion",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#t:Quaternion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abbreviated type synonym for unit quaternions\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#U",
          "type": "type"
        },
        "index": {
          "description": "An abbreviated type synonym for unit quaternions",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#t:U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type for unit quaternions. \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "UnitQuaternion",
          "package": "vect",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#UnitQuaternion",
          "type": "newtype"
        },
        "index": {
          "description": "The type for unit quaternions",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "UnitQuaternion",
          "package": "vect",
          "partial": "Unit Quaternion",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#t:UnitQuaternion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "signature": "Q Vec4",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#Quaternion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "signature": "U Vec4",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#UnitQuaternion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eleft\u003c/em\u003e action of unit quaternions on 3D vectors.\n That is,\n\u003c/p\u003e\u003cpre\u003e actU q1 $ actU q2 v  ==  actU (q1 `multU` q2) v \n\u003c/pre\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "actU",
          "package": "vect",
          "signature": "U -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#actU",
          "type": "function"
        },
        "index": {
          "description": "The left action of unit quaternions on vectors That is actU q1 actU q2 actU q1 multU q2",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "actU",
          "normalized": "U-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "U-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:actU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "fromQ",
          "package": "vect",
          "signature": "Q -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#fromQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "fromQ",
          "normalized": "Q-\u003eVec",
          "package": "vect",
          "signature": "Q-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:fromQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "fromU",
          "package": "vect",
          "signature": "U -\u003e Vec4",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#fromU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "fromU",
          "normalized": "U-\u003eVec",
          "package": "vect",
          "signature": "U-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:fromU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "fromU'",
          "package": "vect",
          "signature": "U -\u003e Normal4",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#fromU%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "fromU'",
          "normalized": "U-\u003eNormal",
          "package": "vect",
          "partial": "U'",
          "signature": "U-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:fromU-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse quaternion\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "invQ",
          "package": "vect",
          "signature": "Q -\u003e Q",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#invQ",
          "type": "function"
        },
        "index": {
          "description": "The inverse quaternion",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "invQ",
          "normalized": "Q-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:invQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse of a unit quaternion\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "invU",
          "package": "vect",
          "signature": "U -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#invU",
          "type": "function"
        },
        "index": {
          "description": "The inverse of unit quaternion",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "invU",
          "normalized": "U-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:invU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes a rotation matrix (to be multiplied with on the \u003cem\u003eleft\u003c/em\u003e) out of a unit quaternion.\n\u003c/p\u003e\u003cpre\u003e leftOrthoU (rotU axis angl) *. v  ==  v .* rotMatrix3 axis angl\n\u003c/pre\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "leftOrthoU",
          "package": "vect",
          "signature": "U -\u003e Ortho3",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#leftOrthoU",
          "type": "function"
        },
        "index": {
          "description": "Makes rotation matrix to be multiplied with on the left out of unit quaternion leftOrthoU rotU axis angl rotMatrix3 axis angl",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "leftOrthoU",
          "normalized": "U-\u003eOrtho",
          "package": "vect",
          "partial": "Ortho",
          "signature": "U-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:leftOrthoU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpolation of unit quaternions. Note that when applied to rotations,\n this may be not what you want, since it is possible that the shortest path\n in the space of unit quaternions is not the shortest path in the space of\n rotations; see \u003ccode\u003e\u003ca\u003eslerpU\u003c/a\u003e\u003c/code\u003e!\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "longSlerpU",
          "package": "vect",
          "signature": "Double -\u003e U -\u003e U -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#longSlerpU",
          "type": "function"
        },
        "index": {
          "description": "Interpolation of unit quaternions Note that when applied to rotations this may be not what you want since it is possible that the shortest path in the space of unit quaternions is not the shortest path in the space of rotations see slerpU",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "longSlerpU",
          "normalized": "Double-\u003eU-\u003eU-\u003eU",
          "package": "vect",
          "partial": "Slerp",
          "signature": "Double-\u003eU-\u003eU-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:longSlerpU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "mkU",
          "package": "vect",
          "signature": "Vec4 -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#mkU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "mkU",
          "normalized": "Vec-\u003eU",
          "package": "vect",
          "signature": "Vec-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:mkU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "multQ",
          "package": "vect",
          "signature": "Q -\u003e Q -\u003e Q",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#multQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "multQ",
          "normalized": "Q-\u003eQ-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:multQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "multU",
          "package": "vect",
          "signature": "U -\u003e U -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#multU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "multU",
          "normalized": "U-\u003eU-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:multU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "negQ",
          "package": "vect",
          "signature": "Q -\u003e Q",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#negQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "negQ",
          "normalized": "Q-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:negQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe opposite quaternion (which encodes the same rotation)\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "negU",
          "package": "vect",
          "signature": "U -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#negU",
          "type": "function"
        },
        "index": {
          "description": "The opposite quaternion which encodes the same rotation",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "negU",
          "normalized": "U-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:negU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "normalizeQ",
          "package": "vect",
          "signature": "Q -\u003e Q",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#normalizeQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "normalizeQ",
          "normalized": "Q-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:normalizeQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is no-op, up to numerical imprecision.\n However, if you multiply together a large number of unit quaternions, \n it may be a good idea to normalize the end result.\n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "normalizeU",
          "package": "vect",
          "signature": "U -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#normalizeU",
          "type": "function"
        },
        "index": {
          "description": "This is no-op up to numerical imprecision However if you multiply together large number of unit quaternions it may be good idea to normalize the end result",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "normalizeU",
          "normalized": "U-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:normalizeU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes a rotation matrix (to be multiplied with on the \u003cem\u003eright\u003c/em\u003e) out of a unit quaternion:\n\u003c/p\u003e\u003cpre\u003e v .* rightOrthoU (rotU axis angl)  ==  v .* rotMatrix3 axis angl\n\u003c/pre\u003e\u003cp\u003ePlease note that while these matrices act on the \u003cem\u003eright\u003c/em\u003e, quaternions act on the \u003cem\u003eleft\u003c/em\u003e; thus\n\u003c/p\u003e\u003cpre\u003e rightOrthoU q1 .*. rightOrthoU q2  ==  rightOrthoU (q2 .*. q1)\n\u003c/pre\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "rightOrthoU",
          "package": "vect",
          "signature": "U -\u003e Ortho3",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#rightOrthoU",
          "type": "function"
        },
        "index": {
          "description": "Makes rotation matrix to be multiplied with on the right out of unit quaternion rightOrthoU rotU axis angl rotMatrix3 axis angl Please note that while these matrices act on the right quaternions act on the left thus rightOrthoU q1 rightOrthoU q2 rightOrthoU q2 q1",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "rightOrthoU",
          "normalized": "U-\u003eOrtho",
          "package": "vect",
          "partial": "Ortho",
          "signature": "U-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:rightOrthoU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe quaternion to encode rotation around an axis. Please note\n that quaternions act on the \u003cem\u003eleft\u003c/em\u003e, that is\n\u003c/p\u003e\u003cpre\u003e rotU axis1 angl1 *. rotU axis2 angl2 *. v  ==  (rotU axis1 angl1 .*. rotU axis2 angl2) *. v \n\u003c/pre\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "rotU",
          "package": "vect",
          "signature": "Vec3 -\u003e Double -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#rotU",
          "type": "function"
        },
        "index": {
          "description": "The quaternion to encode rotation around an axis Please note that quaternions act on the left that is rotU axis1 angl1 rotU axis2 angl2 rotU axis1 angl1 rotU axis2 angl2",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "rotU",
          "normalized": "Vec-\u003eDouble-\u003eU",
          "package": "vect",
          "signature": "Vec-\u003eDouble-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:rotU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "rotU'",
          "package": "vect",
          "signature": "Normal3 -\u003e Double -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#rotU%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "rotU'",
          "normalized": "Normal-\u003eDouble-\u003eU",
          "package": "vect",
          "partial": "U'",
          "signature": "Normal-\u003eDouble-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:rotU-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is shortest path interpolation in the space of rotations; however\n this is achieved by possibly flipping the first endpoint in the space of\n quaternions. Thus \u003ccode\u003eslerpU 0.001 q1 q2\u003c/code\u003e may be very far from \u003ccode\u003eq1\u003c/code\u003e (and very\n close to \u003ccode\u003enegU q1\u003c/code\u003e) in the space of quaternions (but they are very close\n in the space of rotations). \n\u003c/p\u003e",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "slerpU",
          "package": "vect",
          "signature": "Double -\u003e U -\u003e U -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#slerpU",
          "type": "function"
        },
        "index": {
          "description": "This is shortest path interpolation in the space of rotations however this is achieved by possibly flipping the first endpoint in the space of quaternions Thus slerpU q1 q2 may be very far from q1 and very close to negU q1 in the space of quaternions but they are very close in the space of rotations",
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "slerpU",
          "normalized": "Double-\u003eU-\u003eU-\u003eU",
          "package": "vect",
          "signature": "Double-\u003eU-\u003eU-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:slerpU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "toQ",
          "package": "vect",
          "signature": "Vec4 -\u003e Q",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#toQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "toQ",
          "normalized": "Vec-\u003eQ",
          "package": "vect",
          "signature": "Vec-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:toQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "toU",
          "package": "vect",
          "signature": "Normal4 -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#toU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "toU",
          "normalized": "Normal-\u003eU",
          "package": "vect",
          "signature": "Normal-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:toU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "unitQ",
          "package": "vect",
          "signature": "Q",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#unitQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "unitQ",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:unitQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "unitU",
          "package": "vect",
          "signature": "U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#unitU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "unitU",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:unitU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "unsafeToU",
          "package": "vect",
          "signature": "Vec4 -\u003e U",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#unsafeToU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "unsafeToU",
          "normalized": "Vec-\u003eU",
          "package": "vect",
          "partial": "To",
          "signature": "Vec-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:unsafeToU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "zeroQ",
          "package": "vect",
          "signature": "Q",
          "source": "src/Data-Vect-Double-Util-Quaternion.html#zeroQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Double Util Quaternion",
          "module": "Data.Vect.Double.Util.Quaternion",
          "name": "zeroQ",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double-Util-Quaternion.html#v:zeroQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Double",
          "name": "Double",
          "package": "vect",
          "source": "src/Data-Vect-Double.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Double",
          "module": "Data.Vect.Double",
          "name": "Double",
          "package": "vect",
          "partial": "Double",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Double.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Base",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Base",
          "package": "vect",
          "partial": "Base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "AbelianGroup",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#AbelianGroup",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "AbelianGroup",
          "package": "vect",
          "partial": "Abelian Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:AbelianGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCross product\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "CrossProd",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#CrossProd",
          "type": "class"
        },
        "index": {
          "description": "Cross product",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "CrossProd",
          "package": "vect",
          "partial": "Cross Prod",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:CrossProd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Determinant",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Determinant",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Determinant",
          "package": "vect",
          "partial": "Determinant",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Determinant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emakes a diagonal matrix from a vector\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Diagonal",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Diagonal",
          "type": "class"
        },
        "index": {
          "description": "makes diagonal matrix from vector",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Diagonal",
          "package": "vect",
          "partial": "Diagonal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Diagonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Dimension",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Dimension",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Dimension",
          "package": "vect",
          "partial": "Dimension",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Dimension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "DotProd",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#DotProd",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "DotProd",
          "package": "vect",
          "partial": "Dot Prod",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:DotProd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econversion between vectors (and matrices) of different dimensions\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Extend",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Extend",
          "type": "class"
        },
        "index": {
          "description": "conversion between vectors and matrices of different dimensions",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Extend",
          "package": "vect",
          "partial": "Extend",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "HasCoordinates",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#HasCoordinates",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "HasCoordinates",
          "package": "vect",
          "partial": "Has Coordinates",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:HasCoordinates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "LeftModule",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#LeftModule",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "LeftModule",
          "package": "vect",
          "partial": "Left Module",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:LeftModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe components are \u003cem\u003erow\u003c/em\u003e vectors \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Mat2",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Mat2",
          "type": "data"
        },
        "index": {
          "description": "The components are row vectors",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Mat2",
          "package": "vect",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Mat2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Mat3",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Mat3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Mat3",
          "package": "vect",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Mat3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Mat4",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Mat4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Mat4",
          "package": "vect",
          "partial": "Mat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Mat4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Matrix",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Matrix",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Matrix",
          "package": "vect",
          "partial": "Matrix",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "MatrixNorms",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#MatrixNorms",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "MatrixNorms",
          "package": "vect",
          "partial": "Matrix Norms",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:MatrixNorms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "MultSemiGroup",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#MultSemiGroup",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "MultSemiGroup",
          "package": "vect",
          "partial": "Mult Semi Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:MultSemiGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe assumption when dealing with these is always that they are of unit length.\n Also, interpolation works differently.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Normal2",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Normal2",
          "type": "data"
        },
        "index": {
          "description": "The assumption when dealing with these is always that they are of unit length Also interpolation works differently",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Normal2",
          "package": "vect",
          "partial": "Normal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Normal2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Normal3",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Normal3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Normal3",
          "package": "vect",
          "partial": "Normal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Normal3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Normal4",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Normal4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Normal4",
          "package": "vect",
          "partial": "Normal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Normal4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrthogonal matrices.\n\u003c/p\u003e\u003cp\u003eNote: the \u003ca\u003eRandom\u003c/a\u003e instances generates orthogonal matrices with determinant 1\n (that is, orientation-preserving orthogonal transformations)!\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Ortho2",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Ortho2",
          "type": "data"
        },
        "index": {
          "description": "Orthogonal matrices Note the Random instances generates orthogonal matrices with determinant that is orientation-preserving orthogonal transformations",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Ortho2",
          "package": "vect",
          "partial": "Ortho",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Ortho2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Ortho3",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Ortho3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Ortho3",
          "package": "vect",
          "partial": "Ortho",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Ortho3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Ortho4",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Ortho4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Ortho4",
          "package": "vect",
          "partial": "Ortho",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Ortho4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Orthogonal",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Orthogonal",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Orthogonal",
          "package": "vect",
          "partial": "Orthogonal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Orthogonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePointwise multiplication \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Pointwise",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Pointwise",
          "type": "class"
        },
        "index": {
          "description": "Pointwise multiplication",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Pointwise",
          "package": "vect",
          "partial": "Pointwise",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Pointwise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjective matrices, encoding affine transformations in dimension one less.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Proj3",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Proj3",
          "type": "data"
        },
        "index": {
          "description": "Projective matrices encoding affine transformations in dimension one less",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Proj3",
          "package": "vect",
          "partial": "Proj",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Proj3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Proj4",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Proj4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Proj4",
          "package": "vect",
          "partial": "Proj",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Proj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\"Projective\" matrices have the following form: the top left corner\n is an any matrix, the bottom right corner is 1, and the top-right\n column is zero. These describe the affine orthogonal transformation of\n the space one dimension less.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Projective",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Projective",
          "type": "class"
        },
        "index": {
          "description": "Projective matrices have the following form the top left corner is an any matrix the bottom right corner is and the top-right column is zero These describe the affine orthogonal transformation of the space one dimension less",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Projective",
          "package": "vect",
          "partial": "Projective",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Projective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "RightModule",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#RightModule",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "RightModule",
          "package": "vect",
          "partial": "Right Module",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:RightModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Ring",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Ring",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Ring",
          "package": "vect",
          "partial": "Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Ring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOuter product (could be unified with Diagonal?)\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "Tensor",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Tensor",
          "type": "class"
        },
        "index": {
          "description": "Outer product could be unified with Diagonal",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Tensor",
          "package": "vect",
          "partial": "Tensor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Tensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "UnitVector",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#UnitVector",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "UnitVector",
          "package": "vect",
          "partial": "Unit Vector",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:UnitVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Vec2",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Vec2",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Vec2",
          "package": "vect",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Vec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Vec3",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Vec3",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Vec3",
          "package": "vect",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Vec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Vec4",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Vec4",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Vec4",
          "package": "vect",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Vec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Vector",
          "package": "vect",
          "source": "src/Data-Vect-Float-Base.html#Vector",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Vector",
          "package": "vect",
          "partial": "Vector",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(&!)",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#%26%21",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(&!) &!",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-38--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(&*)",
          "package": "vect",
          "signature": "v -\u003e Float -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#%26%2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(&*) &*",
          "normalized": "a-\u003eFloat-\u003ea",
          "package": "vect",
          "signature": "v-\u003eFloat-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-38--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(&+)",
          "package": "vect",
          "signature": "g -\u003e g -\u003e g",
          "source": "src/Data-Vect-Float-Base.html#%26%2B",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(&+) &+",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "g-\u003eg-\u003eg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-38--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(&-)",
          "package": "vect",
          "signature": "g -\u003e g -\u003e g",
          "source": "src/Data-Vect-Float-Base.html#%26-",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(&-) &-",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "g-\u003eg-\u003eg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-38--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(&^)",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#%26%5E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(&^) &^",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-38--94-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(&.)",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#%26.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(&.) &.",
          "normalized": "a-\u003ea-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003ev-\u003eFloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-38-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(*&)",
          "package": "vect",
          "signature": "Float -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#%2A%26",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(*&) *&",
          "normalized": "Float-\u003ea-\u003ea",
          "package": "vect",
          "signature": "Float-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-42--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(*.)",
          "package": "vect",
          "signature": "r -\u003e m -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#%2A.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(*.) *.",
          "normalized": "a-\u003eb-\u003eb",
          "package": "vect",
          "signature": "r-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(.*)",
          "package": "vect",
          "signature": "m -\u003e r -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#.%2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(.*) .*",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vect",
          "signature": "m-\u003er-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:.-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "(.*.)",
          "package": "vect",
          "signature": "r -\u003e r -\u003e r",
          "source": "src/Data-Vect-Float-Base.html#.%2A.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "(.*.) .*.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "r-\u003er-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:.-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Mat2",
          "package": "vect",
          "signature": "Mat2 !Vec2 !Vec2",
          "source": "src/Data-Vect-Float-Base.html#Mat2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Mat2",
          "package": "vect",
          "partial": "Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:Mat2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Mat3",
          "package": "vect",
          "signature": "Mat3 !Vec3 !Vec3 !Vec3",
          "source": "src/Data-Vect-Float-Base.html#Mat3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Mat3",
          "package": "vect",
          "partial": "Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:Mat3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Mat4",
          "package": "vect",
          "signature": "Mat4 !Vec4 !Vec4 !Vec4 !Vec4",
          "source": "src/Data-Vect-Float-Base.html#Mat4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Mat4",
          "package": "vect",
          "partial": "Mat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:Mat4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Vec2",
          "package": "vect",
          "signature": "Vec2 !Float !Float",
          "source": "src/Data-Vect-Float-Base.html#Vec2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Vec2",
          "package": "vect",
          "partial": "Vec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:Vec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Vec3",
          "package": "vect",
          "signature": "Vec3 !Float !Float !Float",
          "source": "src/Data-Vect-Float-Base.html#Vec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Vec3",
          "package": "vect",
          "partial": "Vec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:Vec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "Vec4",
          "package": "vect",
          "signature": "Vec4 !Float !Float !Float !Float",
          "source": "src/Data-Vect-Float-Base.html#Vec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "Vec4",
          "package": "vect",
          "partial": "Vec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:Vec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "_1",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Float-Base.html#_1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "_1",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "_2",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Float-Base.html#_2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "_2",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "_3",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Float-Base.html#_3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "_3",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "_4",
          "package": "vect",
          "signature": "v -\u003e x",
          "source": "src/Data-Vect-Float-Base.html#_4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "_4",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe angle between two vectors\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "angle",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#angle",
          "type": "function"
        },
        "index": {
          "description": "the angle between two vectors",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "angle",
          "normalized": "a-\u003ea-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003ev-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:angle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe angle between two unit vectors\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "angle'",
          "package": "vect",
          "signature": "u -\u003e u -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#angle%27",
          "type": "function"
        },
        "index": {
          "description": "the angle between two unit vectors",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "angle'",
          "normalized": "a-\u003ea-\u003eFloat",
          "package": "vect",
          "signature": "u-\u003eu-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:angle-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "crossprod",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#crossprod",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "crossprod",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:crossprod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "det",
          "package": "vect",
          "signature": "m -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#det",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "det",
          "normalized": "a-\u003eFloat",
          "package": "vect",
          "signature": "m-\u003eFloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:det"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "diag",
          "package": "vect",
          "signature": "s -\u003e t",
          "source": "src/Data-Vect-Float-Base.html#diag",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "diag",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "s-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:diag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "dim",
          "package": "vect",
          "signature": "a -\u003e Int",
          "source": "src/Data-Vect-Float-Base.html#dim",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "dim",
          "normalized": "a-\u003eInt",
          "package": "vect",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:dim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "distance",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#distance",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "distance",
          "normalized": "a-\u003ea-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003ev-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:distance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "dotprod",
          "package": "vect",
          "signature": "v -\u003e v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#dotprod",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "dotprod",
          "normalized": "a-\u003ea-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003ev-\u003eFloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:dotprod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "extendWith",
          "package": "vect",
          "signature": "extendWith",
          "source": "src/Data-Vect-Float-Base.html#extendWith",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "extendWith",
          "package": "vect",
          "partial": "With",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:extendWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "extendZero",
          "package": "vect",
          "signature": "extendZero",
          "source": "src/Data-Vect-Float-Base.html#extendZero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "extendZero",
          "package": "vect",
          "partial": "Zero",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:extendZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSince unit vectors are not a group, we need a separate function.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "flipNormal",
          "package": "vect",
          "signature": "n -\u003e n",
          "source": "src/Data-Vect-Float-Base.html#flipNormal",
          "type": "function"
        },
        "index": {
          "description": "Since unit vectors are not group we need separate function",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "flipNormal",
          "normalized": "a-\u003ea",
          "package": "vect",
          "partial": "Normal",
          "signature": "n-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:flipNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "frobeniusNorm",
          "package": "vect",
          "signature": "frobeniusNorm",
          "source": "src/Data-Vect-Float-Base.html#frobeniusNorm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "frobeniusNorm",
          "package": "vect",
          "partial": "Norm",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:frobeniusNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "fromNormal",
          "package": "vect",
          "signature": "u -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#fromNormal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "fromNormal",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Normal",
          "signature": "u-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:fromNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "fromNormalRadius",
          "package": "vect",
          "signature": "Float -\u003e u -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#fromNormalRadius",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "fromNormalRadius",
          "normalized": "Float-\u003ea-\u003eb",
          "package": "vect",
          "partial": "Normal Radius",
          "signature": "Float-\u003eu-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:fromNormalRadius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "fromOrtho",
          "package": "vect",
          "signature": "o -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#fromOrtho",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "fromOrtho",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Ortho",
          "signature": "o-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:fromOrtho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "fromProjective",
          "package": "vect",
          "signature": "p -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#fromProjective",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "fromProjective",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Projective",
          "signature": "p-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:fromProjective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHouseholder matrix, see \u003ca\u003ehttp://en.wikipedia.org/wiki/Householder_transformation\u003c/a\u003e.  \n In plain words, it is the reflection to the hyperplane orthogonal to the input vector.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "householder",
          "package": "vect",
          "signature": "u -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#householder",
          "type": "function"
        },
        "index": {
          "description": "Householder matrix see http en.wikipedia.org wiki Householder transformation In plain words it is the reflection to the hyperplane orthogonal to the input vector",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "householder",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "u-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:householder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "householderOrtho",
          "package": "vect",
          "signature": "u -\u003e o",
          "source": "src/Data-Vect-Float-Base.html#householderOrtho",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "householderOrtho",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Ortho",
          "signature": "u-\u003eo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:householderOrtho"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "idmtx",
          "package": "vect",
          "signature": "m",
          "source": "src/Data-Vect-Float-Base.html#idmtx",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "idmtx",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:idmtx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "inverse",
          "package": "vect",
          "signature": "m -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#inverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "inverse",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "len",
          "package": "vect",
          "signature": "v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#len",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "len",
          "normalized": "a-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003eFloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:len"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "lensqr",
          "package": "vect",
          "signature": "v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#lensqr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "lensqr",
          "normalized": "a-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003eFloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:lensqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "linear",
          "package": "vect",
          "signature": "n -\u003e p",
          "source": "src/Data-Vect-Float-Base.html#linear",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "linear",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "n-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:linear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "lmul",
          "package": "vect",
          "signature": "r -\u003e m -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#lmul",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "lmul",
          "normalized": "a-\u003eb-\u003eb",
          "package": "vect",
          "signature": "r-\u003em-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:lmul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "mapVec",
          "package": "vect",
          "signature": "(Float -\u003e Float) -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#mapVec",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "mapVec",
          "normalized": "(Float-\u003eFloat)-\u003ea-\u003ea",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Float-\u003eFloat)-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:mapVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "matrixDistance",
          "package": "vect",
          "signature": "matrixDistance",
          "source": "src/Data-Vect-Float-Base.html#matrixDistance",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "matrixDistance",
          "package": "vect",
          "partial": "Distance",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:matrixDistance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "mkNormal",
          "package": "vect",
          "signature": "mkNormal",
          "source": "src/Data-Vect-Float-Base.html#mkNormal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "mkNormal",
          "package": "vect",
          "partial": "Normal",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:mkNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "mkVec2",
          "package": "vect",
          "signature": "(Float, Float) -\u003e Vec2",
          "source": "src/Data-Vect-Float-Base.html#mkVec2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "mkVec2",
          "normalized": "(Float,Float)-\u003eVec",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Float,Float)-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:mkVec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "mkVec3",
          "package": "vect",
          "signature": "(Float, Float, Float) -\u003e Vec3",
          "source": "src/Data-Vect-Float-Base.html#mkVec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "mkVec3",
          "normalized": "(Float,Float,Float)-\u003eVec",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Float,Float,Float)-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:mkVec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "mkVec4",
          "package": "vect",
          "signature": "(Float, Float, Float, Float) -\u003e Vec4",
          "source": "src/Data-Vect-Float-Base.html#mkVec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "mkVec4",
          "normalized": "(Float,Float,Float,Float)-\u003eVec",
          "package": "vect",
          "partial": "Vec",
          "signature": "(Float,Float,Float,Float)-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:mkVec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "neg",
          "package": "vect",
          "signature": "g -\u003e g",
          "source": "src/Data-Vect-Float-Base.html#neg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "neg",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "g-\u003eg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "norm",
          "package": "vect",
          "signature": "v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#norm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "norm",
          "normalized": "a-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003eFloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "normalize",
          "package": "vect",
          "signature": "v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#normalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "normalize",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "normsqr",
          "package": "vect",
          "signature": "v -\u003e Float",
          "source": "src/Data-Vect-Float-Base.html#normsqr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "normsqr",
          "normalized": "a-\u003eFloat",
          "package": "vect",
          "signature": "v-\u003eFloat",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:normsqr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "one",
          "package": "vect",
          "signature": "r",
          "source": "src/Data-Vect-Float-Base.html#one",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "one",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "operatorNorm",
          "package": "vect",
          "signature": "operatorNorm",
          "source": "src/Data-Vect-Float-Base.html#operatorNorm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "operatorNorm",
          "package": "vect",
          "partial": "Norm",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:operatorNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "orthogonal",
          "package": "vect",
          "signature": "o -\u003e p",
          "source": "src/Data-Vect-Float-Base.html#orthogonal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "orthogonal",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "o-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:orthogonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "outer",
          "package": "vect",
          "signature": "v -\u003e v -\u003e t",
          "source": "src/Data-Vect-Float-Base.html#outer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "outer",
          "normalized": "a-\u003ea-\u003eb",
          "package": "vect",
          "signature": "v-\u003ev-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:outer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "pointwise",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#pointwise",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "pointwise",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:pointwise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "project",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#project",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "project",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "signature": "v-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProjects the first vector down to the hyperplane orthogonal to the second (unit) vector\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "project'",
          "package": "vect",
          "signature": "v -\u003e u -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#project%27",
          "type": "function"
        },
        "index": {
          "description": "Projects the first vector down to the hyperplane orthogonal to the second unit vector",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "project'",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vect",
          "signature": "v-\u003eu-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:project-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirection (second argument) is assumed to be a \u003cem\u003eunit\u003c/em\u003e vector!\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Base",
          "name": "projectUnsafe",
          "package": "vect",
          "signature": "v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#projectUnsafe",
          "type": "function"
        },
        "index": {
          "description": "Direction second argument is assumed to be unit vector",
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "projectUnsafe",
          "normalized": "a-\u003ea-\u003ea",
          "package": "vect",
          "partial": "Unsafe",
          "signature": "v-\u003ev-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:projectUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "rmul",
          "package": "vect",
          "signature": "m -\u003e r -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#rmul",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "rmul",
          "normalized": "a-\u003eb-\u003ea",
          "package": "vect",
          "signature": "m-\u003er-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:rmul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "scalarMul",
          "package": "vect",
          "signature": "Float -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Base.html#scalarMul",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "scalarMul",
          "normalized": "Float-\u003ea-\u003ea",
          "package": "vect",
          "partial": "Mul",
          "signature": "Float-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:scalarMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "scaling",
          "package": "vect",
          "signature": "v -\u003e p",
          "source": "src/Data-Vect-Float-Base.html#scaling",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "scaling",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:scaling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "semigroupProduct",
          "package": "vect",
          "signature": "[r] -\u003e r",
          "source": "src/Data-Vect-Float-Base.html#semigroupProduct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "semigroupProduct",
          "normalized": "[a]-\u003ea",
          "package": "vect",
          "partial": "Product",
          "signature": "[r]-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:semigroupProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "toNormalUnsafe",
          "package": "vect",
          "signature": "toNormalUnsafe",
          "source": "src/Data-Vect-Float-Base.html#toNormalUnsafe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "toNormalUnsafe",
          "package": "vect",
          "partial": "Normal Unsafe",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:toNormalUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "toOrthoUnsafe",
          "package": "vect",
          "signature": "m -\u003e o",
          "source": "src/Data-Vect-Float-Base.html#toOrthoUnsafe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "toOrthoUnsafe",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Ortho Unsafe",
          "signature": "m-\u003eo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:toOrthoUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "toProjectiveUnsafe",
          "package": "vect",
          "signature": "m -\u003e p",
          "source": "src/Data-Vect-Float-Base.html#toProjectiveUnsafe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "toProjectiveUnsafe",
          "normalized": "a-\u003eb",
          "package": "vect",
          "partial": "Projective Unsafe",
          "signature": "m-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:toProjectiveUnsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "translation",
          "package": "vect",
          "signature": "v -\u003e p",
          "source": "src/Data-Vect-Float-Base.html#translation",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "translation",
          "normalized": "a-\u003eb",
          "package": "vect",
          "signature": "v-\u003ep",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:translation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "transpose",
          "package": "vect",
          "signature": "m -\u003e m",
          "source": "src/Data-Vect-Float-Base.html#transpose",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "transpose",
          "normalized": "a-\u003ea",
          "package": "vect",
          "signature": "m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "trim",
          "package": "vect",
          "signature": "trim",
          "source": "src/Data-Vect-Float-Base.html#trim",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "trim",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:trim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "vecSum",
          "package": "vect",
          "signature": "[g] -\u003e g",
          "source": "src/Data-Vect-Float-Base.html#vecSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "vecSum",
          "normalized": "[a]-\u003ea",
          "package": "vect",
          "partial": "Sum",
          "signature": "[g]-\u003eg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:vecSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Base",
          "name": "zero",
          "package": "vect",
          "signature": "g",
          "source": "src/Data-Vect-Float-Base.html#zero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Base",
          "module": "Data.Vect.Float.Base",
          "name": "zero",
          "package": "vect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Base.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGram-Schmidt orthogonalization.\n This module is not re-exported by \u003ca\u003eData.Vect\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "source": "src/Data-Vect-Float-GramSchmidt.html",
          "type": "module"
        },
        "index": {
          "description": "Gram-Schmidt orthogonalization This module is not re-exported by Data.Vect",
          "hierarchy": "Data Vect Float GramSchmidt",
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "partial": "Gram Schmidt",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-GramSchmidt.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eproduces orthogonal/orthonormal vectors from a set of vectors    \n\u003c/p\u003e",
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "source": "src/Data-Vect-Float-GramSchmidt.html#GramSchmidt",
          "type": "class"
        },
        "index": {
          "description": "produces orthogonal orthonormal vectors from set of vectors",
          "hierarchy": "Data Vect Float GramSchmidt",
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "GramSchmidt",
          "package": "vect",
          "partial": "Gram Schmidt",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-GramSchmidt.html#t:GramSchmidt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "gramSchmidt",
          "package": "vect",
          "signature": "gramSchmidt",
          "source": "src/Data-Vect-Float-GramSchmidt.html#gramSchmidt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float GramSchmidt",
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "gramSchmidt",
          "package": "vect",
          "partial": "Schmidt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-GramSchmidt.html#v:gramSchmidt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "gramSchmidtNormalize",
          "package": "vect",
          "signature": "gramSchmidtNormalize",
          "source": "src/Data-Vect-Float-GramSchmidt.html#gramSchmidtNormalize",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float GramSchmidt",
          "module": "Data.Vect.Float.GramSchmidt",
          "name": "gramSchmidtNormalize",
          "package": "vect",
          "partial": "Schmidt Normalize",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-GramSchmidt.html#v:gramSchmidtNormalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e instances for vectors and matrices.\n These make writing code much more convenient, but also much more \n dangerous; thus you have to import this module explicitely.\n\u003c/p\u003e\u003cp\u003eIn the case of Vector instances, all operations are pointwise\n (including multiplication and division), and scalars are implicitly\n converted to vectors so that all components of the resulting vectors\n are the equal to the given scalar. This gives a set of consistent\n instances.\n\u003c/p\u003e\u003cp\u003eIn the case of Matrices, multiplication is usual matrix multiplication,\n division is not implemented, and scalars are converted to diagonal \n matrices.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e are implemented to be \u003ccode\u003e\u003ca\u003enormalize\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003enorm\u003c/a\u003e\u003c/code\u003e\n (in the case of matrices, Frobenius norm).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Float.Instances",
          "name": "Instances",
          "package": "vect",
          "source": "src/Data-Vect-Float-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "Eq Num and Fractional instances for vectors and matrices These make writing code much more convenient but also much more dangerous thus you have to import this module explicitely In the case of Vector instances all operations are pointwise including multiplication and division and scalars are implicitly converted to vectors so that all components of the resulting vectors are the equal to the given scalar This gives set of consistent instances In the case of Matrices multiplication is usual matrix multiplication division is not implemented and scalars are converted to diagonal matrices abs and signum are implemented to be normalize and norm in the case of matrices Frobenius norm",
          "hierarchy": "Data Vect Float Instances",
          "module": "Data.Vect.Float.Instances",
          "name": "Instances",
          "package": "vect",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterpolation of vectors. \n Note: we interpolate unit vectors differently from ordinary vectors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Float.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "source": "src/Data-Vect-Float-Interpolate.html",
          "type": "module"
        },
        "index": {
          "description": "Interpolation of vectors Note we interpolate unit vectors differently from ordinary vectors",
          "hierarchy": "Data Vect Float Interpolate",
          "module": "Data.Vect.Float.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "partial": "Interpolate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Interpolate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "source": "src/Data-Vect-Float-Interpolate.html#Interpolate",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Vect Float Interpolate",
          "module": "Data.Vect.Float.Interpolate",
          "name": "Interpolate",
          "package": "vect",
          "partial": "Interpolate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Interpolate.html#t:Interpolate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Interpolate",
          "name": "interpolate",
          "package": "vect",
          "signature": "Float -\u003e v -\u003e v -\u003e v",
          "source": "src/Data-Vect-Float-Interpolate.html#interpolate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Vect Float Interpolate",
          "module": "Data.Vect.Float.Interpolate",
          "name": "interpolate",
          "normalized": "Float-\u003ea-\u003ea-\u003ea",
          "package": "vect",
          "signature": "Float-\u003ev-\u003ev-\u003ev",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Interpolate.html#v:interpolate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpherical linear interpolation.\n See \u003ca\u003ehttp://en.wikipedia.org/wiki/Slerp\u003c/a\u003e    \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Interpolate",
          "name": "slerp",
          "package": "vect",
          "signature": "Float -\u003e u -\u003e u -\u003e u",
          "source": "src/Data-Vect-Float-Interpolate.html#slerp",
          "type": "function"
        },
        "index": {
          "description": "Spherical linear interpolation See http en.wikipedia.org wiki Slerp",
          "hierarchy": "Data Vect Float Interpolate",
          "module": "Data.Vect.Float.Interpolate",
          "name": "slerp",
          "normalized": "Float-\u003ea-\u003ea-\u003ea",
          "package": "vect",
          "signature": "Float-\u003eu-\u003eu-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Interpolate.html#v:slerp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "Dim2",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Dim2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "Dim2",
          "package": "vect",
          "partial": "Dim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe angle relative to the positive X axis\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "angle2",
          "package": "vect",
          "signature": "Vec2 -\u003e Float",
          "source": "src/Data-Vect-Float-Util-Dim2.html#angle2",
          "type": "function"
        },
        "index": {
          "description": "The angle relative to the positive axis",
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "angle2",
          "normalized": "Vec-\u003eFloat",
          "package": "vect",
          "signature": "Vec-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:angle2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "angle2'",
          "package": "vect",
          "signature": "Normal2 -\u003e Float",
          "source": "src/Data-Vect-Float-Util-Dim2.html#angle2%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "angle2'",
          "normalized": "Normal-\u003eFloat",
          "package": "vect",
          "signature": "Normal-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:angle2-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe opposite of \u003ca\u003estructVec2\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "destructVec2",
          "package": "vect",
          "signature": "[Vec2] -\u003e [Float]",
          "source": "src/Data-Vect-Float-Util-Dim2.html#destructVec2",
          "type": "function"
        },
        "index": {
          "description": "The opposite of structVec2",
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "destructVec2",
          "normalized": "[Vec]-\u003e[Float]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Vec]-\u003e[Float]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:destructVec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "det2",
          "package": "vect",
          "signature": "Vec2 -\u003e Vec2 -\u003e Float",
          "source": "src/Data-Vect-Float-Util-Dim2.html#det2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "det2",
          "normalized": "Vec-\u003eVec-\u003eFloat",
          "package": "vect",
          "signature": "Vec-\u003eVec-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:det2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation matrix by a given angle (in radians), counterclockwise.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotMatrix2",
          "package": "vect",
          "signature": "Float -\u003e Mat2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#rotMatrix2",
          "type": "function"
        },
        "index": {
          "description": "Rotation matrix by given angle in radians counterclockwise",
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotMatrix2",
          "normalized": "Float-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Float-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:rotMatrix2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotMatrixOrtho2",
          "package": "vect",
          "signature": "Float -\u003e Ortho2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#rotMatrixOrtho2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotMatrixOrtho2",
          "normalized": "Float-\u003eOrtho",
          "package": "vect",
          "partial": "Matrix Ortho",
          "signature": "Float-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:rotMatrixOrtho2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotate2",
          "package": "vect",
          "signature": "Float -\u003e Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#rotate2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotate2",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:rotate2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotates counterclockwise by 90 degrees.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotateCCW",
          "package": "vect",
          "signature": "Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#rotateCCW",
          "type": "function"
        },
        "index": {
          "description": "Rotates counterclockwise by degrees",
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotateCCW",
          "normalized": "Vec-\u003eVec",
          "package": "vect",
          "partial": "CCW",
          "signature": "Vec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:rotateCCW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotates clockwise by 90 degrees.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotateCW",
          "package": "vect",
          "signature": "Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#rotateCW",
          "type": "function"
        },
        "index": {
          "description": "Rotates clockwise by degrees",
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "rotateCW",
          "normalized": "Vec-\u003eVec",
          "package": "vect",
          "partial": "CW",
          "signature": "Vec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:rotateCW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunit vector with given angle relative to the positive X axis (in the positive direction, that is, CCW).\n A more precise name would be \u003ccode\u003ecosSin\u003c/code\u003e, but that sounds bad :)\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "sinCos",
          "package": "vect",
          "signature": "Float -\u003e Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#sinCos",
          "type": "function"
        },
        "index": {
          "description": "unit vector with given angle relative to the positive axis in the positive direction that is CCW more precise name would be cosSin but that sounds bad",
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "sinCos",
          "normalized": "Float-\u003eVec",
          "package": "vect",
          "partial": "Cos",
          "signature": "Float-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:sinCos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "sinCos'",
          "package": "vect",
          "signature": "Float -\u003e Normal2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#sinCos%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "sinCos'",
          "normalized": "Float-\u003eNormal",
          "package": "vect",
          "partial": "Cos'",
          "signature": "Float-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:sinCos-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "sinCosRadius",
          "package": "vect",
          "signature": "Float-\u003e Float-\u003e Vec2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "sinCosRadius",
          "normalized": "Float-\u003eFloat-\u003eVec",
          "package": "vect",
          "partial": "Cos Radius",
          "signature": "Float-\u003eFloat-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:sinCosRadius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample: \u003ccode\u003estructVec2 [1,2,3,4] = [ Vec2 1 2 , Vec2 3 4 ]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "structVec2",
          "package": "vect",
          "signature": "[Float] -\u003e [Vec2]",
          "source": "src/Data-Vect-Float-Util-Dim2.html#structVec2",
          "type": "function"
        },
        "index": {
          "description": "Example structVec2 Vec2 Vec2",
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "structVec2",
          "normalized": "[Float]-\u003e[Vec]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Float]-\u003e[Vec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:structVec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "translate2X",
          "package": "vect",
          "signature": "Float -\u003e Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#translate2X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "translate2X",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:translate2X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "translate2Y",
          "package": "vect",
          "signature": "Float -\u003e Vec2 -\u003e Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#translate2Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "translate2Y",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:translate2Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "vec2X",
          "package": "vect",
          "signature": "Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#vec2X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "vec2X",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:vec2X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "vec2Y",
          "package": "vect",
          "signature": "Vec2",
          "source": "src/Data-Vect-Float-Util-Dim2.html#vec2Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim2",
          "module": "Data.Vect.Float.Util.Dim2",
          "name": "vec2Y",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim2.html#v:vec2Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "Dim3",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Dim3.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "Dim3",
          "package": "vect",
          "partial": "Dim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe opposite of \u003ca\u003estructVec3\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "destructVec3",
          "package": "vect",
          "signature": "[Vec3] -\u003e [Float]",
          "source": "src/Data-Vect-Float-Util-Dim3.html#destructVec3",
          "type": "function"
        },
        "index": {
          "description": "The opposite of structVec3",
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "destructVec3",
          "normalized": "[Vec]-\u003e[Float]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Vec]-\u003e[Float]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:destructVec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "det3",
          "package": "vect",
          "signature": "Vec3 -\u003e Vec3 -\u003e Vec3 -\u003e Float",
          "source": "src/Data-Vect-Float-Util-Dim3.html#det3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "det3",
          "normalized": "Vec-\u003eVec-\u003eVec-\u003eFloat",
          "package": "vect",
          "signature": "Vec-\u003eVec-\u003eVec-\u003eFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:det3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReflects a vector to an axis: that is, the result of \u003ccode\u003ereflect n v\u003c/code\u003e is\n 2\u003cn,v\u003en - v\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "reflect",
          "package": "vect",
          "signature": "Normal3 -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#reflect",
          "type": "function"
        },
        "index": {
          "description": "Reflects vector to an axis that is the result of reflect is",
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "reflect",
          "normalized": "Normal-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Normal-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:reflect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "reflect'",
          "package": "vect",
          "signature": "Normal3 -\u003e Normal3 -\u003e Normal3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#reflect%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "reflect'",
          "normalized": "Normal-\u003eNormal-\u003eNormal",
          "package": "vect",
          "signature": "Normal-\u003eNormal-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:reflect-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "refract",
          "package": "vect",
          "signature": "Float -\u003e Normal3 -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#refract",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "refract",
          "normalized": "Float-\u003eNormal-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eNormal-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:refract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRefraction.\n First parameter (\u003ccode\u003eeta\u003c/code\u003e) is the relative refraction index \n\u003c/p\u003e\u003cpre\u003e        refl_inside\n eta = --------------\n        refl_outside\n\u003c/pre\u003e\u003cp\u003ewhere \"inside\" is the direction of the second argument \n (to vector normal to plane which models the boundary \n between the two materials). That is, total internal reflection\n can occur when \u003ccode\u003eeta\u003e1\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe convention is that the origin is the point of intersection\n of the ray and the surface, and all the vectors \"point away\"\n from here (unlike, say, GLSL's \u003ccode\u003erefract\u003c/code\u003e, where the incident\n vector \"points towards\" the material)\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "refract'",
          "package": "vect",
          "signature": "Float -\u003e Normal3 -\u003e Normal3 -\u003e Normal3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#refract%27",
          "type": "function"
        },
        "index": {
          "description": "Refraction First parameter eta is the relative refraction index refl inside eta refl outside where inside is the direction of the second argument to vector normal to plane which models the boundary between the two materials That is total internal reflection can occur when eta The convention is that the origin is the point of intersection of the ray and the surface and all the vectors point away from here unlike say GLSL refract where the incident vector points towards the material",
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "refract'",
          "normalized": "Float-\u003eNormal-\u003eNormal-\u003eNormal",
          "package": "vect",
          "signature": "Float-\u003eNormal-\u003eNormal-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:refract-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen total internal reflection would occur, we return \u003ca\u003eNothing\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "refractOnly'",
          "package": "vect",
          "signature": "Float -\u003e Normal3 -\u003e Normal3 -\u003e Maybe Normal3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#refractOnly%27",
          "type": "function"
        },
        "index": {
          "description": "When total internal reflection would occur we return Nothing",
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "refractOnly'",
          "normalized": "Float-\u003eNormal-\u003eNormal-\u003eMaybe Normal",
          "package": "vect",
          "partial": "Only'",
          "signature": "Float-\u003eNormal-\u003eNormal-\u003eMaybe Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:refractOnly-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation around an arbitrary 3D vector. The resulting 3x3 matrix is intended for multiplication on the \u003cem\u003eright\u003c/em\u003e. \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrix3",
          "package": "vect",
          "signature": "Vec3 -\u003e Float -\u003e Mat3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#rotMatrix3",
          "type": "function"
        },
        "index": {
          "description": "Rotation around an arbitrary vector The resulting x3 matrix is intended for multiplication on the right",
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrix3",
          "normalized": "Vec-\u003eFloat-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Vec-\u003eFloat-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotMatrix3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation around an arbitrary 3D \u003cem\u003eunit\u003c/em\u003e vector. The resulting 3x3 matrix is intended for multiplication on the \u003cem\u003eright\u003c/em\u003e. \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrix3'",
          "package": "vect",
          "signature": "Normal3 -\u003e Float -\u003e Mat3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#rotMatrix3%27",
          "type": "function"
        },
        "index": {
          "description": "Rotation around an arbitrary unit vector The resulting x3 matrix is intended for multiplication on the right",
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrix3'",
          "normalized": "Normal-\u003eFloat-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Normal-\u003eFloat-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotMatrix3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixOrtho3",
          "package": "vect",
          "signature": "Vec3 -\u003e Float -\u003e Ortho3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#rotMatrixOrtho3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixOrtho3",
          "normalized": "Vec-\u003eFloat-\u003eOrtho",
          "package": "vect",
          "partial": "Matrix Ortho",
          "signature": "Vec-\u003eFloat-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotMatrixOrtho3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixOrtho3'",
          "package": "vect",
          "signature": "Normal3 -\u003e Float -\u003e Ortho3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#rotMatrixOrtho3%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixOrtho3'",
          "normalized": "Normal-\u003eFloat-\u003eOrtho",
          "package": "vect",
          "partial": "Matrix Ortho",
          "signature": "Normal-\u003eFloat-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotMatrixOrtho3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixX",
          "package": "vect",
          "signature": "Float -\u003e Mat3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#rotMatrixX",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixX",
          "normalized": "Float-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Float-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotMatrixX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixY",
          "package": "vect",
          "signature": "Float -\u003e Mat3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#rotMatrixY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixY",
          "normalized": "Float-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Float-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotMatrixY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixZ",
          "package": "vect",
          "signature": "Float -\u003e Mat3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#rotMatrixZ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotMatrixZ",
          "normalized": "Float-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Float-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotMatrixZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotate3",
          "package": "vect",
          "signature": "Float-\u003e Vec3-\u003e Vec3-\u003e Vec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotate3",
          "normalized": "Float-\u003eVec-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotate3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotate3'",
          "package": "vect",
          "signature": "Float-\u003e Normal3-\u003e Vec3-\u003e Vec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "rotate3'",
          "normalized": "Float-\u003eNormal-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eNormal-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:rotate3-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample: \u003ccode\u003estructVec3 [1,2,3,4,5,6] = [ Vec3 1 2 3 , Vec3 4 5 6]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "structVec3",
          "package": "vect",
          "signature": "[Float] -\u003e [Vec3]",
          "source": "src/Data-Vect-Float-Util-Dim3.html#structVec3",
          "type": "function"
        },
        "index": {
          "description": "Example structVec3 Vec3 Vec3",
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "structVec3",
          "normalized": "[Float]-\u003e[Vec]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Float]-\u003e[Vec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:structVec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "translate3X",
          "package": "vect",
          "signature": "Float -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#translate3X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "translate3X",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:translate3X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "translate3Y",
          "package": "vect",
          "signature": "Float -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#translate3Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "translate3Y",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:translate3Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "translate3Z",
          "package": "vect",
          "signature": "Float -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#translate3Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "translate3Z",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:translate3Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "vec3X",
          "package": "vect",
          "signature": "Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#vec3X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "vec3X",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:vec3X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "vec3Y",
          "package": "vect",
          "signature": "Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#vec3Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "vec3Y",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:vec3Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "vec3Z",
          "package": "vect",
          "signature": "Vec3",
          "source": "src/Data-Vect-Float-Util-Dim3.html#vec3Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim3",
          "module": "Data.Vect.Float.Util.Dim3",
          "name": "vec3Z",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim3.html#v:vec3Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRotation around an arbitrary plane in four dimensions, and other miscellanea.\n Not very useful for most people, and not re-exported by \u003ca\u003eData.Vect\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "Dim4",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Dim4.html",
          "type": "module"
        },
        "index": {
          "description": "Rotation around an arbitrary plane in four dimensions and other miscellanea Not very useful for most people and not re-exported by Data.Vect",
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "Dim4",
          "package": "vect",
          "partial": "Dim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003e(x,y,u,v)\u003c/code\u003e is an orthonormal system, then (written in pseudo-code)\n \u003ccode\u003ebiVector4 (x,y) = plusMinus (reverse $ biVector4 (u,v))\u003c/code\u003e.\n This is a helper function for the 4 dimensional rotation code.\n If \u003ccode\u003e(x,y,z,p,q,r) = biVector4 a b\u003c/code\u003e, then the corresponding antisymmetric tensor is\n\u003c/p\u003e\u003cpre\u003e [  0  r  q  p ]\n [ -r  0  z -y ]\n [ -q -z  0  x ]\n [ -p  y -x  0 ]\n\u003c/pre\u003e",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "biVector4",
          "package": "vect",
          "signature": "Vec4 -\u003e Vec4 -\u003e (Float, Float, Float, Float, Float, Float)",
          "source": "src/Data-Vect-Float-Util-Dim4.html#biVector4",
          "type": "function"
        },
        "index": {
          "description": "If is an orthonormal system then written in pseudo-code biVector4 plusMinus reverse biVector4 This is helper function for the dimensional rotation code If biVector4 then the corresponding antisymmetric tensor is",
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "biVector4",
          "normalized": "Vec-\u003eVec-\u003e(Float,Float,Float,Float,Float,Float)",
          "package": "vect",
          "partial": "Vector",
          "signature": "Vec-\u003eVec-\u003e(Float,Float,Float,Float,Float,Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:biVector4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe corresponding antisymmetric tensor\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "biVector4AsTensor",
          "package": "vect",
          "signature": "Vec4 -\u003e Vec4 -\u003e Mat4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#biVector4AsTensor",
          "type": "function"
        },
        "index": {
          "description": "the corresponding antisymmetric tensor",
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "biVector4AsTensor",
          "normalized": "Vec-\u003eVec-\u003eMat",
          "package": "vect",
          "partial": "Vector As Tensor",
          "signature": "Vec-\u003eVec-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:biVector4AsTensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "destructVec4",
          "package": "vect",
          "signature": "[Vec4] -\u003e [Float]",
          "source": "src/Data-Vect-Float-Util-Dim4.html#destructVec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "destructVec4",
          "normalized": "[Vec]-\u003e[Float]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Vec]-\u003e[Float]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:destructVec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe assume only that the axes are independent vectors.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotMatrix4",
          "package": "vect",
          "signature": "Float -\u003e (Vec4, Vec4) -\u003e Mat4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#rotMatrix4",
          "type": "function"
        },
        "index": {
          "description": "We assume only that the axes are independent vectors",
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotMatrix4",
          "normalized": "Float-\u003e(Vec,Vec)-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Float-\u003e(Vec,Vec)-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:rotMatrix4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotation matrix around a plane specified by two normalized and \u003cem\u003eorthogonal\u003c/em\u003e vectors.\n Intended for multiplication on the \u003cem\u003eright\u003c/em\u003e!\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotMatrix4'",
          "package": "vect",
          "signature": "Float -\u003e (Normal4, Normal4) -\u003e Mat4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#rotMatrix4%27",
          "type": "function"
        },
        "index": {
          "description": "Rotation matrix around plane specified by two normalized and orthogonal vectors Intended for multiplication on the right",
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotMatrix4'",
          "normalized": "Float-\u003e(Normal,Normal)-\u003eMat",
          "package": "vect",
          "partial": "Matrix",
          "signature": "Float-\u003e(Normal,Normal)-\u003eMat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:rotMatrix4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe assume only that the axes are independent vectors.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotate4",
          "package": "vect",
          "signature": "Float -\u003e (Vec4, Vec4) -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#rotate4",
          "type": "function"
        },
        "index": {
          "description": "We assume only that the axes are independent vectors",
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotate4",
          "normalized": "Float-\u003e(Vec,Vec)-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003e(Vec,Vec)-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:rotate4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe assume that the axes are normalized and \u003cem\u003eorthogonal\u003c/em\u003e to each other!\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotate4'",
          "package": "vect",
          "signature": "Float -\u003e (Normal4, Normal4) -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#rotate4%27",
          "type": "function"
        },
        "index": {
          "description": "We assume that the axes are normalized and orthogonal to each other",
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "rotate4'",
          "normalized": "Float-\u003e(Normal,Normal)-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003e(Normal,Normal)-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:rotate4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "structVec4",
          "package": "vect",
          "signature": "[Float] -\u003e [Vec4]",
          "source": "src/Data-Vect-Float-Util-Dim4.html#structVec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "structVec4",
          "normalized": "[Float]-\u003e[Vec]",
          "package": "vect",
          "partial": "Vec",
          "signature": "[Float]-\u003e[Vec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:structVec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4W",
          "package": "vect",
          "signature": "Float -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#translate4W",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4W",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:translate4W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4X",
          "package": "vect",
          "signature": "Float -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#translate4X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4X",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:translate4X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4Y",
          "package": "vect",
          "signature": "Float -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#translate4Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4Y",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:translate4Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4Z",
          "package": "vect",
          "signature": "Float -\u003e Vec4 -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#translate4Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "translate4Z",
          "normalized": "Float-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "Float-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:translate4Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4W",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#vec4W",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4W",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:vec4W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4X",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#vec4X",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4X",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:vec4X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4Y",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#vec4Y",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4Y",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:vec4Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4Z",
          "package": "vect",
          "signature": "Vec4",
          "source": "src/Data-Vect-Float-Util-Dim4.html#vec4Z",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Dim4",
          "module": "Data.Vect.Float.Util.Dim4",
          "name": "vec4Z",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Dim4.html#v:vec4Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClassic 4x4 projective matrices, encoding the affine transformations of R^3.\n Our convention is that they are intended for multiplication on\n the \u003cem\u003eright\u003c/em\u003e, that is, they are of the form\n\u003c/p\u003e\u003cpre\u003e     _____\n [  |     |  0  ]\n [  | 3x3 |  0  ]\n [  |_____|  0  ]\n [  p  q  r  1  ]\n\u003c/pre\u003e\u003cp\u003ePlease note that by default, OpenGL stores the matrices (in memory) by columns, while we \n store them by rows; but OpenGL also use the opposite convention (so the OpenGL projective matrices \n are intended for multiplication on the \u003cem\u003eleft\u003c/em\u003e). So in effect, they are the same when stored in the memory,\n say with \u003ccode\u003epoke :: Ptr Mat4 -\u003e Mat4 -\u003e IO ()\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWarning: The naming conventions will probably change in the future.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "Projective",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Projective.html",
          "type": "module"
        },
        "index": {
          "description": "Classic x4 projective matrices encoding the affine transformations of Our convention is that they are intended for multiplication on the right that is they are of the form x3 Please note that by default OpenGL stores the matrices in memory by columns while we store them by rows but OpenGL also use the opposite convention so the OpenGL projective matrices are intended for multiplication on the left So in effect they are the same when stored in the memory say with poke Ptr Mat4 Mat4 IO Warning The naming conventions will probably change in the future",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "Projective",
          "package": "vect",
          "partial": "Projective",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotMatrixProj4",
          "package": "vect",
          "signature": "Float -\u003e Vec3 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#rotMatrixProj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotMatrixProj4",
          "normalized": "Float-\u003eVec-\u003eProj",
          "package": "vect",
          "partial": "Matrix Proj",
          "signature": "Float-\u003eVec-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:rotMatrixProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotMatrixProj4'",
          "package": "vect",
          "signature": "Float -\u003e Normal3 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#rotMatrixProj4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotMatrixProj4'",
          "normalized": "Float-\u003eNormal-\u003eProj",
          "package": "vect",
          "partial": "Matrix Proj",
          "signature": "Float-\u003eNormal-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:rotMatrixProj4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003em -\u003e m .*. rotMatrixProj4 angle axis\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotateAfterProj4",
          "package": "vect",
          "signature": "Float -\u003e Normal3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#rotateAfterProj4",
          "type": "function"
        },
        "index": {
          "description": "Synonym for rotMatrixProj4 angle axis",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotateAfterProj4",
          "normalized": "Float-\u003eNormal-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "After Proj",
          "signature": "Float-\u003eNormal-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:rotateAfterProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ccode\u003em -\u003e rotMatrixProj4 angle axis .*. m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotateBeforeProj4",
          "package": "vect",
          "signature": "Float -\u003e Normal3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#rotateBeforeProj4",
          "type": "function"
        },
        "index": {
          "description": "Synonym for rotMatrixProj4 angle axis",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotateBeforeProj4",
          "normalized": "Float-\u003eNormal-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Before Proj",
          "signature": "Float-\u003eNormal-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:rotateBeforeProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esynonym for \u003ca\u003erotateAfterProj4\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotateProj4",
          "package": "vect",
          "signature": "Float -\u003e Normal3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#rotateProj4",
          "type": "function"
        },
        "index": {
          "description": "synonym for rotateAfterProj4",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "rotateProj4",
          "normalized": "Float-\u003eNormal-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Proj",
          "signature": "Float-\u003eNormal-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:rotateProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e m .*. scaling v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "scaleAfterProj4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#scaleAfterProj4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to scaling",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "scaleAfterProj4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "After Proj",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:scaleAfterProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e scaling v .*. m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "scaleBeforeProj4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#scaleBeforeProj4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to scaling",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "scaleBeforeProj4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Before Proj",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:scaleBeforeProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Projective",
          "name": "scalingUniformProj4",
          "package": "vect",
          "signature": "Float -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#scalingUniformProj4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "scalingUniformProj4",
          "normalized": "Float-\u003eProj",
          "package": "vect",
          "partial": "Uniform Proj",
          "signature": "Float-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:scalingUniformProj4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for \u003ca\u003etranslateAfter4\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "translate4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#translate4",
          "type": "function"
        },
        "index": {
          "description": "Synonym for translateAfter4",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "translate4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:translate4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e m .*. translation v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "translateAfter4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#translateAfter4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to translation",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "translateAfter4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "After",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:translateAfter4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to \u003ccode\u003em -\u003e translation v .*. m\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "translateBefore4",
          "package": "vect",
          "signature": "Vec3 -\u003e Proj4 -\u003e Proj4",
          "source": "src/Data-Vect-Float-Util-Projective.html#translateBefore4",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to translation",
          "hierarchy": "Data Vect Float Util Projective",
          "module": "Data.Vect.Float.Util.Projective",
          "name": "translateBefore4",
          "normalized": "Vec-\u003eProj-\u003eProj",
          "package": "vect",
          "partial": "Before",
          "signature": "Vec-\u003eProj-\u003eProj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Projective.html#v:translateBefore4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe unit sphere in the space of quaternions has the group structure\n SU(2) coming from the quaternion multiplication, which is the double\n cover of the group SO(3) of rotations in R^3. Thus, unit quaternions can\n be used to encode rotations in 3D, which is a more compact encoding \n (4 floats) than a 3x3 matrix; however, there are \u003cem\u003etwo\u003c/em\u003e quaternions\n corresponding to each rotation.\n\u003c/p\u003e\u003cp\u003eSee \u003ca\u003ehttp://en.wikipedia.org/wiki/Quaternion\u003c/a\u003e and \n \u003ca\u003ehttp://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation\u003c/a\u003e\n for more information.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Quaternion.html",
          "type": "module"
        },
        "index": {
          "description": "The unit sphere in the space of quaternions has the group structure SU coming from the quaternion multiplication which is the double cover of the group SO of rotations in Thus unit quaternions can be used to encode rotations in which is more compact encoding floats than x3 matrix however there are two quaternions corresponding to each rotation See http en.wikipedia.org wiki Quaternion and http en.wikipedia.org wiki Quaternions and spatial rotation for more information",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "partial": "Quaternion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abbreviated type synonym for quaternions\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#Q",
          "type": "type"
        },
        "index": {
          "description": "An abbreviated type synonym for quaternions",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#t:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type for quaternions. \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#Quaternion",
          "type": "newtype"
        },
        "index": {
          "description": "The type for quaternions",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Quaternion",
          "package": "vect",
          "partial": "Quaternion",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#t:Quaternion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abbreviated type synonym for unit quaternions\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#U",
          "type": "type"
        },
        "index": {
          "description": "An abbreviated type synonym for unit quaternions",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#t:U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type for unit quaternions. \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "UnitQuaternion",
          "package": "vect",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#UnitQuaternion",
          "type": "newtype"
        },
        "index": {
          "description": "The type for unit quaternions",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "UnitQuaternion",
          "package": "vect",
          "partial": "Unit Quaternion",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#t:UnitQuaternion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "signature": "Q Vec4",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#Quaternion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "Q",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:Q"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "signature": "U Vec4",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#UnitQuaternion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "U",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eleft\u003c/em\u003e action of unit quaternions on 3D vectors.\n That is,\n\u003c/p\u003e\u003cpre\u003e actU q1 $ actU q2 v  ==  actU (q1 `multU` q2) v \n\u003c/pre\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "actU",
          "package": "vect",
          "signature": "U -\u003e Vec3 -\u003e Vec3",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#actU",
          "type": "function"
        },
        "index": {
          "description": "The left action of unit quaternions on vectors That is actU q1 actU q2 actU q1 multU q2",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "actU",
          "normalized": "U-\u003eVec-\u003eVec",
          "package": "vect",
          "signature": "U-\u003eVec-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:actU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "fromQ",
          "package": "vect",
          "signature": "Q -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#fromQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "fromQ",
          "normalized": "Q-\u003eVec",
          "package": "vect",
          "signature": "Q-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:fromQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "fromU",
          "package": "vect",
          "signature": "U -\u003e Vec4",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#fromU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "fromU",
          "normalized": "U-\u003eVec",
          "package": "vect",
          "signature": "U-\u003eVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:fromU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "fromU'",
          "package": "vect",
          "signature": "U -\u003e Normal4",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#fromU%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "fromU'",
          "normalized": "U-\u003eNormal",
          "package": "vect",
          "partial": "U'",
          "signature": "U-\u003eNormal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:fromU-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse quaternion\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "invQ",
          "package": "vect",
          "signature": "Q -\u003e Q",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#invQ",
          "type": "function"
        },
        "index": {
          "description": "The inverse quaternion",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "invQ",
          "normalized": "Q-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:invQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse of a unit quaternion\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "invU",
          "package": "vect",
          "signature": "U -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#invU",
          "type": "function"
        },
        "index": {
          "description": "The inverse of unit quaternion",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "invU",
          "normalized": "U-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:invU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes a rotation matrix (to be multiplied with on the \u003cem\u003eleft\u003c/em\u003e) out of a unit quaternion.\n\u003c/p\u003e\u003cpre\u003e leftOrthoU (rotU axis angl) *. v  ==  v .* rotMatrix3 axis angl\n\u003c/pre\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "leftOrthoU",
          "package": "vect",
          "signature": "U -\u003e Ortho3",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#leftOrthoU",
          "type": "function"
        },
        "index": {
          "description": "Makes rotation matrix to be multiplied with on the left out of unit quaternion leftOrthoU rotU axis angl rotMatrix3 axis angl",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "leftOrthoU",
          "normalized": "U-\u003eOrtho",
          "package": "vect",
          "partial": "Ortho",
          "signature": "U-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:leftOrthoU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpolation of unit quaternions. Note that when applied to rotations,\n this may be not what you want, since it is possible that the shortest path\n in the space of unit quaternions is not the shortest path in the space of\n rotations; see \u003ccode\u003e\u003ca\u003eslerpU\u003c/a\u003e\u003c/code\u003e!\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "longSlerpU",
          "package": "vect",
          "signature": "Float -\u003e U -\u003e U -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#longSlerpU",
          "type": "function"
        },
        "index": {
          "description": "Interpolation of unit quaternions Note that when applied to rotations this may be not what you want since it is possible that the shortest path in the space of unit quaternions is not the shortest path in the space of rotations see slerpU",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "longSlerpU",
          "normalized": "Float-\u003eU-\u003eU-\u003eU",
          "package": "vect",
          "partial": "Slerp",
          "signature": "Float-\u003eU-\u003eU-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:longSlerpU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "mkU",
          "package": "vect",
          "signature": "Vec4 -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#mkU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "mkU",
          "normalized": "Vec-\u003eU",
          "package": "vect",
          "signature": "Vec-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:mkU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "multQ",
          "package": "vect",
          "signature": "Q -\u003e Q -\u003e Q",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#multQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "multQ",
          "normalized": "Q-\u003eQ-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:multQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "multU",
          "package": "vect",
          "signature": "U -\u003e U -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#multU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "multU",
          "normalized": "U-\u003eU-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:multU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "negQ",
          "package": "vect",
          "signature": "Q -\u003e Q",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#negQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "negQ",
          "normalized": "Q-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:negQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe opposite quaternion (which encodes the same rotation)\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "negU",
          "package": "vect",
          "signature": "U -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#negU",
          "type": "function"
        },
        "index": {
          "description": "The opposite quaternion which encodes the same rotation",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "negU",
          "normalized": "U-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:negU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "normalizeQ",
          "package": "vect",
          "signature": "Q -\u003e Q",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#normalizeQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "normalizeQ",
          "normalized": "Q-\u003eQ",
          "package": "vect",
          "signature": "Q-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:normalizeQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is no-op, up to numerical imprecision.\n However, if you multiply together a large number of unit quaternions, \n it may be a good idea to normalize the end result.\n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "normalizeU",
          "package": "vect",
          "signature": "U -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#normalizeU",
          "type": "function"
        },
        "index": {
          "description": "This is no-op up to numerical imprecision However if you multiply together large number of unit quaternions it may be good idea to normalize the end result",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "normalizeU",
          "normalized": "U-\u003eU",
          "package": "vect",
          "signature": "U-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:normalizeU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes a rotation matrix (to be multiplied with on the \u003cem\u003eright\u003c/em\u003e) out of a unit quaternion:\n\u003c/p\u003e\u003cpre\u003e v .* rightOrthoU (rotU axis angl)  ==  v .* rotMatrix3 axis angl\n\u003c/pre\u003e\u003cp\u003ePlease note that while these matrices act on the \u003cem\u003eright\u003c/em\u003e, quaternions act on the \u003cem\u003eleft\u003c/em\u003e; thus\n\u003c/p\u003e\u003cpre\u003e rightOrthoU q1 .*. rightOrthoU q2  ==  rightOrthoU (q2 .*. q1)\n\u003c/pre\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "rightOrthoU",
          "package": "vect",
          "signature": "U -\u003e Ortho3",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#rightOrthoU",
          "type": "function"
        },
        "index": {
          "description": "Makes rotation matrix to be multiplied with on the right out of unit quaternion rightOrthoU rotU axis angl rotMatrix3 axis angl Please note that while these matrices act on the right quaternions act on the left thus rightOrthoU q1 rightOrthoU q2 rightOrthoU q2 q1",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "rightOrthoU",
          "normalized": "U-\u003eOrtho",
          "package": "vect",
          "partial": "Ortho",
          "signature": "U-\u003eOrtho",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:rightOrthoU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe quaternion to encode rotation around an axis. Please note\n that quaternions act on the \u003cem\u003eleft\u003c/em\u003e, that is\n\u003c/p\u003e\u003cpre\u003e rotU axis1 angl1 *. rotU axis2 angl2 *. v  ==  (rotU axis1 angl1 .*. rotU axis2 angl2) *. v \n\u003c/pre\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "rotU",
          "package": "vect",
          "signature": "Vec3 -\u003e Float -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#rotU",
          "type": "function"
        },
        "index": {
          "description": "The quaternion to encode rotation around an axis Please note that quaternions act on the left that is rotU axis1 angl1 rotU axis2 angl2 rotU axis1 angl1 rotU axis2 angl2",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "rotU",
          "normalized": "Vec-\u003eFloat-\u003eU",
          "package": "vect",
          "signature": "Vec-\u003eFloat-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:rotU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "rotU'",
          "package": "vect",
          "signature": "Normal3 -\u003e Float -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#rotU%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "rotU'",
          "normalized": "Normal-\u003eFloat-\u003eU",
          "package": "vect",
          "partial": "U'",
          "signature": "Normal-\u003eFloat-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:rotU-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is shortest path interpolation in the space of rotations; however\n this is achieved by possibly flipping the first endpoint in the space of\n quaternions. Thus \u003ccode\u003eslerpU 0.001 q1 q2\u003c/code\u003e may be very far from \u003ccode\u003eq1\u003c/code\u003e (and very\n close to \u003ccode\u003enegU q1\u003c/code\u003e) in the space of quaternions (but they are very close\n in the space of rotations). \n\u003c/p\u003e",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "slerpU",
          "package": "vect",
          "signature": "Float -\u003e U -\u003e U -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#slerpU",
          "type": "function"
        },
        "index": {
          "description": "This is shortest path interpolation in the space of rotations however this is achieved by possibly flipping the first endpoint in the space of quaternions Thus slerpU q1 q2 may be very far from q1 and very close to negU q1 in the space of quaternions but they are very close in the space of rotations",
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "slerpU",
          "normalized": "Float-\u003eU-\u003eU-\u003eU",
          "package": "vect",
          "signature": "Float-\u003eU-\u003eU-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:slerpU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "toQ",
          "package": "vect",
          "signature": "Vec4 -\u003e Q",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#toQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "toQ",
          "normalized": "Vec-\u003eQ",
          "package": "vect",
          "signature": "Vec-\u003eQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:toQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "toU",
          "package": "vect",
          "signature": "Normal4 -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#toU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "toU",
          "normalized": "Normal-\u003eU",
          "package": "vect",
          "signature": "Normal-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:toU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "unitQ",
          "package": "vect",
          "signature": "Q",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#unitQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "unitQ",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:unitQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "unitU",
          "package": "vect",
          "signature": "U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#unitU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "unitU",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:unitU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "unsafeToU",
          "package": "vect",
          "signature": "Vec4 -\u003e U",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#unsafeToU",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "unsafeToU",
          "normalized": "Vec-\u003eU",
          "package": "vect",
          "partial": "To",
          "signature": "Vec-\u003eU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:unsafeToU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "zeroQ",
          "package": "vect",
          "signature": "Q",
          "source": "src/Data-Vect-Float-Util-Quaternion.html#zeroQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vect Float Util Quaternion",
          "module": "Data.Vect.Float.Util.Quaternion",
          "name": "zeroQ",
          "package": "vect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float-Util-Quaternion.html#v:zeroQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vect.Float",
          "name": "Float",
          "package": "vect",
          "source": "src/Data-Vect-Float.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vect Float",
          "module": "Data.Vect.Float",
          "name": "Float",
          "package": "vect",
          "partial": "Float",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect-Float.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImporting this module is equivalent to importing \u003ca\u003eData.Vect.Float\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vect",
          "name": "Vect",
          "package": "vect",
          "source": "src/Data-Vect.html",
          "type": "module"
        },
        "index": {
          "description": "Importing this module is equivalent to importing Data.Vect.Float",
          "hierarchy": "Data Vect",
          "module": "Data.Vect",
          "name": "Vect",
          "package": "vect",
          "partial": "Vect",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vect/docs/Data-Vect.html#"
      }
    }
  ]
]